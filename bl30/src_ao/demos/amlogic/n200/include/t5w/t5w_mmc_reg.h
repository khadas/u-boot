// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_for_mmc_register_map_h.pl
//
// and was applied to the file
//
// Project name: t5w
//
// Create time: Wed Aug  4 16:14:04 PDT 2021 by martin
//
// ./mmc_reg.vh
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef MMC_REG_DEFINE
#else
#define MMC_REG_DEFINE

//#define MMC_Wr(addr, data) *(volatile uint32_t *)(addr) = (data)
//#define MMC_Rd(addr) *(volatile uint32_t *)(addr)
//#define writel(v, c)  *(volatile uint32_t *)(c) = v
//#define readl(c)  *(volatile uint32_t *)(c)

//
// Reading file:  ./mmc_reg.vh
//
//
// Reading file:  ../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
// APB1_BASE_ADDR	 32'hff638c00
// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xff638c00
// -----------------------------------------------

#define AM_DDR_PLL_CNTL0                 ((0x0000  << 2) + 0xff638c00)
  //bit 29    : dpll_reset.
  //bit 28    : dpll_en.
  //bit 27:26 : dpll_clk_en
  //bit 25    : dpll_inv_sel
  //bit 21:19 : od1
  //			OD1[0] : 0 /2,  1: /4.
  //			OD1[2:1].  2'b00: /1, 2'b01: /2. 2'b10 /4. 2'b11: /8.
  //bit 18:16 : od
  //bit 14:10 : dpll_ref_div_n
  //bit 8:0   : dpll_int_num

#define AM_DDR_PLL_CNTL1                 ((0x0001  << 2) + 0xff638c00)
  //bit 18:0    : ddr_dpll_frac
#define AM_DDR_PLL_CNTL2                 ((0x0002  << 2) + 0xff638c00)
  //bit 22:20  : fref_sel
  //bit 17:16  : os_ssc
  //bit 15:12  : ssc_str_m
  //bit 8      : ssc_en
  //bit 7:4    : ssc_dep_sel
  //bit 1:0    : dpll ss_mode.
#define AM_DDR_PLL_CNTL3                 ((0x0003  << 2) + 0xff638c00)
  //bit 31     : afc bypass
  //bit 30     : afc clk sel
  //bit 29     : code new
  //bit 28     : dco_m_en
  //bit 27     : dco_sdm_en
  //bit 26     : div2
  //bit 25     : div mode
  //bit 24     : fast_lock mode
  //bit 23     : fb_pre_div
  //bit 22     : filter_mode
  //bit 21     : fix_en
  //bit 20     : freq_shift_en
  //bit 19     : load
  //bit 18     : load_en
  //bit 17     : lock_f
  //bit 16     : pulse_width_en
  //bit 15     : sdmnc_en
  //bit 14     : sdmnc_mode
  //bit 13     : sdmnc_range
  //bit 12     : tdc_en
  //bit 11     : tdc_mode_sel
  //bit 10     :  wait_en

#define AM_DDR_PLL_CNTL4                 ((0x0004  << 2) + 0xff638c00)
  //bit 1:0    : pfd_gain
  //bit 7:4    : filter_pvt1
  //bit 11:8   : filter pvt2
  //bit 13:12  : acq_gain
  //bit 18:16  : lambda0
  //bit 22:20  : lambda1
  //bit 26:24  : rou
  //bit 30:28  : alpha
#define AM_DDR_PLL_CNTL5                 ((0x0005  << 2) + 0xff638c00)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo

#define AM_DDR_PLL_CNTL6                 ((0x0006  << 2) + 0xff638c00)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo

#define AM_DDR_PLL_STS                   ((0x0007  << 2) + 0xff638c00)
  //bit 31     : DDR_PLL_LOCK
  //bit 30:19  : not used.
  //bit 18     : DDR_AFC_DONE
  //bit 17     : DDR_PLL_LOCK
  //bit 16:7   : DDR_DPLL_OUT_RSV
  //bit 6:0    : DDR_SDMNC_MONITOR

#define DDR_CLK_CNTL                     ((0x0008  << 2) + 0xff638c00)
  //bit 31     ddr_pll_clk enable.
  //enable the clock from DDR_PLL to clock generateion.
  // whenever change the DDR_PLL frequency,
  //disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 30.    ddr_pll_prod_test_en.
  //  enable the clock to clock/32 which to clock frequency measurement
  //and production test pin.
  //bit 29.    not used.
  //bit 28.    clock generation logic soft reset. 0 = reset.
  //bit 27.    phy_4xclk phase inverter..
  //bit 25.    DDRPHY DfiClk/DMC clock selection.
  //1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 24.    enable AM_PLL CLK output /2 function.
  //1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 26.    pll_freq divide/2.
  //1:  use pll div/2 clock as the n_clk. 0: use pll clock as n_clk.
  //this setting is used for the synopsys DDR PHY PLL fast lock mode.
  //bit 2. enable dmc_clk.
  //bit 1. not used.
  //bit 0. enable LPDDR4-PHY clock

#define DDR_PHY_CTRL                     ((0x0009  << 2) + 0xff638c00)
  //LPDDR4 power on reset need to
  //special combination of PwrOkIn and phy_reset_n.
  //bit 31:  DDr PHY power on status.  read only.
  //bit 4.   DDR PHY PwrOkIn pin.
  //bit 1.   DDR PHY APB soft reset_n.
  //bit 0.   phy_reset_n.

#define AM_DDR_PLL_FREQ1_OD                   ((0x000c  << 2) + 0xff638c00)
 //freqency set 1 PLL OD and OD1 setting.
 //when change to freqency 1 will use this setting.
 //frequency set 0 use original DDR_PLL_CNTL0 setting.
 //bit 8     currunt FREQ selection.
 //it can forced to change to select which freqency to select,
 //or it can auto changed by FREQ change hardware.
 //bit 5:3   OD1.
 //bit 2:0.  OD.

//
// Closing file:  ../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//
// -----------------------------------------------
// REG_BASE:  DMC_REG_BASE = 0xff638000
// -----------------------------------------------
#define DMC_REQ_CTRL                     ((0x0000  << 2) + 0xff638000)
  //bit 23.  enable dmc request of ambus chan 7.
  //Reserved for GE2D interface. Async interface.
  //bit 22.  enable dmc request of ambus chan 6.
  //DOS HCODEC  interface   Sync interface.
  //bit 21.  enable dmc request of ambus chan 5.
  //DOS VDEC  interface   Sync interface.
  //bit 20.  enable dmc request of ambus chan 4.
  //VPU write interface 1  Sync interface.
  //bit 19.  enable dmc request of ambus chan 3.
  //VPU write interface 0  Sync interface.
  //bit 18.  enable dmc request of ambus chan 2.
  //VPU read interface 2.   Sync interface.
  //bit 17.  enable dmc request of ambus chan 1.
  //VPU read interface 1.   Sync interface.
  //bit 16.  enable dmc request of ambus chan 0.
  //VPU read interface 0.  Sync interface.
  //bit 9    enable dmc request of axibus chan 9.
  //wave  async interface.
  //bit 8.   enable dmc request of axibus chan 8
  //hevc_b  async interface.
  //bit 7.   enable dmc request of axibus chan 7.
  //DEVICE.    Async interface.
  //bit 6.   enable dmc request of axibus chan 6.
  //USB   Async interface.
  //bit 5.   enable dmc request of axibus chan 5.
  //reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.
  //hevc front Async interface.
  //bit 3.   enable dmc request of axibus chan 3.
  //HDCP/HDMI   Async interface.
  //bit 2.   enable dmc request of axibus chan 2.
  //pcie  async
  //bit 1.   enable dmc request of axibus chan 1.
  //Mali .  async interface.
  //bit 0.   enable dmc request of axibus chan 0.
  //CPU/A53   async interface.

//DMC CLK and RESET domain register.
//please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST                     ((0x0001  << 2) + 0xff638000)
  //bit 31~24. reserved for future.
  //bit 23:16 8 AMBUS input interface n_clk domain reset_n signal.
  //0 : reset.  1: normal working mode.
  //bit 15:0. 16 AXI BUS input interfaces n_clk domain reset_n signal.
  //0: reset. 1: normal working mode. each bit for one interface.

#define DMC_SOFT_RST1                    ((0x0002  << 2) + 0xff638000)
  //To reset the Async interface,
  //you need to disable the interface both clock domain,
  //then reset both n_clk and m_clk domain
  //bit 31~24 not used.
  //bit 23.16  8 am bus interfaces master clock domain reset_n signal.
  //0 : reset : 1 normal working mode.
  //bit 15:0.  16 AXI bus interfaces master clock domain reset_n signal.
  //0 : reset : 1 normal working mode.

#define DMC_SOFT_RST2                    ((0x0003  << 2) + 0xff638000)
  //bit 31~11.  reserved for future.
  //bit 10  DMC DFI cmd soft reset_n
  //bit 9   DMC DFI MISC soft reset_n
  //bit 8   DMC DFI data soft reset_n
  //bit 7   DMC DFI dcu soft reset_n
  //bit 6   DMC siu soft reset_n
  //bit 5.  DMC test soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 4.  DMC low power control module soft reset_n.
  //0 : reset. 1 : normal working mode.
  //bit 3.  DMC QOS monitor module soft reset_n.
  //0 : reset. 1 : normal working mode.
  //bit 2.  DMC register model soft reset_n.
  //0 : reset. 1 : normal working mode.
  //bit 1.  DMC canvas transfer module soft reset_n.
  //0 : reset. 1 : normal working mode.
  //bit 0.  DMC command buffers and command generation modules soft reset.
  //0 = reset. 1:

#define DMC_RST_STS1                     ((0x0004  << 2) + 0xff638000)
  //31~24.  not used.
  //23~0.   Read only.  the DMC_SOFT_RST1 signal in n_clk domain.
  //the purpose of this register is
  //when one of the 2 clocks is too slow or too fast,
  //we can read this register to make sure another clock domain reset is done.
#define DMC_CLKG_CTRL0                   ((0x0006  << 2) + 0xff638000)
  //bit 23:16. enable the 8 ambus interfaces both main and
  //n_clk auto clock gating function. each 1 bit for one interface.
  //bit 15:0.  enable the 16 axi interfaces both main and
  //n_clk auto clock gating function. each 1 bit for one interface.
#define DMC_CLKG_CTRL1                   ((0x0007  << 2) + 0xff638000)
  //bit 23:16. force to disable the 8 ambus interfaces both main and n_clk.
  //each 1 bit for one interface.
  //bit 15:0.  force to disable the 16 axi interfaces both main and n_clk.
  //each 1 bit for one interface.

#define DMC_CLKG_CTRL2                   ((0x0008  << 2) + 0xff638000)
  //bit 12  enalbe auto clock gating for awcmdfifo.
  //bit 11  enalbe auto clock gating for arcmdfifo.
  //bit 10  enable auto clock gating for dfi command generation
  //bit 9   enable auto clock gating for dram controller
  //bit 8   enable auto clock gating for dfi data path.
  //bit 7.  enalbe auto clock gating for write rsp generation.
  //bit 6.  enalbe auto clock gating for read rsp generation.
  //bit 5.  enalbe auto clock gating for ddr0 command filter.
  //bit 4.  enalbe auto clock gating for ddr0 write reorder buffer.
  //bit 3.  enalbe auto clock gating for ddr0 write data buffer.
  //bit 2.  enalbe auto clock gating for ddr0 read reorder buffer.
  //bit 1.  enalbe auto clock gating for read canvas.
  //bit 0.  enalbe auto clock gating for write canvas.

#define DMC_CLKG_CTRL3                   ((0x0009  << 2) + 0xff638000)
  //bit 12  force to disable the clock of awcmdfifo.
  //bit 11  force to disable the clock of arcmdfifo.
  //bit 10  force to disable the clock of dfi command generation
  //bit 9   force to disable the clock of dram controller
  //bit 8   force to disable the clock of dfi data path.
  //bit 7. force to disalbe the clock of write rsp generation.
  //bit 6. force to disalbe the clock of read rsp generation.
  //bit 5.  force to disalbe the clock of  command filter.
  //bit 4.  force to disalbe the clock of  write reorder buffer.
  //bit 3.  force to disalbe the clock of write data buffer.
  //bit 2.  force to disalbe the clock of read reorder buffer.
  //bit 1.  force to disalbe the clock of read canvas.
  //bit 0.  force to disalbe the clock of write canvas.

#define DMC_MON_CTRL0                    ((0x0020  << 2) + 0xff638000)
   //bit 31.   qos_mon_en. write 1 to trigger the enable.
   //polling this bit 0, means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.
   //read 1 = qos mon finish interrupt.
   //bit 7.    BW monitor 3 enable.
   //bit 6.    BW monitor 3 enable.
   //bit 5.    BW monitor 3 enable.
   //bit 4.    BW monitor 3 enable.
   //bit 3.    BW monitor 3 enable.
   //bit 2.    BW monitor 2 enable.
   //bit 1.    BW monitor 1 enable.
   //bit 0.    BW monitor 0 enable.
#define DMC_MON_TIMER                    ((0x0021  << 2) + 0xff638000)
 // timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT                  ((0x0022  << 2) + 0xff638000)
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW                   ((0x0023  << 2) + 0xff638000)
  // at the test period,  the whole MMC granted data cycles. 64bits unit.
#define DMC_MON_ALL16_BW                 ((0x0024  << 2) + 0xff638000)
  // at the test period,  the whole MMC granted data cycles
  //which goes to 16bits ddr. unit:64bits

#define DMC_MON0_CTRL                    ((0x0025  << 2) + 0xff638000)
  //BW MONTIOR 0 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON0_CTRL1                   ((0x0026  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 0 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON0_CTRL2                   ((0x0027  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 0 port select for the selected channel.
#define DMC_MON0_BW                      ((0x0028  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON1_CTRL                    ((0x0029  << 2) + 0xff638000)
  //BW monitor 1 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON1_CTRL1                   ((0x002a  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 1 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON1_CTRL2                   ((0x002b  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 1 port select for the selected channel.
#define DMC_MON1_BW                      ((0x002c  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON2_CTRL                    ((0x002d  << 2) + 0xff638000)
  //BW monitor 2 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON2_CTRL1                   ((0x002e  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 2 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON2_CTRL2                   ((0x002f  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 2 port select for the selected channel.
#define DMC_MON2_BW                      ((0x0030  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON3_CTRL                    ((0x0031  << 2) + 0xff638000)
  //BW monitor 3 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON3_CTRL1                   ((0x0032  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 3 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON3_CTRL2                   ((0x0033  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 3 port select for the selected channel.
#define DMC_MON3_BW                      ((0x0034  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON4_CTRL                    ((0x0035  << 2) + 0xff638000)
  //BW monitor 4 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON4_CTRL1                   ((0x0036  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 4 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON4_CTRL2                   ((0x0037  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 4 port select for the selected channel.
#define DMC_MON4_BW                      ((0x0038  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON5_CTRL                    ((0x0039  << 2) + 0xff638000)
  //BW monitor 5 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON5_CTRL1                   ((0x003a  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 5 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON5_CTRL2                   ((0x003b  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 5 port select for the selected channel.
#define DMC_MON5_BW                      ((0x003c  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON6_CTRL                    ((0x003d  << 2) + 0xff638000)
  //BW monitor 6 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON6_CTRL1                   ((0x003e  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 6 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON6_CTRL2                   ((0x003f  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 6 port select for the selected channel.

#define DMC_MON6_BW                      ((0x0040  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_MON7_CTRL                    ((0x0041  << 2) + 0xff638000)
  //BW monitor 7 address range control.
  //start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON7_CTRL1                   ((0x0042  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 7 channel select.
   //8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected,
  //you can use DMC_MONx_CTRL2 to chose any subid of this selected channel.
  //otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON7_CTRL2                   ((0x0043  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 7 port select for the selected channel.
#define DMC_MON7_BW                      ((0x0044  << 2) + 0xff638000)
  // at the test period,
  //this range granted data cycles for the selected channel and ports.

#define DMC_CMD_FILTER_CTRL1                  ((0x0050  << 2) + 0xff638000)
  //not used.
#define DMC_CMD_FILTER_CTRL2                  ((0x0051  << 2) + 0xff638000)
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.

#define DMC_CMD_FILTER_CTRL3                  ((0x0052  << 2) + 0xff638000)
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number

#define DMC_CMD_FILTER_CTRL4                  ((0x0053  << 2) + 0xff638000)
  //bit 29:25.  tITW.long
  //bit 24:20.  tITW. short
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.

#define DMC_CMD_FILTER_CTRL5                  ((0x0054  << 2) + 0xff638000)
  //bit 31:24   Once ddr data bus switch to read,
  //the maxmum read command number to give up the bus
  //when there's write request pending for write buffer.
  //bit 23:16   Once ddr data bus switch to write,
  //the maxmum write command number to give up the bus
  //when there's read request pending too long.
  //bit 15:8.   Once ddr data bus switch to read,
  //the minimum read command number to transfer back to write stage
  //if there's still pending read request.
  //bit 7:0.    Once ddr data bus switch to write,
  //the minimum write command number to transfer back to read stage
  //if there's still pending write request.

#define DMC_CMD_FILTER_CTRL6                  ((0x0055  << 2) + 0xff638000)
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.

#define DMC_CMD_FILTER_CTRL7                  ((0x0056  << 2) + 0xff638000)
  //bit 31:24.  aw_req_pedning signal assertion after wbuf full.
  //bit 23:16   aw_req_pending signal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.

#define DMC_CMD_FILTER_CTRL8                  ((0x0057  << 2) + 0xff638000)
  //bit 31:8    reserved.
  //bit 7:0     rank limit to change to another rank.

#define DMC_CMD_BUFFER_CTRL                   ((0x0058  << 2) + 0xff638000)
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8    reserved.
  //bit 7:0    aw_pending_inc_num.
  //incease write ugent level 1
  //when write command waiting to in write buffer that long.

#define DMC_CMD_BUFFER_CTRL1                  ((0x0059  << 2) + 0xff638000)
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.

#define DMC_2ARB_CTRL                    ((0x005c  << 2) + 0xff638000)
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //22.    1: allow to increase
  //       2 urgent levels if waiting time is doubled than inc_ugt_limit.
  //21:12  inc_ugt_limit.
  //       if waiting time > inc_ugt_limit, increase the urgent level by one
  //11:6.  the final arbitration control from AXI bus(port channel 0~7).
  //5:0.   the final arbitration weight control for Ambus ( port channel 8~15).
#define DMC_VERSION                      ((0x005f  << 2) + 0xff638000)
   //read only 32'h000a0008  for sc2

#define DMC_AM0_CHAN_CTRL                ((0x0060  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM0_HOLD_CTRL                ((0x0061  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM0_CHAN_CTRL1                    ((0x0062  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM0_CHAN_CTRL2                    ((0x0063  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request,
 //and side bank signal is high,  block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request,
 //and side bank signal is high,  block the axi bus related bits write request.

#define DMC_AM1_CHAN_CTRL                ((0x0064  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM1_HOLD_CTRL                ((0x0065  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM1_CHAN_CTRL1                    ((0x0066  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM1_CHAN_CTRL2                    ((0x0067  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request,
 //and side bank signal is high,  block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request,
 //and side bank signal is high,  block the axi bus related bits write request.

#define DMC_AM2_CHAN_CTRL                ((0x0068  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM2_HOLD_CTRL                ((0x0069  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM2_CHAN_CTRL1                    ((0x006a  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM2_CHAN_CTRL2                    ((0x006b  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request,
 //and side bank signal is high, block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request,
 //and side bank signal is high, block the axi bus related bits write request.

#define DMC_AM3_CHAN_CTRL                ((0x006c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM3_HOLD_CTRL                ((0x006d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num.
	//if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM3_CHAN_CTRL1                    ((0x006e  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM3_CHAN_CTRL2                    ((0x006f  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request,
 //and side bank signal is high, block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request,
 //and side bank signal is high, block the axi bus related bits write request.

#define DMC_AM4_CHAN_CTRL                ((0x0070  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM4_HOLD_CTRL                ((0x0071  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num.
	//if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AM4_CHAN_CTRL1                    ((0x0072  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM4_CHAN_CTRL2                    ((0x0073  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits write request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits write request.

#define DMC_AM5_CHAN_CTRL                ((0x0074  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM5_HOLD_CTRL                ((0x0075  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM6_CHAN_CTRL                ((0x0078  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM6_HOLD_CTRL                ((0x0079  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AM7_CHAN_CTRL                ((0x007c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AM7_HOLD_CTRL                ((0x007d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI0_CHAN_CTRL                    ((0x0080  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi0 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL                    ((0x0081  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AXI0_CHAN_CTRL1                   ((0x0082  << 2) + 0xff638000)
  //bit 31:28.  FIQ status
  //bit 27:24.  IRQ status.
  //bit 22      use ACTIVE input as clock gating control.
  //bit 21:20.  chan0 QOS mode.
  //bit 19:16.   AXI0 QOS high limit.
  //bit 15:12    AXI0 QOS mit limit.
  //bit 11  ARM  FIQ controlled super urgent enable.
  //bit 10  ARM  FIQ controlled urgent enable.
  //bit  9. ARM IRQ controlled super urgent enable.
  //bit  8. ARM IRQ controlled urgent enable.
  //bit  7.  IRQ/FIQ control enable.
  //bit  6:5.  not used.
  //bit 4. enable AXI0 auto urgent enable. When there's no other request,
  //       treat the AXI0 as super urgent request.
  //       other wise, use the bit3:0 to set the urgent.
  //bit 3:2 A9 urgent if there's VIU request.
  //bit 1:0 A9 urgent if there's request other than VIU

#define DMC_AXI1_CHAN_CTRL                    ((0x0084  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI1_HOLD_CTRL                    ((0x0085  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1                   ((0x0086  << 2) + 0xff638000)
  //bit 31:28.  FIQ status
  //bit 27:24.  IRQ status.
  //bit 21:20.  Mali QOS mode.
  //bit 19:16.   mail QOS high limit.
  //bit 15:12    mail QOS mit limit.
  //bit 11  ARM  FIQ controlled super urgent enable.
  //bit 10  ARM  FIQ controlled urgent enable.
  //bit  9. ARM IRQ controlled super urgent enable.
  //bit  8. ARM IRQ controlled urgent enable.
  //bit  7.  IRQ/FIQ control enable.
  //bit  6:0.  not used.

#define DMC_AXI2_CHAN_CTRL                    ((0x0088  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI2_HOLD_CTRL                    ((0x0089  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI3_CHAN_CTRL                    ((0x008c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI3_HOLD_CTRL                    ((0x008d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI4_CHAN_CTRL                    ((0x0090  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI4_HOLD_CTRL                    ((0x0091  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI5_CHAN_CTRL                    ((0x0094  << 2) + 0xff638000)
  //not used.
#define DMC_AXI5_HOLD_CTRL                    ((0x0095  << 2) + 0xff638000)
  //not used.

#define DMC_AXI6_CHAN_CTRL                    ((0x0098  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI6_HOLD_CTRL                    ((0x0099  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI7_CHAN_CTRL                    ((0x009c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI7_HOLD_CTRL                    ((0x009d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AXI7_CHAN_CTRL1                   ((0x009e  << 2) + 0xff638000)
  //bit 0.  wrdata hold mode.
  //1, after receive enough wrdata, send AWVALID. 0: send AWVALID dont wait WRDATA.

#define DMC_AXI8_CHAN_CTRL                    ((0x00a0  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI8_HOLD_CTRL                    ((0x00a1  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI9_CHAN_CTRL                    ((0x00a4  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI9_HOLD_CTRL                    ((0x00a5  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI10_CHAN_CTRL                   ((0x00a8  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI10_HOLD_CTRL                   ((0x00a9  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AXI10_CHAN_CTRL1                  ((0x00aa  << 2) + 0xff638000)
  //bit 0.  wrdata hold mode.
  //        1, after receive enough wrdata, send AWVALID. 0: send AWVALID dont wait WRDATA.

#define DMC_AXI11_CHAN_CTRL                   ((0x00ac  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight

#define DMC_AXI11_HOLD_CTRL                   ((0x00ad  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI12_CHAN_CTRL                   ((0x00b0  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI12_HOLD_CTRL                   ((0x00b1  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.

#define DMC_AXI13_CHAN_CTRL                   ((0x00b4  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control
  //             : 1 use AWUGT/ARUGT pins in the port.
  //             0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter weight
#define DMC_AXI13_HOLD_CTRL                   ((0x00b5  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num,
	//then hold this request unless the outstanding request number
	//bellow the hold release number, then continue to request.
#define DMC_AM0_CHAN_STS                 ((0x00b8  << 2) + 0xff638000)
#define DMC_AM1_CHAN_STS                 ((0x00b9  << 2) + 0xff638000)
#define DMC_AM2_CHAN_STS                 ((0x00ba  << 2) + 0xff638000)
#define DMC_AM3_CHAN_STS                 ((0x00bb  << 2) + 0xff638000)
#define DMC_AM4_CHAN_STS                 ((0x00bc  << 2) + 0xff638000)
#define DMC_AM5_CHAN_STS                 ((0x00bd  << 2) + 0xff638000)
#define DMC_AM6_CHAN_STS                 ((0x00be  << 2) + 0xff638000)
#define DMC_AM7_CHAN_STS                 ((0x00bf  << 2) + 0xff638000)

#define DMC_AXI0_CHAN_STS                ((0x00c0  << 2) + 0xff638000)
#define DMC_AXI1_CHAN_STS                ((0x00c1  << 2) + 0xff638000)
#define DMC_AXI2_CHAN_STS                ((0x00c2  << 2) + 0xff638000)
#define DMC_AXI3_CHAN_STS                ((0x00c3  << 2) + 0xff638000)
#define DMC_AXI4_CHAN_STS                ((0x00c4  << 2) + 0xff638000)
#define DMC_AXI5_CHAN_STS                ((0x00c5  << 2) + 0xff638000)
#define DMC_AXI6_CHAN_STS                ((0x00c6  << 2) + 0xff638000)
#define DMC_AXI7_CHAN_STS                ((0x00c7  << 2) + 0xff638000)
#define DMC_AXI8_CHAN_STS                ((0x00c8  << 2) + 0xff638000)
#define DMC_AXI9_CHAN_STS                ((0x00c9  << 2) + 0xff638000)
#define DMC_AXI10_CHAN_STS                    ((0x00ca  << 2) + 0xff638000)
#define DMC_AXI11_CHAN_STS                    ((0x00cb  << 2) + 0xff638000)
#define DMC_AXI12_CHAN_STS                    ((0x00cc  << 2) + 0xff638000)
#define DMC_AXI13_CHAN_STS                    ((0x00cd  << 2) + 0xff638000)
#define DMC_CHAN_STS                     ((0x00ce  << 2) + 0xff638000)
  //AXI0  is first CPU and Mali combined channel from CCI-400 directly.
  //The first 2Gbyte address will go through this channel.
  //AXI10  is the second CPU, Mali channel combined with NNA  from NIC-400.
  //The upper 2Gbyte address will go through this channel.
  // read only register.
  // the second mali and NNA channel IDLE.
  // the second CPU channel IDLE.
  // the first mali channel IDLE.
  // the first CPU channel IDLE.
  //bit 27      always 1
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      always 1.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:16   ambus channel idle.          1 : idle 0: busy.
  //bit 15:0.   axibus channel idle.         1 : idle 0: busy.
#define DMC_IRQ_STS                      ((0x00cf  << 2) + 0xff638000)
  //bit 31:3   Not used.
  //bit 2 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrupt.
  //           write 1 to clean this interrupt.
  //bit 1 :    WRITE protection interrupt.  1: means there's write protection violation.
  //           need to write DMC_PROT_IRQ_CTRL  bit 1to clean this bit.
  //bit 0 :    read protection interrupt.   1: means there's read  protection violation.
  //           need to write DMC_PROT_IRQ_CTRL bit 0 to clean this bit.

#define DMC_PROT0_RANGE                  ((0x00d0  << 2) + 0xff638000)
  //protection 0 address range. the range define is 64Kbyte boundary.
  //current address [31:16] >= start address && current address [31:16] <= end address.
  //bit 31:16 :   range end address.
  //bit 15:0  :   range start address
#define DMC_PROT0_CTRL                   ((0x00d1  << 2) + 0xff638000)
  //bit 23:16. each bit to eanble one of the 8 ambus channal for the protection function.
  //bit 15:0   each bit to enable one of the 15 channel input for the protection function.
#define DMC_PROT0_CTRL1                  ((0x00d2  << 2) + 0xff638000)
  //bit 26.  protection 0  read access protection enable.
  //bit 25.  protection 0  write access block function. if enabled,
  //         the access wouldn't write to the DDR SDRAM.
  //         if not enabled only generate a interrupt, but the access still wrote to DDR.
  //bit 24.  protection range 0  write access protection enable.
  //bit 15:0 for some AXI port subID bits
#define DMC_PROT1_RANGE                  ((0x00d3  << 2) + 0xff638000)
  //protection 1 address range. the range define is 64Kbyte boundary.
  //current address [31:16] >= start address && current address [31:16] <= end address.
  //bit 31:16 :   range end address.
  //bit 15:0  :   range start address
#define DMC_PROT1_CTRL                   ((0x00d4  << 2) + 0xff638000)
  //bit 23:16. each bit to eanble one of the 8 ambus channal for the protection function.
  //bit 15:0   each bit to enable one of the 15 channel input for the protection function.
#define DMC_PROT1_CTRL1                  ((0x00d5  << 2) + 0xff638000)
  //bit 26.  protection range 1 read access protection enable bit.
  //bit 25.  protection 1  write access block function.
  //         if enabled, the access wouldn't write to the DDR SDRAM.
  //         if not enabled only generate a interrupt, but the access still wrote to DDR.
  //bit 24.  protection range 1 write access protection enable bit.
  //bit 15:0 for some AXI port subID bits

#define DMC_PROT_VIO_0                   ((0x00d6  << 2) + 0xff638000)
  //ddr0 write protection violation address.
#define DMC_PROT_VIO_1                   ((0x00d7  << 2) + 0xff638000)
  //bit 31:22 . not used. always 0.
  //21.    ddr0 protection 1 violation.
  //20     ddr0 protection 0 violation.
  //19:16. ddr0 write violation AWPROT bits. ( 4 bits for security)
  //15:14.  Not used.
  //13:0    ddr0_write violation ID. bit 13~9 for Master ID. bit 7:4 for subid.
#define DMC_PROT_VIO_2                   ((0x00d8  << 2) + 0xff638000)
  //ddr0 read prot violation address
#define DMC_PROT_VIO_3                   ((0x00d9  << 2) + 0xff638000)
  //bit 31:21 . not used. always 0.
  //21     ddr0 read protection 1 violation.
  //20     ddr0 read protection 0 violation.
  //19:16. ddr0 read violation ARPROT bits.
  //15:0   ddr0 read violation ID.   bit 13~9 for master ID. bit 7:4 for subid.
#define DMC_PROT_IRQ_CTRL                ((0x00da  << 2) + 0xff638000)
  //bit 2 :  protect function IRQ enable.
  //bit 1 :  write protection violation.  write 1 to clean write protection vio registers.
  //bit 0 :  read  protection violation.  write 1 to clean read protection vio registers.
// -----------------------------------------------
// REG_BASE:  DMC_TEST_REG_BASE = 0xff639800
// -----------------------------------------------

#define DMC_TEST_STA                     ((0x0000  << 2) + 0xff639800)
  //test start address.  for non-sha mode,  the last 5 bits would be ignored.
  //the test address at 32bytes boundary.
  //                     for sha mode,      address must be in 64 bytes boundary.
  //that mean the last 6 bits must be 0.

#define DMC_TEST_EDA                     ((0x0001  << 2) + 0xff639800)
  //test end address.  for non-sha mode,  the last 5 bits would be ignored.
  //the test address at 32bytes boundary.
  //                   for sha mode,       address must be in 64 bytes boundary.
  //that mean the last 6bits must be 1.
#define DMC_TEST_CTRL                    ((0x0002  << 2) + 0xff639800)
   //bit 31.  enable test.
   //bit 30.  when enable test, enable the write to DDR function.
   //bit 29.  when enable test, enable the read from DDR function.
   //bit 28.  when enable test,  enable the sha calculation function
   //         must be same as read enable but without write function.
   //bit 27.  enable to compare data.
   //         when do the read enable to enable the error comparison.
   //         suppose the read data should be same as the data in the write buffer.
   //bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
   //bit 25.  address generation type.
   //         0: continuous increase the address in the range of test start address
   //         and test end address.
   //         1: test module would pick the random address
   //         from test start address  and test end address.
   //bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
   //         for write if the write command number == the DMC_TEST_NUM, the write is done.
   //         for read if the read command number == the DMC TEST_num, the read id done.
   //                             for one read command can be repeated repeat number times.
   //                         1 : finshed at end address.
   //bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0},
   //                         then the latter is the previous data plus a pattern.
   //                         ( { + WD7,  + WD6, + WD5, + WD4}).
   //                         0 : the WDATA is the data in write register.
   //bit 23.  1  compare the sha result with the test sha message registers.
   //         0 : dont compare the result.
   //bit 22:20.   read repeat times.
   //             for non-sha function, we can define multi times of the read.
   //             the test module would repeat the same address repeat times.
   //bit 19.     limit write.  0: no outstanding write request limitation.
   //                          1: limit the outstanding write commands to the number of bits [15:8]
   //bit 18.     limit read.   0. no outstanding read request limitation.
   //                          1. limit the read outstanding request to the number of bits[7:0].
   //bit 17:16.  sha mode for sha function enabled.
   //            00 : not used.  01 : sha1. 2: sha2-256.
   //            3: sha2_224. not used in GXL fixed to be  Sha 2.
   //bit 15:8.   write outstanding commands limit.
   //bit 7:0.    read  outstanding commands limit.

#define DMC_TEST_NUM                     ((0x0003  << 2) + 0xff639800)
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.

#define DMC_TEST_WDG                     ((0x0004  << 2) + 0xff639800)
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.

#define DMC_TEST_COMP_MASK                    ((0x0005  << 2) + 0xff639800)
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.

#define DMC_TEST_WSTRB0                  ((0x0006  << 2) + 0xff639800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.

#define DMC_TEST_WSTRB1                  ((0x0007  << 2) + 0xff639800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.

#define DMC_TEST_WD0                     ((0x0010  << 2) + 0xff639800)
   // write data 0 for write command. also for read back data comparision.
#define DMC_TEST_WD1                     ((0x0011  << 2) + 0xff639800)
   // write data 1 for write command. also for read back data comparision.
#define DMC_TEST_WD2                     ((0x0012  << 2) + 0xff639800)
   // write data 2 for write command. also for read back data comparision.
#define DMC_TEST_WD3                     ((0x0013  << 2) + 0xff639800)
   // write data 3 for write command. also for read back data comparision.
#define DMC_TEST_WD4                     ((0x0014  << 2) + 0xff639800)
   // write data 4 for write command. also for read back data comparision.
#define DMC_TEST_WD5                     ((0x0015  << 2) + 0xff639800)
   // write data 5 for write command. also for read back data comparision.
#define DMC_TEST_WD6                     ((0x0016  << 2) + 0xff639800)
   // write data 6 for write command. also for read back data comparision.
#define DMC_TEST_WD7                     ((0x0017  << 2) + 0xff639800)
   // write data 7 for write command. also for read back data comparision.
#define DMC_TEST_WD8                     ((0x0018  << 2) + 0xff639800)
   // write data 8 for write command. also for read back data comparision.
#define DMC_TEST_WD9                     ((0x0019  << 2) + 0xff639800)
   // write data 9 for write command. also for read back data comparision.
#define DMC_TEST_WD10                    ((0x001a  << 2) + 0xff639800)
   // write data 10 for write command. also for read back data comparision.
#define DMC_TEST_WD11                    ((0x001b  << 2) + 0xff639800)
   // write data 11 for write command. also for read back data comparision.
#define DMC_TEST_WD12                    ((0x001c  << 2) + 0xff639800)
   // write data 12 for write command. also for read back data comparision.
#define DMC_TEST_WD13                    ((0x001d  << 2) + 0xff639800)
   // write data 13 for write command. also for read back data comparision.
#define DMC_TEST_WD14                    ((0x001e  << 2) + 0xff639800)
   // write data 14 for write command. also for read back data comparision.
#define DMC_TEST_WD15                    ((0x001f  << 2) + 0xff639800)
   // write data 15 for write command. also for read back data comparision.

#define DMC_TEST_RD0                     ((0x0020  << 2) + 0xff639800)
   // the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1                     ((0x0021  << 2) + 0xff639800)
   // the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2                     ((0x0022  << 2) + 0xff639800)
   // the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3                     ((0x0023  << 2) + 0xff639800)
   // the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4                     ((0x0024  << 2) + 0xff639800)
   // the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5                     ((0x0025  << 2) + 0xff639800)
   // the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6                     ((0x0026  << 2) + 0xff639800)
   // the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7                     ((0x0027  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8                     ((0x0028  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9                     ((0x0029  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10                    ((0x002a  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11                    ((0x002b  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12                    ((0x002c  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13                    ((0x002d  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14                    ((0x002e  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15                    ((0x002f  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.

#define DMC_TEST_ERR_ADDR                ((0x0040  << 2) + 0xff639800)
  //read only. it capture the first error address.
#define DMC_TEST_ERR_CNT                 ((0x0041  << 2) + 0xff639800)
  //read only. how many data error happens in the whole test period.
#define DMC_TEST_STS                     ((0x0042  << 2) + 0xff639800)
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.

#define DMC_TEST_WRCMD_ADDR                   ((0x0043  << 2) + 0xff639800)
  //read only. the current write cmd address.
#define DMC_TEST_RDCMD_ADDR                   ((0x0044  << 2) + 0xff639800)
   //read only. the current read command address.
#define DMC_TEST_RDRSP_ADDR                   ((0x0045  << 2) + 0xff639800)
  //read only. the failed read response address(for error data )

// -----------------------------------------------
// REG_BASE:  DMC_DRAM_REG_BASE = 0xff638400
// -----------------------------------------------
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency,
//the hardware would automatically select one of these two set of timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD                    ((0x0000  << 2) + 0xff638400)
   //bit 4:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC                    ((0x0001  << 2) + 0xff638400)
   //bit 9:0 tRFC
#define DMC_DRAM_TRP                     ((0x0002  << 2) + 0xff638400)
   //bit 21:16.  tRP for precharge all banks.
   //bit 5:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW                    ((0x0003  << 2) + 0xff638400)
   //bit 31:6:   Not used.
   //bit 5:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command =
   //               (RL + BL/2 - tWODTON) + TDQSCK_MAX + tWPRE +RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL                     ((0x0004  << 2) + 0xff638400)
  //bit 5:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL                    ((0x0005  << 2) + 0xff638400)
  //bit 5:0.  CWL:  write latency.
#define DMC_DRAM_TRAS                    ((0x0006  << 2) + 0xff638400)
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC                     ((0x0007  << 2) + 0xff638400)
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD                    ((0x0008  << 2) + 0xff638400)
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD                    ((0x0009  << 2) + 0xff638400)
  //bit 21:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 5:0.    tRRD/tRRD_s   active bank A to active bank b time.
	      //tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW                    ((0x000a  << 2) + 0xff638400)
  //bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP                    ((0x000b  << 2) + 0xff638400)
  //bit 5:0  tRTP.
#define DMC_DRAM_TWR                     ((0x000c  << 2) + 0xff638400)
  //bit 5:0 tWR.
#define DMC_DRAM_TWTR                    ((0x000d  << 2) + 0xff638400)
  //bit 21:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 5:0 tWTR_s.
#define DMC_DRAM_TCCD                    ((0x000e  << 2) + 0xff638400)
  //bit 19:16. tCCD/tCCD_l.
  //bit 3:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR                   ((0x000f  << 2) + 0xff638400)
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS                     ((0x0010  << 2) + 0xff638400)
  //bit 9:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP                     ((0x0011  << 2) + 0xff638400)
  //bit 3:0. tXP.  EXIT power down to other command time
#define DMC_DRAM_TXPDLL                  ((0x0012  << 2) + 0xff638400)
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS                   ((0x0013  << 2) + 0xff638400)
  //bit 11:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE                  ((0x0014  << 2) + 0xff638400)
  //bit 4:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX                  ((0x0015  << 2) + 0xff638400)
  //bit 4:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE                    ((0x0016  << 2) + 0xff638400)
  //bit 4:0.  CKE high or low minimum time.
#define DMC_DRAM_TMOD                    ((0x0017  << 2) + 0xff638400)
  //bit 4:0  tMOD.  MRR/MRW to other command time.
  //in LPDDR4, still use this register but it called tMRD.

#define DMC_DRAM_TDQS                    ((0x0018  << 2) + 0xff638400)
  //bit 31:28 reserved
  //bit 27:24 tDQS. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL                   ((0x0019  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_TZQLAT                  ((0x001a  << 2) + 0xff638400)
  //bit 5:0 ZQ LATCH command to other command timing in LPDDR4 mode.
#define DMC_DRAM_TMRR                    ((0x001b  << 2) + 0xff638400)
  //bit 7:0 tMRR  not used in DMC.

#define DMC_DRAM_TCKESR                  ((0x001c  << 2) + 0xff638400)
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD                    ((0x001d  << 2) + 0xff638400)
 //not support.
#define DMC_DRAM_DFITCTRLDELAY                ((0x001e  << 2) + 0xff638400)
  //bit 3:0. DFI_t_ctrldealy
#define DMC_DRAM_DFITPHYWRDATA                ((0x001f  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT                 ((0x0020  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN                 ((0x0021  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT                 ((0x0022  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN               ((0x0023  << 2) + 0xff638400)
  //bit 7:0.  CTRLUPD_MIN  minimux clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX               ((0x0024  << 2) + 0xff638400)
  //bit 7:0   CTRLUPD_MAX.  maxmum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI                  ((0x0026  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_DFITCTRLUPDI                 ((0x0027  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_DFITDRAMCLK                  ((0x0028  << 2) + 0xff638400)
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer

#define DMC_DRAM_DFITLPRESP                   ((0x002a  << 2) + 0xff638400)
  //bit 3:0.  dfi_lp_ctrl_req response time.
  //          after dfi_lp_ctrl_req asserted, and after response time
  //          if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.

#define DMC_DRAM_TCKECK                  ((0x002c  << 2) + 0xff638400)
 //bit 4:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay

#define DMC_DRAM_TREFI                   ((0x002d  << 2) + 0xff638400)
 //write this register will update the auto refresh related register to
 //the auto refresh control logic.
 //bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
 //bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
 //bit 15:8.   tREFI.dmc send auto refresh command period. unit is 100ns.
 //bit 7:0.    t100ns period. unit is dmc clock cycles
#define DMC_DRAM_TSR                     ((0x002e  << 2) + 0xff638400)
  //bit 5:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW                  ((0x002f  << 2) + 0xff638400)
  //bit 5:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE                  ((0x0030  << 2) + 0xff638400)
  //bit 5:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3                   ((0x0031  << 2) + 0xff638400)
  //7:0. DDR3 SDRAM tREFI single auto refresh time . the unit is t100ns.
  //use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL                  ((0x0032  << 2) + 0xff638400)
  //11:0. ZQCAL for LPDDR4. ZQINIT/ZQoper for DDR3/4 ZQCL command.
#define DMC_DRAM_T10US                   ((0x0033  << 2) + 0xff638400)
  //10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI                   ((0x0034  << 2) + 0xff638400)
//bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST                ((0x0035  << 2) + 0xff638400)
 //bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG                    ((0x0036  << 2) + 0xff638400)
  //bit 12.  rank1 ODT default. default value for ODT[1] pins if theres no read/write activity.
  //bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
  //bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
  //bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
  //bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occur in rank0.
  //bit 4.   rank0 ODT default.    default value for ODT[0] pins if theres no read/write activity.
  //bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
  //bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
  //bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
  //bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occur in rank1.
#define DMC_DRAM_DFIODTCFG1                   ((0x0037  << 2) + 0xff638400)
  //bit 27:24  ODT length for BL8 read transfer.
  //bit 19:16. ODT length for BL8 write transfer.
  //bit 12:8.  ODT latency for reads.  suppose to be 0.
  //bit 4:0.   ODT latency for writes.  suppose to be 0.

#define DMC_DRAM_TWODTON                 ((0x0038  << 2) + 0xff638400)
  //bit 5:0   DRAM write access ODT on time.
  //   in DDR3/4 should be same as WL.
  //   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
  //   In LPDDR4 ODT disable mode:  tWL.

#define DMC_DRAM_TRETRAIN                ((0x0039  << 2) + 0xff638400)
 //bit 15:0 LPDDR4 OSCRING retraining timer(units = auto_refresh timer). sync with autorefresh

#define DMC_DRAM_PHYADDRON                    ((0x003a  << 2) + 0xff638400)
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON                 ((0x003b  << 2) + 0xff638400)
  //bit 6:0 PHY_CTRL_ADDR_ON for new PHY. unit: ddr clk
  // PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON                 ((0x003c  << 2) + 0xff638400)
  // PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2

#define DMC_DRAM_ZQCTRL                  ((0x003d  << 2) + 0xff638400)
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period,
  //which refresh period count to send partial ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.

//timing parameter for frequency set 1.
#define DMC_NFQ_TMRD                     ((0x0040  << 2) + 0xff638400)
#define DMC_NFQ_TRFC                     ((0x0041  << 2) + 0xff638400)
#define DMC_NFQ_TRP                      ((0x0042  << 2) + 0xff638400)
#define DMC_NFQ_TRTW                     ((0x0043  << 2) + 0xff638400)
#define DMC_NFQ_TCL                      ((0x0044  << 2) + 0xff638400)
#define DMC_NFQ_TCWL                     ((0x0045  << 2) + 0xff638400)
#define DMC_NFQ_TRAS                     ((0x0046  << 2) + 0xff638400)
#define DMC_NFQ_TRC                      ((0x0047  << 2) + 0xff638400)
#define DMC_NFQ_TRCD                     ((0x0048  << 2) + 0xff638400)
#define DMC_NFQ_TRRD                     ((0x0049  << 2) + 0xff638400)
#define DMC_NFQ_TFAW                     ((0x004a  << 2) + 0xff638400)
#define DMC_NFQ_TRTP                     ((0x004b  << 2) + 0xff638400)
#define DMC_NFQ_TWR                      ((0x004c  << 2) + 0xff638400)
#define DMC_NFQ_TWTR                     ((0x004d  << 2) + 0xff638400)
#define DMC_NFQ_TCCD                     ((0x004e  << 2) + 0xff638400)
#define DMC_NFQ_TEXSR                    ((0x004f  << 2) + 0xff638400)
#define DMC_NFQ_TXS                      ((0x0050  << 2) + 0xff638400)
#define DMC_NFQ_TXP                      ((0x0051  << 2) + 0xff638400)
#define DMC_NFQ_TXPDLL                   ((0x0052  << 2) + 0xff638400)
#define DMC_NFQ_TZQCS                    ((0x0053  << 2) + 0xff638400)
#define DMC_NFQ_TCKSRE                   ((0x0054  << 2) + 0xff638400)
#define DMC_NFQ_TCKSRX                   ((0x0055  << 2) + 0xff638400)
#define DMC_NFQ_TCKE                     ((0x0056  << 2) + 0xff638400)
#define DMC_NFQ_TMOD                     ((0x0057  << 2) + 0xff638400)
#define DMC_NFQ_TDQS                     ((0x0058  << 2) + 0xff638400)
#define DMC_NFQ_TRSTL                    ((0x0059  << 2) + 0xff638400)
#define DMC_NFQ_TZQLAT                   ((0x005a  << 2) + 0xff638400)
#define DMC_NFQ_TMRR                     ((0x005b  << 2) + 0xff638400)
#define DMC_NFQ_TCKESR                   ((0x005c  << 2) + 0xff638400)
#define DMC_NFQ_TDPD                     ((0x005d  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLDELAY                 ((0x005e  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYWRDATA                 ((0x005f  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYWRLAT                  ((0x0060  << 2) + 0xff638400)
#define DMC_NFQ_DFITRDDATAEN                  ((0x0061  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYRDLAT                  ((0x0062  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDMIN                ((0x0063  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDMAX                ((0x0064  << 2) + 0xff638400)
#define DMC_NFQ_DFITREFMSKI                   ((0x0066  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDI                  ((0x0067  << 2) + 0xff638400)
#define DMC_NFQ_DFITDRAMCLK                   ((0x0068  << 2) + 0xff638400)
#define DMC_NFQ_DFITLPRESP                    ((0x006a  << 2) + 0xff638400)
#define DMC_NFQ_TCKECK                   ((0x006c  << 2) + 0xff638400)
#define DMC_NFQ_TREFI                    ((0x006d  << 2) + 0xff638400)
#define DMC_NFQ_TSR                      ((0x006e  << 2) + 0xff638400)
#define DMC_NFQ_TCCDMW                   ((0x006f  << 2) + 0xff638400)
#define DMC_NFQ_TESCKE                   ((0x0070  << 2) + 0xff638400)
#define DMC_NFQ_TREFI_DDR3                    ((0x0071  << 2) + 0xff638400)
#define DMC_NFQ_TZQCAL                   ((0x0072  << 2) + 0xff638400)
#define DMC_NFQ_T10US                    ((0x0073  << 2) + 0xff638400)
#define DMC_NFQ_TMRRI                    ((0x0074  << 2) + 0xff638400)
#define DMC_NFQ_TXS_FAST                 ((0x0075  << 2) + 0xff638400)
#define DMC_NFQ_DFIODTCFG                ((0x0076  << 2) + 0xff638400)
#define DMC_NFQ_DFIODTCFG1                    ((0x0077  << 2) + 0xff638400)
#define DMC_NFQ_TWODTON                  ((0x0078  << 2) + 0xff638400)
#define DMC_NFQ_TRETRAIN                 ((0x0079  << 2) + 0xff638400)
#define DMC_NFQ_PHYADDRON                ((0x007a  << 2) + 0xff638400)
#define DMC_NFQ_PHYWRON                  ((0x007b  << 2) + 0xff638400)
#define DMC_NFQ_PHYRDON                  ((0x007c  << 2) + 0xff638400)
#define DMC_NFQ_ZQCTRL                   ((0x007d  << 2) + 0xff638400)
//end of second frequency timing parameter

#define DMC_DRAM_DFITPHYUPDTYPE0              ((0x0080  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1              ((0x0081  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2              ((0x0082  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3              ((0x0083  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.

#define DMC_DRAM_MCFG                    ((0x0086  << 2) + 0xff638400)
 //bit 31:27  not used.
 //bit 26:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23     not used.
 //bit 22:20. rank0_d16_sel. 16bit mode, rank 0 byte selection.
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit register triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.

#define DMC_DRAM_ZQ_CTRL                 ((0x0087  << 2) + 0xff638400)
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only

#define DMC_DRAM_MCFG1                   ((0x0088  << 2) + 0xff638400)
 //bit7:0 LPDDR4 WDBI mode maskwrite dbi pattern

#define DMC_DRAM_DFI_CTRL                ((0x0089  << 2) + 0xff638400)
  //bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation,
  //       generate data error. 0 : disable.
  //bit 20 phy_ctrl_rd_on phy_ctrl_wr_on ignore 16bit mode.  1: sending 0xf in 16bit mode.
  //      0: sending valid byte enable in 16bit mode
  //bit 19: dfi_init_complete wait enable.
  //      1: after dfi_init_complete, wait additional EXSR time for new command.
  //      0: phy will handle all the timing
  //      after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polarity.
  //      0:  rank0 select = 2'b10. rank1 select = 2'b10.
  //      1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polarity.
  //      0:  rank0 select = 2'b10. rank1 select = 2'b10.
  //      1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 16:  force PHY ctrl_on  if = 1, phy_ctrl_on signal will keep on.
   //bit 15 siu_dfi1_lp_en
  //bit 14 siu_dfi_lp_ack_and
  //bit 13 siu_dfi_lp_ack_or
  //bit 12 siu_dfi1_init_start_en
  //bit 11 siu_dfi_init_com_and
  //bit 10 siu_dfi_init_com_or
  //bit  9 siu_dfi1_freq_en
  //bit  8 siu_dfi1_dram_clk_dis_en
  //bit  7 siu_dfi_phyupd_type_sel
  //bit  6 siu_dfi1_phyupd_ack_en
  //bit  5 siu_dfi_phyupd_req_and
  //bit  4 siu_dfi_phyupd_req_or
  //bit  3 siu_dfi_ctrlupd_ack_and
  //bit  2 siu_dfi_ctrlupd_ack_or
  //bit  1 siu_dfi1_ctrlupd_req_en
  //bit  0 siu_dfi1_cmd_en

#define DMC_DRAM_DFIINITCFG                   ((0x008a  << 2) + 0xff638400)
  //bit 31.   dfi_init_complete status. read only.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.

#define DMC_DRAM_APD_CTRL                ((0x008c  << 2) + 0xff638400)
 //bit 19:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
	    //non zero value to enable auto power down
	    //when DMC is in idle state for this number of clock cycles.

#define DMC_DRAM_ASR_CTRL                ((0x008d  << 2) + 0xff638400)
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit 28. enable dmc wait 10us after LP2 mode exit if it's long time the PHY in LP2 mode..
  //bit [27:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode.
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
	     // Non-zero value enable ASR mode.
	     //when DMC is in idle state for this number of clock cycles,
	     //the DMC will enter ASR mode.

#define DMC_DRAM_REFR_CTRL                    ((0x0092  << 2) + 0xff638400)
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  retrain enable for auto refresh frequency. 1: enable. 0: disable.
  //bit 6  Disabled auto refresh command if over 16 auto refresh command sent in 2 TREFI_DDR3 period
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.

#define DMC_DRAM_FREQ_CTRL                    ((0x0093  << 2) + 0xff638400)
//bit 31 .  write 1 to change freqency   read 0: finished.
//bit 30.   waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29:22.  not used.
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW function: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes,
//        state machine stop at self refresh state in case there's something need to handle.
	      //     0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.

#define DMC_DRAM_SCFG                    ((0x0094  << 2) + 0xff638400)
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.

#define DMC_DRAM_STAT                    ((0x0095  << 2) + 0xff638400)
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:15   sleep_st
  //bit 14:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
			  //1 :   ACCESS sending precharge command.
			  //2 :   ACCESS sending AUTO REFRESH command.
			  //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
			  //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
			  //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.

  //bit 11:8   APD STATUS:   0 :   APD_IDLE
			  //1 :    APD sending PRECHARGE command
			  //2 :    APD sending CKE low command
			  //3 :    APD sending DISABLE DRAM CLOCK command
			  //4 :    APD sending DFI_LP_CTRL_REQ
			  //5 :    APD in Auto Power down mode.
			  //6 :    APD deassert DFI_LP_CTRL_REQ
			  //7 :    APD sending enable DRAM CLOCK command
			  //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
			 //1  :    DRAM_STOP/DRAM_CFG
			 //2  :    DRAM_ACCESS
			 //3  :    DRAM_SLEEP
			 //4  :    DRAM APD(AUTO POWER DOWN).
			 //5  :    IDLE -> STOP/CONFIG
			 //6  :    STOP -> SLEEP
			 //7  :    STOP -> ACCESS
			 //8  :    ACCESS -> SLEEP.
			 //9  :    ACCESS -> STOP
			 //A  :    ACCESS -> APD
			 //B  :    SLEEP -> STOP
			 //C  :    SLEEP -> ACCESS
			 //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.

#define DMC_DRAM_STAT1                   ((0x0096  << 2) + 0xff638400)
  //bit 11:8  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to
    //       configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 7:5   train_st
  //bit 4:0   dram_phy_st

#define DMC_PHY_RETRAINING_CTRL               ((0x0097  << 2) + 0xff638400)
  //bit 31 :  phy_retraining enable.
  //bit 30 :  check  vpu sleep_en.
  //bit 25:24 : retraining dfi_freq[4:3],
  //            the [2:0] bit still use the dfi_freq bits to keep the frequency.
  //bit 23:0: retraining period unit : 100ns.

#define DMC_DFI_ERR_STAT                 ((0x0098  << 2) + 0xff638400)
 //LPDDR4 PHY DFI error information.
 //bit 31:20. not used.
 //bit 9.    ddr0_dfi_error
 //bit 8:5   ddr0_dfi_error_info.
 //bit 4.    ddr1_dfi_error.
 //bit 3:0.  ddr1_dfi_error_info.

#define DMC_LP2_TIMER                    ((0x009a  << 2) + 0xff638400)
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register.
//if the counter is large than this number,
//that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.

#define DMC_DRAM_COMPLETE_WAIT                ((0x009b  << 2) + 0xff638400)
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.

#define DMC_DRAM_DFI_SWAP_0                   ((0x00a0  << 2) + 0xff638400)
  //bit 5:0. dfi_act_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].

#define DMC_DRAM_DFI_SWAP_1                   ((0x00a1  << 2) + 0xff638400)
  //bit 5:0. dfi_ras_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_2                   ((0x00a2  << 2) + 0xff638400)
  //bit 5:0. dfi_cas_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_3                   ((0x00a3  << 2) + 0xff638400)
  //bit 5:0. dfi_we_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_4                   ((0x00a4  << 2) + 0xff638400)
  //bit 5:0. dfi_bg0 function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_5                   ((0x00a5  << 2) + 0xff638400)
  //bit 5:0. dfi_bg[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_6                   ((0x00a6  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_7                   ((0x00a7  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_8                   ((0x00a8  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[2] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_9                   ((0x00a9  << 2) + 0xff638400)
  //bit 5:0. dfi_a[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_10                  ((0x00aa  << 2) + 0xff638400)
  //bit 5:0. dfi_a[1] function select
#define DMC_DRAM_DFI_SWAP_11                  ((0x00ab  << 2) + 0xff638400)
  //bit 5:0. dfi_a[2] function select
#define DMC_DRAM_DFI_SWAP_12                  ((0x00ac  << 2) + 0xff638400)
  //bit 5:0. dfi_a[3] function select
#define DMC_DRAM_DFI_SWAP_13                  ((0x00ad  << 2) + 0xff638400)
  //bit 5:0. dfi_a[4] function select
#define DMC_DRAM_DFI_SWAP_14                  ((0x00ae  << 2) + 0xff638400)
  //bit 5:0. dfi_a[5] function select
#define DMC_DRAM_DFI_SWAP_15                  ((0x00af  << 2) + 0xff638400)
  //bit 5:0. dfi_a[6] function select
#define DMC_DRAM_DFI_SWAP_16                  ((0x00b0  << 2) + 0xff638400)
  //bit 5:0. dfi_a[7] function select
#define DMC_DRAM_DFI_SWAP_17                  ((0x00b1  << 2) + 0xff638400)
  //bit 5:0. dfi_a[8] function select
#define DMC_DRAM_DFI_SWAP_18                  ((0x00b2  << 2) + 0xff638400)
  //bit 5:0. dfi_a[9] function select
#define DMC_DRAM_DFI_SWAP_19                  ((0x00b3  << 2) + 0xff638400)
  //bit 5:0. dfi_a[10] function select
#define DMC_DRAM_DFI_SWAP_20                  ((0x00b4  << 2) + 0xff638400)
  //bit 5:0. dfi_a[11] function select
#define DMC_DRAM_DFI_SWAP_21                  ((0x00b5  << 2) + 0xff638400)
  //bit 5:0. dfi_a[12] function select
#define DMC_DRAM_DFI_SWAP_22                  ((0x00b6  << 2) + 0xff638400)
  //bit 5:0. dfi_a[13] function select
#define DMC_DRAM_DFI_SWAP_23                  ((0x00b7  << 2) + 0xff638400)
  //bit 5:0. dfi_a[14] function select
#define DMC_DRAM_DFI_SWAP_24                  ((0x00b8  << 2) + 0xff638400)
  //bit 5:0. dfi_a[15] function select
#define DMC_DRAM_DFI_SWAP_25                  ((0x00b9  << 2) + 0xff638400)
  //bit 5:0. dfi_a[16] function select
#define DMC_DRAM_DFI_SWAP_26                  ((0x00ba  << 2) + 0xff638400)
  //bit 5:0. dfi_a[17] function select

#define DMC_DRAM_CMD                     ((0x00d0  << 2) + 0xff638400)
 //bit 31. cmd done.  write 0 to clean.
 //bit 30. data done. write 0 to clean.
 //bit 8.  1: MPC/MRR command is in a 16bits width SDRAM. 0 : normal operation.
 //bit 5.  user defined command.
 //bit 4.  LPDDR4 MPC write data command( MPC WR FIFO).
 //bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO).
 //bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
 //bit 1.  mrr command.
 //bit 0.  mrw command.

#define DMC_DRAM_CMD_CODE                ((0x00d1  << 2) + 0xff638400)
 //bit 31:28  user command case: = {act_n, ras_n, cas_n, we_n}
 //bit 27:26. 128bits data cycles . 0: 1 clock cycles;  1: 2  clock cycles;
 //           2: 3 clock cycles; 3:4 clock cycles.
 //           LPDDR4 : 4 clock cycles;
 //           DDR3/4/LPDDR3  : 2 clock cycles.
 //bit 25     MRW/MRR/MPC command rank 1 select.  1: select.  0: not select.
 //bit 24.    MRW/MRR/MPC command rank 0 select.  1: select.  0: not select.
 //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
 //bit 15:0   opcode.

#define DMC_DRAM_CMD_TIME                ((0x00d2  << 2) + 0xff638400)
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.

#define DMC_DRAM_WSTRB0                  ((0x00d3  << 2) + 0xff638400)
#define DMC_DRAM_WSTRB1                  ((0x00d4  << 2) + 0xff638400)
#define DMC_DRAM_RDBI0                   ((0x00d5  << 2) + 0xff638400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1                   ((0x00d6  << 2) + 0xff638400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.

//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER command enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command,
//          the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.
//           {act_n, ras_n, cas_n, we_n} value for user command
				     //in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
	     //DDR3:    18:16 bank address. 15:0:  address.
	     //DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
	     //LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
	     //LPDDR4.   5:0, first edge address,  11:6 second edge address,
	     //          17:12: third edge address. 23:18, forth edge address.
	   //MRW command format:
	      //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
	      //bit 15:0   opcode.
#define DMC_DRAM_WD0                     ((0x00e0  << 2) + 0xff638400)
#define DMC_DRAM_WD1                     ((0x00e1  << 2) + 0xff638400)
#define DMC_DRAM_WD2                     ((0x00e2  << 2) + 0xff638400)
#define DMC_DRAM_WD3                     ((0x00e3  << 2) + 0xff638400)
#define DMC_DRAM_WD4                     ((0x00e4  << 2) + 0xff638400)
#define DMC_DRAM_WD5                     ((0x00e5  << 2) + 0xff638400)
#define DMC_DRAM_WD6                     ((0x00e6  << 2) + 0xff638400)
#define DMC_DRAM_WD7                     ((0x00e7  << 2) + 0xff638400)
#define DMC_DRAM_WD8                     ((0x00e8  << 2) + 0xff638400)
#define DMC_DRAM_WD9                     ((0x00e9  << 2) + 0xff638400)
#define DMC_DRAM_WD10                    ((0x00ea  << 2) + 0xff638400)
#define DMC_DRAM_WD11                    ((0x00eb  << 2) + 0xff638400)
#define DMC_DRAM_WD12                    ((0x00ec  << 2) + 0xff638400)
#define DMC_DRAM_WD13                    ((0x00ed  << 2) + 0xff638400)
#define DMC_DRAM_WD14                    ((0x00ee  << 2) + 0xff638400)
#define DMC_DRAM_WD15                    ((0x00ef  << 2) + 0xff638400)

#define DMC_DRAM_RD0                     ((0x00f0  << 2) + 0xff638400)
#define DMC_DRAM_RD1                     ((0x00f1  << 2) + 0xff638400)
#define DMC_DRAM_RD2                     ((0x00f2  << 2) + 0xff638400)
#define DMC_DRAM_RD3                     ((0x00f3  << 2) + 0xff638400)
#define DMC_DRAM_RD4                     ((0x00f4  << 2) + 0xff638400)
#define DMC_DRAM_RD5                     ((0x00f5  << 2) + 0xff638400)
#define DMC_DRAM_RD6                     ((0x00f6  << 2) + 0xff638400)
#define DMC_DRAM_RD7                     ((0x00f7  << 2) + 0xff638400)
#define DMC_DRAM_RD8                     ((0x00f8  << 2) + 0xff638400)
#define DMC_DRAM_RD9                     ((0x00f9  << 2) + 0xff638400)
#define DMC_DRAM_RD10                    ((0x00fa  << 2) + 0xff638400)
#define DMC_DRAM_RD11                    ((0x00fb  << 2) + 0xff638400)
#define DMC_DRAM_RD12                    ((0x00fc  << 2) + 0xff638400)
#define DMC_DRAM_RD13                    ((0x00fd  << 2) + 0xff638400)
#define DMC_DRAM_RD14                    ((0x00fe  << 2) + 0xff638400)
#define DMC_DRAM_RD15                    ((0x00ff  << 2) + 0xff638400)

// -----------------------------------------------
// REG_BASE:  DMC_STICKY_REG_BASE = 0xff638800
// -----------------------------------------------
//those register is for software save some temporary value.
//and because it's in RAM. it won't lose if DMC get reseted.
#define DMC_STICKY_0                     ((0x0000  << 2) + 0xff638800)
#define DMC_STICKY_1                     ((0x0001  << 2) + 0xff638800)
#define DMC_STICKY_2                     ((0x0002  << 2) + 0xff638800)
#define DMC_STICKY_3                     ((0x0003  << 2) + 0xff638800)
#define DMC_STICKY_4                     ((0x0004  << 2) + 0xff638800)
#define DMC_STICKY_5                     ((0x0005  << 2) + 0xff638800)
#define DMC_STICKY_6                     ((0x0006  << 2) + 0xff638800)
#define DMC_STICKY_7                     ((0x0007  << 2) + 0xff638800)
#define DMC_STICKY_8                     ((0x0008  << 2) + 0xff638800)
#define DMC_STICKY_9                     ((0x0009  << 2) + 0xff638800)
#define DMC_STICKY_10                    ((0x000a  << 2) + 0xff638800)
#define DMC_STICKY_11                    ((0x000b  << 2) + 0xff638800)
#define DMC_STICKY_12                    ((0x000c  << 2) + 0xff638800)
#define DMC_STICKY_13                    ((0x000d  << 2) + 0xff638800)
#define DMC_STICKY_14                    ((0x000e  << 2) + 0xff638800)
#define DMC_STICKY_15                    ((0x000f  << 2) + 0xff638800)
#define DMC_STICKY_16                    ((0x0010  << 2) + 0xff638800)
#define DMC_STICKY_17                    ((0x0011  << 2) + 0xff638800)
#define DMC_STICKY_18                    ((0x0012  << 2) + 0xff638800)
#define DMC_STICKY_19                    ((0x0013  << 2) + 0xff638800)
#define DMC_STICKY_20                    ((0x0014  << 2) + 0xff638800)
#define DMC_STICKY_21                    ((0x0015  << 2) + 0xff638800)
#define DMC_STICKY_22                    ((0x0016  << 2) + 0xff638800)
#define DMC_STICKY_23                    ((0x0017  << 2) + 0xff638800)
#define DMC_STICKY_24                    ((0x0018  << 2) + 0xff638800)
#define DMC_STICKY_25                    ((0x0019  << 2) + 0xff638800)
#define DMC_STICKY_26                    ((0x001a  << 2) + 0xff638800)
#define DMC_STICKY_27                    ((0x001b  << 2) + 0xff638800)
#define DMC_STICKY_28                    ((0x001c  << 2) + 0xff638800)
#define DMC_STICKY_29                    ((0x001d  << 2) + 0xff638800)
#define DMC_STICKY_30                    ((0x001e  << 2) + 0xff638800)
#define DMC_STICKY_31                    ((0x001f  << 2) + 0xff638800)
#define DMC_STICKY_32                    ((0x0020  << 2) + 0xff638800)
#define DMC_STICKY_33                    ((0x0021  << 2) + 0xff638800)
#define DMC_STICKY_34                    ((0x0022  << 2) + 0xff638800)
#define DMC_STICKY_35                    ((0x0023  << 2) + 0xff638800)
#define DMC_STICKY_36                    ((0x0024  << 2) + 0xff638800)
#define DMC_STICKY_37                    ((0x0025  << 2) + 0xff638800)
#define DMC_STICKY_38                    ((0x0026  << 2) + 0xff638800)
#define DMC_STICKY_39                    ((0x0027  << 2) + 0xff638800)
#define DMC_STICKY_40                    ((0x0028  << 2) + 0xff638800)
#define DMC_STICKY_41                    ((0x0029  << 2) + 0xff638800)
#define DMC_STICKY_42                    ((0x002a  << 2) + 0xff638800)
#define DMC_STICKY_43                    ((0x002b  << 2) + 0xff638800)
#define DMC_STICKY_44                    ((0x002c  << 2) + 0xff638800)
#define DMC_STICKY_45                    ((0x002d  << 2) + 0xff638800)
#define DMC_STICKY_46                    ((0x002e  << 2) + 0xff638800)
#define DMC_STICKY_47                    ((0x002f  << 2) + 0xff638800)
#define DMC_STICKY_48                    ((0x0030  << 2) + 0xff638800)
#define DMC_STICKY_49                    ((0x0031  << 2) + 0xff638800)
#define DMC_STICKY_50                    ((0x0032  << 2) + 0xff638800)
#define DMC_STICKY_51                    ((0x0033  << 2) + 0xff638800)
#define DMC_STICKY_52                    ((0x0034  << 2) + 0xff638800)
#define DMC_STICKY_53                    ((0x0035  << 2) + 0xff638800)
#define DMC_STICKY_54                    ((0x0036  << 2) + 0xff638800)
#define DMC_STICKY_55                    ((0x0037  << 2) + 0xff638800)
#define DMC_STICKY_56                    ((0x0038  << 2) + 0xff638800)
#define DMC_STICKY_57                    ((0x0039  << 2) + 0xff638800)
#define DMC_STICKY_58                    ((0x003a  << 2) + 0xff638800)
#define DMC_STICKY_59                    ((0x003b  << 2) + 0xff638800)
#define DMC_STICKY_60                    ((0x003c  << 2) + 0xff638800)
#define DMC_STICKY_61                    ((0x003d  << 2) + 0xff638800)
#define DMC_STICKY_62                    ((0x003e  << 2) + 0xff638800)
#define DMC_STICKY_63                    ((0x003f  << 2) + 0xff638800)

// -----------------------------------------------
// REG_BASE:  DMC_SEC_REG_BASE = 0xff639000
// -----------------------------------------------

//DMC use 15bits ID to identify the input ports and ID.
// bit 14:10.
// AXI bus ID number from 0 ~15.  2, 8~10, 12~15 Not used the others defined as bellow.
// 0 : CPU and MALI.   Mali and cpu will be separated to 2 channel.
//     CPU traffic will be assigned to ID = 0. Mali traffic will assigned to ID =1.
// 1 : Mali
// 3 : HDMI.
// 4 : HEVC.   //HEVC_F/B combined to one
// 5 : TEST.
// 6 : USB
// 7 : Device.
//11 : DEMUX
// 16: VPU read 0.
// 17: VPU read 1.
// 18: VPU read 2.
// 19: VPU write 0.
// 20: VPU write 1.
// 21: VDEC.
// 22: HCODEC.
// 23: ge2d.

//control bit for  SubID functions for all the input.
// ARM   2 bit.    HPROT[1] == 0 : SECURE CPU;   HPROT[1] == 1 : NONSEC CPU.
// GPU   2 bit.    HPROT[2] == 1 : SECURE GPU;   HPROT[2] == 0 : NONSEC GPU access;
// HDCP  4 bits.   ID AR/AWID[1:0].
// HEVC  9 bits.   HEVC use ARUSER/AWUSER[3:0] 16 levels of security control.
// TEST  1 type.
// USB   1 type.
// DEVICE  DMA    : AR/AWID[7:3] == 4'h2.  8bits control   use AR/WID[3:1].
//         AUDIO  : AR/AWID[7:3] == 4'h6.  8bits control.  use AR/AWID[2:0].
//         the others total 16 bits use AR/AWID[7:3].  bit 2 and bit 6 not used.

//VPU the 5 VPU ports use ARSEC/AWSEC as the security control.
//VDEC  total 16bits.  use AR/WID[5:2]
//GE2D. total 3bits.  2 read bits, check ARID[0].  1 write bit.   AWID dont care.

//there's total 16 ranges in the whole memory range.
// 15 ranges can be defined in 64kbyte boundary start address and end address.
// the 16th range is all other space not defined by 15 ranges.
// Each range can be enabled or disabled
//and  each range use security level bit to select key to do data scramble.
// The ranges can be overlapped or crossover.
//But from 0 to 15 ranges, the earlier has higher priority.

#define DMC_SEC_RANGE0_CTRL                   ((0x0000  << 2) + 0xff639000)
  //bit 31:16   | 0 | range0_eda | range 0 end address  higher 16bits.
  //bit 15:0    | 0 | range0_sta | range 0 start address higher 16bits.
#define DMC_SEC_RANGE0_CTRL1                  ((0x0001  << 2) + 0xff639000)
  //bit 7:5 | 0 | range0_security_level | range0 security level for DMC and DEMUX only.
  //bit 4  | 0 | range0_prot_en       | range0 allow protect monitor function.
  //             1: allowed.  0: not allowed.
  //bit 3  | 0 | range0_local_des_en  | range0 data describe enable.
  //             1: enable. 0 : disable.
  //             this bit works together with GLOBAL_DES_EN to
  //             decide this region data describe enable or not.
  //bit 2  | 0 | range0_lock  |  lock range 0 registers.
  //       write 1 to lock range 0 register. can't change anymore.
  //bit 1  | 0 | range0_key_sel | range 0 data describe key selection.  1 : key1. 0 : key0.
  //bit 0  | 0 | range0_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE1_CTRL                   ((0x0002  << 2) + 0xff639000)
  //bit 31:16   | 0 | range1_eda | range 1 end address  higher 16bits.
  //bit 15:0    | 0 | range1_sta | range 1 start address higher 16bits.
#define DMC_SEC_RANGE1_CTRL1                  ((0x0003  << 2) + 0xff639000)
  //bit 7:5 | 0 | range1_security_level | range1 security level for DMC and DEMUX only.
  //bit 4  | 0 | range1_prot_en       | range1 allow protect monitor function.
  //             1: allowed.  0: not allowed.
  //bit 3  | 0 | range1_local_des_en  | range1 data describe enable.
  //             1: enable. 0 : disable.
  //             this bit works together with GLOBAL_DES_EN to
  //             decide this region data describe enable or not.
  //bit 2  | 0 | range1_lock  |  lock range 1 registers.
  //       write 1 to lock range 1 register. can't change anymore.
  //bit 1  | 0 | range1_key_sel | range 1 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range1_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE2_CTRL                   ((0x0004  << 2) + 0xff639000)
  //bit 31:16   | 0 | range2_eda | range 2 end address  higher 16bits.
  //bit 15:0    | 0 | range2_sta | range 2 start address higher 16bits.
#define DMC_SEC_RANGE2_CTRL1                  ((0x0005  << 2) + 0xff639000)
  //bit 7:5 | 0 | range2_security_level | range2 security level for DMC and DEMUX only.
  //bit 4  | 0 | range2_prot_en       | range2 allow protect monitor function.
  //             1: allowed.  0: not allowed.
  //bit 3  | 0 | range2_local_des_en  | range2 data describe enable.
  //       1: enable. 0 : disable.
  //       this bit works together with GLOBAL_DES to
  //       decide this region data describe enable or not.
  //bit 2  | 0 | range2_lock  |  lock range 2 registers.
  //        write 1 to lock range 2 register. can't change anymore.
  //bit 1  | 0 | range2_key_sel | range 2 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range2_en    | range 2 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE3_CTRL                   ((0x0006  << 2) + 0xff639000)
  //bit 31:16   | 0 | range3_eda | range 3 end address  higher 16bits.
  //bit 15:0    | 0 | range3_sta | range 3 start address higher 16bits.
#define DMC_SEC_RANGE3_CTRL1                  ((0x0007  << 2) + 0xff639000)
  //bit 7:5 | 0 | range3_security_level | range3 security level for DMC and DEMUX only.
  //bit 4  | 0 | range3_prot_en       | range3 allow protect monitor function.
  //             1: allowed.  0: not allowed.
  //bit 3  | 0 | range3_local_des_en  | range3 data describe enable.
  //       1: enable. 0 : disable.
  //       this bit works together with GLOBAL_DES to
  //       decide this region data describe enable or not.
  //bit 2  | 0 | range3_lock    | lock range 3 registers.
  //       write 1 to lock range 3 related registers. can't change anymore.
  //bit 1  | 0 | range3_key_sel | range 3 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range3_en      | range 3 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE4_CTRL                   ((0x0008  << 2) + 0xff639000)
  //bit 31:16   | 0 | range4_eda | range 4 end address  higher 16bits.
  //bit 15:0    | 0 | range4_sta | range 4 start address higher 16bits.
#define DMC_SEC_RANGE4_CTRL1                  ((0x0009  << 2) + 0xff639000)
  //bit 7:5 | 0 | range4_security_level | range4 security level for DMC and DEMUX only.
  //bit 4  | 0 | range4_prot_en       | range4 allow protect monitor function.
  //             1: allowed.  0: not allowed.
  //bit 3  | 0 | range4_local_des_en  | range4 data describe enable.
  //       1: enable. 0 : disable.
  //       this bit works together with GLOBAL_DES to
  //       decide this region data describe enable or not.
  //bit 2  | 0 | range4_lock    | lock range 4 registers.
  //       write 1 to lock range 4 related registers. can't change anymore.
  //bit 1  | 0 | range4_key_sel | range 4 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range4_en      | range 4 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE5_CTRL                   ((0x000a  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_CTRL1                  ((0x000b  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_CTRL                   ((0x000c  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_CTRL1                  ((0x000d  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_CTRL                   ((0x000e  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_CTRL1                  ((0x000f  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_CTRL                   ((0x0010  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_CTRL1                  ((0x0011  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_CTRL                   ((0x0012  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_CTRL1                  ((0x0013  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_CTRL                  ((0x0014  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_CTRL1                 ((0x0015  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_CTRL                  ((0x0016  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_CTRL1                 ((0x0017  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_CTRL                  ((0x0018  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_CTRL1                 ((0x0019  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_CTRL                  ((0x001a  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_CTRL1                 ((0x001b  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_CTRL                  ((0x001c  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_CTRL1                 ((0x001d  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_CTRL1                 ((0x001f  << 2) + 0xff639000)
  //default : 0
  //bit 7:5 | 0 | range1_security_level | range1 security level for DMC and DEMUX only.
  //bit 4  | 0 | range1_prot_en       | range1 allow protect monitor function.
  //1: allowed.  0: not allowed.
  //bit 3  | 0 | range1_local_des_en  | range1 data describe enable.
  //1: enable. 0 : disable.
  //this bit works together with GLOBAL_DES_EN to
  //decide this region data describe enable or not.
  //bit 2  | 0 | range1_lock  |  lock range 1 registers.
  //       write 1 to lock range 1 register. can't change anymore.
  //bit 1  | 0 | range1_key_sel | range 1 data describe key selection.
  //1 : key1. 1 : key0.
  //bit 0  | 0 | not used. range 15 is always enabled.

//for each range there's 96bits read/write subid control to control all master DDR access.
//the 96bits assignments  rangex_rd_sid_en[95:0] and rangex_wr_sid_en[95:0] is as below:

//bit 3:0. for CPU  ARPROT[2:1]/AWPROT[2:1] selection.
      //CPU ARPROT[2:1] /AWPROT[2:1] define:
//bit0 PROT[2:1]==00:   data secure access.
//bit1 PROT[2:1]==01:   data non-secure access.
//bit2 PROT[2:1] 10:    instruction secure access.
//bit3 PROT[2:1] 11:    instruction non-secure access.
//bit 5:4 for GPU
//bit 4. for GPU  protected-video.
//bit 5. for GPU non-protected-video.
//bit 8. for HDCP based on HDCP input
//bit 12 for dmc_test.
//bit 13. for USB
//bit 14. for DEMUX.  DEMUX write also need check the sec_lvl <= region_sec_lvl.
//bit 15. for tvfe
//bit 31:16.for audio subid[3:0].
//bit 47:32 for 16 device subids. bit34 and bit38 not used which for dma and audio subid.
//bit 55:48 for DMA 8 thread IDs. DMA write also need check the sec_lvl <= region_sec_lvl.
//bit 63:56 not used.
//bit 79:64 for HEVC 16 security levels.
//bit 87:80 for VDEC  8 security levels.
//bit 88 for GE2D security video.
//bit 89 for GE2D security video.
//bit 90 read control bit for VPURD0 read secure video.(VPURD0 is read only).
//bit 90 write control bit for VPUWR3 write secure video.(VPUWR3 is write only path).
//bit 91 read control bit for VPURD0 read non-secure video
//bit 91 write_control bit for  VPUWR3 write non-secure video.
//bit 92 read control bit for VPURD1 read secure video.(VPURD1 is read only).
//bit 92 write control bit for VPUWR4 write secure video.(VPUWR4 is write only path).
//bit 93 read control bit for VPURD1 read non-secure video
//bit 93 write_control bit for VPUWR4 write non-secure video.
//bit 94 read control bit for VPURD2 read secure video.(VPURD2 is read only).
//bit 95 read control bit for VPURD2 read non-secure video

//per range per sub ID access enable.
#define DMC_SEC_RANGE0_RID_CTRL0              ((0x0020  << 2) + 0xff639000)
  //default : 0
  //range0_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1              ((0x0021  << 2) + 0xff639000)
  //default : 0
  //range0_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_RID_CTRL2              ((0x0022  << 2) + 0xff639000)
  //default : 0
  //range0_rd_sid_en[95:64];
#define DMC_SEC_RANGE0_RID_CTRL3              ((0x0023  << 2) + 0xff639000)
  //default : 0
  // not used.
#define DMC_SEC_RANGE0_RID_CTRL4              ((0x0024  << 2) + 0xff639000)
  //default : 0 not used in

#define DMC_SEC_RANGE1_RID_CTRL0              ((0x0026  << 2) + 0xff639000)
  //default : 0
  //range1_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_RID_CTRL1              ((0x0027  << 2) + 0xff639000)
  //default : 0
  //range1_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_RID_CTRL2              ((0x0028  << 2) + 0xff639000)
  //default : 0
  //range1_rd_sid_en[95:64];
#define DMC_SEC_RANGE1_RID_CTRL3              ((0x0029  << 2) + 0xff639000)
  // not used.
#define DMC_SEC_RANGE1_RID_CTRL4              ((0x002a  << 2) + 0xff639000)
  // not used.

#define DMC_SEC_RANGE2_RID_CTRL0              ((0x002c  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL1              ((0x002d  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL2              ((0x002e  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL3              ((0x002f  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE2_RID_CTRL4              ((0x0030  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE3_RID_CTRL0              ((0x0032  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL1              ((0x0033  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL2              ((0x0034  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL3              ((0x0035  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE3_RID_CTRL4              ((0x0036  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE4_RID_CTRL0              ((0x0038  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL1              ((0x0039  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL2              ((0x003a  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL3              ((0x003b  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE4_RID_CTRL4              ((0x003c  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE5_RID_CTRL0              ((0x003e  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL1              ((0x003f  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL2              ((0x0040  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL3              ((0x0041  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE5_RID_CTRL4              ((0x0042  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE6_RID_CTRL0              ((0x0044  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL1              ((0x0045  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL2              ((0x0046  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL3              ((0x0047  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE6_RID_CTRL4              ((0x0048  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE7_RID_CTRL0              ((0x004a  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL1              ((0x004b  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL2              ((0x004c  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL3              ((0x004d  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE7_RID_CTRL4              ((0x004e  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE8_RID_CTRL0              ((0x0050  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL1              ((0x0051  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL2              ((0x0052  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL3              ((0x0053  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE8_RID_CTRL4              ((0x0054  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE9_RID_CTRL0              ((0x0056  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL1              ((0x0057  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL2              ((0x0058  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL3              ((0x0059  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL4              ((0x005a  << 2) + 0xff639000)

#define DMC_SEC_RANGE10_RID_CTRL0             ((0x005c  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL1             ((0x005d  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL2             ((0x005e  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL3             ((0x005f  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL4             ((0x0060  << 2) + 0xff639000)

#define DMC_SEC_RANGE11_RID_CTRL0             ((0x0062  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL1             ((0x0063  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL2             ((0x0064  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL3             ((0x0065  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL4             ((0x0066  << 2) + 0xff639000)

#define DMC_SEC_RANGE12_RID_CTRL0             ((0x0068  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL1             ((0x0069  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL2             ((0x006a  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL3             ((0x006b  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL4             ((0x006c  << 2) + 0xff639000)

#define DMC_SEC_RANGE13_RID_CTRL0             ((0x006e  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL1             ((0x006f  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL2             ((0x0070  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL3             ((0x0071  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL4             ((0x0072  << 2) + 0xff639000)

#define DMC_SEC_RANGE14_RID_CTRL0             ((0x0074  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL1             ((0x0075  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL2             ((0x0076  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL3             ((0x0077  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL4             ((0x0078  << 2) + 0xff639000)

#define DMC_SEC_RANGE15_RID_CTRL0             ((0x007a  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL1             ((0x007b  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL2             ((0x007c  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL3             ((0x007d  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL4             ((0x007e  << 2) + 0xff639000)

//per range per sub ID access enable.
#define DMC_SEC_RANGE0_WID_CTRL0              ((0x0080  << 2) + 0xff639000)
  //default : 0
  //range0_wr_sid_en[31:0];
#define DMC_SEC_RANGE0_WID_CTRL1              ((0x0081  << 2) + 0xff639000)
  //default : 0
  //range0_wr_sid_en[63:32];
#define DMC_SEC_RANGE0_WID_CTRL2              ((0x0082  << 2) + 0xff639000)
  //default : 0
  //range0_wr_sid_en[95:64];
#define DMC_SEC_RANGE0_WID_CTRL3              ((0x0083  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE0_WID_CTRL4              ((0x0084  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE1_WID_CTRL0              ((0x0086  << 2) + 0xff639000)
  //default : 0
  //range1_wr_sid_en[31:0];
#define DMC_SEC_RANGE1_WID_CTRL1              ((0x0087  << 2) + 0xff639000)
  //default : 0
  //range1_wr_sid_en[63:32];
#define DMC_SEC_RANGE1_WID_CTRL2              ((0x0088  << 2) + 0xff639000)
  //default : 0
  //range1_wr_sid_en[95:64];
#define DMC_SEC_RANGE1_WID_CTRL3              ((0x0089  << 2) + 0xff639000)
  //not used.
#define DMC_SEC_RANGE1_WID_CTRL4              ((0x008a  << 2) + 0xff639000)
  //not used.

#define DMC_SEC_RANGE2_WID_CTRL0              ((0x008c  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL1              ((0x008d  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL2              ((0x008e  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL3              ((0x008f  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL4              ((0x0090  << 2) + 0xff639000)

#define DMC_SEC_RANGE3_WID_CTRL0              ((0x0092  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL1              ((0x0093  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL2              ((0x0094  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL3              ((0x0095  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL4              ((0x0096  << 2) + 0xff639000)

#define DMC_SEC_RANGE4_WID_CTRL0              ((0x0098  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL1              ((0x0099  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL2              ((0x009a  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL3              ((0x009b  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL4              ((0x009c  << 2) + 0xff639000)

#define DMC_SEC_RANGE5_WID_CTRL0              ((0x009e  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL1              ((0x009f  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL2              ((0x00a0  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL3              ((0x00a1  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL4              ((0x00a2  << 2) + 0xff639000)

#define DMC_SEC_RANGE6_WID_CTRL0              ((0x00a4  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL1              ((0x00a5  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL2              ((0x00a6  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL3              ((0x00a7  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL4              ((0x00a8  << 2) + 0xff639000)

#define DMC_SEC_RANGE7_WID_CTRL0              ((0x00aa  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL1              ((0x00ab  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL2              ((0x00ac  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL3              ((0x00ad  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL4              ((0x00ae  << 2) + 0xff639000)

#define DMC_SEC_RANGE8_WID_CTRL0              ((0x00b0  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL1              ((0x00b1  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL2              ((0x00b2  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL3              ((0x00b3  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL4              ((0x00b4  << 2) + 0xff639000)

#define DMC_SEC_RANGE9_WID_CTRL0              ((0x00b6  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL1              ((0x00b7  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL2              ((0x00b8  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL3              ((0x00b9  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL4              ((0x00ba  << 2) + 0xff639000)

#define DMC_SEC_RANGE10_WID_CTRL0             ((0x00bc  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL1             ((0x00bd  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL2             ((0x00be  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL3             ((0x00bf  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL4             ((0x00c0  << 2) + 0xff639000)

#define DMC_SEC_RANGE11_WID_CTRL0             ((0x00c2  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL1             ((0x00c3  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL2             ((0x00c4  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL3             ((0x00c5  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL4             ((0x00c6  << 2) + 0xff639000)

#define DMC_SEC_RANGE12_WID_CTRL0             ((0x00c8  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL1             ((0x00c9  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL2             ((0x00ca  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL3             ((0x00cb  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL4             ((0x00cc  << 2) + 0xff639000)

#define DMC_SEC_RANGE13_WID_CTRL0             ((0x00ce  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL1             ((0x00cf  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL2             ((0x00d0  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL3             ((0x00d1  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL4             ((0x00d2  << 2) + 0xff639000)

#define DMC_SEC_RANGE14_WID_CTRL0             ((0x00d4  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL1             ((0x00d5  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL2             ((0x00d6  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL3             ((0x00d7  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL4             ((0x00d8  << 2) + 0xff639000)

#define DMC_SEC_RANGE15_WID_CTRL0             ((0x00da  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL1             ((0x00db  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL2             ((0x00dc  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL3             ((0x00dd  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL4             ((0x00de  << 2) + 0xff639000)

#define DMC_DES_CTRL                     ((0x00e1  << 2) + 0xff639000)
 //bit 31 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN.
 //0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
 //bit 30 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && GLOBAL_DES_EN.
 //0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
 //bit 29 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && GLOBAL_DES_EN.
 //0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
 //bit 28 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && GLOBAL_DES_EN.
 //0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
 //bit 27 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN.
 //0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
 //bit 26 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && GLOBAL_DES_EN.
 //0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
 //bit 25 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && GLOBAL_DES_EN.
 //0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
 //bit 24 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && GLOBAL_DES_EN.
 //0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
 //bit 23 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN.
 //0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
 //bit 22 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && GLOBAL_DES_EN.
 //0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
 //bit 21 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && GLOBAL_DES_EN.
 //0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
 //bit 20 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN.
 //0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
 //bit 19 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && GLOBAL_DES_EN.
 //0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
 //bit 18 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && GLOBAL_DES_EN.
 //0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
 //bit 17 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN.
 //0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
 //bit 16 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && GLOBAL_DES_EN.
 //        0 :  range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.
 //bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
 //bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit,
 //     DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.

//DES KEY registers and DES_PADDING can only be reset by pad reset.
//But it can be changed by software after watch dog reset.
#define DMC_DES_KEY0_REG0                ((0x00e2  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY0_REG1                ((0x00e3  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY0_REG2                ((0x00e4  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY0_REG3                ((0x00e5  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY1_REG0                ((0x00e6  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY1_REG1                ((0x00e7  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY1_REG2                ((0x00e8  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_KEY1_REG3                ((0x00e9  << 2) + 0xff639000)
  //default : 0
#define DMC_DES_PADDING                  ((0x00e0  << 2) + 0xff639000)
  //default : 0
  //bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.

//FROM SC2, the APB bus provided Master ID through PUSER signals.
//there's total 8 master IDs could access DMC non-secure registers.
//we assign 1 control bit for each APB Master and each DMC non-secure register domains
//and we added one lock bits to lock this setting can't be modified any more.
#define DDR_APB_SEC_CTRL0                ((0x00f0  << 2) + 0xff639000)
   // APB access  control for dmc REQUEST control register access control register.
   // default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL1                ((0x00f1  << 2) + 0xff639000)
   // APB access control for DMC DRAM timing parameter and DFI interface registers.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL2                ((0x00f2  << 2) + 0xff639000)
   // APB access control for DMC PLL clock frequency control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL3                ((0x00f3  << 2) + 0xff639000)
   // APB access control for DMC sticky control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL4                ((0x00f4  << 2) + 0xff639000)
   // APB access control for DMC test control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL5                ((0x00f5  << 2) + 0xff639000)
   // APB access control for DMC clk reset control register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL6                ((0x00f6  << 2) + 0xff639000)
   // APB access control for DMC protection register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL7                ((0x00f7  << 2) + 0xff639000)
   // APB access control for DMC normal register.
   //default : 0x0ff
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL8                ((0x00f8  << 2) + 0xff639000)
   // APB access control for DDR PHY group registers.
   //default : 0x50005
   //bit 23:16.  APB access enable for DDR PHY group 1 register.
   //bit 10  PHY IMEM control 1: force PHY IMEM output 0. 0: normal working mode.
   //bit 9   PHY DMEM control 1: force PHY DMEM output 0. 0: normal working mode.
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

#define DDR_APB_SEC_CTRL9                ((0x00f9  << 2) + 0xff639000)
   // APB access control for DMC canvas register.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.

//registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS                   ((0x00fa  << 2) + 0xff639000)
 //bit 31~2. not used.
 //bit 6
 //bit 5
 //bit 4
 //bit 3   1 : normal security register write violation.
 //       ( APB bus WDATA not enquire the register value when APB write).
 //       write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC security register alert function triggered.
 //        can't clean. only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.

#define DMC_VIO_ADDR0                    ((0x00fb  << 2) + 0xff639000)
  //ddr0 write secure violation address.
#define DMC_VIO_ADDR1                    ((0x00fc  << 2) + 0xff639000)
  //bit 31:26 . not used. always 0.
  //24      ddr0 secure check violation.
  //23:21.  not used.
  //20     ddr0 write address overflow. write out of DDR size.
  //19:16. ddr0 write violation AWPROT bits.
  //15:0   ddr0_write violation ID. bit 13~9. Master ID bit 7:4 for subid.
#define DMC_VIO_ADDR2                    ((0x00fd  << 2) + 0xff639000)
  //ddr0 read secure violation address
#define DMC_VIO_ADDR3                    ((0x00fe  << 2) + 0xff639000)
  //bit 31:26. not used. always 0.
  //24     ddr0 read secure check violation.
  //23:21. Not used.
  //20     ddr 0 read address overflow. write out of DDR size.
  //19:16. ddr 0 read violation ARPROT bits.
  //15:0   ddr 0 read violation ID. bit 13~9 Master ID. bit 7:4 subid.

#define DMC_DDR_CTRL                     ((0x0100  << 2) + 0xff639000)
   //bit 27.   0 : canvas use 64bytes boundary
	      // 1 : canvas use 32bytes boundary.
  //bit 24:22   3'b000 : ddr3 mode.
	      //3'b001 : ddr4 mode.
	      //3'b010 : lpddr3 mode.
	      //3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface.
   //          0 : normal data interface.
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b0101 : DDR rank 1 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b0101 : DDR rank 0 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.

//DDR3/4 LPDDR3/4 SDRAM address  to 32bits linear address map:
//DDR0_ADDRMAP is used to select RANK0 bank, row, col address selection.
//DDR1_ADDRMAP is used to select RANK1 bank, row, col address selection.
#define DDR0_ADDRMAP_0                   ((0x0101  << 2) + 0xff639000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DDR0_ADDRMAP_1                   ((0x0102  << 2) + 0xff639000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DDR0_ADDRMAP_2                   ((0x0103  << 2) + 0xff639000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DDR0_ADDRMAP_3                   ((0x0104  << 2) + 0xff639000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DDR0_ADDRMAP_4                   ((0x0105  << 2) + 0xff639000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2.    or bg0 for DDR4.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.

#define DDR1_ADDRMAP_0                   ((0x0106  << 2) + 0xff639000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DDR1_ADDRMAP_1                   ((0x0107  << 2) + 0xff639000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DDR1_ADDRMAP_2                   ((0x0108  << 2) + 0xff639000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DDR1_ADDRMAP_3                   ((0x0109  << 2) + 0xff639000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DDR1_ADDRMAP_4                   ((0x010a  << 2) + 0xff639000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2  or bg0 for DDR4 SDRAM..
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.

#define DMC_AXI2DDR0                     ((0x0120  << 2) + 0xff639000)
  //for AXI address first 256MB  AXI ADDRESS[31:28] == 4'b0000.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr data 16bits mode   0 : 32bits.  1: 16 bits valid data in a 32bits data bus.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR1                     ((0x0121  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0001.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR2                     ((0x0122  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0010.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR3                     ((0x0123  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0011.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR4                     ((0x0124  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0100.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR5                     ((0x0125  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0101.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR6                     ((0x0126  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0110.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR7                     ((0x0127  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0111.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR8                     ((0x0128  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1000.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR9                     ((0x0129  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1001.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRA                     ((0x012a  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1010.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRB                     ((0x012b  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1011.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRC                     ((0x012c  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1100.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRD                     ((0x012d  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1101.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRE                     ((0x012e  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1110.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRF                     ((0x012f  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1111.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_DDR_CTRL1                    ((0x0130  << 2) + 0xff639000)
  //bit 1.  1: only allow DMA/DEMUX write data level == region security level.
  //0:  DMA/DEMUX write data level <= region sec level.
  //bit 0. DMC_DDR_LOCK.
  //1: LOCK DMC_DDR_CTRL, DMC_DDR_CTRL1, DMC_AXI2DDRx, DDR0/1_ADDRMAP_x registers.
  //those register can't modified any more.
  //  0: all these registers can be read/write by secure APB access.

//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//
//
// Closing file:  ./mmc_reg.vh
//

#endif // MMC_REG_DEFINE
