// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_from_register_h.pl
//
// and was applied to the file
//
// Project name: t7c
//
// Create time: Tue Mar 29 09:14:58 CST 2022 by chong.gu
//
// ./REG_LIST_RTL.h
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef REGISTER_REVC_H
#else
#define REGISTER_REVC_H

#if 0
#ifndef VERIFICATION
    #define Wr64(addr, data) *(volatile uint64_t *)(addr)=(data)
    #define Rd64(addr) *(volatile uint64_t *)(addr)
    #define Wr8(addr, data) *(volatile uint8_t *)(addr)=(data)
    #define Rd8(addr) *(volatile uint8_t *)(addr)
    #define Wr(addr, data) *(volatile uint32_t *)(addr)=(data)
    #define Rd(addr) *(volatile uint32_t *)(addr)
    #define Wr_reg_bits(reg, val, start, len) \
      Wr(reg, ((Rd(reg) & ~(((1L<<(len))-1)<<(start))) | ((uint32_t)(val & ((1L<<len)-1)) << (start))))
#else
    #include "dpi.h"
#endif
#endif

//
// Reading file:  ./REG_LIST_RTL.h
//
// synopsys translate_off
// synopsys translate_on
//
//
// Reading file:  ./../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
//dmc pll and frequency domain control registers.
//`define DMC_FREQ_REG_BASE   32'hfe0a0000
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe0a0000
// -----------------------------------------------
//
//              |               |            |---------->  1/(OD,OD1) -->ddr_dpll_clk_out_a
//  VCO ------> |  1/ reve[5:4] | --VCO_A--->|
//              |               |            |----inv--->  1/(OD,OD1) -->ddr_dpll_clk_out_b
#define AM_DDR_PLL_CNTL0                           ((0x0000  << 2) + 0xfe0a0000)
  //bit 31    : dpll_lock
  //bit 29    : dpll_reset.
  //bit 28    : dpll_en.
  //bit 27:26 : dpll_clk_en  2'b10: pll_clock output enable. 4xclk output disable..   2'b11,  pll_clock and 4xclk output enable.
                 //if set ddr_freq_sel , it would replaced by AM_DDR_FREQ_CTRL bit[11:10];
  //bit 25    : dpll_inv_sel.  4xclk inverter. if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL bit[12]
  //bit 21:19 : od1; if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[6:4]
  //bit 18:16 : od;  if set ddr_freq_sel, it would replaced by AM_DDR_FREQ_CTRL[2:0]
  //bit 14:10 : dpll_ref_div_n
  //bit 8:0   : dpll_int_num
#define AM_DDR_PLL_CNTL1                           ((0x0001  << 2) + 0xfe0a0000)
  //bit 18:0    : ddr_dpll_frac
#define AM_DDR_PLL_CNTL2                           ((0x0002  << 2) + 0xfe0a0000)
  //bit 22:20  : fref_sel
  //bit 17:16  : os_ssc
  //bit 15:12  : ssc_str_m
  //bit 8      : ssc_en
  //bit 7:4    : ssc_dep_sel
  //bit 1:0    : dpll ss_mode.
#define AM_DDR_PLL_CNTL3                           ((0x0003  << 2) + 0xfe0a0000)
  //bit 31     : afc bypass
  //bit 30     : afc clk sel
  //bit 29     : code new
  //bit 28     : dco_m_en
  //bit 27     : dco_sdm_en
  //bit 26     : div2
  //bit 25     : div mode
  //bit 24     : fast_lock mode
  //bit 23     : fb_pre_div
  //bit 22     : filter_mode
  //bit 21     : fix_en
  //bit 20     : freq_shift_en
  //bit 19     : load
  //bit 18     : load_en
  //bit 17     : lock_f
  //bit 16     : pulse_width_en
  //bit 15     : sdmnc_en
  //bit 14     : sdmnc_mode
  //bit 13     : sdmnc_range
  //bit 12     : tdc_en
  //bit 11     : tdc_mode_sel
  //bit 10     :  wait_en
#define AM_DDR_PLL_CNTL4                           ((0x0004  << 2) + 0xfe0a0000)
  //bit 1:0    : pfd_gain
  //bit 7:4    : filter_pvt1
  //bit 11:8   : filter pvt2
  //bit 13:12  : acq_gain
  //bit 18:16  : lambda0
  //bit 27:24  : rou
  //bit 31:28  : alpha
#define AM_DDR_PLL_CNTL5                           ((0x0005  << 2) + 0xfe0a0000)
  //bit
  //bit 30:28  : adj_vco_ldo
  //bit 27:24  : lm_w
  //bit 21:16  : lm_s
  //bit 15:6   : reve[15:6]
  //bit 5:4.   : reve[5:4] for chan_A, chan_B phase control. if freq =1, it would replaced by AM_DDR_FREQ_CTRL bit[11:10];
  //bit 3:0    : reve[3:0]
#define AM_DDR_PLL_CNTL6                           ((0x0006  << 2) + 0xfe0a0000)
  //bit 31:30  : afc_hold_t
  //bit 29:28  : lkw_sel
  //bit 27:26  : dco_sdm_clk_sel
  //bit 25:24  : afc_in
  //bit 23:22  : afc_nt
  //bit 21:20  : vc_in
  //bit 19:18  : lock_long
  //bit 17:16  : freq_shift_v
  //bit 15     : not used.
  //bit 14:12  : data_sel
  //bit 10:8   : sdmnc_ulms
  //bit 6:0    : sdmnc_power
#define AM_DDR_PLL_STS                             ((0x0007  << 2) + 0xfe0a0000)
  //bit 31     : DDR_PLL_LOCK
  //bit 30     : lock_a
  //bit 29     : afc_done
  //bit 22:16  : sdmnc_monitor
  //bit 9:0    : out_rsv
#define AM_DDR_CLK_CNTL                            ((0x0008  << 2) + 0xfe0a0000)
  //bit 31     Channel 0 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
               // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 30.    channel 0 ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 29.    pll production  clock output selection. 1: select ddr_dpll_clk_out_b. : 0 : select ddr_dpll_clk_out_a;
  //bit 28.    clock generation logic soft reset_n. 0: reset. 1: normal mode.
  //bit 27.    channel 0 phy_4xclk phase inverter..
  //bit 25.    Channel 0 DDRPHY DfiClk/DfiCtlClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 24.    Channel 0 AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 23     Channel 1 ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
               // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 22.    channel 1 ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 21:20. not used.
  //bit 19.    channel 1 phy_4xclk phase inverter..
  //bit 17.    Channel 1 DDRPHY DfiClk/DfiCtlClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 16.    Channel 1 AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 12. ddr1 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
  //bit 11.  ddr1 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
  //bit 10. enable ddr channel 1 dmc_clk.
  //bit 9.  enable LPDDR4-PHY channel 1 DfiClk.
  //bit 8.  enable LPDDR4-PHY channel 1 DfiCtlClk.
  //bit 4.  ddr0 def_clk_sel   1: select reference clock as LPDDR4-PHY clock.  0: normal.
  //bit 3.  ddr0 default clock enable. enable PCLK as LPDDR4_PHY clock. 0: disable.
  //bit 2.  enable ddr channel 0 dmc_clk.
  //bit 1.  enable LPDDR4-PHY channel 0 DfiClk.
  //bit 0.  enable LPDDR4-PHY channel 0 DfiCtlClk.
#define AM_DDR_PHY_CTRL                            ((0x0009  << 2) + 0xfe0a0000)
  // LPDDR4 power on reset need to special combination of PwrOkIn and phy_reset_n.
  // please check the PHY PUB data book for detail.
  //bit 31:8.  Not used.
  //bit 7.   use dmc_clk_freq to control DDR-PHY channel 1 refresh/retraining/freqency change/phy power etc.
  //bit 6.   use dmc_clk_freq to control DDR-PHY channel 0 refresh/retraining/freqency change/phy power etc.
  //bit 5.   DDR_PHY 1 PwrOkIn pin.
  //bit 4.   DDR_PHY 0 PwrOkIn pin.
  //bit 3.   DDR_PHY 1 APB soft reset_n.
  //bit 2.   DDR_PHY 1 phy_reset_n.
  //bit 1.   DDR_PHY 0 APB soft reset_n.
  //bit 0.   DDR_PHY 0 phy_reset_n.
#define AM_DDR_FREQ_CTRL                           ((0x000c  << 2) + 0xfe0a0000)
  //bit 31.  write trigger the DDR frequency change procedure.  read =0 the freqency change done.
  //bit 30     currunt FREQ selection.  it can forced to change to select which freqency to select, or it can auto changed by FREQ change hardware.
  //bit 29     next freq for frequency change.
  //bit 12.    ddr_dpll_inv_sel in frequency1 for 4xclk inverter.
  //bit 11:10. ddr_dpll_clk_en in frequency1 for 4xclk and clock output.
  //bit 9:8. pll_reseve in frequency1. pll_reseve[5:4] used to tune 2 DMC channel clock phase.
  //bit 6:4   OD1 number in frequency 1.
  //bit 2:0.  OD  number in frequency 1.
#define AM_DDR_TIMING_F0                           ((0x000d  << 2) + 0xfe0a0000)
  //freqency 0  auto refresh timing.
  //bit 7:0. T100ns. how many clock cycle for 100ns.
  //bit15:8. refresh period in 100ns.
#define AM_DDR_TIMING_F1                           ((0x000e  << 2) + 0xfe0a0000)
  //freqency 1  auto refresh timing.
  //bit 7:0. T100ns. how many clock cycle for 100ns.
  //bit15:8. refresh period in 100ns.
#define AM_DDR_TIMING_CFG                          ((0x000f  << 2) + 0xfe0a0000)
  //bit 31.  cfg ddr timing.  write 1 to save the timing parameters to ddr clock domain.
  //bit 30.  dmc_clk_freq control the LPDDR4 retraining.
  //bit 29.  dmc_clk_freq control the auto refresh timing.
  //bit 28:24. not use.
  //bit 23:0.  lpddr4 phy retraining timer counter in 100ns.
//
// Closing file:  ./../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
//========================================================================
// STARTUP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe02e000
// -----------------------------------------------
#define STARTUP_LOCK                               ((0x0000  << 2) + 0xfe02e000)
#define STARTUP_DFU_STS                            ((0x0004  << 2) + 0xfe02e000)
#define STARTUP_BOOT_SRC                           ((0x0008  << 2) + 0xfe02e000)
#define STARTUP_TEE_REQ_DFU                        ((0x0009  << 2) + 0xfe02e000)
#define STARTUP_BOOT_OVERRIDE                      ((0x000a  << 2) + 0xfe02e000)
#define STARTUP_COLD_BOOT_CNT                      ((0x000b  << 2) + 0xfe02e000)
#define STARTUP_KEY_PRESERVE                       ((0x000c  << 2) + 0xfe02e000)
//========================================================================
// MIPI_DSI_PHY
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe014000
// -----------------------------------------------
//`define MIPI_DSI_PHY_START      8'h00
//`define MIPI_DSI_PHY_END        16'hffff
#define MIPI_DSI_PHY_CTRL                          ((0x0000  << 2) + 0xfe014000)
  //bit 31.  soft reset for the phy. 1 = reset. 0 = dessert the reset.
  //bit 30.  clock lane soft reset.
  //bit 29.  data byte lane 3 soft reset.
  //bit 28.  data byte lane 2 soft reset.
  //bit 27.  data byte lane 1 soft reset.
  //bit 26.  data byte lane 0 soft reset.
  //bit 5.   LPDT data endian.  1 = transfer the high bit first. 0 : transfer the low bit first.
  //bit 4.   HS data endian.
  //bit 3.  force data byte lane in stop mode.
  //bit 2.  force data byte lane 0 in reciever mode.
  //bit 1. write 1 to sync the txclkesc input. the internal logic have to use txclkesc to decide Txvalid and Txready.
  //bit 0.  enalbe the MIPI DSI PHY TxDDRClk.
#define MIPI_DSI_CHAN_CTRL                         ((0x0001  << 2) + 0xfe014000)
  //bit 31.   clk lane tx_hs_en control selection.  1 = from register. 0 use clk lane state machine.
  //bit 30.   register bit for clock lane tx_hs_en.
  //bit 29.  clk lane tx_lp_en contrl selection.  1 = from register. 0 from clk lane state machine.
  //bit 28.  register bit for clock lane tx_lp_en.
  //bit 27.  chan0 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 26.  register bit for chan0 tx_hs_en.
  //bit 25.  chan0 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 24. register bit from chan0 tx_lp_en.
  //bit 23.  chan0 rx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 22. register bit from chan0 rx_lp_en.
  //bit 21.  chan0 contention detection enable control selection. 1 = from register. 0 from chan0 state machine.
  //bit 20. register bit from chan0 contention detection enable.
  //bit 19.  chan1 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 18.  register bit for chan1 tx_hs_en.
  //bit 17.  chan1 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 16. register bit from chan1 tx_lp_en.
  //bit 15.  chan2 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 14.  register bit for chan2 tx_hs_en.
  //bit 13.  chan2 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 12. register bit from chan2 tx_lp_en.
  //bit 11. chan3 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 10. register bit for chan3 tx_hs_en.
  //bit 9.  chan3 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 8. register bit from chan3 tx_lp_en.
  //bit 4.  clk chan power down. this bit is also used as the power down of the whole MIPI_DSI_PHY.
  //bit 3.  chan3 power down.
  //bit 2.  chan2 power down.
  //bit 1.  chan1 power down.
  //bit 0.  chan0 power down.
#define MIPI_DSI_CHAN_STS                          ((0x0002  << 2) + 0xfe014000)
 //bit 24.  chan0 TX->RX turn can't accept the ACK command from slave watch dog triggered.  write 1 to clear the status bit.
 //bit 23.  chan0 RX ESC command watch dog triggered. write 1 to clean this bit.
 //bit
#define MIPI_DSI_CLK_TIM                           ((0x0003  << 2) + 0xfe014000)
  //bit 31:24. TCLK_PREPARE.
  //bit 23:16. TCLK_ZERO.
  //bit 15:8.  TCLK_POST.
  //bit 7:0.   TCLK_TRAIL.
#define MIPI_DSI_HS_TIM                            ((0x0004  << 2) + 0xfe014000)
  //bit 31:24. THS_PREPARE.
  //bit 23:16. THS_ZERO.
  //bit 15:8.  THS_TRAIL.
  //bit 7:0.   THS_EXIT.
#define MIPI_DSI_LP_TIM                            ((0x0005  << 2) + 0xfe014000)
  //bit 31:24. tTA_GET.
  //bit 23:16. tTA_GO.
  //bit 15:8.  tTA_SURE.
  //bit 7:0.   tLPX.
#define MIPI_DSI_ANA_UP_TIM                        ((0x0006  << 2) + 0xfe014000)
  //wait time to  MIPI DIS analog ready.
#define MIPI_DSI_INIT_TIM                          ((0x0007  << 2) + 0xfe014000)
  // TINIT.
#define MIPI_DSI_WAKEUP_TIM                        ((0x0008  << 2) + 0xfe014000)
  //TWAKEUP.
#define MIPI_DSI_LPOK_TIM                          ((0x0009  << 2) + 0xfe014000)
  //bit 31:0 when in RxULPS state, RX reciever is in sleep mode.
  //every MIPI_DSI_ULPS_CHECK period, the reciever would be enabled once, and waiting this timer period to get the stable input.
#define MIPI_DSI_LP_WCHDOG                         ((0x000a  << 2) + 0xfe014000)
  //bit 31:0 watch dog timer for MIPI DSI LP receive state.
#define MIPI_DSI_ANA_CTRL                          ((0x000b  << 2) + 0xfe014000)
  //bit 31:0 tMBIAS.  timer to wait for analog mBIAS voltage stable.
#define MIPI_DSI_CLK_TIM1                          ((0x000c  << 2) + 0xfe014000)
  //bit 31:8  not used.
  //bit 7:0    tCLK_PRE
#define MIPI_DSI_TURN_WCHDOG                       ((0x000d  << 2) + 0xfe014000)
 //bit 31:0 watch dog timer for lane 0 LP turn around waiting time.
#define MIPI_DSI_ULPS_CHECK                        ((0x000e  << 2) + 0xfe014000)
 //bit 31:0 when Lane0 in LP recieve state,  if the another side sent Low power command,  using this timer to enable Tcheck the another size wakeup nor not.
#define MIPI_DSI_TEST_CTRL0                        ((0x000f  << 2) + 0xfe014000)
#define MIPI_DSI_TEST_CTRL1                        ((0x0010  << 2) + 0xfe014000)
//========================================================================
// MIPI_DSI_PHY B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe016000
// -----------------------------------------------
//`define MIPI_DSI_PHY_START      8'h00
//`define MIPI_DSI_PHY_END        16'hffff
#define MIPI_DSI_B_PHY_CTRL                        ((0x0000  << 2) + 0xfe016000)
  //bit 31.  soft reset for the phy. 1 = reset. 0 = dessert the reset.
  //bit 30.  clock lane soft reset.
  //bit 29.  data byte lane 3 soft reset.
  //bit 28.  data byte lane 2 soft reset.
  //bit 27.  data byte lane 1 soft reset.
  //bit 26.  data byte lane 0 soft reset.
  //bit 5.   LPDT data endian.  1 = transfer the high bit first. 0 : transfer the low bit first.
  //bit 4.   HS data endian.
  //bit 3.  force data byte lane in stop mode.
  //bit 2.  force data byte lane 0 in reciever mode.
  //bit 1. write 1 to sync the txclkesc input. the internal logic have to use txclkesc to decide Txvalid and Txready.
  //bit 0.  enalbe the MIPI DSI PHY TxDDRClk.
#define MIPI_DSI_B_CHAN_CTRL                       ((0x0001  << 2) + 0xfe016000)
  //bit 31.   clk lane tx_hs_en control selection.  1 = from register. 0 use clk lane state machine.
  //bit 30.   register bit for clock lane tx_hs_en.
  //bit 29.  clk lane tx_lp_en contrl selection.  1 = from register. 0 from clk lane state machine.
  //bit 28.  register bit for clock lane tx_lp_en.
  //bit 27.  chan0 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 26.  register bit for chan0 tx_hs_en.
  //bit 25.  chan0 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 24. register bit from chan0 tx_lp_en.
  //bit 23.  chan0 rx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 22. register bit from chan0 rx_lp_en.
  //bit 21.  chan0 contention detection enable control selection. 1 = from register. 0 from chan0 state machine.
  //bit 20. register bit from chan0 contention detection enable.
  //bit 19.  chan1 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 18.  register bit for chan1 tx_hs_en.
  //bit 17.  chan1 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 16. register bit from chan1 tx_lp_en.
  //bit 15.  chan2 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 14.  register bit for chan2 tx_hs_en.
  //bit 13.  chan2 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 12. register bit from chan2 tx_lp_en.
  //bit 11. chan3 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 10. register bit for chan3 tx_hs_en.
  //bit 9.  chan3 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 8. register bit from chan3 tx_lp_en.
  //bit 4.  clk chan power down. this bit is also used as the power down of the whole MIPI_DSI_PHY.
  //bit 3.  chan3 power down.
  //bit 2.  chan2 power down.
  //bit 1.  chan1 power down.
  //bit 0.  chan0 power down.
#define MIPI_DSI_B_CHAN_STS                        ((0x0002  << 2) + 0xfe016000)
 //bit 24.  chan0 TX->RX turn can't accept the ACK command from slave watch dog triggered.  write 1 to clear the status bit.
 //bit 23.  chan0 RX ESC command watch dog triggered. write 1 to clean this bit.
 //bit
#define MIPI_DSI_B_CLK_TIM                         ((0x0003  << 2) + 0xfe016000)
  //bit 31:24. TCLK_PREPARE.
  //bit 23:16. TCLK_ZERO.
  //bit 15:8.  TCLK_POST.
  //bit 7:0.   TCLK_TRAIL.
#define MIPI_DSI_B_HS_TIM                          ((0x0004  << 2) + 0xfe016000)
  //bit 31:24. THS_PREPARE.
  //bit 23:16. THS_ZERO.
  //bit 15:8.  THS_TRAIL.
  //bit 7:0.   THS_EXIT.
#define MIPI_DSI_B_LP_TIM                          ((0x0005  << 2) + 0xfe016000)
  //bit 31:24. tTA_GET.
  //bit 23:16. tTA_GO.
  //bit 15:8.  tTA_SURE.
  //bit 7:0.   tLPX.
#define MIPI_DSI_B_ANA_UP_TIM                      ((0x0006  << 2) + 0xfe016000)
  //wait time to  MIPI DIS analog ready.
#define MIPI_DSI_B_INIT_TIM                        ((0x0007  << 2) + 0xfe016000)
  // TINIT.
#define MIPI_DSI_B_WAKEUP_TIM                      ((0x0008  << 2) + 0xfe016000)
  //TWAKEUP.
#define MIPI_DSI_B_LPOK_TIM                        ((0x0009  << 2) + 0xfe016000)
  //bit 31:0 when in RxULPS state, RX reciever is in sleep mode.
  //every MIPI_DSI_ULPS_CHECK period, the reciever would be enabled once, and waiting this timer period to get the stable input.
#define MIPI_DSI_B_LP_WCHDOG                       ((0x000a  << 2) + 0xfe016000)
  //bit 31:0 watch dog timer for MIPI DSI LP receive state.
#define MIPI_DSI_B_ANA_CTRL                        ((0x000b  << 2) + 0xfe016000)
  //bit 31:0 tMBIAS.  timer to wait for analog mBIAS voltage stable.
#define MIPI_DSI_B_CLK_TIM1                        ((0x000c  << 2) + 0xfe016000)
  //bit 31:8  not used.
  //bit 7:0    tCLK_PRE
#define MIPI_DSI_B_TURN_WCHDOG                     ((0x000d  << 2) + 0xfe016000)
 //bit 31:0 watch dog timer for lane 0 LP turn around waiting time.
#define MIPI_DSI_B_ULPS_CHECK                      ((0x000e  << 2) + 0xfe016000)
 //bit 31:0 when Lane0 in LP recieve state,  if the another side sent Low power command,  using this timer to enable Tcheck the another size wakeup nor not.
#define MIPI_DSI_B_TEST_CTRL0                      ((0x000f  << 2) + 0xfe016000)
#define MIPI_DSI_B_TEST_CTRL1                      ((0x0010  << 2) + 0xfe016000)
//========================================================================
//  Temp sensor: A73
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe020000
// -----------------------------------------------
#define TS_A73_CFG_REG1                            ((0x0001  << 2) + 0xfe020000)
#define TS_A73_CFG_REG2                            ((0x0002  << 2) + 0xfe020000)
#define TS_A73_CFG_REG3                            ((0x0003  << 2) + 0xfe020000)
#define TS_A73_CFG_REG4                            ((0x0004  << 2) + 0xfe020000)
#define TS_A73_CFG_REG5                            ((0x0005  << 2) + 0xfe020000)
#define TS_A73_CFG_REG6                            ((0x0006  << 2) + 0xfe020000)
#define TS_A73_CFG_REG7                            ((0x0007  << 2) + 0xfe020000)
#define TS_A73_STAT0                               ((0x0010  << 2) + 0xfe020000)
#define TS_A73_STAT1                               ((0x0011  << 2) + 0xfe020000)
#define TS_A73_STAT2                               ((0x0012  << 2) + 0xfe020000)
#define TS_A73_STAT3                               ((0x0013  << 2) + 0xfe020000)
#define TS_A73_STAT4                               ((0x0014  << 2) + 0xfe020000)
#define TS_A73_STAT5                               ((0x0015  << 2) + 0xfe020000)
#define TS_A73_STAT6                               ((0x0016  << 2) + 0xfe020000)
#define TS_A73_STAT7                               ((0x0017  << 2) + 0xfe020000)
#define TS_A73_STAT8                               ((0x0018  << 2) + 0xfe020000)
#define TS_A73_STAT9                               ((0x0019  << 2) + 0xfe020000)
//========================================================================
//  Temp sensor: A53
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe022000
// -----------------------------------------------
#define TS_A53_CFG_REG1                            ((0x0001  << 2) + 0xfe022000)
#define TS_A53_CFG_REG2                            ((0x0002  << 2) + 0xfe022000)
#define TS_A53_CFG_REG3                            ((0x0003  << 2) + 0xfe022000)
#define TS_A53_CFG_REG4                            ((0x0004  << 2) + 0xfe022000)
#define TS_A53_CFG_REG5                            ((0x0005  << 2) + 0xfe022000)
#define TS_A53_CFG_REG6                            ((0x0006  << 2) + 0xfe022000)
#define TS_A53_CFG_REG7                            ((0x0007  << 2) + 0xfe022000)
#define TS_A53_STAT0                               ((0x0010  << 2) + 0xfe022000)
#define TS_A53_STAT1                               ((0x0011  << 2) + 0xfe022000)
#define TS_A53_STAT2                               ((0x0012  << 2) + 0xfe022000)
#define TS_A53_STAT3                               ((0x0013  << 2) + 0xfe022000)
#define TS_A53_STAT4                               ((0x0014  << 2) + 0xfe022000)
#define TS_A53_STAT5                               ((0x0015  << 2) + 0xfe022000)
#define TS_A53_STAT6                               ((0x0016  << 2) + 0xfe022000)
#define TS_A53_STAT7                               ((0x0017  << 2) + 0xfe022000)
#define TS_A53_STAT8                               ((0x0018  << 2) + 0xfe022000)
#define TS_A53_STAT9                               ((0x0019  << 2) + 0xfe022000)
//========================================================================
//  Temp sensor GPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe094000
// -----------------------------------------------
#define TS_GPU_CFG_REG1                            ((0x0001  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG2                            ((0x0002  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG3                            ((0x0003  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG4                            ((0x0004  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG5                            ((0x0005  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG6                            ((0x0006  << 2) + 0xfe094000)
#define TS_GPU_CFG_REG7                            ((0x0007  << 2) + 0xfe094000)
#define TS_GPU_STAT0                               ((0x0010  << 2) + 0xfe094000)
#define TS_GPU_STAT1                               ((0x0011  << 2) + 0xfe094000)
#define TS_GPU_STAT2                               ((0x0012  << 2) + 0xfe094000)
#define TS_GPU_STAT3                               ((0x0013  << 2) + 0xfe094000)
#define TS_GPU_STAT4                               ((0x0014  << 2) + 0xfe094000)
#define TS_GPU_STAT5                               ((0x0015  << 2) + 0xfe094000)
#define TS_GPU_STAT6                               ((0x0016  << 2) + 0xfe094000)
#define TS_GPU_STAT7                               ((0x0017  << 2) + 0xfe094000)
#define TS_GPU_STAT8                               ((0x0018  << 2) + 0xfe094000)
#define TS_GPU_STAT9                               ((0x0019  << 2) + 0xfe094000)
//========================================================================
//  Temp sensor NNA
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe096000
// -----------------------------------------------
#define TS_NNA_CFG_REG1                            ((0x0001  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG2                            ((0x0002  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG3                            ((0x0003  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG4                            ((0x0004  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG5                            ((0x0005  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG6                            ((0x0006  << 2) + 0xfe096000)
#define TS_NNA_CFG_REG7                            ((0x0007  << 2) + 0xfe096000)
#define TS_NNA_STAT0                               ((0x0010  << 2) + 0xfe096000)
#define TS_NNA_STAT1                               ((0x0011  << 2) + 0xfe096000)
#define TS_NNA_STAT2                               ((0x0012  << 2) + 0xfe096000)
#define TS_NNA_STAT3                               ((0x0013  << 2) + 0xfe096000)
#define TS_NNA_STAT4                               ((0x0014  << 2) + 0xfe096000)
#define TS_NNA_STAT5                               ((0x0015  << 2) + 0xfe096000)
#define TS_NNA_STAT6                               ((0x0016  << 2) + 0xfe096000)
#define TS_NNA_STAT7                               ((0x0017  << 2) + 0xfe096000)
#define TS_NNA_STAT8                               ((0x0018  << 2) + 0xfe096000)
#define TS_NNA_STAT9                               ((0x0019  << 2) + 0xfe096000)
//========================================================================
//  Temp sensor VPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe098000
// -----------------------------------------------
#define TS_VPU_CFG_REG1                            ((0x0001  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG2                            ((0x0002  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG3                            ((0x0003  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG4                            ((0x0004  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG5                            ((0x0005  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG6                            ((0x0006  << 2) + 0xfe098000)
#define TS_VPU_CFG_REG7                            ((0x0007  << 2) + 0xfe098000)
#define TS_VPU_STAT0                               ((0x0010  << 2) + 0xfe098000)
#define TS_VPU_STAT1                               ((0x0011  << 2) + 0xfe098000)
#define TS_VPU_STAT2                               ((0x0012  << 2) + 0xfe098000)
#define TS_VPU_STAT3                               ((0x0013  << 2) + 0xfe098000)
#define TS_VPU_STAT4                               ((0x0014  << 2) + 0xfe098000)
#define TS_VPU_STAT5                               ((0x0015  << 2) + 0xfe098000)
#define TS_VPU_STAT6                               ((0x0016  << 2) + 0xfe098000)
#define TS_VPU_STAT7                               ((0x0017  << 2) + 0xfe098000)
#define TS_VPU_STAT8                               ((0x0018  << 2) + 0xfe098000)
#define TS_VPU_STAT9                               ((0x0019  << 2) + 0xfe098000)
//========================================================================
//  Temp sensor HEVC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09a000
// -----------------------------------------------
#define TS_HEVC_CFG_REG1                           ((0x0001  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG2                           ((0x0002  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG3                           ((0x0003  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG4                           ((0x0004  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG5                           ((0x0005  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG6                           ((0x0006  << 2) + 0xfe09a000)
#define TS_HEVC_CFG_REG7                           ((0x0007  << 2) + 0xfe09a000)
#define TS_HEVC_STAT0                              ((0x0010  << 2) + 0xfe09a000)
#define TS_HEVC_STAT1                              ((0x0011  << 2) + 0xfe09a000)
#define TS_HEVC_STAT2                              ((0x0012  << 2) + 0xfe09a000)
#define TS_HEVC_STAT3                              ((0x0013  << 2) + 0xfe09a000)
#define TS_HEVC_STAT4                              ((0x0014  << 2) + 0xfe09a000)
#define TS_HEVC_STAT5                              ((0x0015  << 2) + 0xfe09a000)
#define TS_HEVC_STAT6                              ((0x0016  << 2) + 0xfe09a000)
#define TS_HEVC_STAT7                              ((0x0017  << 2) + 0xfe09a000)
#define TS_HEVC_STAT8                              ((0x0018  << 2) + 0xfe09a000)
#define TS_HEVC_STAT9                              ((0x0019  << 2) + 0xfe09a000)
//========================================================================
//  RNG
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe034000
// -----------------------------------------------
//========================================================================
//  ACODEC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01a000
// -----------------------------------------------
#define ACODEC_0                                   ((0x0000  << 2) + 0xfe01a000)
#define ACODEC_1                                   ((0x0001  << 2) + 0xfe01a000)
#define ACODEC_2                                   ((0x0002  << 2) + 0xfe01a000)
#define ACODEC_3                                   ((0x0003  << 2) + 0xfe01a000)
#define ACODEC_4                                   ((0x0004  << 2) + 0xfe01a000)
#define ACODEC_5                                   ((0x0005  << 2) + 0xfe01a000)
#define ACODEC_6                                   ((0x0006  << 2) + 0xfe01a000)
#define ACODEC_7                                   ((0x0007  << 2) + 0xfe01a000)
//========================================================================
//  AML USB PHY A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe03c000
// -----------------------------------------------
#define AMLUSB_A0                                  ((0x0000  << 2) + 0xfe03c000)
#define AMLUSB_A1                                  ((0x0001  << 2) + 0xfe03c000)
#define AMLUSB_A2                                  ((0x0002  << 2) + 0xfe03c000)
#define AMLUSB_A3                                  ((0x0003  << 2) + 0xfe03c000)
#define AMLUSB_A4                                  ((0x0004  << 2) + 0xfe03c000)
#define AMLUSB_A5                                  ((0x0005  << 2) + 0xfe03c000)
#define AMLUSB_A6                                  ((0x0006  << 2) + 0xfe03c000)
#define AMLUSB_A7                                  ((0x0007  << 2) + 0xfe03c000)
#define AMLUSB_A8                                  ((0x0008  << 2) + 0xfe03c000)
#define AMLUSB_A9                                  ((0x0009  << 2) + 0xfe03c000)
#define AMLUSB_A10                                 ((0x000a  << 2) + 0xfe03c000)
#define AMLUSB_A11                                 ((0x000b  << 2) + 0xfe03c000)
#define AMLUSB_A12                                 ((0x000c  << 2) + 0xfe03c000)
#define AMLUSB_A13                                 ((0x000d  << 2) + 0xfe03c000)
#define AMLUSB_A14                                 ((0x000e  << 2) + 0xfe03c000)
#define AMLUSB_A15                                 ((0x000f  << 2) + 0xfe03c000)
#define AMLUSB_A16                                 ((0x0010  << 2) + 0xfe03c000)
#define AMLUSB_A17                                 ((0x0011  << 2) + 0xfe03c000)
#define AMLUSB_A18                                 ((0x0012  << 2) + 0xfe03c000)
#define AMLUSB_A19                                 ((0x0013  << 2) + 0xfe03c000)
#define AMLUSB_A20                                 ((0x0014  << 2) + 0xfe03c000)
#define AMLUSB_A21                                 ((0x0015  << 2) + 0xfe03c000)
#define AMLUSB_A22                                 ((0x0016  << 2) + 0xfe03c000)
#define AMLUSB_A23                                 ((0x0017  << 2) + 0xfe03c000)
#define AMLUSB_A24                                 ((0x0018  << 2) + 0xfe03c000)
#define AMLUSB_A25                                 ((0x0019  << 2) + 0xfe03c000)
#define AMLUSB_A26                                 ((0x001a  << 2) + 0xfe03c000)
#define AMLUSB_A27                                 ((0x001b  << 2) + 0xfe03c000)
#define AMLUSB_A28                                 ((0x001c  << 2) + 0xfe03c000)
#define AMLUSB_A29                                 ((0x001d  << 2) + 0xfe03c000)
#define AMLUSB_A30                                 ((0x001e  << 2) + 0xfe03c000)
#define AMLUSB_A31                                 ((0x001f  << 2) + 0xfe03c000)
//========================================================================
//  AML USB PHY B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe03e000
// -----------------------------------------------
#define AMLUSB_B0                                  ((0x0000  << 2) + 0xfe03e000)
#define AMLUSB_B1                                  ((0x0001  << 2) + 0xfe03e000)
#define AMLUSB_B2                                  ((0x0002  << 2) + 0xfe03e000)
#define AMLUSB_B3                                  ((0x0003  << 2) + 0xfe03e000)
#define AMLUSB_B4                                  ((0x0004  << 2) + 0xfe03e000)
#define AMLUSB_B5                                  ((0x0005  << 2) + 0xfe03e000)
#define AMLUSB_B6                                  ((0x0006  << 2) + 0xfe03e000)
#define AMLUSB_B7                                  ((0x0007  << 2) + 0xfe03e000)
#define AMLUSB_B8                                  ((0x0008  << 2) + 0xfe03e000)
#define AMLUSB_B9                                  ((0x0009  << 2) + 0xfe03e000)
#define AMLUSB_B10                                 ((0x000a  << 2) + 0xfe03e000)
#define AMLUSB_B11                                 ((0x000b  << 2) + 0xfe03e000)
#define AMLUSB_B12                                 ((0x000c  << 2) + 0xfe03e000)
#define AMLUSB_B13                                 ((0x000d  << 2) + 0xfe03e000)
#define AMLUSB_B14                                 ((0x000e  << 2) + 0xfe03e000)
#define AMLUSB_B15                                 ((0x000f  << 2) + 0xfe03e000)
#define AMLUSB_B16                                 ((0x0010  << 2) + 0xfe03e000)
#define AMLUSB_B17                                 ((0x0011  << 2) + 0xfe03e000)
#define AMLUSB_B18                                 ((0x0012  << 2) + 0xfe03e000)
#define AMLUSB_B19                                 ((0x0013  << 2) + 0xfe03e000)
#define AMLUSB_B20                                 ((0x0014  << 2) + 0xfe03e000)
#define AMLUSB_B21                                 ((0x0015  << 2) + 0xfe03e000)
#define AMLUSB_B22                                 ((0x0016  << 2) + 0xfe03e000)
#define AMLUSB_B23                                 ((0x0017  << 2) + 0xfe03e000)
#define AMLUSB_B24                                 ((0x0018  << 2) + 0xfe03e000)
#define AMLUSB_B25                                 ((0x0019  << 2) + 0xfe03e000)
#define AMLUSB_B26                                 ((0x001a  << 2) + 0xfe03e000)
#define AMLUSB_B27                                 ((0x001b  << 2) + 0xfe03e000)
#define AMLUSB_B28                                 ((0x001c  << 2) + 0xfe03e000)
#define AMLUSB_B29                                 ((0x001d  << 2) + 0xfe03e000)
#define AMLUSB_B30                                 ((0x001e  << 2) + 0xfe03e000)
#define AMLUSB_B31                                 ((0x001f  << 2) + 0xfe03e000)
//========================================================================
//  PAD_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe004000
// -----------------------------------------------
#define PADCTRL_PIN_MUX_REG0                       ((0x0000  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG1                       ((0x0001  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG2                       ((0x0002  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG3                       ((0x0003  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG4                       ((0x0004  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG5                       ((0x0005  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG6                       ((0x0006  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG7                       ((0x0007  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG8                       ((0x0008  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG9                       ((0x0009  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGA                       ((0x000a  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGB                       ((0x000b  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGC                       ((0x000c  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGD                       ((0x000d  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGE                       ((0x000e  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGF                       ((0x000f  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGG                       ((0x0010  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGH                       ((0x0011  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGI                       ((0x0012  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGJ                       ((0x0013  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGK                       ((0x0014  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGL                       ((0x0015  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGM                       ((0x0016  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGN                       ((0x0017  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGO                       ((0x0018  << 2) + 0xfe004000)
#define PWRCTRL_CCI_REG                            ((0x0019  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL0                     ((0x0020  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL1                     ((0x0021  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL2                     ((0x0022  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL3                     ((0x0023  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL4                     ((0x0024  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL5                     ((0x0025  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL6                     ((0x0026  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL7                     ((0x0027  << 2) + 0xfe004000)
#define PADCTRL_WORLD_SYNC_CTRL0                   ((0x0028  << 2) + 0xfe004000)
#define PADCTRL_GPIO_MSR_CTRL0                     ((0x0029  << 2) + 0xfe004000)
#define PADCTRL_MISC_CTRL0                         ((0x002a  << 2) + 0xfe004000)
#define PADCTRL_WD_RSTO_CTRL                       ((0x002b  << 2) + 0xfe004000)
#define PADCTRL_BL_CTRL                            ((0x002c  << 2) + 0xfe004000)
#define PADCTRL_UART_DISABLE_CTRL                  ((0x002d  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_I                            ((0x0030  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_O                            ((0x0031  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_OEN                          ((0x0032  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PULL_EN                      ((0x0033  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PULL_UP                      ((0x0034  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_LOCK                         ((0x0035  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PROT                         ((0x0036  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_DS                           ((0x0037  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_I                            ((0x0038  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_O                            ((0x0039  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_OEN                          ((0x003a  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PULL_EN                      ((0x003b  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PULL_UP                      ((0x003c  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_LOCK                         ((0x003d  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PROT                         ((0x003e  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_DS                           ((0x003f  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_I                            ((0x0040  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_O                            ((0x0041  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_OEN                          ((0x0042  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_PULL_EN                      ((0x0043  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_PULL_UP                      ((0x0044  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_LOCK                         ((0x0045  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_PROT                         ((0x0046  << 2) + 0xfe004000)
#define PADCTRL_GPIOZ_DS                           ((0x0047  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_I                            ((0x0048  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_O                            ((0x0049  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_OEN                          ((0x004a  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_PULL_EN                      ((0x004b  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_PULL_UP                      ((0x004c  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_LOCK                         ((0x004d  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_PROT                         ((0x004e  << 2) + 0xfe004000)
#define PADCTRL_GPIOH_DS                           ((0x004f  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_I                            ((0x0050  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_O                            ((0x0051  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_OEN                          ((0x0052  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PULL_EN                      ((0x0053  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PULL_UP                      ((0x0054  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_LOCK                         ((0x0055  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PROT                         ((0x0056  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_DS                           ((0x0057  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_I                            ((0x0058  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_O                            ((0x0059  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_OEN                          ((0x005a  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PULL_EN                      ((0x005b  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PULL_UP                      ((0x005c  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_LOCK                         ((0x005d  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PROT                         ((0x005e  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_DS                           ((0x005f  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_I                            ((0x0060  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_O                            ((0x0061  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_OEN                          ((0x0062  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PULL_EN                      ((0x0063  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PULL_UP                      ((0x0064  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_LOCK                         ((0x0065  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PROT                         ((0x0066  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_DS                           ((0x0067  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_DS_EXT                       ((0x0068  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_I                            ((0x0070  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_O                            ((0x0071  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_OEN                          ((0x0072  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_PULL_EN                      ((0x0073  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_PULL_UP                      ((0x0074  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_LOCK                         ((0x0075  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_PROT                         ((0x0076  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_DS                           ((0x0077  << 2) + 0xfe004000)
#define PADCTRL_GPIOT_DS_EXT                       ((0x0078  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_I                            ((0x0080  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_O                            ((0x0081  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_OEN                          ((0x0082  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_PULL_EN                      ((0x0083  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_PULL_UP                      ((0x0084  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_LOCK                         ((0x0085  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_PROT                         ((0x0086  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_DS                           ((0x0087  << 2) + 0xfe004000)
#define PADCTRL_GPIOY_DS_EXT                       ((0x0088  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_I                            ((0x0090  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_O                            ((0x0091  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_OEN                          ((0x0092  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_PULL_EN                      ((0x0093  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_PULL_UP                      ((0x0094  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_LOCK                         ((0x0095  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_PROT                         ((0x0096  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_DS                           ((0x0097  << 2) + 0xfe004000)
#define PADCTRL_GPIOW_DS_EXT                       ((0x0098  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_I                            ((0x00a0  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_O                            ((0x00a1  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_OEN                          ((0x00a2  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_PULL_EN                      ((0x00a3  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_PULL_UP                      ((0x00a4  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_LOCK                         ((0x00a5  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_PROT                         ((0x00a6  << 2) + 0xfe004000)
#define PADCTRL_GPIOM_DS                           ((0x00a7  << 2) + 0xfe004000)
#define PADCTRL_TESTN_I                            ((0x00b0  << 2) + 0xfe004000)
#define PADCTRL_TESTN_O                            ((0x00b1  << 2) + 0xfe004000)
#define PADCTRL_TESTN_OEN                          ((0x00b2  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PULL_EN                      ((0x00b3  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PULL_UP                      ((0x00b4  << 2) + 0xfe004000)
#define PADCTRL_TESTN_LOCK                         ((0x00b5  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PROT                         ((0x00b6  << 2) + 0xfe004000)
#define PADCTRL_TESTN_DS                           ((0x00b7  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX0                      ((0x00d0  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX1                      ((0x00d1  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX2                      ((0x00d2  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX3                      ((0x00d3  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX4                      ((0x00d4  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX5                      ((0x00d5  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX6                      ((0x00d6  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX0                      ((0x00d8  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX1                      ((0x00d9  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX2                      ((0x00da  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX3                      ((0x00db  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX4                      ((0x00dc  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX5                      ((0x00dd  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX6                      ((0x00de  << 2) + 0xfe004000)
#define PADCTRL_MUTE_CTRL                          ((0x00e0  << 2) + 0xfe004000)
#define PADCTRL_MUTE_TDM_DISA                      ((0x00e1  << 2) + 0xfe004000)
#define PADCTRL_DEBUG_SEL                          ((0x00e2  << 2) + 0xfe004000)
//========================================================================
//  SYS_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe010000
// -----------------------------------------------
#define SYSCTRL_METAL_REV0                         ((0x0000  << 2) + 0xfe010000)
#define SYSCTRL_METAL_REV1                         ((0x0001  << 2) + 0xfe010000)
#define SYSCTRL_METAL_REV2                         ((0x0002  << 2) + 0xfe010000)
#define SYSCTRL_CHIP_ID                            ((0x000b  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_REG0                    ((0x0010  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_STICKY_REG0             ((0x0011  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_SEC_REG0                ((0x0012  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_STICKY_SEC_REG0         ((0x0013  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_REG0                     ((0x0014  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_REG1                     ((0x0015  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_SEC_REG0                 ((0x0016  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_REG0              ((0x0017  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_REG1              ((0x0018  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_SEC_REG0          ((0x0019  << 2) + 0xfe010000)
#define SYSCTRL_TIMERA_CTRL                        ((0x0030  << 2) + 0xfe010000)
#define SYSCTRL_TIMERA                             ((0x0031  << 2) + 0xfe010000)
#define SYSCTRL_TIMERB_CTRL                        ((0x0032  << 2) + 0xfe010000)
#define SYSCTRL_TIMERB                             ((0x0033  << 2) + 0xfe010000)
#define SYSCTRL_TIMERC_CTRL                        ((0x0034  << 2) + 0xfe010000)
#define SYSCTRL_TIMERC                             ((0x0035  << 2) + 0xfe010000)
#define SYSCTRL_TIMERD_CTRL                        ((0x0036  << 2) + 0xfe010000)
#define SYSCTRL_TIMERD                             ((0x0037  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERA_CTRL                    ((0x0038  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERA                         ((0x0039  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE_CTRL                        ((0x003a  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE                             ((0x003b  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE_HI                          ((0x003c  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF_CTRL                        ((0x003d  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF                             ((0x003e  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF_HI                          ((0x003f  << 2) + 0xfe010000)
#define SYSCTRL_TIMERG_CTRL                        ((0x0040  << 2) + 0xfe010000)
#define SYSCTRL_TIMERG                             ((0x0041  << 2) + 0xfe010000)
#define SYSCTRL_TIMERH_CTRL                        ((0x0042  << 2) + 0xfe010000)
#define SYSCTRL_TIMERH                             ((0x0043  << 2) + 0xfe010000)
#define SYSCTRL_TIMERI_CTRL                        ((0x0044  << 2) + 0xfe010000)
#define SYSCTRL_TIMERI                             ((0x0045  << 2) + 0xfe010000)
#define SYSCTRL_TIMERJ_CTRL                        ((0x0046  << 2) + 0xfe010000)
#define SYSCTRL_TIMERJ                             ((0x0047  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE_CTRL                    ((0x0048  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE                         ((0x0049  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE_HI                      ((0x004a  << 2) + 0xfe010000)
#define SYSCTRL_OSC_RING_CTRL0                     ((0x0050  << 2) + 0xfe010000)
#define SYSCTRL_OSC_RING_CTRL1                     ((0x0051  << 2) + 0xfe010000)
#define SYSCTRL_AM2AXI_CTRL0                       ((0x0052  << 2) + 0xfe010000)
#define SYSCTRL_AM2AXI_STS                         ((0x0053  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL0                     ((0x0055  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL1                     ((0x0056  << 2) + 0xfe010000)
#define SYSCTRL_TIMER90K                           ((0x0057  << 2) + 0xfe010000)
#define SYSCTRL_SCR                                ((0x0058  << 2) + 0xfe010000)
#define SYSCTRL_HPG_TIMER                          ((0x0059  << 2) + 0xfe010000)
//`define SYSCTRL_VIPNANOQ_CTRL0                  10'h5A
#define SYSCTRL_AHB2DDR_CTRL0                      ((0x005b  << 2) + 0xfe010000)
#define SYSCTRL_AHB2DDR_CTRL1                      ((0x005c  << 2) + 0xfe010000)
#define SYSCTRL_POC                                ((0x0060  << 2) + 0xfe010000)
#define SYSCTRL_VPU_SECURE_REG0                    ((0x0061  << 2) + 0xfe010000)
#define SYSCTRL_VPU_SECURE_REG1                    ((0x0062  << 2) + 0xfe010000)
#define SYSCTRL_DEWARP_SECURE_REG                  ((0x0063  << 2) + 0xfe010000)
//`define SYSCTRL_NIC_CFG0                        10'h63
#define SYSCTRL_ALERT_STS_STICKY                   ((0x0064  << 2) + 0xfe010000)
#define SYSCTRL_ALERT_ENABLE                       ((0x0066  << 2) + 0xfe010000)
#define SYSCTRL_ENABLE_SPIFC                       ((0x0068  << 2) + 0xfe010000)
#define SYSCTRL_OSC_RING_CTRL2                     ((0x0069  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL2                     ((0x006a  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL3                     ((0x006b  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL4                     ((0x006c  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL5                     ((0x006d  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL6                     ((0x006e  << 2) + 0xfe010000)
#define SYSCTRL_EDP_TEST_CTRL0                     ((0x0070  << 2) + 0xfe010000)
#define SYSCTRL_EDP_TEST_CTRL1                     ((0x0071  << 2) + 0xfe010000)
#define SYSCTRL_HDMIRXPLL_TEST_CTRL                ((0x0072  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG0                         ((0x0090  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG1                         ((0x0091  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG2                         ((0x0092  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG3                         ((0x0093  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG4                         ((0x0094  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG5                         ((0x0095  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG6                         ((0x0096  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG7                         ((0x0097  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG0                        ((0x00a0  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG1                        ((0x00a1  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG2                        ((0x00a2  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG3                        ((0x00a3  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG4                        ((0x00a4  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG5                        ((0x00a5  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG6                        ((0x00a6  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG7                        ((0x00a7  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG0                        ((0x00b0  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG1                        ((0x00b1  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG2                        ((0x00b2  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG3                        ((0x00b3  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG4                        ((0x00b4  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG5                        ((0x00b5  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG6                        ((0x00b6  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG7                        ((0x00b7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG0                    ((0x00c0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG1                    ((0x00c1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG2                    ((0x00c2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG3                    ((0x00c3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG4                    ((0x00c4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG5                    ((0x00c5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG6                    ((0x00c6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG7                    ((0x00c7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG8                    ((0x00c8  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG9                    ((0x00c9  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG10                   ((0x00ca  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG11                   ((0x00cb  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG12                   ((0x00cc  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG13                   ((0x00cd  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG14                   ((0x00ce  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG15                   ((0x00cf  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG16                   ((0x00d0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG17                   ((0x00d1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG18                   ((0x00d2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG19                   ((0x00d3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG20                   ((0x00d4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG21                   ((0x00d5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG22                   ((0x00d6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG23                   ((0x00d7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG24                   ((0x00d8  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG25                   ((0x00d9  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG26                   ((0x00da  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG27                   ((0x00db  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG28                   ((0x00dc  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG29                   ((0x00dd  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG30                   ((0x00de  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG31                   ((0x00df  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG0                    ((0x00e0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG1                    ((0x00e1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG2                    ((0x00e2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG3                    ((0x00e3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG4                    ((0x00e4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG5                    ((0x00e5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG6                    ((0x00e6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG7                    ((0x00e7  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX0_STICKY                  ((0x00f0  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX1_STICKY                  ((0x00f1  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX2_STICKY                  ((0x00f2  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX3_STICKY                  ((0x00f3  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG0                           ((0x0100  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG1                           ((0x0101  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG2                           ((0x0102  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG3                           ((0x0103  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG4                           ((0x0104  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG5                           ((0x0105  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG6                           ((0x0106  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG7                           ((0x0107  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG8                           ((0x0108  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG9                           ((0x0109  << 2) + 0xfe010000)
#define SYSCTRL_CCI_CFG10                          ((0x010a  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS0                           ((0x0110  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS1                           ((0x0111  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS2                           ((0x0112  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS3                           ((0x0113  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS4                           ((0x0114  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS5                           ((0x0115  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS6                           ((0x0116  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS7                           ((0x0117  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS8                           ((0x0118  << 2) + 0xfe010000)
#define SYSCTRL_CCI_STS9                           ((0x0119  << 2) + 0xfe010000)
#define SYSCTRL_MALI_CFG0                          ((0x0120  << 2) + 0xfe010000)
#define SYSCTRL_SPICC_CTRL0                        ((0x0124  << 2) + 0xfe010000)
#define SYSCTRL_AXISRAM_CFG0                       ((0x0128  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG0                           ((0x0130  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG1                           ((0x0131  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG2                           ((0x0132  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG3                           ((0x0133  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG4                           ((0x0134  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG5                           ((0x0135  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG6                           ((0x0136  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG7                           ((0x0137  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG8                           ((0x0138  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG9                           ((0x0139  << 2) + 0xfe010000)
#define SYSCTRL_BUS_CFG10                          ((0x013a  << 2) + 0xfe010000)
#define SYSCTRL_NOC_CFG0                           ((0x0140  << 2) + 0xfe010000)
#define SYSCTRL_NOC_STS0                           ((0x0148  << 2) + 0xfe010000)
#define SYSCTRL_NOC_STS1                           ((0x0149  << 2) + 0xfe010000)
#define SYSCTRL_LOCK_BUS_CFG0                      ((0x0150  << 2) + 0xfe010000)
#define SYSCTRL_LOCK_BUS_CFG1                      ((0x0151  << 2) + 0xfe010000)
#define SYSCTRL_PROT_BUS_CFG0                      ((0x0152  << 2) + 0xfe010000)
#define SYSCTRL_PROT_BUS_CFG1                      ((0x0153  << 2) + 0xfe010000)
//========================================================================
//  CLK_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe000000
// -----------------------------------------------
#define CLKCTRL_OSCIN_CTRL                         ((0x0001  << 2) + 0xfe000000)
#define CLKCTRL_RTC_BY_OSCIN_CTRL0                 ((0x0002  << 2) + 0xfe000000)
#define CLKCTRL_RTC_BY_OSCIN_CTRL1                 ((0x0003  << 2) + 0xfe000000)
#define CLKCTRL_RTC_CTRL                           ((0x0004  << 2) + 0xfe000000)
#define CLKCTRL_CHECK_CLK_RESULT                   ((0x0005  << 2) + 0xfe000000)
#define CLKCTRL_MBIST_ATSPEED_CTRL                 ((0x0006  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG0                      ((0x0008  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG1                      ((0x0009  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG2                      ((0x000a  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG3                      ((0x000b  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG0                      ((0x000c  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG1                      ((0x000d  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG2                      ((0x000e  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG3                      ((0x000f  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_CTRL0                      ((0x0010  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG0                   ((0x0011  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG1                   ((0x0012  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG2                   ((0x0013  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG3                   ((0x0014  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG0                   ((0x0015  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG1                   ((0x0016  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG2                   ((0x0017  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG3                   ((0x0018  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_VPU_EN0                    ((0x0019  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_VPU_EN1                    ((0x001a  << 2) + 0xfe000000)
#define CLKCTRL_AXI_CLK_CTRL0                      ((0x001b  << 2) + 0xfe000000)
#define CLKCTRL_TST_CTRL0                          ((0x0020  << 2) + 0xfe000000)
#define CLKCTRL_TST_CTRL1                          ((0x0021  << 2) + 0xfe000000)
#define CLKCTRL_CECA_CTRL0                         ((0x0022  << 2) + 0xfe000000)
#define CLKCTRL_CECA_CTRL1                         ((0x0023  << 2) + 0xfe000000)
#define CLKCTRL_CECB_CTRL0                         ((0x0024  << 2) + 0xfe000000)
#define CLKCTRL_CECB_CTRL1                         ((0x0025  << 2) + 0xfe000000)
#define CLKCTRL_SC_CLK_CTRL                        ((0x0026  << 2) + 0xfe000000)
#define CLKCTRL_DSPA_CLK_CTRL0                     ((0x0027  << 2) + 0xfe000000)
#define CLKCTRL_DSPB_CLK_CTRL0                     ((0x0028  << 2) + 0xfe000000)
#define CLKCTRL_CLK12_24_CTRL                      ((0x002a  << 2) + 0xfe000000)
#define CLKCTRL_ANAKIN_CLK_CTRL                    ((0x002b  << 2) + 0xfe000000)
#define CLKCTRL_GDC_CLK_CTRL                       ((0x002c  << 2) + 0xfe000000)
#define CLKCTRL_AMLGDC_CLK_CTRL                    ((0x002d  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK0_CTRL                      ((0x0030  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK0_CTRL2                     ((0x0031  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK0_DIV                       ((0x0032  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK0_DIV                      ((0x0033  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK0_CTRL                     ((0x0034  << 2) + 0xfe000000)
#define CLKCTRL_ENC0_HDMI_CLK_CTRL                 ((0x0035  << 2) + 0xfe000000)
#define CLKCTRL_ENC2_HDMI_CLK_CTRL                 ((0x0036  << 2) + 0xfe000000)
#define CLKCTRL_ENC_HDMI_CLK_CTRL                  ((0x0037  << 2) + 0xfe000000)
#define CLKCTRL_HDMI_CLK_CTRL                      ((0x0038  << 2) + 0xfe000000)
#define CLKCTRL_VID_PLL_CLK0_DIV                   ((0x0039  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLK_CTRL                       ((0x003a  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLKB_CTRL                      ((0x003b  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLKC_CTRL                      ((0x003c  << 2) + 0xfe000000)
#define CLKCTRL_VID_LOCK_CLK_CTRL                  ((0x003d  << 2) + 0xfe000000)
#define CLKCTRL_VDIN_MEAS_CLK_CTRL                 ((0x003e  << 2) + 0xfe000000)
#define CLKCTRL_VAPBCLK_CTRL                       ((0x003f  << 2) + 0xfe000000)
#define CLKCTRL_MIPIDSI_PHY_CLK_CTRL               ((0x0041  << 2) + 0xfe000000)
//`define CLKCTRL_CDAC_CLK_CTRL           10'h42
#define CLKCTRL_MIPI_CSI_PHY_CLK_CTRL              ((0x0043  << 2) + 0xfe000000)
#define CLKCTRL_MIPI_ISP_CLK_CTRL                  ((0x0044  << 2) + 0xfe000000)
#define CLKCTRL_WAVE420L_CLK_CTRL                  ((0x0045  << 2) + 0xfe000000)
#define CLKCTRL_WAVE420L_CLK_CTRL2                 ((0x0046  << 2) + 0xfe000000)
#define CLKCTRL_HTX_CLK_CTRL0                      ((0x0047  << 2) + 0xfe000000)
#define CLKCTRL_HTX_CLK_CTRL1                      ((0x0048  << 2) + 0xfe000000)
#define CLKCTRL_HRX_CLK_CTRL0                      ((0x004a  << 2) + 0xfe000000)
#define CLKCTRL_HRX_CLK_CTRL1                      ((0x004b  << 2) + 0xfe000000)
#define CLKCTRL_HRX_CLK_CTRL2                      ((0x004c  << 2) + 0xfe000000)
#define CLKCTRL_HRX_CLK_CTRL3                      ((0x004d  << 2) + 0xfe000000)
#define CLKCTRL_VDEC_CLK_CTRL                      ((0x0050  << 2) + 0xfe000000)
#define CLKCTRL_VDEC2_CLK_CTRL                     ((0x0051  << 2) + 0xfe000000)
#define CLKCTRL_VDEC3_CLK_CTRL                     ((0x0052  << 2) + 0xfe000000)
#define CLKCTRL_VDEC4_CLK_CTRL                     ((0x0053  << 2) + 0xfe000000)
#define CLKCTRL_WAVE521_CLK_CTRL                   ((0x0054  << 2) + 0xfe000000)
#define CLKCTRL_WAVE521_CLK_CTRL2                  ((0x0055  << 2) + 0xfe000000)
#define CLKCTRL_TS_CLK_CTRL                        ((0x0056  << 2) + 0xfe000000)
#define CLKCTRL_MALI_CLK_CTRL                      ((0x0057  << 2) + 0xfe000000)
#define CLKCTRL_VIPNANOQ_CLK_CTRL                  ((0x0058  << 2) + 0xfe000000)
#define CLKCTRL_ETH_CLK_CTRL                       ((0x0059  << 2) + 0xfe000000)
#define CLKCTRL_NAND_CLK_CTRL                      ((0x005a  << 2) + 0xfe000000)
#define CLKCTRL_SD_EMMC_CLK_CTRL                   ((0x005b  << 2) + 0xfe000000)
#define CLKCTRL_BT656_CLK_CTRL                     ((0x005c  << 2) + 0xfe000000)
#define CLKCTRL_SPICC_CLK_CTRL                     ((0x005d  << 2) + 0xfe000000)
#define CLKCTRL_GEN_CLK_CTRL                       ((0x005e  << 2) + 0xfe000000)
#define CLKCTRL_SAR_CLK_CTRL0                      ((0x005f  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_AB_CTRL                    ((0x0060  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_CD_CTRL                    ((0x0061  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_EF_CTRL                    ((0x0062  << 2) + 0xfe000000)
//`define CLKCTRL_PWM_CLK_GH_CTRL         10'h63
//`define CLKCTRL_PWM_CLK_IJ_CTRL         10'h64
#define CLKCTRL_PWM_CLK_AO_AB_CTRL                 ((0x0068  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_AO_CD_CTRL                 ((0x0069  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_AO_EF_CTRL                 ((0x006a  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_AO_GH_CTRL                 ((0x006b  << 2) + 0xfe000000)
#define CLKCTRL_SPICC_CLK_CTRL1                    ((0x0070  << 2) + 0xfe000000)
#define CLKCTRL_SPICC_CLK_CTRL2                    ((0x0071  << 2) + 0xfe000000)
//`define CLKCTRL_SPICC_CLK_CTRL3         10'h72
#define CLKCTRL_VID_CLK1_CTRL                      ((0x0073  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK1_CTRL2                     ((0x0074  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK1_DIV                       ((0x0075  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK1_DIV                      ((0x0076  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK1_CTRL                     ((0x0077  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK2_CTRL                      ((0x0078  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK2_CTRL2                     ((0x0079  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK2_DIV                       ((0x007a  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK2_DIV                      ((0x007b  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK2_CTRL                     ((0x007c  << 2) + 0xfe000000)
#define CLKCTRL_VID_PLL_CLK1_DIV                   ((0x007d  << 2) + 0xfe000000)
#define CLKCTRL_VID_PLL_CLK2_DIV                   ((0x007e  << 2) + 0xfe000000)
#define CLKCTRL_MIPI_DSI_MEAS_CLK_CTRL             ((0x0080  << 2) + 0xfe000000)
#define CLKCTRL_HDMI_VID_PLL_CLK_DIV               ((0x0081  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL                     ((0x0100  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL1                    ((0x0101  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL2                    ((0x0103  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_RD0                      ((0x0104  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_RD1                      ((0x0105  << 2) + 0xfe000000)
#define CLKCTRL_TIMEBASE_CTRL0                     ((0x0106  << 2) + 0xfe000000)
#define CLKCTRL_TIMEBASE_CTRL1                     ((0x0107  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_CPU_CFG01                    ((0x0120  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_CPU_CFG2                     ((0x0121  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_ENCP_CFG0                    ((0x0122  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_MALI_CFG01                   ((0x0123  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_HEVCB_CFG01                  ((0x0124  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_HEVCB_CFG2                   ((0x0125  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_LOCK                         ((0x0126  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_A73_CFG01                    ((0x0127  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_A73_CFG2                     ((0x0128  << 2) + 0xfe000000)
//========================================================================
//  PWR_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00c000
// -----------------------------------------------
#define PWRCTRL_PWR_ACK0                           ((0x0000  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_ACK1                           ((0x0001  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_OFF0                           ((0x0004  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_OFF1                           ((0x0005  << 2) + 0xfe00c000)
#define PWRCTRL_ISO_EN0                            ((0x0008  << 2) + 0xfe00c000)
#define PWRCTRL_ISO_EN1                            ((0x0009  << 2) + 0xfe00c000)
#define PWRCTRL_FOCRST0                            ((0x000c  << 2) + 0xfe00c000)
#define PWRCTRL_FOCRST1                            ((0x000d  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD0                            ((0x0010  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD1                            ((0x0011  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD2                            ((0x0012  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD3                            ((0x0013  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD4                            ((0x0014  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD5                            ((0x0015  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD6                            ((0x0016  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD7                            ((0x0017  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD8                            ((0x0018  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD9                            ((0x0019  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD10                           ((0x001a  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD11                           ((0x001b  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD12                           ((0x001c  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD13                           ((0x001d  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD14                           ((0x001e  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD15                           ((0x001f  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD16                           ((0x0020  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD17                           ((0x0021  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD18                           ((0x0022  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD19                           ((0x0023  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD20                           ((0x0024  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD21                           ((0x0025  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD22                           ((0x0026  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD23                           ((0x0027  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD24                           ((0x0028  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD25                           ((0x0029  << 2) + 0xfe00c000)
#define PWRCTRL_IRQ_EN                             ((0x0030  << 2) + 0xfe00c000)
#define PWRCTRL_IRQ_STS                            ((0x0031  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL0                ((0x0040  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL1                ((0x0041  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL2                ((0x0042  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL3                ((0x0043  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL4                ((0x0044  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL5                ((0x0045  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_01                   ((0x0048  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_23                   ((0x0049  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_45                   ((0x004a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_67                   ((0x004b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_89                   ((0x004c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK0                     ((0x0050  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK1                     ((0x0051  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK2                     ((0x0052  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK3                     ((0x0053  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK4                     ((0x0054  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK5                     ((0x0055  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK6                     ((0x0056  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK7                     ((0x0057  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK8                     ((0x0058  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK9                     ((0x0059  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK10                    ((0x005a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK11                    ((0x005b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK12                    ((0x005c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK13                    ((0x005d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK14                    ((0x005e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK15                    ((0x005f  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_INIT_SET                ((0x0060  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_OFF_SET                 ((0x0061  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_A_SET                ((0x0062  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_B_SET                ((0x0063  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_C_SET                ((0x0064  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_D_SET                ((0x0065  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_STS                     ((0x0066  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS0                      ((0x0067  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS1                      ((0x0068  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS2                      ((0x0069  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_START_OFF                 ((0x006d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_START_ON                  ((0x006e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_JUMP                      ((0x006f  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL0                ((0x0070  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL1                ((0x0071  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL2                ((0x0072  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL3                ((0x0073  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL4                ((0x0074  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL5                ((0x0075  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_01                   ((0x0078  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_23                   ((0x0079  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_45                   ((0x007a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_67                   ((0x007b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_89                   ((0x007c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK0                     ((0x0080  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK1                     ((0x0081  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK2                     ((0x0082  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK3                     ((0x0083  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK4                     ((0x0084  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK5                     ((0x0085  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK6                     ((0x0086  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK7                     ((0x0087  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK8                     ((0x0088  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK9                     ((0x0089  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK10                    ((0x008a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK11                    ((0x008b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK12                    ((0x008c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK13                    ((0x008d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK14                    ((0x008e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK15                    ((0x008f  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_INIT_SET                ((0x0090  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_OFF_SET                 ((0x0091  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_A_SET                ((0x0092  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_B_SET                ((0x0093  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_C_SET                ((0x0094  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_D_SET                ((0x0095  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_STS                     ((0x0096  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS0                      ((0x0097  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS1                      ((0x0098  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS2                      ((0x0099  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_START_OFF                 ((0x009d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_START_ON                  ((0x009e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_JUMP                      ((0x009f  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL0                ((0x00a0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL1                ((0x00a1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL2                ((0x00a2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL3                ((0x00a3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL4                ((0x00a4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_AUTO_OFF_CTRL5                ((0x00a5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_TIMER_TH_01                   ((0x00a8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_TIMER_TH_23                   ((0x00a9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_TIMER_TH_45                   ((0x00aa  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_TIMER_TH_67                   ((0x00ab  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_TIMER_TH_89                   ((0x00ac  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK0                     ((0x00b0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK1                     ((0x00b1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK2                     ((0x00b2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK3                     ((0x00b3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK4                     ((0x00b4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK5                     ((0x00b5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK6                     ((0x00b6  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK7                     ((0x00b7  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK8                     ((0x00b8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK9                     ((0x00b9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK10                    ((0x00ba  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK11                    ((0x00bb  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK12                    ((0x00bc  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK13                    ((0x00bd  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK14                    ((0x00be  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_IRQ_MASK15                    ((0x00bf  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_INIT_SET                ((0x00c0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_OFF_SET                 ((0x00c1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_ON_A_SET                ((0x00c2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_ON_B_SET                ((0x00c3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_ON_C_SET                ((0x00c4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_ON_D_SET                ((0x00c5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_MEMPD_STS                     ((0x00c6  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_STS0                      ((0x00c7  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_STS1                      ((0x00c8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_STS2                      ((0x00c9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_START_OFF                 ((0x00cd  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_START_ON                  ((0x00ce  << 2) + 0xfe00c000)
#define PWRCTRL_CPU2_FSM_JUMP                      ((0x00cf  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL0                ((0x00d0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL1                ((0x00d1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL2                ((0x00d2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL3                ((0x00d3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL4                ((0x00d4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_AUTO_OFF_CTRL5                ((0x00d5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_TIMER_TH_01                   ((0x00d8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_TIMER_TH_23                   ((0x00d9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_TIMER_TH_45                   ((0x00da  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_TIMER_TH_67                   ((0x00db  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_TIMER_TH_89                   ((0x00dc  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK0                     ((0x00e0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK1                     ((0x00e1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK2                     ((0x00e2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK3                     ((0x00e3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK4                     ((0x00e4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK5                     ((0x00e5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK6                     ((0x00e6  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK7                     ((0x00e7  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK8                     ((0x00e8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK9                     ((0x00e9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK10                    ((0x00ea  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK11                    ((0x00eb  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK12                    ((0x00ec  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK13                    ((0x00ed  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK14                    ((0x00ee  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_IRQ_MASK15                    ((0x00ef  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_INIT_SET                ((0x00f0  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_OFF_SET                 ((0x00f1  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_ON_A_SET                ((0x00f2  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_ON_B_SET                ((0x00f3  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_ON_C_SET                ((0x00f4  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_ON_D_SET                ((0x00f5  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_MEMPD_STS                     ((0x00f6  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_STS0                      ((0x00f7  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_STS1                      ((0x00f8  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_STS2                      ((0x00f9  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_START_OFF                 ((0x00fd  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_START_ON                  ((0x00fe  << 2) + 0xfe00c000)
#define PWRCTRL_CPU3_FSM_JUMP                      ((0x00ff  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL0              ((0x0100  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL1              ((0x0101  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL2              ((0x0102  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL3              ((0x0103  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL4              ((0x0104  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL5              ((0x0105  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_01                 ((0x0108  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_23                 ((0x0109  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_45                 ((0x010a  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_67                 ((0x010b  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_89                 ((0x010c  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK0                   ((0x0110  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK1                   ((0x0111  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK2                   ((0x0112  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK3                   ((0x0113  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK4                   ((0x0114  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK5                   ((0x0115  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK6                   ((0x0116  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK7                   ((0x0117  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK8                   ((0x0118  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK9                   ((0x0119  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK10                  ((0x011a  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK11                  ((0x011b  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK12                  ((0x011c  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK13                  ((0x011d  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK14                  ((0x011e  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK15                  ((0x011f  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_INIT_SET              ((0x0120  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_OFF_SET               ((0x0121  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_A_SET              ((0x0122  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_B_SET              ((0x0123  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_C_SET              ((0x0124  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_D_SET              ((0x0125  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_STS                   ((0x0126  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS0                    ((0x0127  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS1                    ((0x0128  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS2                    ((0x0129  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_START_OFF               ((0x012d  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_START_ON                ((0x012e  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_JUMP                    ((0x012f  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL0                ((0x0130  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL1                ((0x0131  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL2                ((0x0132  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL3                ((0x0133  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL4                ((0x0134  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_AUTO_OFF_CTRL5                ((0x0135  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_TIMER_TH_01                   ((0x0138  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_TIMER_TH_23                   ((0x0139  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_TIMER_TH_45                   ((0x013a  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_TIMER_TH_67                   ((0x013b  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_TIMER_TH_89                   ((0x013c  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK0                     ((0x0140  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK1                     ((0x0141  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK2                     ((0x0142  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK3                     ((0x0143  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK4                     ((0x0144  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK5                     ((0x0145  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK6                     ((0x0146  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK7                     ((0x0147  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK8                     ((0x0148  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK9                     ((0x0149  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK10                    ((0x014a  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK11                    ((0x014b  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK12                    ((0x014c  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK13                    ((0x014d  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK14                    ((0x014e  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_IRQ_MASK15                    ((0x014f  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_INIT_SET                ((0x0150  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_OFF_SET                 ((0x0151  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_ON_A_SET                ((0x0152  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_ON_B_SET                ((0x0153  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_ON_C_SET                ((0x0154  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_ON_D_SET                ((0x0155  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_MEMPD_STS                     ((0x0156  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_STS0                      ((0x0157  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_STS1                      ((0x0158  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_STS2                      ((0x0159  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_START_OFF                 ((0x015d  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_START_ON                  ((0x015e  << 2) + 0xfe00c000)
#define PWRCTRL_DSPA_FSM_JUMP                      ((0x015f  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL0                ((0x0160  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL1                ((0x0161  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL2                ((0x0162  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL3                ((0x0163  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL4                ((0x0164  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_AUTO_OFF_CTRL5                ((0x0165  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_TIMER_TH_01                   ((0x0168  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_TIMER_TH_23                   ((0x0169  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_TIMER_TH_45                   ((0x016a  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_TIMER_TH_67                   ((0x016b  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_TIMER_TH_89                   ((0x016c  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK0                     ((0x0170  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK1                     ((0x0171  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK2                     ((0x0172  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK3                     ((0x0173  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK4                     ((0x0174  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK5                     ((0x0175  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK6                     ((0x0176  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK7                     ((0x0177  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK8                     ((0x0178  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK9                     ((0x0179  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK10                    ((0x017a  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK11                    ((0x017b  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK12                    ((0x017c  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK13                    ((0x017d  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK14                    ((0x017e  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_IRQ_MASK15                    ((0x017f  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_INIT_SET                ((0x0180  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_OFF_SET                 ((0x0181  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_ON_A_SET                ((0x0182  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_ON_B_SET                ((0x0183  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_ON_C_SET                ((0x0184  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_ON_D_SET                ((0x0185  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_MEMPD_STS                     ((0x0186  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_STS0                      ((0x0187  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_STS1                      ((0x0188  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_STS2                      ((0x0189  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_START_OFF                 ((0x018d  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_START_ON                  ((0x018e  << 2) + 0xfe00c000)
#define PWRCTRL_DSPB_FSM_JUMP                      ((0x018f  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL0                ((0x0190  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL1                ((0x0191  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL2                ((0x0192  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL3                ((0x0193  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL4                ((0x0194  << 2) + 0xfe00c000)
#define PWRCTRL_A730_AUTO_OFF_CTRL5                ((0x0195  << 2) + 0xfe00c000)
#define PWRCTRL_A730_TIMER_TH_01                   ((0x0198  << 2) + 0xfe00c000)
#define PWRCTRL_A730_TIMER_TH_23                   ((0x0199  << 2) + 0xfe00c000)
#define PWRCTRL_A730_TIMER_TH_45                   ((0x019a  << 2) + 0xfe00c000)
#define PWRCTRL_A730_TIMER_TH_67                   ((0x019b  << 2) + 0xfe00c000)
#define PWRCTRL_A730_TIMER_TH_89                   ((0x019c  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK0                     ((0x01a0  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK1                     ((0x01a1  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK2                     ((0x01a2  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK3                     ((0x01a3  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK4                     ((0x01a4  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK5                     ((0x01a5  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK6                     ((0x01a6  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK7                     ((0x01a7  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK8                     ((0x01a8  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK9                     ((0x01a9  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK10                    ((0x01aa  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK11                    ((0x01ab  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK12                    ((0x01ac  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK13                    ((0x01ad  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK14                    ((0x01ae  << 2) + 0xfe00c000)
#define PWRCTRL_A730_IRQ_MASK15                    ((0x01af  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_INIT_SET                ((0x01b0  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_OFF_SET                 ((0x01b1  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_ON_A_SET                ((0x01b2  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_ON_B_SET                ((0x01b3  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_ON_C_SET                ((0x01b4  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_ON_D_SET                ((0x01b5  << 2) + 0xfe00c000)
#define PWRCTRL_A730_MEMPD_STS                     ((0x01b6  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_STS0                      ((0x01b7  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_STS1                      ((0x01b8  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_STS2                      ((0x01b9  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_START_OFF                 ((0x01bd  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_START_ON                  ((0x01be  << 2) + 0xfe00c000)
#define PWRCTRL_A730_FSM_JUMP                      ((0x01bf  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL0                ((0x01c0  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL1                ((0x01c1  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL2                ((0x01c2  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL3                ((0x01c3  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL4                ((0x01c4  << 2) + 0xfe00c000)
#define PWRCTRL_A731_AUTO_OFF_CTRL5                ((0x01c5  << 2) + 0xfe00c000)
#define PWRCTRL_A731_TIMER_TH_01                   ((0x01c8  << 2) + 0xfe00c000)
#define PWRCTRL_A731_TIMER_TH_23                   ((0x01c9  << 2) + 0xfe00c000)
#define PWRCTRL_A731_TIMER_TH_45                   ((0x01ca  << 2) + 0xfe00c000)
#define PWRCTRL_A731_TIMER_TH_67                   ((0x01cb  << 2) + 0xfe00c000)
#define PWRCTRL_A731_TIMER_TH_89                   ((0x01cc  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK0                     ((0x01d0  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK1                     ((0x01d1  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK2                     ((0x01d2  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK3                     ((0x01d3  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK4                     ((0x01d4  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK5                     ((0x01d5  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK6                     ((0x01d6  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK7                     ((0x01d7  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK8                     ((0x01d8  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK9                     ((0x01d9  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK10                    ((0x01da  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK11                    ((0x01db  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK12                    ((0x01dc  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK13                    ((0x01dd  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK14                    ((0x01de  << 2) + 0xfe00c000)
#define PWRCTRL_A731_IRQ_MASK15                    ((0x01df  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_INIT_SET                ((0x01e0  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_OFF_SET                 ((0x01e1  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_ON_A_SET                ((0x01e2  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_ON_B_SET                ((0x01e3  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_ON_C_SET                ((0x01e4  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_ON_D_SET                ((0x01e5  << 2) + 0xfe00c000)
#define PWRCTRL_A731_MEMPD_STS                     ((0x01e6  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_STS0                      ((0x01e7  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_STS1                      ((0x01e8  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_STS2                      ((0x01e9  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_START_OFF                 ((0x01ed  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_START_ON                  ((0x01ee  << 2) + 0xfe00c000)
#define PWRCTRL_A731_FSM_JUMP                      ((0x01ef  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL0                ((0x01f0  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL1                ((0x01f1  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL2                ((0x01f2  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL3                ((0x01f3  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL4                ((0x01f4  << 2) + 0xfe00c000)
#define PWRCTRL_A732_AUTO_OFF_CTRL5                ((0x01f5  << 2) + 0xfe00c000)
#define PWRCTRL_A732_TIMER_TH_01                   ((0x01f8  << 2) + 0xfe00c000)
#define PWRCTRL_A732_TIMER_TH_23                   ((0x01f9  << 2) + 0xfe00c000)
#define PWRCTRL_A732_TIMER_TH_45                   ((0x01fa  << 2) + 0xfe00c000)
#define PWRCTRL_A732_TIMER_TH_67                   ((0x01fb  << 2) + 0xfe00c000)
#define PWRCTRL_A732_TIMER_TH_89                   ((0x01fc  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK0                     ((0x0200  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK1                     ((0x0201  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK2                     ((0x0202  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK3                     ((0x0203  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK4                     ((0x0204  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK5                     ((0x0205  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK6                     ((0x0206  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK7                     ((0x0207  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK8                     ((0x0208  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK9                     ((0x0209  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK10                    ((0x020a  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK11                    ((0x020b  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK12                    ((0x020c  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK13                    ((0x020d  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK14                    ((0x020e  << 2) + 0xfe00c000)
#define PWRCTRL_A732_IRQ_MASK15                    ((0x020f  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_INIT_SET                ((0x0210  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_OFF_SET                 ((0x0211  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_ON_A_SET                ((0x0212  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_ON_B_SET                ((0x0213  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_ON_C_SET                ((0x0214  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_ON_D_SET                ((0x0215  << 2) + 0xfe00c000)
#define PWRCTRL_A732_MEMPD_STS                     ((0x0216  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_STS0                      ((0x0217  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_STS1                      ((0x0218  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_STS2                      ((0x0219  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_START_OFF                 ((0x021d  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_START_ON                  ((0x021e  << 2) + 0xfe00c000)
#define PWRCTRL_A732_FSM_JUMP                      ((0x021f  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL0                ((0x0220  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL1                ((0x0221  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL2                ((0x0222  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL3                ((0x0223  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL4                ((0x0224  << 2) + 0xfe00c000)
#define PWRCTRL_A733_AUTO_OFF_CTRL5                ((0x0225  << 2) + 0xfe00c000)
#define PWRCTRL_A733_TIMER_TH_01                   ((0x0228  << 2) + 0xfe00c000)
#define PWRCTRL_A733_TIMER_TH_23                   ((0x0229  << 2) + 0xfe00c000)
#define PWRCTRL_A733_TIMER_TH_45                   ((0x022a  << 2) + 0xfe00c000)
#define PWRCTRL_A733_TIMER_TH_67                   ((0x022b  << 2) + 0xfe00c000)
#define PWRCTRL_A733_TIMER_TH_89                   ((0x022c  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK0                     ((0x0230  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK1                     ((0x0231  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK2                     ((0x0232  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK3                     ((0x0233  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK4                     ((0x0234  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK5                     ((0x0235  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK6                     ((0x0236  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK7                     ((0x0237  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK8                     ((0x0238  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK9                     ((0x0239  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK10                    ((0x023a  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK11                    ((0x023b  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK12                    ((0x023c  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK13                    ((0x023d  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK14                    ((0x023e  << 2) + 0xfe00c000)
#define PWRCTRL_A733_IRQ_MASK15                    ((0x023f  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_INIT_SET                ((0x0240  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_OFF_SET                 ((0x0241  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_ON_A_SET                ((0x0242  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_ON_B_SET                ((0x0243  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_ON_C_SET                ((0x0244  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_ON_D_SET                ((0x0245  << 2) + 0xfe00c000)
#define PWRCTRL_A733_MEMPD_STS                     ((0x0246  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_STS0                      ((0x0247  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_STS1                      ((0x0248  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_STS2                      ((0x0249  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_START_OFF                 ((0x024d  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_START_ON                  ((0x024e  << 2) + 0xfe00c000)
#define PWRCTRL_A733_FSM_JUMP                      ((0x024f  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL0              ((0x0250  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL1              ((0x0251  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL2              ((0x0252  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL3              ((0x0253  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL4              ((0x0254  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_AUTO_OFF_CTRL5              ((0x0255  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_TIMER_TH_01                 ((0x0258  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_TIMER_TH_23                 ((0x0259  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_TIMER_TH_45                 ((0x025a  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_TIMER_TH_67                 ((0x025b  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_TIMER_TH_89                 ((0x025c  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK0                   ((0x0260  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK1                   ((0x0261  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK2                   ((0x0262  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK3                   ((0x0263  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK4                   ((0x0264  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK5                   ((0x0265  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK6                   ((0x0266  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK7                   ((0x0267  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK8                   ((0x0268  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK9                   ((0x0269  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK10                  ((0x026a  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK11                  ((0x026b  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK12                  ((0x026c  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK13                  ((0x026d  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK14                  ((0x026e  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_IRQ_MASK15                  ((0x026f  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_INIT_SET              ((0x0270  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_OFF_SET               ((0x0271  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_ON_A_SET              ((0x0272  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_ON_B_SET              ((0x0273  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_ON_C_SET              ((0x0274  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_ON_D_SET              ((0x0275  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_MEMPD_STS                   ((0x0276  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_STS0                    ((0x0277  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_STS1                    ((0x0278  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_STS2                    ((0x0279  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_START_OFF               ((0x027d  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_START_ON                ((0x027e  << 2) + 0xfe00c000)
#define PWRCTRL_A73TOP_FSM_JUMP                    ((0x027f  << 2) + 0xfe00c000)
//========================================================================
// RSA
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe042000
// -----------------------------------------------
#define RSA_BASE                                   ((0x0000  << 2) + 0xfe042000)
//========================================================================
//  AOCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09c000
// -----------------------------------------------
#define AOCPU_CPU_CTRL0                            ((0x0000  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_CTRL1                            ((0x0001  << 2) + 0xfe09c000)
//Bit 31:11-       0   - n205 address shift, 1: 0x8000_0000~0x4000_0000
//Bit 30:11-       0   - reserved
//Bit 10   -       0   - gate by sleep, 1: gate, 0: free run
//Bit  9   -       0   - RXEV for riscv input refer riscv doc
//Bit  8   -       0   - reserved
//Bit   7:6-       0   - n205_debug_sel,aocpu_core_status0 info select
//Bit   5:2-       0   - reserved
//Bit 1    -       0   - n205_i_dbg_stop
//Bit 0    -       0   - n205_pc_enable
#define AOCPU_CPU_CTRL2                            ((0x0002  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_CTRL3                            ((0x0003  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_CTRL4                            ((0x0004  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_CTRL5                            ((0x0005  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_STS0                             ((0x000a  << 2) + 0xfe09c000)
//Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
#define AOCPU_CPU_STS1                             ((0x000b  << 2) + 0xfe09c000)
//Bit 31   -       0   - n205_core_sleep_value
//Bit 30:29-       0   - n205_trace_priv
//Bit 28:20-       0   - reserved
//Bit 19   -       0   - n205_core_wfi_mode
//Bit 18   -       0   - n205_trace_invalid
//Bit 17   -       0   - n205_trace_iexception
//Bit 16   -       0   - n205_trace_interrupt
//Bit 15:0 -       0   - reserved
#define AOCPU_CPU_STS2                             ((0x000c  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_CPU_STS3                             ((0x000d  << 2) + 0xfe09c000)
//Bit 31   -       0   - n205_hart_halted
//Bit 30   -       0   - n205_ndmreset
//Bit 29   -       0   - n205_dmactive
//Bit 28:0 -       0   - reserved
#define AOCPU_CPU_VECTOR                           ((0x000f  << 2) + 0xfe09c000)
//Bit 31:0-   0x1000_0000   - reserved
#define AOCPU_IRQ_SEL0                             ((0x0010  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR01 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR00 interrupt source select in int_map
#define AOCPU_IRQ_SEL1                             ((0x0011  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR03 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR02 interrupt source select in int_map
#define AOCPU_IRQ_SEL2                             ((0x0012  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR05 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR04 interrupt source select in int_map
#define AOCPU_IRQ_SEL3                             ((0x0013  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR07 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR06 interrupt source select in int_map
#define AOCPU_IRQ_SEL4                             ((0x0014  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR09 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR08 interrupt source select in int_map
#define AOCPU_IRQ_SEL5                             ((0x0015  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR11 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR10 interrupt source select in int_map
#define AOCPU_IRQ_SEL6                             ((0x0016  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR13 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR12 interrupt source select in int_map
#define AOCPU_IRQ_SEL7                             ((0x0017  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR15 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR14 interrupt source select in int_map
#define AOCPU_STS00_BYCPU                          ((0x0018  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS01_BYCPU                          ((0x0019  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS02_BYCPU                          ((0x001a  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS03_BYCPU                          ((0x001b  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS04_BYCPU                          ((0x001c  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS05_BYCPU                          ((0x001d  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS06_BYCPU                          ((0x001e  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_STS07_BYCPU                          ((0x001f  << 2) + 0xfe09c000)
//Bit 31:0-       0   - reserved
#define AOCPU_IRQ_SEL8                             ((0x0020  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR17 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR16 interrupt source select in int_map
#define AOCPU_IRQ_SEL9                             ((0x0021  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR19 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR18 interrupt source select in int_map
#define AOCPU_IRQ_SEL10                            ((0x0022  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR21 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR20 interrupt source select in int_map
#define AOCPU_IRQ_SEL11                            ((0x0023  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR23 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR22 interrupt source select in int_map
#define AOCPU_IRQ_SEL12                            ((0x0024  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR25 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR24 interrupt source select in int_map
#define AOCPU_IRQ_SEL13                            ((0x0025  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR27 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR26 interrupt source select in int_map
#define AOCPU_IRQ_SEL14                            ((0x0026  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR29 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR28 interrupt source select in int_map
#define AOCPU_IRQ_SEL15                            ((0x0027  << 2) + 0xfe09c000)
//Bit 24:16-       0   - INTISR31 interrupt source select in int_map
//Bit  8:0 -       0   - INTISR30 interrupt source select in int_map
//========================================================================
//  AUCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09e000
// -----------------------------------------------
#define AUCPU_CPU_CTRL0                            ((0x0000  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_CTRL1                            ((0x0001  << 2) + 0xfe09e000)
//Bit 31:11-       0   - reserved
//Bit 10   -       0   - gate by sleep
//Bit 9    -       0   - RXEV
//Bit 8    -       0   - reserved
//Bit 7:6  -       0   - n205_debug_sel,aucpu_core_status0 info select
//Bit 5:2  -       0   - reserved
//Bit 1    -       0   - n205_i_dbg_stop
//Bit 0    -       0   - n205_pc_enable
#define AUCPU_CPU_CTRL2                            ((0x0002  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_CTRL3                            ((0x0003  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_CTRL4                            ((0x0004  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_CTRL5                            ((0x0005  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_STS0                             ((0x000a  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
#define AUCPU_CPU_STS1                             ((0x000b  << 2) + 0xfe09e000)
//Bit 31   -       0   - n205_core_sleep_value
//Bit 30:29-       0   - n205_trace_priv
//Bit 28:20-       0   - reserved
//Bit 19   -       0   - n205_core_wfi_mode
//Bit 18   -       0   - n205_trace_invalid
//Bit 17   -       0   - n205_trace_iexception
//Bit 16   -       0   - n205_trace_interrupt
//Bit 15:0 -       0   - reserved
#define AUCPU_CPU_STS2                             ((0x000c  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_CPU_STS3                             ((0x000d  << 2) + 0xfe09e000)
//Bit 31   -       0   - n205_hart_halted
//Bit 30   -       0   - n205_ndmreset
//Bit 29   -       0   - n205_dmactive
//Bit 28:0 -       0   - reserved
#define AUCPU_DMA_APB_SEL                          ((0x0010  << 2) + 0xfe09e000)
//Bit 31:30-       0   - reserved
//Bit 0    -       0   - 1: riscv control dma, 0: ap control dma
#define AUCPU_IRQ_AP2RISCV                         ((0x0011  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - AP cpu send irq to riscv
#define AUCPU_IRQ_RISCV2AP                         ((0x0012  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - riscv send irq to AP
#define AUCPU_STS00_BY_AP                          ((0x0020  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS01_BY_AP                          ((0x0021  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS02_BY_AP                          ((0x0022  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS03_BY_AP                          ((0x0023  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS04_BY_AP                          ((0x0024  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS05_BY_AP                          ((0x0025  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS06_BY_AP                          ((0x0026  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS07_BY_AP                          ((0x0027  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS08_BY_AP                          ((0x0028  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS09_BY_AP                          ((0x0029  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS10_BY_AP                          ((0x002a  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS11_BY_AP                          ((0x002b  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS12_BY_AP                          ((0x002c  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS13_BY_AP                          ((0x002d  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS14_BY_AP                          ((0x002e  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS15_BY_AP                          ((0x002f  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS16_BY_AP                          ((0x0030  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS17_BY_AP                          ((0x0031  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS18_BY_AP                          ((0x0032  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS19_BY_AP                          ((0x0033  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS20_BY_AP                          ((0x0034  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS21_BY_AP                          ((0x0035  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS22_BY_AP                          ((0x0036  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS23_BY_AP                          ((0x0037  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS24_BY_AP                          ((0x0038  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS25_BY_AP                          ((0x0039  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS26_BY_AP                          ((0x003a  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS27_BY_AP                          ((0x003b  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS28_BY_AP                          ((0x003c  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS29_BY_AP                          ((0x003d  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS30_BY_AP                          ((0x003e  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS31_BY_AP                          ((0x003f  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS00_BY_RISCV                       ((0x0040  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS01_BY_RISCV                       ((0x0041  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS02_BY_RISCV                       ((0x0042  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS03_BY_RISCV                       ((0x0043  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS04_BY_RISCV                       ((0x0044  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS05_BY_RISCV                       ((0x0045  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS06_BY_RISCV                       ((0x0046  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS07_BY_RISCV                       ((0x0047  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS08_BY_RISCV                       ((0x0048  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS09_BY_RISCV                       ((0x0049  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS10_BY_RISCV                       ((0x004a  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS11_BY_RISCV                       ((0x004b  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS12_BY_RISCV                       ((0x004c  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS13_BY_RISCV                       ((0x004d  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS14_BY_RISCV                       ((0x004e  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS15_BY_RISCV                       ((0x004f  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS16_BY_RISCV                       ((0x0050  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS17_BY_RISCV                       ((0x0051  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS18_BY_RISCV                       ((0x0052  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS19_BY_RISCV                       ((0x0053  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS20_BY_RISCV                       ((0x0054  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS21_BY_RISCV                       ((0x0055  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS22_BY_RISCV                       ((0x0056  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS23_BY_RISCV                       ((0x0057  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS24_BY_RISCV                       ((0x0058  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS25_BY_RISCV                       ((0x0059  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS26_BY_RISCV                       ((0x005a  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS27_BY_RISCV                       ((0x005b  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS28_BY_RISCV                       ((0x005c  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS29_BY_RISCV                       ((0x005d  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS30_BY_RISCV                       ((0x005e  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_STS31_BY_RISCV                       ((0x005f  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - reserved
#define AUCPU_DEMUX_STS_BY_RISCV                   ((0x0060  << 2) + 0xfe09e000)
//Bit 31   -       0   - read only, demux status updated
//Bit 31:8 -       0   - reserved
//Bit  7:0 -       0   - read demux chn select
#define AUCPU_DEMUX_STS0                           ((0x0061  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - demux status 0
#define AUCPU_DEMUX_STS1                           ((0x0062  << 2) + 0xfe09e000)
//Bit 31:0 -       0   - demux status 1
//========================================================================
//  AXI_SRAM
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe090000
// -----------------------------------------------
#define SRAM_RANGE0_STA                            ((0x0000  << 2) + 0xfe090000)
#define SRAM_RANGE1_STA                            ((0x0001  << 2) + 0xfe090000)
#define SRAM_RANGE2_STA                            ((0x0002  << 2) + 0xfe090000)
#define SRAM_RANGE3_STA                            ((0x0003  << 2) + 0xfe090000)
#define SRAM_RANGE4_STA                            ((0x0004  << 2) + 0xfe090000)
#define SRAM_RANGE5_STA                            ((0x0005  << 2) + 0xfe090000)
#define SRAM_RANGE6_STA                            ((0x0006  << 2) + 0xfe090000)
#define SRAM_RANGE7_STA                            ((0x0007  << 2) + 0xfe090000)
#define SRAM_RANGE8_STA                            ((0x0008  << 2) + 0xfe090000)
#define SRAM_RANGE9_STA                            ((0x0009  << 2) + 0xfe090000)
#define SRAM_RANGE10_STA                           ((0x000a  << 2) + 0xfe090000)
#define SRAM_RANGE11_STA                           ((0x000b  << 2) + 0xfe090000)
#define SRAM_RANGE12_STA                           ((0x000c  << 2) + 0xfe090000)
#define SRAM_RANGE13_STA                           ((0x000d  << 2) + 0xfe090000)
#define SRAM_RANGE14_STA                           ((0x000e  << 2) + 0xfe090000)
#define SRAM_RANGE0_EDA                            ((0x000f  << 2) + 0xfe090000)
#define SRAM_RANGE1_EDA                            ((0x0010  << 2) + 0xfe090000)
#define SRAM_RANGE2_EDA                            ((0x0011  << 2) + 0xfe090000)
#define SRAM_RANGE3_EDA                            ((0x0012  << 2) + 0xfe090000)
#define SRAM_RANGE4_EDA                            ((0x0013  << 2) + 0xfe090000)
#define SRAM_RANGE5_EDA                            ((0x0014  << 2) + 0xfe090000)
#define SRAM_RANGE6_EDA                            ((0x0015  << 2) + 0xfe090000)
#define SRAM_RANGE7_EDA                            ((0x0016  << 2) + 0xfe090000)
#define SRAM_RANGE8_EDA                            ((0x0017  << 2) + 0xfe090000)
#define SRAM_RANGE9_EDA                            ((0x0018  << 2) + 0xfe090000)
#define SRAM_RANGE10_EDA                           ((0x0019  << 2) + 0xfe090000)
#define SRAM_RANGE11_EDA                           ((0x001a  << 2) + 0xfe090000)
#define SRAM_RANGE12_EDA                           ((0x001b  << 2) + 0xfe090000)
#define SRAM_RANGE13_EDA                           ((0x001c  << 2) + 0xfe090000)
#define SRAM_RANGE14_EDA                           ((0x001d  << 2) + 0xfe090000)
#define SRAM_RANGE0_READ_CTRL0                     ((0x001e  << 2) + 0xfe090000)
#define SRAM_RANGE1_READ_CTRL0                     ((0x001f  << 2) + 0xfe090000)
#define SRAM_RANGE2_READ_CTRL0                     ((0x0020  << 2) + 0xfe090000)
#define SRAM_RANGE3_READ_CTRL0                     ((0x0021  << 2) + 0xfe090000)
#define SRAM_RANGE4_READ_CTRL0                     ((0x0022  << 2) + 0xfe090000)
#define SRAM_RANGE5_READ_CTRL0                     ((0x0023  << 2) + 0xfe090000)
#define SRAM_RANGE6_READ_CTRL0                     ((0x0024  << 2) + 0xfe090000)
#define SRAM_RANGE7_READ_CTRL0                     ((0x0025  << 2) + 0xfe090000)
#define SRAM_RANGE8_READ_CTRL0                     ((0x0026  << 2) + 0xfe090000)
#define SRAM_RANGE9_READ_CTRL0                     ((0x0027  << 2) + 0xfe090000)
#define SRAM_RANGE10_READ_CTRL0                    ((0x0028  << 2) + 0xfe090000)
#define SRAM_RANGE11_READ_CTRL0                    ((0x0029  << 2) + 0xfe090000)
#define SRAM_RANGE12_READ_CTRL0                    ((0x002a  << 2) + 0xfe090000)
#define SRAM_RANGE13_READ_CTRL0                    ((0x002b  << 2) + 0xfe090000)
#define SRAM_RANGE14_READ_CTRL0                    ((0x002c  << 2) + 0xfe090000)
#define SRAM_RANGE15_READ_CTRL0                    ((0x002d  << 2) + 0xfe090000)
#define SRAM_RANGE0_WRITE_CTRL0                    ((0x002e  << 2) + 0xfe090000)
#define SRAM_RANGE1_WRITE_CTRL0                    ((0x002f  << 2) + 0xfe090000)
#define SRAM_RANGE2_WRITE_CTRL0                    ((0x0030  << 2) + 0xfe090000)
#define SRAM_RANGE3_WRITE_CTRL0                    ((0x0031  << 2) + 0xfe090000)
#define SRAM_RANGE4_WRITE_CTRL0                    ((0x0032  << 2) + 0xfe090000)
#define SRAM_RANGE5_WRITE_CTRL0                    ((0x0033  << 2) + 0xfe090000)
#define SRAM_RANGE6_WRITE_CTRL0                    ((0x0034  << 2) + 0xfe090000)
#define SRAM_RANGE7_WRITE_CTRL0                    ((0x0035  << 2) + 0xfe090000)
#define SRAM_RANGE8_WRITE_CTRL0                    ((0x0036  << 2) + 0xfe090000)
#define SRAM_RANGE9_WRITE_CTRL0                    ((0x0037  << 2) + 0xfe090000)
#define SRAM_RANGE10_WRITE_CTRL0                   ((0x0038  << 2) + 0xfe090000)
#define SRAM_RANGE11_WRITE_CTRL0                   ((0x0039  << 2) + 0xfe090000)
#define SRAM_RANGE12_WRITE_CTRL0                   ((0x003a  << 2) + 0xfe090000)
#define SRAM_RANGE13_WRITE_CTRL0                   ((0x003b  << 2) + 0xfe090000)
#define SRAM_RANGE14_WRITE_CTRL0                   ((0x003c  << 2) + 0xfe090000)
#define SRAM_RANGE15_WRITE_CTRL0                   ((0x003d  << 2) + 0xfe090000)
#define SRAM_RANGE0_READ_CTRL1                     ((0x003e  << 2) + 0xfe090000)
#define SRAM_RANGE1_READ_CTRL1                     ((0x003f  << 2) + 0xfe090000)
#define SRAM_RANGE2_READ_CTRL1                     ((0x0040  << 2) + 0xfe090000)
#define SRAM_RANGE3_READ_CTRL1                     ((0x0041  << 2) + 0xfe090000)
#define SRAM_RANGE4_READ_CTRL1                     ((0x0042  << 2) + 0xfe090000)
#define SRAM_RANGE5_READ_CTRL1                     ((0x0043  << 2) + 0xfe090000)
#define SRAM_RANGE6_READ_CTRL1                     ((0x0044  << 2) + 0xfe090000)
#define SRAM_RANGE7_READ_CTRL1                     ((0x0045  << 2) + 0xfe090000)
#define SRAM_RANGE8_READ_CTRL1                     ((0x0046  << 2) + 0xfe090000)
#define SRAM_RANGE9_READ_CTRL1                     ((0x0047  << 2) + 0xfe090000)
#define SRAM_RANGE10_READ_CTRL1                    ((0x0048  << 2) + 0xfe090000)
#define SRAM_RANGE11_READ_CTRL1                    ((0x0049  << 2) + 0xfe090000)
#define SRAM_RANGE12_READ_CTRL1                    ((0x004a  << 2) + 0xfe090000)
#define SRAM_RANGE13_READ_CTRL1                    ((0x004b  << 2) + 0xfe090000)
#define SRAM_RANGE14_READ_CTRL1                    ((0x004c  << 2) + 0xfe090000)
#define SRAM_RANGE15_READ_CTRL1                    ((0x004d  << 2) + 0xfe090000)
#define SRAM_RANGE0_WRITE_CTRL1                    ((0x004e  << 2) + 0xfe090000)
#define SRAM_RANGE1_WRITE_CTRL1                    ((0x004f  << 2) + 0xfe090000)
#define SRAM_RANGE2_WRITE_CTRL1                    ((0x0050  << 2) + 0xfe090000)
#define SRAM_RANGE3_WRITE_CTRL1                    ((0x0051  << 2) + 0xfe090000)
#define SRAM_RANGE4_WRITE_CTRL1                    ((0x0052  << 2) + 0xfe090000)
#define SRAM_RANGE5_WRITE_CTRL1                    ((0x0053  << 2) + 0xfe090000)
#define SRAM_RANGE6_WRITE_CTRL1                    ((0x0054  << 2) + 0xfe090000)
#define SRAM_RANGE7_WRITE_CTRL1                    ((0x0055  << 2) + 0xfe090000)
#define SRAM_RANGE8_WRITE_CTRL1                    ((0x0056  << 2) + 0xfe090000)
#define SRAM_RANGE9_WRITE_CTRL1                    ((0x0057  << 2) + 0xfe090000)
#define SRAM_RANGE10_WRITE_CTRL1                   ((0x0058  << 2) + 0xfe090000)
#define SRAM_RANGE11_WRITE_CTRL1                   ((0x0059  << 2) + 0xfe090000)
#define SRAM_RANGE12_WRITE_CTRL1                   ((0x005a  << 2) + 0xfe090000)
#define SRAM_RANGE13_WRITE_CTRL1                   ((0x005b  << 2) + 0xfe090000)
#define SRAM_RANGE14_WRITE_CTRL1                   ((0x005c  << 2) + 0xfe090000)
#define SRAM_RANGE15_WRITE_CTRL1                   ((0x005d  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL0                     ((0x005e  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL1                     ((0x005f  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL0                    ((0x0060  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL1                    ((0x0061  << 2) + 0xfe090000)
#define SRAM_SEC_CTRL0                             ((0x0062  << 2) + 0xfe090000)
#define SRAM_REG_LOCK0                             ((0x0063  << 2) + 0xfe090000)
#define SRAM_REG_LOCK1                             ((0x0064  << 2) + 0xfe090000)
#define SRAM_REG_LOCK2                             ((0x0065  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL0_LOCK                ((0x0066  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL1_LOCK                ((0x0067  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL0_LOCK               ((0x0068  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL1_LOCK               ((0x0069  << 2) + 0xfe090000)
#define SRAM_SEC_CTRL0_LOCK                        ((0x006a  << 2) + 0xfe090000)
#define SRAM_STATUS_REG                            ((0x006b  << 2) + 0xfe090000)
//========================================================================
//  AXI_SRAM B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe092000
// -----------------------------------------------
#define SRAM_B_RANGE0_STA                          ((0x0000  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_STA                          ((0x0001  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_STA                          ((0x0002  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_STA                          ((0x0003  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_STA                          ((0x0004  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_STA                          ((0x0005  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_STA                          ((0x0006  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_STA                          ((0x0007  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_STA                          ((0x0008  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_STA                          ((0x0009  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_STA                         ((0x000a  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_STA                         ((0x000b  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_STA                         ((0x000c  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_STA                         ((0x000d  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_STA                         ((0x000e  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_EDA                          ((0x000f  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_EDA                          ((0x0010  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_EDA                          ((0x0011  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_EDA                          ((0x0012  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_EDA                          ((0x0013  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_EDA                          ((0x0014  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_EDA                          ((0x0015  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_EDA                          ((0x0016  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_EDA                          ((0x0017  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_EDA                          ((0x0018  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_EDA                         ((0x0019  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_EDA                         ((0x001a  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_EDA                         ((0x001b  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_EDA                         ((0x001c  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_EDA                         ((0x001d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_READ_CTRL0                   ((0x001e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_READ_CTRL0                   ((0x001f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_READ_CTRL0                   ((0x0020  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_READ_CTRL0                   ((0x0021  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_READ_CTRL0                   ((0x0022  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_READ_CTRL0                   ((0x0023  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_READ_CTRL0                   ((0x0024  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_READ_CTRL0                   ((0x0025  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_READ_CTRL0                   ((0x0026  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_READ_CTRL0                   ((0x0027  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_READ_CTRL0                  ((0x0028  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_READ_CTRL0                  ((0x0029  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_READ_CTRL0                  ((0x002a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_READ_CTRL0                  ((0x002b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_READ_CTRL0                  ((0x002c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_READ_CTRL0                  ((0x002d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_WRITE_CTRL0                  ((0x002e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_WRITE_CTRL0                  ((0x002f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_WRITE_CTRL0                  ((0x0030  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_WRITE_CTRL0                  ((0x0031  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_WRITE_CTRL0                  ((0x0032  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_WRITE_CTRL0                  ((0x0033  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_WRITE_CTRL0                  ((0x0034  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_WRITE_CTRL0                  ((0x0035  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_WRITE_CTRL0                  ((0x0036  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_WRITE_CTRL0                  ((0x0037  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_WRITE_CTRL0                 ((0x0038  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_WRITE_CTRL0                 ((0x0039  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_WRITE_CTRL0                 ((0x003a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_WRITE_CTRL0                 ((0x003b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_WRITE_CTRL0                 ((0x003c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_WRITE_CTRL0                 ((0x003d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_READ_CTRL1                   ((0x003e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_READ_CTRL1                   ((0x003f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_READ_CTRL1                   ((0x0040  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_READ_CTRL1                   ((0x0041  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_READ_CTRL1                   ((0x0042  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_READ_CTRL1                   ((0x0043  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_READ_CTRL1                   ((0x0044  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_READ_CTRL1                   ((0x0045  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_READ_CTRL1                   ((0x0046  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_READ_CTRL1                   ((0x0047  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_READ_CTRL1                  ((0x0048  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_READ_CTRL1                  ((0x0049  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_READ_CTRL1                  ((0x004a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_READ_CTRL1                  ((0x004b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_READ_CTRL1                  ((0x004c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_READ_CTRL1                  ((0x004d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_WRITE_CTRL1                  ((0x004e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_WRITE_CTRL1                  ((0x004f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_WRITE_CTRL1                  ((0x0050  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_WRITE_CTRL1                  ((0x0051  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_WRITE_CTRL1                  ((0x0052  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_WRITE_CTRL1                  ((0x0053  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_WRITE_CTRL1                  ((0x0054  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_WRITE_CTRL1                  ((0x0055  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_WRITE_CTRL1                  ((0x0056  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_WRITE_CTRL1                  ((0x0057  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_WRITE_CTRL1                 ((0x0058  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_WRITE_CTRL1                 ((0x0059  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_WRITE_CTRL1                 ((0x005a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_WRITE_CTRL1                 ((0x005b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_WRITE_CTRL1                 ((0x005c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_WRITE_CTRL1                 ((0x005d  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL0                   ((0x005e  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL1                   ((0x005f  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL0                  ((0x0060  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL1                  ((0x0061  << 2) + 0xfe092000)
#define SRAM_B_SEC_CTRL0                           ((0x0062  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK0                           ((0x0063  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK1                           ((0x0064  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK2                           ((0x0065  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL0_LOCK              ((0x0066  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL1_LOCK              ((0x0067  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL0_LOCK             ((0x0068  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL1_LOCK             ((0x0069  << 2) + 0xfe092000)
#define SRAM_B_SEC_CTRL0_LOCK                      ((0x006a  << 2) + 0xfe092000)
#define SRAM_B_STATUS_REG                          ((0x006b  << 2) + 0xfe092000)
//========================================================================
//  MAILBOX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe006000
// -----------------------------------------------
#define MAILBOX_BUF_MBOX00                         ((0x0000  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX01                         ((0x0020  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX02                         ((0x0040  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX03                         ((0x0060  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX04                         ((0x0080  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX05                         ((0x00a0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX06                         ((0x00c0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX07                         ((0x00e0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX08                         ((0x0100  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX09                         ((0x0120  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX10                         ((0x0140  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX11                         ((0x0160  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX12                         ((0x0180  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX13                         ((0x01a0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX14                         ((0x01c0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX15                         ((0x01e0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX16                         ((0x0200  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX17                         ((0x0220  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX18                         ((0x0240  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX19                         ((0x0260  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX20                         ((0x0280  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX21                         ((0x02a0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX22                         ((0x02c0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX23                         ((0x02e0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX24                         ((0x0300  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX25                         ((0x0320  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX26                         ((0x0340  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX27                         ((0x0360  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX28                         ((0x0380  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX29                         ((0x03a0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX30                         ((0x03c0  << 2) + 0xfe006000)
#define MAILBOX_BUF_MBOX31                         ((0x03e0  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT0                          ((0x0400  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT1                          ((0x0401  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT2                          ((0x0402  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT3                          ((0x0403  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT0                          ((0x0404  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT1                          ((0x0405  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT2                          ((0x0406  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT3                          ((0x0407  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQA_CLR                 ((0x0408  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQB_CLR                 ((0x0409  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQC_CLR                 ((0x040a  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQD_CLR                 ((0x040b  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQE_CLR                 ((0x040c  << 2) + 0xfe006000)
#define MAILBOX_IRQ_TYPE0                          ((0x040d  << 2) + 0xfe006000)
#define MAILBOX_IRQ_TYPE1                          ((0x040e  << 2) + 0xfe006000)
#define MAILBOX_IRQA_MASK0                         ((0x0410  << 2) + 0xfe006000)
#define MAILBOX_IRQA_MASK1                         ((0x0411  << 2) + 0xfe006000)
#define MAILBOX_IRQB_MASK0                         ((0x0412  << 2) + 0xfe006000)
#define MAILBOX_IRQB_MASK1                         ((0x0413  << 2) + 0xfe006000)
#define MAILBOX_IRQC_MASK0                         ((0x0414  << 2) + 0xfe006000)
#define MAILBOX_IRQC_MASK1                         ((0x0415  << 2) + 0xfe006000)
#define MAILBOX_IRQD_MASK0                         ((0x0416  << 2) + 0xfe006000)
#define MAILBOX_IRQD_MASK1                         ((0x0417  << 2) + 0xfe006000)
#define MAILBOX_IRQE_MASK0                         ((0x0418  << 2) + 0xfe006000)
#define MAILBOX_IRQE_MASK1                         ((0x0419  << 2) + 0xfe006000)
#define MAILBOX_IRQA_CLR0                          ((0x0420  << 2) + 0xfe006000)
#define MAILBOX_IRQA_CLR1                          ((0x0421  << 2) + 0xfe006000)
#define MAILBOX_IRQB_CLR0                          ((0x0422  << 2) + 0xfe006000)
#define MAILBOX_IRQB_CLR1                          ((0x0423  << 2) + 0xfe006000)
#define MAILBOX_IRQC_CLR0                          ((0x0424  << 2) + 0xfe006000)
#define MAILBOX_IRQC_CLR1                          ((0x0425  << 2) + 0xfe006000)
#define MAILBOX_IRQD_CLR0                          ((0x0426  << 2) + 0xfe006000)
#define MAILBOX_IRQD_CLR1                          ((0x0427  << 2) + 0xfe006000)
#define MAILBOX_IRQE_CLR0                          ((0x0428  << 2) + 0xfe006000)
#define MAILBOX_IRQE_CLR1                          ((0x0429  << 2) + 0xfe006000)
#define MAILBOX_IRQA_STS0                          ((0x0430  << 2) + 0xfe006000)
#define MAILBOX_IRQA_STS1                          ((0x0431  << 2) + 0xfe006000)
#define MAILBOX_IRQB_STS0                          ((0x0432  << 2) + 0xfe006000)
#define MAILBOX_IRQB_STS1                          ((0x0433  << 2) + 0xfe006000)
#define MAILBOX_IRQC_STS0                          ((0x0434  << 2) + 0xfe006000)
#define MAILBOX_IRQC_STS1                          ((0x0435  << 2) + 0xfe006000)
#define MAILBOX_IRQD_STS0                          ((0x0436  << 2) + 0xfe006000)
#define MAILBOX_IRQD_STS1                          ((0x0437  << 2) + 0xfe006000)
#define MAILBOX_IRQE_STS0                          ((0x0438  << 2) + 0xfe006000)
#define MAILBOX_IRQE_STS1                          ((0x0439  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX00                   ((0x0440  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX01                   ((0x0441  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX02                   ((0x0442  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX03                   ((0x0443  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX04                   ((0x0444  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX05                   ((0x0445  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX06                   ((0x0446  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX07                   ((0x0447  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX08                   ((0x0448  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX09                   ((0x0449  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX10                   ((0x044a  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX11                   ((0x044b  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX12                   ((0x044c  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX13                   ((0x044d  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX14                   ((0x044e  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX15                   ((0x044f  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX16                   ((0x0450  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX17                   ((0x0451  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX18                   ((0x0452  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX19                   ((0x0453  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX20                   ((0x0454  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX21                   ((0x0455  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX22                   ((0x0456  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX23                   ((0x0457  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX24                   ((0x0458  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX25                   ((0x0459  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX26                   ((0x045a  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX27                   ((0x045b  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX28                   ((0x045c  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX29                   ((0x045d  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX30                   ((0x045e  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX31                   ((0x045f  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX00                         ((0x0460  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX01                         ((0x0461  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX02                         ((0x0462  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX03                         ((0x0463  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX04                         ((0x0464  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX05                         ((0x0465  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX06                         ((0x0466  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX07                         ((0x0467  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX08                         ((0x0468  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX09                         ((0x0469  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX10                         ((0x046a  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX11                         ((0x046b  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX12                         ((0x046c  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX13                         ((0x046d  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX14                         ((0x046e  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX15                         ((0x046f  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX16                         ((0x0470  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX17                         ((0x0471  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX18                         ((0x0472  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX19                         ((0x0473  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX20                         ((0x0474  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX21                         ((0x0475  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX22                         ((0x0476  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX23                         ((0x0477  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX24                         ((0x0478  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX25                         ((0x0479  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX26                         ((0x047a  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX27                         ((0x047b  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX28                         ((0x047c  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX29                         ((0x047d  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX30                         ((0x047e  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX31                         ((0x047f  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX00                         ((0x0480  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX01                         ((0x0481  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX02                         ((0x0482  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX03                         ((0x0483  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX04                         ((0x0484  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX05                         ((0x0485  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX06                         ((0x0486  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX07                         ((0x0487  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX08                         ((0x0488  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX09                         ((0x0489  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX10                         ((0x048a  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX11                         ((0x048b  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX12                         ((0x048c  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX13                         ((0x048d  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX14                         ((0x048e  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX15                         ((0x048f  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX16                         ((0x0490  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX17                         ((0x0491  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX18                         ((0x0492  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX19                         ((0x0493  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX20                         ((0x0494  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX21                         ((0x0495  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX22                         ((0x0496  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX23                         ((0x0497  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX24                         ((0x0498  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX25                         ((0x0499  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX26                         ((0x049a  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX27                         ((0x049b  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX28                         ((0x049c  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX29                         ((0x049d  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX30                         ((0x049e  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX31                         ((0x049f  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX00                         ((0x04a0  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX01                         ((0x04a1  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX02                         ((0x04a2  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX03                         ((0x04a3  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX04                         ((0x04a4  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX05                         ((0x04a5  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX06                         ((0x04a6  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX07                         ((0x04a7  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX08                         ((0x04a8  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX09                         ((0x04a9  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX10                         ((0x04aa  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX11                         ((0x04ab  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX12                         ((0x04ac  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX13                         ((0x04ad  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX14                         ((0x04ae  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX15                         ((0x04af  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX16                         ((0x04b0  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX17                         ((0x04b1  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX18                         ((0x04b2  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX19                         ((0x04b3  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX20                         ((0x04b4  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX21                         ((0x04b5  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX22                         ((0x04b6  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX23                         ((0x04b7  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX24                         ((0x04b8  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX25                         ((0x04b9  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX26                         ((0x04ba  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX27                         ((0x04bb  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX28                         ((0x04bc  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX29                         ((0x04bd  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX30                         ((0x04be  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX31                         ((0x04bf  << 2) + 0xfe006000)
//========================================================================
//  IRQ_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00a000
// -----------------------------------------------
#define IRQCTRL_IRQ_INV0                           ((0x0000  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV1                           ((0x0001  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV2                           ((0x0002  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV3                           ((0x0003  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV4                           ((0x0004  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV5                           ((0x0005  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV6                           ((0x0006  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV7                           ((0x0007  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV8                           ((0x0008  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV9                           ((0x0009  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV10                          ((0x000a  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_GIC                          ((0x0010  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_GIC                          ((0x0011  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_GIC                          ((0x0012  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_GIC                          ((0x0013  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_GIC                          ((0x0014  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_GIC                          ((0x0015  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_GIC                          ((0x0016  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_GIC                          ((0x0017  << 2) + 0xfe00a000)
#define IRQCTRL_MASK8_GIC                          ((0x0018  << 2) + 0xfe00a000)
#define IRQCTRL_MASK9_GIC                          ((0x0019  << 2) + 0xfe00a000)
#define IRQCTRL_MASK10_GIC                         ((0x001a  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_DSP                          ((0x0020  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_DSP                          ((0x0021  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_DSP                          ((0x0022  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_DSP                          ((0x0023  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_DSP                          ((0x0024  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_DSP                          ((0x0025  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_DSP                          ((0x0026  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_DSP                          ((0x0027  << 2) + 0xfe00a000)
#define IRQCTRL_MASK8_DSP                          ((0x0028  << 2) + 0xfe00a000)
#define IRQCTRL_MASK9_DSP                          ((0x0029  << 2) + 0xfe00a000)
#define IRQCTRL_MASK10_DSP                         ((0x002a  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_PWRCTRL                      ((0x0030  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_PWRCTRL                      ((0x0031  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_PWRCTRL                      ((0x0032  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_PWRCTRL                      ((0x0033  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_PWRCTRL                      ((0x0034  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_PWRCTRL                      ((0x0035  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_PWRCTRL                      ((0x0036  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_PWRCTRL                      ((0x0037  << 2) + 0xfe00a000)
#define IRQCTRL_MASK8_PWRCTRL                      ((0x0038  << 2) + 0xfe00a000)
#define IRQCTRL_MASK9_PWRCTRL                      ((0x0039  << 2) + 0xfe00a000)
#define IRQCTRL_MASK10_PWRCTRL                     ((0x003a  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_AOCPU                        ((0x0040  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_AOCPU                        ((0x0041  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_AOCPU                        ((0x0042  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_AOCPU                        ((0x0043  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_AOCPU                        ((0x0044  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_AOCPU                        ((0x0045  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_AOCPU                        ((0x0046  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_AOCPU                        ((0x0047  << 2) + 0xfe00a000)
#define IRQCTRL_MASK8_AOCPU                        ((0x0048  << 2) + 0xfe00a000)
#define IRQCTRL_MASK9_AOCPU                        ((0x0049  << 2) + 0xfe00a000)
#define IRQCTRL_MASK10_AOCPU                       ((0x004a  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE0                          ((0x0050  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE1                          ((0x0051  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE2                          ((0x0052  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE3                          ((0x0053  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE4                          ((0x0054  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE5                          ((0x0055  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE6                          ((0x0056  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE7                          ((0x0057  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE8                          ((0x0058  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE9                          ((0x0059  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE10                         ((0x005a  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH0                         ((0x0060  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH1                         ((0x0061  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH2                         ((0x0062  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH3                         ((0x0063  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH4                         ((0x0064  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH5                         ((0x0065  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH6                         ((0x0066  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH7                         ((0x0067  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH8                         ((0x0068  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH9                         ((0x0069  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH10                        ((0x006a  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR0                     ((0x0070  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR1                     ((0x0071  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR2                     ((0x0072  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR3                     ((0x0073  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR4                     ((0x0074  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR5                     ((0x0075  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR6                     ((0x0076  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR7                     ((0x0077  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR8                     ((0x0078  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR9                     ((0x0079  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR10                    ((0x007a  << 2) + 0xfe00a000)
#define IRQCTRL_LOCK_BIT                           ((0x0080  << 2) + 0xfe00a000)
#define IRQCTRL_PROT_BIT                           ((0x0081  << 2) + 0xfe00a000)
#define IRQCTRL_SOFT_IRQ                           ((0x0088  << 2) + 0xfe00a000)
//========================================================================
//  RESET_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe002000
// -----------------------------------------------
#define RESETCTRL_RESET0                           ((0x0000  << 2) + 0xfe002000)
#define RESETCTRL_RESET1                           ((0x0001  << 2) + 0xfe002000)
#define RESETCTRL_RESET2                           ((0x0002  << 2) + 0xfe002000)
#define RESETCTRL_RESET3                           ((0x0003  << 2) + 0xfe002000)
#define RESETCTRL_RESET4                           ((0x0004  << 2) + 0xfe002000)
#define RESETCTRL_RESET5                           ((0x0005  << 2) + 0xfe002000)
#define RESETCTRL_RESET6                           ((0x0006  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_LEVEL                     ((0x0010  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_LEVEL                     ((0x0011  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_LEVEL                     ((0x0012  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_LEVEL                     ((0x0013  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_LEVEL                     ((0x0014  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_LEVEL                     ((0x0015  << 2) + 0xfe002000)
#define RESETCTRL_RESET6_LEVEL                     ((0x0016  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_MASK                      ((0x0020  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_MASK                      ((0x0021  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_MASK                      ((0x0022  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_MASK                      ((0x0023  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_MASK                      ((0x0024  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_MASK                      ((0x0025  << 2) + 0xfe002000)
#define RESETCTRL_RESET6_MASK                      ((0x0026  << 2) + 0xfe002000)
#define RESETCTRL_RESET_HOLD_CYC                   ((0x0030  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CTRL0                   ((0x0040  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CTRL1                   ((0x0041  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CNT                     ((0x0042  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CLR                     ((0x0043  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CTRL0               ((0x0044  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CTRL1               ((0x0045  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CNT                 ((0x0046  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CLR                 ((0x0047  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_DLY_CNT                 ((0x0048  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0                       ((0x0050  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1                       ((0x0051  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET2                       ((0x0052  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_LEVEL                 ((0x0060  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_LEVEL                 ((0x0061  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET2_LEVEL                 ((0x0062  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_MASK                  ((0x0070  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_MASK                  ((0x0071  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET2_MASK                  ((0x0072  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_LOCK                      ((0x0080  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_LOCK                      ((0x0081  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_LOCK                      ((0x0082  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_LOCK                      ((0x0083  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_LOCK                      ((0x0084  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_LOCK                      ((0x0085  << 2) + 0xfe002000)
#define RESETCTRL_RESET6_LOCK                      ((0x0086  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_LOCK                  ((0x0088  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_LOCK                  ((0x0089  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET2_LOCK                  ((0x008a  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_PROT                      ((0x0090  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_PROT                      ((0x0091  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_PROT                      ((0x0092  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_PROT                      ((0x0093  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_PROT                      ((0x0094  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_PROT                      ((0x0095  << 2) + 0xfe002000)
#define RESETCTRL_RESET6_PROT                      ((0x0096  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_PROT                  ((0x0098  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_PROT                  ((0x0099  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET2_PROT                  ((0x009a  << 2) + 0xfe002000)
//========================================================================
//  CPU_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00e000
// -----------------------------------------------
#define CPUCTRL_SYS_A73_RESET_CNTL                 ((0x0040  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CLK_CTRL0                  ((0x0041  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CLK_CTRL1                  ((0x0042  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CLK_CTRL2                  ((0x0043  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_RESET_CNTL                 ((0x0050  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL0                  ((0x0051  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL1                  ((0x0052  << 2) + 0xfe00e000)
//`define CPUCTRL_SYS_CPU_CLK_CTRL4           8'h55
//`define CPUCTRL_SYS_CPU_CLK_CTRL5           8'h56
//`define CPUCTRL_SYS_CPU_CLK_CTRL6           8'h57
#define CPUCTRL_SYS_CPU_CLK_RESULT                 ((0x0058  << 2) + 0xfe00e000)
#define CPUCTRL_ROM_DISABLE                        ((0x0060  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_PERIPHBASE                 ((0x0080  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_TARGETID                   ((0x0081  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_POR_CFG0                   ((0x0090  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_POR_CFG1                   ((0x0091  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG0                       ((0x0092  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG1                       ((0x0093  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG2                       ((0x0094  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG3                       ((0x0095  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG4                       ((0x0096  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG5                       ((0x0097  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG6                       ((0x0098  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG7                       ((0x0099  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG8                       ((0x009a  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG9                       ((0x009b  << 2) + 0xfe00e000)
//`define CPUCTRL_SYS_CPU_CFG10               8'h9c
//`define CPUCTRL_SYS_CPU_CFG11               8'h9d
//`define CPUCTRL_SYS_CPU_CFG12               8'h9e
//`define CPUCTRL_SYS_CPU_CFG13               8'h9f
#define CPUCTRL_SYS_CPU_STATUS0                    ((0x00a0  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS1                    ((0x00a1  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS2                    ((0x00a2  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS3                    ((0x00a3  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS4                    ((0x00a4  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS5                    ((0x00a5  << 2) + 0xfe00e000)
//`define CPUCTRL_SYS_CPU_STATUS6             8'ha6
//`define CPUCTRL_SYS_CPU_STATUS7             8'ha7
#define CPUCTRL_SYS_A73_PERIPHBASE                 ((0x00b0  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_POR_CFG0                   ((0x00c0  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_POR_CFG1                   ((0x00c1  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG0                       ((0x00c2  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG1                       ((0x00c3  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG2                       ((0x00c4  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG3                       ((0x00c5  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG4                       ((0x00c6  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG5                       ((0x00c7  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG6                       ((0x00c8  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG7                       ((0x00c9  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG8                       ((0x00ca  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_CFG9                       ((0x00cb  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS0                    ((0x00d0  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS1                    ((0x00d1  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS2                    ((0x00d2  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS3                    ((0x00d3  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS4                    ((0x00d4  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_A73_STATUS5                    ((0x00d5  << 2) + 0xfe00e000)
//========================================================================
//  SAR_ADC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe026000
// -----------------------------------------------
#define SAR_ADC_REG0                               ((0x0000  << 2) + 0xfe026000)
#define SAR_ADC_CHAN_LIST                          ((0x0001  << 2) + 0xfe026000)
#define SAR_ADC_AVG_CNTL                           ((0x0002  << 2) + 0xfe026000)
#define SAR_ADC_REG3                               ((0x0003  << 2) + 0xfe026000)
#define SAR_ADC_DELAY                              ((0x0004  << 2) + 0xfe026000)
#define SAR_ADC_LAST_RD                            ((0x0005  << 2) + 0xfe026000)
#define SAR_ADC_FIFO_RD                            ((0x0006  << 2) + 0xfe026000)
#define SAR_ADC_AUX_SW                             ((0x0007  << 2) + 0xfe026000)
#define SAR_ADC_CHAN_10_SW                         ((0x0008  << 2) + 0xfe026000)
#define SAR_ADC_DETECT_IDLE_SW                     ((0x0009  << 2) + 0xfe026000)
#define SAR_ADC_DELTA_10                           ((0x000a  << 2) + 0xfe026000)
#define SAR_ADC_REG11                              ((0x000b  << 2) + 0xfe026000)
#define SAR_ADC_REG12                              ((0x000c  << 2) + 0xfe026000)
#define SAR_ADC_REG13                              ((0x000d  << 2) + 0xfe026000)
#define SAR_ADC_CHNL01                             ((0x000e  << 2) + 0xfe026000)
#define SAR_ADC_CHNL23                             ((0x000f  << 2) + 0xfe026000)
#define SAR_ADC_CHNL45                             ((0x0010  << 2) + 0xfe026000)
#define SAR_ADC_CHNL67                             ((0x0011  << 2) + 0xfe026000)
//========================================================================
//  ANA_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe008000
// -----------------------------------------------
#define ANACTRL_SYS0PLL_CTRL0                      ((0x0000  << 2) + 0xfe008000)
#define ANACTRL_SYS0PLL_CTRL1                      ((0x0001  << 2) + 0xfe008000)
#define ANACTRL_SYS0PLL_CTRL2                      ((0x0002  << 2) + 0xfe008000)
#define ANACTRL_SYS0PLL_CTRL3                      ((0x0003  << 2) + 0xfe008000)
#define ANACTRL_SYS0PLL_STS                        ((0x0004  << 2) + 0xfe008000)
#define ANACTRL_SYS1PLL_CTRL0                      ((0x0008  << 2) + 0xfe008000)
#define ANACTRL_SYS1PLL_CTRL1                      ((0x0009  << 2) + 0xfe008000)
#define ANACTRL_SYS1PLL_CTRL2                      ((0x000a  << 2) + 0xfe008000)
#define ANACTRL_SYS1PLL_CTRL3                      ((0x000b  << 2) + 0xfe008000)
#define ANACTRL_SYS1PLL_STS                        ((0x000c  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL0                       ((0x0010  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL1                       ((0x0011  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL2                       ((0x0012  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL3                       ((0x0013  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL4                       ((0x0014  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL5                       ((0x0015  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL6                       ((0x0016  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_STS                         ((0x0017  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL0                       ((0x0020  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL1                       ((0x0021  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL2                       ((0x0022  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL3                       ((0x0023  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL4                       ((0x0024  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL5                       ((0x0025  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL6                       ((0x0026  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_STS                         ((0x0027  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL0                       ((0x0030  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL1                       ((0x0031  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL2                       ((0x0032  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL3                       ((0x0033  << 2) + 0xfe008000)
//`define ANACTRL_GP1PLL_CTRL4    8'h34
//`define ANACTRL_GP1PLL_CTRL5    8'h35
//`define ANACTRL_GP1PLL_CTRL6    8'h36
#define ANACTRL_GP1PLL_STS                         ((0x0037  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL0                      ((0x0040  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL1                      ((0x0041  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL2                      ((0x0042  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL3                      ((0x0043  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL4                      ((0x0044  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL5                      ((0x0045  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL6                      ((0x0046  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_STS                        ((0x0047  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL0                      ((0x0050  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL1                      ((0x0051  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL2                      ((0x0052  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL3                      ((0x0053  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL4                      ((0x0054  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_CTRL5                      ((0x0055  << 2) + 0xfe008000)
#define ANACTRL_PCIEPLL_STS                        ((0x0056  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL0                         ((0x0060  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL1                         ((0x0061  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL2                         ((0x0062  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL3                         ((0x0063  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL4                         ((0x0064  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL5                         ((0x0065  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL6                         ((0x0066  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL7                         ((0x0067  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL8                         ((0x0068  << 2) + 0xfe008000)
#define ANACTRL_MPLL_STS                           ((0x0069  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL0                      ((0x0070  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL1                      ((0x0071  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL2                      ((0x0072  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL3                      ((0x0073  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL4                      ((0x0074  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL5                      ((0x0075  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_CTRL6                      ((0x0076  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_STS                        ((0x0077  << 2) + 0xfe008000)
#define ANACTRL_HDMIPLL_VLOCK                      ((0x0079  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL0                      ((0x0080  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL1                      ((0x0081  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL2                      ((0x0082  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL3                      ((0x0083  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL4                      ((0x0084  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_CTRL5                      ((0x0085  << 2) + 0xfe008000)
#define ANACTRL_HDMIPHY_STS                        ((0x0086  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL0                      ((0x0090  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL1                      ((0x0091  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL2                      ((0x0092  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL3                      ((0x0093  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL4                      ((0x0094  << 2) + 0xfe008000)
#define ANACTRL_MIPICSI_CTRL5                      ((0x0095  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_CTRL0                      ((0x00a0  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_CTRL1                      ((0x00a1  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_CTRL2                      ((0x00a2  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_STS                        ((0x00a3  << 2) + 0xfe008000)
//`define ANACTRL_VDAC_CTRL0       8'hB0
//`define ANACTRL_VDAC_CTRL1       8'hB1
#define ANACTRL_POR_CTRL                           ((0x00b6  << 2) + 0xfe008000)
#define ANACTRL_LOCK_BIT                           ((0x00b8  << 2) + 0xfe008000)
#define ANACTRL_PROT_BIT                           ((0x00b9  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_CNTL0                     ((0x00c0  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_CNTL1                     ((0x00c1  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_CNTL2                     ((0x00c2  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_CNTL3                     ((0x00c3  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_CNTL4                     ((0x00c4  << 2) + 0xfe008000)
#define ANACTRL_MCLK_PLL_STS                       ((0x00c5  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL1                      ((0x00c8  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL2                      ((0x00c9  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL3                      ((0x00ca  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL4                      ((0x00cb  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL5                      ((0x00cc  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL6                      ((0x00cd  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL7                      ((0x00ce  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL8                      ((0x00cf  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL9                      ((0x00d0  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL10                     ((0x00d1  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL11                     ((0x00d2  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL12                     ((0x00d3  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL13                     ((0x00d4  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL14                     ((0x00d5  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL15                     ((0x00d6  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL16                     ((0x00d7  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL17                     ((0x00d8  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL18                     ((0x00d9  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL19                     ((0x00da  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL20                     ((0x00db  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_CNTL21                     ((0x00dc  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_CNTL0                    ((0x00e0  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_CNTL1                    ((0x00e1  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_CNTL2                    ((0x00e2  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_CNTL3                    ((0x00e3  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_CNTL4                    ((0x00e4  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_CNTL0                    ((0x00e5  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_CNTL1                    ((0x00e6  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_CNTL2                    ((0x00e7  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_CNTL3                    ((0x00e8  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_CNTL4                    ((0x00e9  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_CNTL0                    ((0x00ea  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_CNTL1                    ((0x00eb  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_CNTL2                    ((0x00ec  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_CNTL3                    ((0x00ed  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_CNTL4                    ((0x00ee  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL0_STS                      ((0x00ef  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL1_STS                      ((0x00f0  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL2_STS                      ((0x00f1  << 2) + 0xfe008000)
#define ANACTRL_TCON_PLL_VLOCK                     ((0x00f2  << 2) + 0xfe008000)
#define ANACTRL_DIF_PHY_STS                        ((0x00f3  << 2) + 0xfe008000)
//========================================================================
//  Ethernet Phy
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe028000
// -----------------------------------------------
#define ETH_PHY_DBG_CTL0                           ((0x0000  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CTL1                           ((0x0001  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG0                           ((0x0002  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG1                           ((0x0003  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG2                           ((0x0004  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG3                           ((0x0005  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG4                           ((0x0006  << 2) + 0xfe028000)
#define ETH_PLL_STS                                ((0x0010  << 2) + 0xfe028000)
#define ETH_PLL_CTL0                               ((0x0011  << 2) + 0xfe028000)
#define ETH_PLL_CTL1                               ((0x0012  << 2) + 0xfe028000)
#define ETH_PLL_CTL2                               ((0x0013  << 2) + 0xfe028000)
#define ETH_PLL_CTL3                               ((0x0014  << 2) + 0xfe028000)
#define ETH_PLL_CTL4                               ((0x0015  << 2) + 0xfe028000)
#define ETH_PLL_CTL5                               ((0x0016  << 2) + 0xfe028000)
#define ETH_PLL_CTL6                               ((0x0017  << 2) + 0xfe028000)
#define ETH_PLL_CTL7                               ((0x0018  << 2) + 0xfe028000)
#define ETH_PHY_CNTL0                              ((0x0020  << 2) + 0xfe028000)
#define ETH_PHY_CNTL1                              ((0x0021  << 2) + 0xfe028000)
#define ETH_PHY_CNTL2                              ((0x0022  << 2) + 0xfe028000)
#define ETH_PHY_CNTL3                              ((0x0023  << 2) + 0xfe028000)
#define ETH_PHY_STS0                               ((0x0025  << 2) + 0xfe028000)
#define ETH_PHY_STS1                               ((0x0026  << 2) + 0xfe028000)
#define ETH_PHY_STS2                               ((0x0027  << 2) + 0xfe028000)
#define ETH_PHY_DBG_REG                            ((0x0028  << 2) + 0xfe028000)
//========================================================================
//  Ethernet TOP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe024000
// -----------------------------------------------
#define ETHTOP_CNTL0                               ((0x0000  << 2) + 0xfe024000)
#define ETHTOP_CNTL1                               ((0x0001  << 2) + 0xfe024000)
#define ETHTOP_CNTL2                               ((0x0002  << 2) + 0xfe024000)
#define ETHTOP_CNTL3                               ((0x0003  << 2) + 0xfe024000)
#define ETHTOP_STS0                                ((0x0008  << 2) + 0xfe024000)
#define ETHTOP_STS1                                ((0x0009  << 2) + 0xfe024000)
#define ETHTOP_STS2                                ((0x000a  << 2) + 0xfe024000)
#define ETHTOP_STS3                                ((0x000b  << 2) + 0xfe024000)
//========================================================================
//  I2C Slave A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe064000
// -----------------------------------------------
#define I2C_S_A_CONTROL_REG                        ((0x0000  << 2) + 0xfe064000)
#define I2C_S_A_SEND_REG                           ((0x0001  << 2) + 0xfe064000)
#define I2C_S_A_RECV_REG                           ((0x0002  << 2) + 0xfe064000)
#define I2C_S_A_CNTL1_REG                          ((0x0003  << 2) + 0xfe064000)
//========================================================================
//  IR RX/TX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe084000
// -----------------------------------------------
#define IRCTRL_IR_DEC_LDR_ACTIVE                   ((0x0000  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_LDR_IDLE                     ((0x0001  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_LDR_REPEAT                   ((0x0002  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_BIT_0                        ((0x0003  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_REG0                         ((0x0004  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_FRAME                        ((0x0005  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_STATUS                       ((0x0006  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_REG1                         ((0x0007  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_ACTIVE                ((0x0010  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_IDLE                  ((0x0011  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_REPEAT                ((0x0012  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_BIT_0                     ((0x0013  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG0                      ((0x0014  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME                     ((0x0015  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS                    ((0x0016  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG1                      ((0x0017  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG2                      ((0x0018  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_DURATN2                   ((0x0019  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_DURATN3                   ((0x001a  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME1                    ((0x001b  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS1                   ((0x001c  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS2                   ((0x001d  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG3                      ((0x001e  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME_RSV0                ((0x001f  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME_RSV1                ((0x0020  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FILTE                     ((0x0021  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_IRQ_CTL                   ((0x0022  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FIFO_CTL                  ((0x0023  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_WIDTH_NEW                 ((0x0024  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REPEAT_DET                ((0x0025  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNTL0                  ((0x0030  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNTL1                  ((0x0031  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_IIR_THD                ((0x0032  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_THD0                   ((0x0033  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_THD1                   ((0x0034  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_SUM_CNT0               ((0x0035  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_SUM_CNT1               ((0x0036  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNT0                   ((0x0037  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNT1                   ((0x0038  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR0                    ((0x0043  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR1                    ((0x0044  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR2                    ((0x0045  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR3                    ((0x0046  << 2) + 0xfe084000)
//========================================================================
//  I2C Master AO_A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe076000
// -----------------------------------------------
#define I2C_M_AO_A_CONTROL_REG                     ((0x0000  << 2) + 0xfe076000)
#define I2C_M_AO_A_SLAVE_ADDR                      ((0x0001  << 2) + 0xfe076000)
#define I2C_M_AO_A_TOKEN_LIST0                     ((0x0002  << 2) + 0xfe076000)
#define I2C_M_AO_A_TOKEN_LIST1                     ((0x0003  << 2) + 0xfe076000)
#define I2C_M_AO_A_WDATA_REG0                      ((0x0004  << 2) + 0xfe076000)
#define I2C_M_AO_A_WDATA_REG1                      ((0x0005  << 2) + 0xfe076000)
#define I2C_M_AO_A_RDATA_REG0                      ((0x0006  << 2) + 0xfe076000)
#define I2C_M_AO_A_RDATA_REG1                      ((0x0007  << 2) + 0xfe076000)
#define I2C_M_AO_A_TIMEOUT_TH                      ((0x0008  << 2) + 0xfe076000)
#define I2C_M_AO_A_CNTL_DELY1                      ((0x0009  << 2) + 0xfe076000)
#define I2C_M_AO_A_CNTL_DELY2                      ((0x000a  << 2) + 0xfe076000)
#define I2C_M_AO_A_LOW_DELY                        ((0x000b  << 2) + 0xfe076000)
#define I2C_M_AO_A_HIGH_DELY                       ((0x000c  << 2) + 0xfe076000)
#define I2C_M_AO_A_FIFO_CTRL0                      ((0x000d  << 2) + 0xfe076000)
#define I2C_M_AO_A_FIFO_CTRL1                      ((0x000e  << 2) + 0xfe076000)
#define I2C_M_AO_A_FIFO_PENDING                    ((0x000f  << 2) + 0xfe076000)
#define I2C_M_AO_A_FIFO_PENDING_MASK               ((0x0010  << 2) + 0xfe076000)
#define I2C_M_AO_A_FIFO_ST0                        ((0x0011  << 2) + 0xfe076000)
//========================================================================
//  I2C Master AO_B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe086000
// -----------------------------------------------
#define I2C_M_AO_B_CONTROL_REG                     ((0x0000  << 2) + 0xfe086000)
#define I2C_M_AO_B_SLAVE_ADDR                      ((0x0001  << 2) + 0xfe086000)
#define I2C_M_AO_B_TOKEN_LIST0                     ((0x0002  << 2) + 0xfe086000)
#define I2C_M_AO_B_TOKEN_LIST1                     ((0x0003  << 2) + 0xfe086000)
#define I2C_M_AO_B_WDATA_REG0                      ((0x0004  << 2) + 0xfe086000)
#define I2C_M_AO_B_WDATA_REG1                      ((0x0005  << 2) + 0xfe086000)
#define I2C_M_AO_B_RDATA_REG0                      ((0x0006  << 2) + 0xfe086000)
#define I2C_M_AO_B_RDATA_REG1                      ((0x0007  << 2) + 0xfe086000)
#define I2C_M_AO_B_TIMEOUT_TH                      ((0x0008  << 2) + 0xfe086000)
#define I2C_M_AO_B_CNTL_DELY1                      ((0x0009  << 2) + 0xfe086000)
#define I2C_M_AO_B_CNTL_DELY2                      ((0x000a  << 2) + 0xfe086000)
#define I2C_M_AO_B_LOW_DELY                        ((0x000b  << 2) + 0xfe086000)
#define I2C_M_AO_B_HIGH_DELY                       ((0x000c  << 2) + 0xfe086000)
#define I2C_M_AO_B_FIFO_CTRL0                      ((0x000d  << 2) + 0xfe086000)
#define I2C_M_AO_B_FIFO_CTRL1                      ((0x000e  << 2) + 0xfe086000)
#define I2C_M_AO_B_FIFO_PENDING                    ((0x000f  << 2) + 0xfe086000)
#define I2C_M_AO_B_FIFO_PENDING_MASK               ((0x0010  << 2) + 0xfe086000)
#define I2C_M_AO_B_FIFO_ST0                        ((0x0011  << 2) + 0xfe086000)
//========================================================================
//  I2C Master A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066000
// -----------------------------------------------
#define I2C_M_A_CONTROL_REG                        ((0x0000  << 2) + 0xfe066000)
#define I2C_M_A_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe066000)
#define I2C_M_A_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe066000)
#define I2C_M_A_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe066000)
#define I2C_M_A_WDATA_REG0                         ((0x0004  << 2) + 0xfe066000)
#define I2C_M_A_WDATA_REG1                         ((0x0005  << 2) + 0xfe066000)
#define I2C_M_A_RDATA_REG0                         ((0x0006  << 2) + 0xfe066000)
#define I2C_M_A_RDATA_REG1                         ((0x0007  << 2) + 0xfe066000)
#define I2C_M_A_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe066000)
#define I2C_M_A_CNTL_DELY1                         ((0x0009  << 2) + 0xfe066000)
#define I2C_M_A_CNTL_DELY2                         ((0x000a  << 2) + 0xfe066000)
#define I2C_M_A_LOW_DELY                           ((0x000b  << 2) + 0xfe066000)
#define I2C_M_A_HIGH_DELY                          ((0x000c  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_PENDING                       ((0x000f  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_ST0                           ((0x0011  << 2) + 0xfe066000)
//========================================================================
//  I2C Master B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe068000
// -----------------------------------------------
#define I2C_M_B_CONTROL_REG                        ((0x0000  << 2) + 0xfe068000)
#define I2C_M_B_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe068000)
#define I2C_M_B_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe068000)
#define I2C_M_B_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe068000)
#define I2C_M_B_WDATA_REG0                         ((0x0004  << 2) + 0xfe068000)
#define I2C_M_B_WDATA_REG1                         ((0x0005  << 2) + 0xfe068000)
#define I2C_M_B_RDATA_REG0                         ((0x0006  << 2) + 0xfe068000)
#define I2C_M_B_RDATA_REG1                         ((0x0007  << 2) + 0xfe068000)
#define I2C_M_B_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe068000)
#define I2C_M_B_CNTL_DELY1                         ((0x0009  << 2) + 0xfe068000)
#define I2C_M_B_CNTL_DELY2                         ((0x000a  << 2) + 0xfe068000)
#define I2C_M_B_LOW_DELY                           ((0x000b  << 2) + 0xfe068000)
#define I2C_M_B_HIGH_DELY                          ((0x000c  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_PENDING                       ((0x000f  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_ST0                           ((0x0011  << 2) + 0xfe068000)
//========================================================================
//  I2C Master C
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06a000
// -----------------------------------------------
#define I2C_M_C_CONTROL_REG                        ((0x0000  << 2) + 0xfe06a000)
#define I2C_M_C_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06a000)
#define I2C_M_C_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06a000)
#define I2C_M_C_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06a000)
#define I2C_M_C_WDATA_REG0                         ((0x0004  << 2) + 0xfe06a000)
#define I2C_M_C_WDATA_REG1                         ((0x0005  << 2) + 0xfe06a000)
#define I2C_M_C_RDATA_REG0                         ((0x0006  << 2) + 0xfe06a000)
#define I2C_M_C_RDATA_REG1                         ((0x0007  << 2) + 0xfe06a000)
#define I2C_M_C_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06a000)
#define I2C_M_C_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06a000)
#define I2C_M_C_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06a000)
#define I2C_M_C_LOW_DELY                           ((0x000b  << 2) + 0xfe06a000)
#define I2C_M_C_HIGH_DELY                          ((0x000c  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_ST0                           ((0x0011  << 2) + 0xfe06a000)
//========================================================================
//  I2C Master D
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06c000
// -----------------------------------------------
#define I2C_M_D_CONTROL_REG                        ((0x0000  << 2) + 0xfe06c000)
#define I2C_M_D_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06c000)
#define I2C_M_D_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06c000)
#define I2C_M_D_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06c000)
#define I2C_M_D_WDATA_REG0                         ((0x0004  << 2) + 0xfe06c000)
#define I2C_M_D_WDATA_REG1                         ((0x0005  << 2) + 0xfe06c000)
#define I2C_M_D_RDATA_REG0                         ((0x0006  << 2) + 0xfe06c000)
#define I2C_M_D_RDATA_REG1                         ((0x0007  << 2) + 0xfe06c000)
#define I2C_M_D_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06c000)
#define I2C_M_D_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06c000)
#define I2C_M_D_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06c000)
#define I2C_M_D_LOW_DELY                           ((0x000b  << 2) + 0xfe06c000)
#define I2C_M_D_HIGH_DELY                          ((0x000c  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_ST0                           ((0x0011  << 2) + 0xfe06c000)
//========================================================================
//  I2C Master E
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06e000
// -----------------------------------------------
#define I2C_M_E_CONTROL_REG                        ((0x0000  << 2) + 0xfe06e000)
#define I2C_M_E_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06e000)
#define I2C_M_E_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06e000)
#define I2C_M_E_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06e000)
#define I2C_M_E_WDATA_REG0                         ((0x0004  << 2) + 0xfe06e000)
#define I2C_M_E_WDATA_REG1                         ((0x0005  << 2) + 0xfe06e000)
#define I2C_M_E_RDATA_REG0                         ((0x0006  << 2) + 0xfe06e000)
#define I2C_M_E_RDATA_REG1                         ((0x0007  << 2) + 0xfe06e000)
#define I2C_M_E_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06e000)
#define I2C_M_E_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06e000)
#define I2C_M_E_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06e000)
#define I2C_M_E_LOW_DELY                           ((0x000b  << 2) + 0xfe06e000)
#define I2C_M_E_HIGH_DELY                          ((0x000c  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_ST0                           ((0x0011  << 2) + 0xfe06e000)
//========================================================================
//  I2C Master F
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe070000
// -----------------------------------------------
#define I2C_M_F_CONTROL_REG                        ((0x0000  << 2) + 0xfe070000)
#define I2C_M_F_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe070000)
#define I2C_M_F_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe070000)
#define I2C_M_F_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe070000)
#define I2C_M_F_WDATA_REG0                         ((0x0004  << 2) + 0xfe070000)
#define I2C_M_F_WDATA_REG1                         ((0x0005  << 2) + 0xfe070000)
#define I2C_M_F_RDATA_REG0                         ((0x0006  << 2) + 0xfe070000)
#define I2C_M_F_RDATA_REG1                         ((0x0007  << 2) + 0xfe070000)
#define I2C_M_F_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe070000)
#define I2C_M_F_CNTL_DELY1                         ((0x0009  << 2) + 0xfe070000)
#define I2C_M_F_CNTL_DELY2                         ((0x000a  << 2) + 0xfe070000)
#define I2C_M_F_LOW_DELY                           ((0x000b  << 2) + 0xfe070000)
#define I2C_M_F_HIGH_DELY                          ((0x000c  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_PENDING                       ((0x000f  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_ST0                           ((0x0011  << 2) + 0xfe070000)
//========================================================================
//  APB0_UART_A - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe078000
// -----------------------------------------------
#define UART_A_WFIFO                               ((0x0000  << 2) + 0xfe078000)
#define UART_A_RFIFO                               ((0x0001  << 2) + 0xfe078000)
#define UART_A_CONTROL                             ((0x0002  << 2) + 0xfe078000)
#define UART_A_STATUS                              ((0x0003  << 2) + 0xfe078000)
#define UART_A_MISC                                ((0x0004  << 2) + 0xfe078000)
#define UART_A_REG5                                ((0x0005  << 2) + 0xfe078000)
//========================================================================
//  APB0_UART_B - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07a000
// -----------------------------------------------
#define UART_B_WFIFO                               ((0x0000  << 2) + 0xfe07a000)
#define UART_B_RFIFO                               ((0x0001  << 2) + 0xfe07a000)
#define UART_B_CONTROL                             ((0x0002  << 2) + 0xfe07a000)
#define UART_B_STATUS                              ((0x0003  << 2) + 0xfe07a000)
#define UART_B_MISC                                ((0x0004  << 2) + 0xfe07a000)
#define UART_B_REG5                                ((0x0005  << 2) + 0xfe07a000)
//========================================================================
//  APB0_UART_C - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07c000
// -----------------------------------------------
#define UART_C_WFIFO                               ((0x0000  << 2) + 0xfe07c000)
#define UART_C_RFIFO                               ((0x0001  << 2) + 0xfe07c000)
#define UART_C_CONTROL                             ((0x0002  << 2) + 0xfe07c000)
#define UART_C_STATUS                              ((0x0003  << 2) + 0xfe07c000)
#define UART_C_MISC                                ((0x0004  << 2) + 0xfe07c000)
#define UART_C_REG5                                ((0x0005  << 2) + 0xfe07c000)
//========================================================================
//  APB0_UART_D - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07e000
// -----------------------------------------------
#define UART_D_WFIFO                               ((0x0000  << 2) + 0xfe07e000)
#define UART_D_RFIFO                               ((0x0001  << 2) + 0xfe07e000)
#define UART_D_CONTROL                             ((0x0002  << 2) + 0xfe07e000)
#define UART_D_STATUS                              ((0x0003  << 2) + 0xfe07e000)
#define UART_D_MISC                                ((0x0004  << 2) + 0xfe07e000)
#define UART_D_REG5                                ((0x0005  << 2) + 0xfe07e000)
//========================================================================
//  APB0_UART_E - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe080000
// -----------------------------------------------
#define UART_E_WFIFO                               ((0x0000  << 2) + 0xfe080000)
#define UART_E_RFIFO                               ((0x0001  << 2) + 0xfe080000)
#define UART_E_CONTROL                             ((0x0002  << 2) + 0xfe080000)
#define UART_E_STATUS                              ((0x0003  << 2) + 0xfe080000)
#define UART_E_MISC                                ((0x0004  << 2) + 0xfe080000)
#define UART_E_REG5                                ((0x0005  << 2) + 0xfe080000)
//========================================================================
//  APB0_UART_F - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe082000
// -----------------------------------------------
#define UART_F_WFIFO                               ((0x0000  << 2) + 0xfe082000)
#define UART_F_RFIFO                               ((0x0001  << 2) + 0xfe082000)
#define UART_F_CONTROL                             ((0x0002  << 2) + 0xfe082000)
#define UART_F_STATUS                              ((0x0003  << 2) + 0xfe082000)
#define UART_F_MISC                                ((0x0004  << 2) + 0xfe082000)
#define UART_F_REG5                                ((0x0005  << 2) + 0xfe082000)
//========================================================================
//  PWM_AB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058000
// -----------------------------------------------
#define PWMAB_PWM_A                                ((0x0000  << 2) + 0xfe058000)
#define PWMAB_PWM_B                                ((0x0001  << 2) + 0xfe058000)
#define PWMAB_MISC_REG_AB                          ((0x0002  << 2) + 0xfe058000)
#define PWMAB_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe058000)
#define PWMAB_TIME_AB                              ((0x0004  << 2) + 0xfe058000)
#define PWMAB_A2                                   ((0x0005  << 2) + 0xfe058000)
#define PWMAB_B2                                   ((0x0006  << 2) + 0xfe058000)
#define PWMAB_BLINK_AB                             ((0x0007  << 2) + 0xfe058000)
#define PWMAB_LOCK_AB                              ((0x0008  << 2) + 0xfe058000)
//========================================================================
//  PWM_CD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05a000
// -----------------------------------------------
#define PWMCD_PWM_A                                ((0x0000  << 2) + 0xfe05a000)
#define PWMCD_PWM_B                                ((0x0001  << 2) + 0xfe05a000)
#define PWMCD_MISC_REG_AB                          ((0x0002  << 2) + 0xfe05a000)
#define PWMCD_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe05a000)
#define PWMCD_TIME_AB                              ((0x0004  << 2) + 0xfe05a000)
#define PWMCD_A2                                   ((0x0005  << 2) + 0xfe05a000)
#define PWMCD_B2                                   ((0x0006  << 2) + 0xfe05a000)
#define PWMCD_BLINK_AB                             ((0x0007  << 2) + 0xfe05a000)
#define PWMCD_LOCK_AB                              ((0x0008  << 2) + 0xfe05a000)
//========================================================================
//  PWM_EF - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05c000
// -----------------------------------------------
#define PWMEF_PWM_A                                ((0x0000  << 2) + 0xfe05c000)
#define PWMEF_PWM_B                                ((0x0001  << 2) + 0xfe05c000)
#define PWMEF_MISC_REG_AB                          ((0x0002  << 2) + 0xfe05c000)
#define PWMEF_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe05c000)
#define PWMEF_TIME_AB                              ((0x0004  << 2) + 0xfe05c000)
#define PWMEF_A2                                   ((0x0005  << 2) + 0xfe05c000)
#define PWMEF_B2                                   ((0x0006  << 2) + 0xfe05c000)
#define PWMEF_BLINK_AB                             ((0x0007  << 2) + 0xfe05c000)
#define PWMEF_LOCK_AB                              ((0x0008  << 2) + 0xfe05c000)
//========================================================================
//  PWM_AO_AB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05e000
// -----------------------------------------------
#define PWM_AO_AB_PWM_A                            ((0x0000  << 2) + 0xfe05e000)
#define PWM_AO_AB_PWM_B                            ((0x0001  << 2) + 0xfe05e000)
#define PWM_AO_AB_MISC_REG_AB                      ((0x0002  << 2) + 0xfe05e000)
#define PWM_AO_AB_DELTA_SIGMA_AB                   ((0x0003  << 2) + 0xfe05e000)
#define PWM_AO_AB_TIME_AB                          ((0x0004  << 2) + 0xfe05e000)
#define PWM_AO_AB_A2                               ((0x0005  << 2) + 0xfe05e000)
#define PWM_AO_AB_B2                               ((0x0006  << 2) + 0xfe05e000)
#define PWM_AO_AB_BLINK_AB                         ((0x0007  << 2) + 0xfe05e000)
#define PWM_AO_AB_LOCK_AB                          ((0x0008  << 2) + 0xfe05e000)
//========================================================================
//  PWM_AO_CD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe060000
// -----------------------------------------------
#define PWM_AO_CD_PWM_A                            ((0x0000  << 2) + 0xfe060000)
#define PWM_AO_CD_PWM_B                            ((0x0001  << 2) + 0xfe060000)
#define PWM_AO_CD_MISC_REG_AB                      ((0x0002  << 2) + 0xfe060000)
#define PWM_AO_CD_DELTA_SIGMA_AB                   ((0x0003  << 2) + 0xfe060000)
#define PWM_AO_CD_TIME_AB                          ((0x0004  << 2) + 0xfe060000)
#define PWM_AO_CD_A2                               ((0x0005  << 2) + 0xfe060000)
#define PWM_AO_CD_B2                               ((0x0006  << 2) + 0xfe060000)
#define PWM_AO_CD_BLINK_AB                         ((0x0007  << 2) + 0xfe060000)
#define PWM_AO_CD_LOCK_AB                          ((0x0008  << 2) + 0xfe060000)
//========================================================================
//  PWM_AO_EF - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe030000
// -----------------------------------------------
#define PWM_AO_EF_PWM_A                            ((0x0000  << 2) + 0xfe030000)
#define PWM_AO_EF_PWM_B                            ((0x0001  << 2) + 0xfe030000)
#define PWM_AO_EF_MISC_REG_AB                      ((0x0002  << 2) + 0xfe030000)
#define PWM_AO_EF_DELTA_SIGMA_AB                   ((0x0003  << 2) + 0xfe030000)
#define PWM_AO_EF_TIME_AB                          ((0x0004  << 2) + 0xfe030000)
#define PWM_AO_EF_A2                               ((0x0005  << 2) + 0xfe030000)
#define PWM_AO_EF_B2                               ((0x0006  << 2) + 0xfe030000)
#define PWM_AO_EF_BLINK_AB                         ((0x0007  << 2) + 0xfe030000)
#define PWM_AO_EF_LOCK_AB                          ((0x0008  << 2) + 0xfe030000)
//========================================================================
//  PWM_AO_GH - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe032000
// -----------------------------------------------
#define PWM_AO_GH_PWM_A                            ((0x0000  << 2) + 0xfe032000)
#define PWM_AO_GH_PWM_B                            ((0x0001  << 2) + 0xfe032000)
#define PWM_AO_GH_MISC_REG_AB                      ((0x0002  << 2) + 0xfe032000)
#define PWM_AO_GH_DELTA_SIGMA_AB                   ((0x0003  << 2) + 0xfe032000)
#define PWM_AO_GH_TIME_AB                          ((0x0004  << 2) + 0xfe032000)
#define PWM_AO_GH_A2                               ((0x0005  << 2) + 0xfe032000)
#define PWM_AO_GH_B2                               ((0x0006  << 2) + 0xfe032000)
#define PWM_AO_GH_BLINK_AB                         ((0x0007  << 2) + 0xfe032000)
#define PWM_AO_GH_LOCK_AB                          ((0x0008  << 2) + 0xfe032000)
//========================================================================
//  SPICC_0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe050000
// -----------------------------------------------
#define SPICC0_RXDATA                              ((0x0000  << 2) + 0xfe050000)
#define SPICC0_TXDATA                              ((0x0001  << 2) + 0xfe050000)
#define SPICC0_CONREG                              ((0x0002  << 2) + 0xfe050000)
#define SPICC0_INTREG                              ((0x0003  << 2) + 0xfe050000)
#define SPICC0_DMAREG                              ((0x0004  << 2) + 0xfe050000)
#define SPICC0_STATREG                             ((0x0005  << 2) + 0xfe050000)
#define SPICC0_PERIODREG                           ((0x0006  << 2) + 0xfe050000)
#define SPICC0_TESTREG                             ((0x0007  << 2) + 0xfe050000)
#define SPICC0_DRADDR                              ((0x0008  << 2) + 0xfe050000)
#define SPICC0_DWADDR                              ((0x0009  << 2) + 0xfe050000)
#define SPICC0_LD_CNTL0                            ((0x000a  << 2) + 0xfe050000)
#define SPICC0_LD_CNTL1                            ((0x000b  << 2) + 0xfe050000)
#define SPICC0_LD_RADDR                            ((0x000c  << 2) + 0xfe050000)
#define SPICC0_LD_WADDR                            ((0x000d  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe050000)
//========================================================================
//  SPICC_1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe052000
// -----------------------------------------------
#define SPICC1_RXDATA                              ((0x0000  << 2) + 0xfe052000)
#define SPICC1_TXDATA                              ((0x0001  << 2) + 0xfe052000)
#define SPICC1_CONREG                              ((0x0002  << 2) + 0xfe052000)
#define SPICC1_INTREG                              ((0x0003  << 2) + 0xfe052000)
#define SPICC1_DMAREG                              ((0x0004  << 2) + 0xfe052000)
#define SPICC1_STATREG                             ((0x0005  << 2) + 0xfe052000)
#define SPICC1_PERIODREG                           ((0x0006  << 2) + 0xfe052000)
#define SPICC1_TESTREG                             ((0x0007  << 2) + 0xfe052000)
#define SPICC1_DRADDR                              ((0x0008  << 2) + 0xfe052000)
#define SPICC1_DWADDR                              ((0x0009  << 2) + 0xfe052000)
#define SPICC1_LD_CNTL0                            ((0x000a  << 2) + 0xfe052000)
#define SPICC1_LD_CNTL1                            ((0x000b  << 2) + 0xfe052000)
#define SPICC1_LD_RADDR                            ((0x000c  << 2) + 0xfe052000)
#define SPICC1_LD_WADDR                            ((0x000d  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe052000)
//========================================================================
//  SPICC_2
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe054000
// -----------------------------------------------
#define SPICC2_RXDATA                              ((0x0000  << 2) + 0xfe054000)
#define SPICC2_TXDATA                              ((0x0001  << 2) + 0xfe054000)
#define SPICC2_CONREG                              ((0x0002  << 2) + 0xfe054000)
#define SPICC2_INTREG                              ((0x0003  << 2) + 0xfe054000)
#define SPICC2_DMAREG                              ((0x0004  << 2) + 0xfe054000)
#define SPICC2_STATREG                             ((0x0005  << 2) + 0xfe054000)
#define SPICC2_PERIODREG                           ((0x0006  << 2) + 0xfe054000)
#define SPICC2_TESTREG                             ((0x0007  << 2) + 0xfe054000)
#define SPICC2_DRADDR                              ((0x0008  << 2) + 0xfe054000)
#define SPICC2_DWADDR                              ((0x0009  << 2) + 0xfe054000)
#define SPICC2_LD_CNTL0                            ((0x000a  << 2) + 0xfe054000)
#define SPICC2_LD_CNTL1                            ((0x000b  << 2) + 0xfe054000)
#define SPICC2_LD_RADDR                            ((0x000c  << 2) + 0xfe054000)
#define SPICC2_LD_WADDR                            ((0x000d  << 2) + 0xfe054000)
#define SPICC2_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe054000)
#define SPICC2_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe054000)
#define SPICC2_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe054000)
//========================================================================
//  SPICC_3
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04a000
// -----------------------------------------------
#define SPICC3_RXDATA                              ((0x0000  << 2) + 0xfe04a000)
#define SPICC3_TXDATA                              ((0x0001  << 2) + 0xfe04a000)
#define SPICC3_CONREG                              ((0x0002  << 2) + 0xfe04a000)
#define SPICC3_INTREG                              ((0x0003  << 2) + 0xfe04a000)
#define SPICC3_DMAREG                              ((0x0004  << 2) + 0xfe04a000)
#define SPICC3_STATREG                             ((0x0005  << 2) + 0xfe04a000)
#define SPICC3_PERIODREG                           ((0x0006  << 2) + 0xfe04a000)
#define SPICC3_TESTREG                             ((0x0007  << 2) + 0xfe04a000)
#define SPICC3_DRADDR                              ((0x0008  << 2) + 0xfe04a000)
#define SPICC3_DWADDR                              ((0x0009  << 2) + 0xfe04a000)
#define SPICC3_LD_CNTL0                            ((0x000a  << 2) + 0xfe04a000)
#define SPICC3_LD_CNTL1                            ((0x000b  << 2) + 0xfe04a000)
#define SPICC3_LD_RADDR                            ((0x000c  << 2) + 0xfe04a000)
#define SPICC3_LD_WADDR                            ((0x000d  << 2) + 0xfe04a000)
#define SPICC3_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe04a000)
#define SPICC3_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe04a000)
#define SPICC3_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe04a000)
//========================================================================
//  SPICC_4
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04c000
// -----------------------------------------------
#define SPICC4_RXDATA                              ((0x0000  << 2) + 0xfe04c000)
#define SPICC4_TXDATA                              ((0x0001  << 2) + 0xfe04c000)
#define SPICC4_CONREG                              ((0x0002  << 2) + 0xfe04c000)
#define SPICC4_INTREG                              ((0x0003  << 2) + 0xfe04c000)
#define SPICC4_DMAREG                              ((0x0004  << 2) + 0xfe04c000)
#define SPICC4_STATREG                             ((0x0005  << 2) + 0xfe04c000)
#define SPICC4_PERIODREG                           ((0x0006  << 2) + 0xfe04c000)
#define SPICC4_TESTREG                             ((0x0007  << 2) + 0xfe04c000)
#define SPICC4_DRADDR                              ((0x0008  << 2) + 0xfe04c000)
#define SPICC4_DWADDR                              ((0x0009  << 2) + 0xfe04c000)
#define SPICC4_LD_CNTL0                            ((0x000a  << 2) + 0xfe04c000)
#define SPICC4_LD_CNTL1                            ((0x000b  << 2) + 0xfe04c000)
#define SPICC4_LD_RADDR                            ((0x000c  << 2) + 0xfe04c000)
#define SPICC4_LD_WADDR                            ((0x000d  << 2) + 0xfe04c000)
#define SPICC4_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe04c000)
#define SPICC4_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe04c000)
#define SPICC4_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe04c000)
//========================================================================
//  SPICC_5
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04e000
// -----------------------------------------------
#define SPICC5_RXDATA                              ((0x0000  << 2) + 0xfe04e000)
#define SPICC5_TXDATA                              ((0x0001  << 2) + 0xfe04e000)
#define SPICC5_CONREG                              ((0x0002  << 2) + 0xfe04e000)
#define SPICC5_INTREG                              ((0x0003  << 2) + 0xfe04e000)
#define SPICC5_DMAREG                              ((0x0004  << 2) + 0xfe04e000)
#define SPICC5_STATREG                             ((0x0005  << 2) + 0xfe04e000)
#define SPICC5_PERIODREG                           ((0x0006  << 2) + 0xfe04e000)
#define SPICC5_TESTREG                             ((0x0007  << 2) + 0xfe04e000)
#define SPICC5_DRADDR                              ((0x0008  << 2) + 0xfe04e000)
#define SPICC5_DWADDR                              ((0x0009  << 2) + 0xfe04e000)
#define SPICC5_LD_CNTL0                            ((0x000a  << 2) + 0xfe04e000)
#define SPICC5_LD_CNTL1                            ((0x000b  << 2) + 0xfe04e000)
#define SPICC5_LD_RADDR                            ((0x000c  << 2) + 0xfe04e000)
#define SPICC5_LD_WADDR                            ((0x000d  << 2) + 0xfe04e000)
#define SPICC5_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe04e000)
#define SPICC5_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe04e000)
#define SPICC5_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe04e000)
//========================================================================
//  AIFIFO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe046000
// -----------------------------------------------
#define AIU_AIFIFO_CTRL                            ((0x0000  << 2) + 0xfe046000)
#define AIU_AIFIFO_STATUS                          ((0x0001  << 2) + 0xfe046000)
#define AIU_AIFIFO_GBIT                            ((0x0002  << 2) + 0xfe046000)
#define AIU_AIFIFO_CLB                             ((0x0003  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_START_PTR                   ((0x0004  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_CURR_PTR                    ((0x0005  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_END_PTR                     ((0x0006  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_BYTES_AVAIL                 ((0x0007  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_CONTROL                     ((0x0008  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_MAN_WP                      ((0x0009  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_MAN_RP                      ((0x000a  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_LEVEL                       ((0x000b  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_BUF_CNTL                    ((0x000c  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT              ((0x000d  << 2) + 0xfe046000)
#define AIU_MEM_AIFIFO_MEM_CTL                     ((0x000f  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_CNTL                     ((0x0010  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_SYNC_0                   ((0x0011  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_SYNC_1                   ((0x0012  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_0                        ((0x0013  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_1                        ((0x0014  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_2                        ((0x0015  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_3                        ((0x0016  << 2) + 0xfe046000)
#define AIFIFO_TIME_STAMP_LENGTH                   ((0x0017  << 2) + 0xfe046000)
//========================================================================
//  MSR_CLK - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe048000
// -----------------------------------------------
#define MSR_CLK_REG0                               ((0x0000  << 2) + 0xfe048000)
#define MSR_CLK_REG1                               ((0x0001  << 2) + 0xfe048000)
#define MSR_CLK_REG2                               ((0x0002  << 2) + 0xfe048000)
#define MSR_CLK_REG3                               ((0x0003  << 2) + 0xfe048000)
#define MSR_CLK_REG4                               ((0x0004  << 2) + 0xfe048000)
#define MSR_CLK_REG5                               ((0x0005  << 2) + 0xfe048000)
#define MSR_CLK_DUTY                               ((0x0006  << 2) + 0xfe048000)
//========================================================================
//  SPIFC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe056000
// -----------------------------------------------
#define SPI_FLASH_CMD                              ((0x0000  << 2) + 0xfe056000)
    // SPI_FLASH_READ    31
    // SPI_FLASH_WREN    30
    // SPI_FLASH_WRDI    29
    // SPI_FLASH_RDID    28
    // SPI_FLASH_RDSR    27
    // SPI_FLASH_WRSR    26
    // SPI_FLASH_PP      25
    // SPI_FLASH_SE      24
    // SPI_FLASH_BE      23
    // SPI_FLASH_CE      22
    // SPI_FLASH_DP      21
    // SPI_FLASH_RES     20
    // SPI_HPM           19
    // SPI_FLASH_USR     18
    // SPI_FLASH_USR_ADDR 15
    // SPI_FLASH_USR_DUMMY 14
    // SPI_FLASH_USR_DIN   13
    // SPI_FLASH_USR_DOUT   12
    // SPI_FLASH_USR_DUMMY_BLEN   10
    // SPI_FLASH_USR_CMD     0
#define SPI_FLASH_ADDR                             ((0x0001  << 2) + 0xfe056000)
    // SPI_FLASH_BYTES_LEN 24
    // SPI_FLASH_ADDR_START 0
#define SPI_FLASH_CTRL                             ((0x0002  << 2) + 0xfe056000)
    // SPI_ENABLE_AHB    17
    // SPI_SST_AAI       16
    // SPI_RES_RID       15
    // SPI_FREAD_DUAL    14
    // SPI_READ_READ_EN  13
    // SPI_CLK_DIV0      12
    // SPI_CLKCNT_N      8
    // SPI_CLKCNT_H      4
    // SPI_CLKCNT_L      0
#define SPI_FLASH_CTRL1                            ((0x0003  << 2) + 0xfe056000)
#define SPI_FLASH_STATUS                           ((0x0004  << 2) + 0xfe056000)
#define SPI_FLASH_CTRL2                            ((0x0005  << 2) + 0xfe056000)
#define SPI_FLASH_CLOCK                            ((0x0006  << 2) + 0xfe056000)
#define SPI_FLASH_USER                             ((0x0007  << 2) + 0xfe056000)
#define SPI_FLASH_USER1                            ((0x0008  << 2) + 0xfe056000)
#define SPI_FLASH_USER2                            ((0x0009  << 2) + 0xfe056000)
#define SPI_FLASH_USER3                            ((0x000a  << 2) + 0xfe056000)
#define SPI_FLASH_USER4                            ((0x000b  << 2) + 0xfe056000)
#define SPI_FLASH_SLAVE                            ((0x000c  << 2) + 0xfe056000)
#define SPI_FLASH_SLAVE1                           ((0x000d  << 2) + 0xfe056000)
#define SPI_FLASH_SLAVE2                           ((0x000e  << 2) + 0xfe056000)
#define SPI_FLASH_SLAVE3                           ((0x000f  << 2) + 0xfe056000)
#define SPI_FLASH_C0                               ((0x0010  << 2) + 0xfe056000)
#define SPI_FLASH_C1                               ((0x0011  << 2) + 0xfe056000)
#define SPI_FLASH_C2                               ((0x0012  << 2) + 0xfe056000)
#define SPI_FLASH_C3                               ((0x0013  << 2) + 0xfe056000)
#define SPI_FLASH_C4                               ((0x0014  << 2) + 0xfe056000)
#define SPI_FLASH_C5                               ((0x0015  << 2) + 0xfe056000)
#define SPI_FLASH_C6                               ((0x0016  << 2) + 0xfe056000)
#define SPI_FLASH_C7                               ((0x0017  << 2) + 0xfe056000)
#define SPI_FLASH_B8                               ((0x0018  << 2) + 0xfe056000)
#define SPI_FLASH_B9                               ((0x0019  << 2) + 0xfe056000)
#define SPI_FLASH_B10                              ((0x001a  << 2) + 0xfe056000)
#define SPI_FLASH_B11                              ((0x001b  << 2) + 0xfe056000)
#define SPI_FLASH_B12                              ((0x001c  << 2) + 0xfe056000)
#define SPI_FLASH_B13                              ((0x001d  << 2) + 0xfe056000)
#define SPI_FLASH_B14                              ((0x001e  << 2) + 0xfe056000)
#define SPI_FLASH_B15                              ((0x001f  << 2) + 0xfe056000)
//========================================================================
//  CEC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe044000
// -----------------------------------------------
#define CECA_GEN_CNTL                              ((0x0000  << 2) + 0xfe044000)
#define CECA_RW_REG                                ((0x0001  << 2) + 0xfe044000)
#define CECA_INTR_MASKN                            ((0x0002  << 2) + 0xfe044000)
#define CECA_INTR_CLR                              ((0x0003  << 2) + 0xfe044000)
#define CECA_INTR_STAT                             ((0x0004  << 2) + 0xfe044000)
#define CECB_GEN_CNTL                              ((0x0010  << 2) + 0xfe044000)
#define CECB_RW_REG                                ((0x0011  << 2) + 0xfe044000)
#define CECB_INTR_MASKN                            ((0x0012  << 2) + 0xfe044000)
#define CECB_INTR_CLR                              ((0x0013  << 2) + 0xfe044000)
#define CECB_INTR_STAT                             ((0x0014  << 2) + 0xfe044000)
//========================================================================
//  SMART CARD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe038000
// -----------------------------------------------
#define SMARTCARD_REG0                             ((0x0000  << 2) + 0xfe038000)
#define SMARTCARD_REG1                             ((0x0001  << 2) + 0xfe038000)
#define SMARTCARD_REG2                             ((0x0002  << 2) + 0xfe038000)
#define SMARTCARD_STATUS                           ((0x0003  << 2) + 0xfe038000)
#define SMARTCARD_INTR                             ((0x0004  << 2) + 0xfe038000)
#define SMARTCARD_REG5                             ((0x0005  << 2) + 0xfe038000)
#define SMARTCARD_REG6                             ((0x0006  << 2) + 0xfe038000)
#define SMARTCARD_FIFO                             ((0x0007  << 2) + 0xfe038000)
#define SMARTCARD_REG8                             ((0x0008  << 2) + 0xfe038000)
//========================================================================
//  CAPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe012000
// -----------------------------------------------
#define CAPU_ACCESS_EN_AHB_NIC5                    ((0x00cc  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_NIC4                    ((0x00cb  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_NIC3                    ((0x00ca  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_NIC2                    ((0x00c9  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_NIC1                    ((0x00c8  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_ETH                     ((0x00c2  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_USB0                    ((0x00c1  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_USB1                    ((0x00c0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_16M_SLOT1                   ((0x00b1  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_16M_SLOT0                   ((0x00b0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_1M_SLOT0                    ((0x00a8  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_256K_SLOT1                  ((0x00a1  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_256K_SLOT0                  ((0x00a0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOTB                   ((0x008b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOTA                   ((0x008a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT9                   ((0x0089  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT8                   ((0x0088  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT7                   ((0x0087  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT6                   ((0x0086  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT5                   ((0x0085  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT4                   ((0x0084  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT3                   ((0x0083  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT2                   ((0x0082  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT1                   ((0x0081  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT0                   ((0x0080  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5F                   ((0x005f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5E                   ((0x005e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5D                   ((0x005d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5C                   ((0x005c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5B                   ((0x005b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT5A                   ((0x005a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT59                   ((0x0059  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT58                   ((0x0058  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT57                   ((0x0057  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT56                   ((0x0056  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT55                   ((0x0055  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT54                   ((0x0054  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT53                   ((0x0053  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT52                   ((0x0052  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT51                   ((0x0051  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT50                   ((0x0050  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4F                   ((0x004f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4E                   ((0x004e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4D                   ((0x004d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4C                   ((0x004c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4B                   ((0x004b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4A                   ((0x004a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT49                   ((0x0049  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT48                   ((0x0048  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT47                   ((0x0047  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT46                   ((0x0046  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT45                   ((0x0045  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT44                   ((0x0044  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT43                   ((0x0043  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT42                   ((0x0042  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT41                   ((0x0041  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT40                   ((0x0040  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3F                   ((0x003f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3E                   ((0x003e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3D                   ((0x003d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3C                   ((0x003c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3B                   ((0x003b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3A                   ((0x003a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT39                   ((0x0039  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT38                   ((0x0038  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT37                   ((0x0037  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT36                   ((0x0036  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT35                   ((0x0035  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT34                   ((0x0034  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT33                   ((0x0033  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT32                   ((0x0032  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT31                   ((0x0031  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT30                   ((0x0030  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2F                   ((0x002f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2E                   ((0x002e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2D                   ((0x002d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2C                   ((0x002c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2B                   ((0x002b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2A                   ((0x002a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT29                   ((0x0029  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT28                   ((0x0028  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT27                   ((0x0027  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT26                   ((0x0026  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT25                   ((0x0025  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT24                   ((0x0024  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT23                   ((0x0023  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT22                   ((0x0022  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT21                   ((0x0021  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT20                   ((0x0020  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1F                   ((0x001f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1E                   ((0x001e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1D                   ((0x001d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1C                   ((0x001c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1B                   ((0x001b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1A                   ((0x001a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT19                   ((0x0019  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT18                   ((0x0018  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT17                   ((0x0017  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT16                   ((0x0016  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT15                   ((0x0015  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT14                   ((0x0014  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT13                   ((0x0013  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT12                   ((0x0012  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT11                   ((0x0011  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT10                   ((0x0010  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0F                   ((0x000f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0E                   ((0x000e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0D                   ((0x000d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0C                   ((0x000c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0B                   ((0x000b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0A                   ((0x000a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT09                   ((0x0009  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT08                   ((0x0008  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT07                   ((0x0007  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT06                   ((0x0006  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT05                   ((0x0005  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT04                   ((0x0004  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT03                   ((0x0003  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT02                   ((0x0002  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT01                   ((0x0001  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT00                   ((0x0000  << 2) + 0xfe012000)
//========================================================================
//  HDMI20_AES
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01e000
// -----------------------------------------------
// RW [   31] freeclk_en: 0=Gated clocks; 1=free-run clocks. Default 0.
// RW [    3] htx_sel: 0=Program for RX keys; 1=Program for TX keys. Default 0.
// RW [ 2: 1] endian. Default 0.
// WO [    0] start: write 1 to reset internal counters. Read back 0.
#define HDMI20_AES_CNTL0                           ((0x0000  << 2) + 0xfe01e000)
// RW [31: 0] encrypted HDCP data, 4-byte each, endian optional. Default 0.
#define HDMI20_AES_DATA                            ((0x0001  << 2) + 0xfe01e000)
// RO [26:16] nxt_otp_addr for either TX or RX
// RO [   12] secure_access
// RO [   11] aes_out128b_vld
// RO [   10] aes_din128b_vld
// RO [    9] aes_rdy
// RO [    8] aes_key_vld
// RO [    5] hrx_aes_rdy: 1=16-byte data are programmed into RX
// RO [    4] 1=RX aes_key is ready
// RO [    1] htx_aes_rdy: 1=16-byte data are programmed into TX
// RO [    0] 1=TX aes_key is ready
#define HDMI20_AES_STAT0                           ((0x0002  << 2) + 0xfe01e000)
// RW [    0] sw_reset. 0=No reset; 1=Reset. Default 0.
#define HDMI20_AES_RESET                           ((0x0003  << 2) + 0xfe01e000)
//========================================================================
//  HDMIRX_PHY
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe39c000
// -----------------------------------------------
#define HDMIRX_APLL_CNTL0                          ((0x0000  << 2) + 0xfe39c000)
#define HDMIRX_APLL_CNTL1                          ((0x0001  << 2) + 0xfe39c000)
#define HDMIRX_APLL_CNTL2                          ((0x0002  << 2) + 0xfe39c000)
#define HDMIRX_APLL_CNTL3                          ((0x0003  << 2) + 0xfe39c000)
#define HDMIRX_APLL_CNTL4                          ((0x0004  << 2) + 0xfe39c000)
#define HDMIRX_PHY_MISC0                           ((0x0005  << 2) + 0xfe39c000)
#define HDMIRX_PHY_MISC1                           ((0x0006  << 2) + 0xfe39c000)
#define HDMIRX_PHY_MISC2                           ((0x0007  << 2) + 0xfe39c000)
#define HDMIRX_PHY_MISC3                           ((0x0008  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHA_CNTL0                      ((0x0009  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHA_CNTL1                      ((0x000a  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHA_CNTL2                      ((0x000b  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHA_CNTL3                      ((0x000c  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_CNTL0                      ((0x000d  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_CNTL1                      ((0x000e  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_CNTL2                      ((0x000f  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_CNTL3                      ((0x0010  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_CNTL4                      ((0x0011  << 2) + 0xfe39c000)
#define HDMIRX_PHY_MISC_STAT                       ((0x0012  << 2) + 0xfe39c000)
#define HDMIRX_PHY_DCHD_STAT                       ((0x0013  << 2) + 0xfe39c000)
#define HDMIRX_AUD_PLL_CNTL                        ((0x0020  << 2) + 0xfe39c000)
#define HDMIRX_AUD_PLL_CNTL2                       ((0x0021  << 2) + 0xfe39c000)
#define HDMIRX_AUD_PLL_CNTL3                       ((0x0022  << 2) + 0xfe39c000)
#define HDMIRX_AUD_PLL_CNTL_I                      ((0x0023  << 2) + 0xfe39c000)
#define HDMIRX_AUD_PLL4X_CNTL                      ((0x0024  << 2) + 0xfe39c000)
#define HDMIRX_PHY_PROD_TEST0                      ((0x0030  << 2) + 0xfe39c000)
#define HDMIRX_PHY_PROD_TEST1                      ((0x0031  << 2) + 0xfe39c000)
#define HDMIRX_EARCTX_CNTL0                        ((0x0040  << 2) + 0xfe39c000)
#define HDMIRX_EARCTX_CNTL1                        ((0x0041  << 2) + 0xfe39c000)
#define HDMIRX_ARC_CNTL                            ((0x0042  << 2) + 0xfe39c000)
//========================================================================
//  COMBO_DPHY DSI_LVDS_EDP_VX1
//========================================================================
//
// Reading file:  ./combo_dphy_regs.h
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe018000
// -----------------------------------------------
#define COMBO_DPHY_CNTL0                           ((0x0000  << 2) + 0xfe018000)
//Bit 31:7        reserved
//Bit 6           reg_phy2_pll_sel                            // unsigned ,  RW, default = 0
//Bit 5           reg_phy1_pll_sel                            // unsigned ,  RW, default = 0
//Bit 4           reg_phy2_din_sel_lvds                       // unsigned ,  RW, default = 0
//Bit 3           reg_phy1_din_sel_edp                        // unsigned ,  RW, default = 0
//Bit 2           reg_phy1_din_sel_lvds_vx1                   // unsigned ,  RW, default = 0
//Bit 1           reg_phy0_din_sel_edp                        // unsigned ,  RW, default = 0
//Bit 0           reg_phy0_din_sel_lvds_vx1                   // unsigned ,  RW, default = 0
#define COMBO_DPHY_CNTL1                           ((0x0001  << 2) + 0xfe018000)
//Bit 31:30       reg_lane15_sel                              // unsigned ,  RW, default = 0
//Bit 29:28       reg_lane14_sel                              // unsigned ,  RW, default = 0
//Bit 27:26       reg_lane13_sel                              // unsigned ,  RW, default = 0
//Bit 25:24       reg_lane12_sel                              // unsigned ,  RW, default = 0
//Bit 23:22       reg_lane11_sel                              // unsigned ,  RW, default = 0
//Bit 21:20       reg_lane10_sel                              // unsigned ,  RW, default = 0
//Bit 19:18       reg_lane9_sel                               // unsigned ,  RW, default = 0
//Bit 17:16       reg_lane8_sel                               // unsigned ,  RW, default = 0
//Bit 15:14       reg_lane7_sel                               // unsigned ,  RW, default = 0
//Bit 13:12       reg_lane6_sel                               // unsigned ,  RW, default = 0
//Bit 11:10       reg_lane5_sel                               // unsigned ,  RW, default = 0
//Bit 9:8         reg_lane4_sel                               // unsigned ,  RW, default = 0
//Bit 7:6         reg_lane3_sel                               // unsigned ,  RW, default = 0
//Bit 5:4         reg_lane2_sel                               // unsigned ,  RW, default = 0
//Bit 3:2         reg_lane1_sel                               // unsigned ,  RW, default = 0
//Bit 1:0         reg_lane0_sel                               // unsigned ,  RW, default = 0
#define COMBO_DPHY_VID_PLL0_DIV                    ((0x0002  << 2) + 0xfe018000)
//Bit 31:24       reserved
//Bit 23:0        reg_hi_vid_pll0_clk_div                     // unsigned ,  RW, default = 0
//Bit 19          clk_final_en                                //final stage enable
//Bit 18          clk_div1                                    //bypass
//Bit 17:16       clk_sel                                     //2'b0: select div12, 2'b1:select div14, 2'b10:select div15, 2'b11:select div25
//Bit 15          set_preset                                  //load the clk pattern in shift registers
//Bit 14:0        shift_preset                                //clk pattern in shifter registers
#define COMBO_DPHY_VID_PLL1_DIV                    ((0x0003  << 2) + 0xfe018000)
//Bit 31:24       reserved
//Bit 23:0        reg_hi_vid_pll1_clk_div                     // unsigned ,  RW, default = 0
//Bit 19          clk_final_en                                //final stage enable
//Bit 18          clk_div1                                    //bypass
//Bit 17:16       clk_sel                                     //2'b0: select div12, 2'b1:select div14, 2'b10:select div15, 2'b11:select div25
//Bit 15          set_preset                                  //load the clk pattern in shift registers
//Bit 14:0        shift_preset                                //clk pattern in shifter registers
#define COMBO_DPHY_VID_PLL2_DIV                    ((0x0004  << 2) + 0xfe018000)
//Bit 31:24       reserved
//Bit 23:0        reg_hi_vid_pll2_clk_div                     // unsigned ,  RW, default = 0
//Bit 19          clk_final_en                                //final stage enable
//Bit 18          clk_div1                                    //bypass
//Bit 17:16       clk_sel                                     //2'b0: select div12, 2'b1:select div14, 2'b10:select div15, 2'b11:select div25
//Bit 15          set_preset                                  //load the clk pattern in shift registers
//Bit 14:0        shift_preset                                //clk pattern in shifter registers
#define COMBO_DPHY_EDP_PIXEL_CLK_DIV               ((0x0005  << 2) + 0xfe018000)
//Bit 31:27       reserved
//Bit 26          reg_edp2_div_clk_en                         // unsigned ,  RW, default = 0  , useless
//Bit 25          reg_edp1_div_clk_en                         // unsigned ,  RW, default = 0
//Bit 24          reg_edp0_div_clk_en                         // unsigned ,  RW, default = 0
//Bit 23:0        reg_hi_edp_pixel_clk_div                    // unsigned ,  RW, default = 0
//Bit 15:12       edp1_clk_div_clk1_sel
//Bit 11:8        edp1_clk_div_clk0_sel
//Bit 7:4         edp0_clk_div_clk1_sel
//Bit 3:0         edp0_clk_div_clk0_sel
#define COMBO_DPHY_EDP_LVDS_TX_PHY0_CNTL0          ((0x0006  << 2) + 0xfe018000)
//Bit 31:0        reg_hi_edp_lvds_tx_phy0_cntl0               // unsigned ,  RW, default = 0
//Bit 23:16       cntl_ser_en                                 // ff: enable all 8 channel. 01: enable channel 0.
//Bit 13          cntl_prbs_en                                // 1: enable prbs
//Bit 12          cntl_prbs_err_en
//Bit 11:10       cntl_mode_set_high                          // force channel output high
//Bit 9:8         cntl_mode_set_low                           // force channel output low
//Bit 7:5         fifo_clk_sel                                // 0: div6, 1: div7, 2: div8, 3: div10, else: div20
//Bit 3           mode_bit_rev                                // swap lanes from 01234567 to 76543210
//Bit 2           mode_inv_p_n                                // invert all lane PN
//Bit 0           soft_reset                                  // soft reset PHY
#define COMBO_DPHY_EDP_LVDS_TX_PHY1_CNTL0          ((0x0007  << 2) + 0xfe018000)
//Bit 31:0        reg_hi_edp_lvds_tx_phy1_cntl0               // unsigned ,  RW, default = 0
//Bit 23:16       cntl_ser_en                                 // ff: enable all 8 channel. 01: enable channel 0.
//Bit 13          cntl_prbs_en                                // 1: enable prbs
//Bit 12          cntl_prbs_err_en
//Bit 11:10       cntl_mode_set_high                          // force channel output high
//Bit 9:8         cntl_mode_set_low                           // force channel output low
//Bit 7:5         fifo_clk_sel                                // 0: div6, 1: div7, 2: div8, 3: div10, else: div20
//Bit 3           mode_bit_rev                                // swap lanes from 01234567 to 76543210
//Bit 2           mode_inv_p_n                                // invert all lane PN
//Bit 0           soft_reset                                  // soft reset PHY
#define COMBO_DPHY_EDP_LVDS_TX_PHY2_CNTL0          ((0x0008  << 2) + 0xfe018000)
//Bit 31:0        reg_hi_edp_lvds_tx_phy2_cntl0               // unsigned ,  RW, default = 0
//Bit 25:16       cntl_ser_en                                 // ff: enable all 10 channel. 01: enable channel 0.
//Bit 13          cntl_prbs_en                                // 1: enable prbs
//Bit 12          cntl_prbs_err_en
//Bit 11:10       cntl_mode_set_high                          // force channel output high
//Bit 9:8         cntl_mode_set_low                           // force channel output low
//Bit 7:5         fifo_clk_sel                                // 0: div6, 1: div7, 2: div8, 3: div10, else: div20
//Bit 3           mode_bit_rev                                // swap lanes from 01234567 to 76543210
//Bit 2           mode_inv_p_n                                // invert all lane PN
//Bit 0           soft_reset                                  // soft reset PHY
#define COMBO_DPHY_EDP_LVDS_TX_PHY0_CNTL1          ((0x0009  << 2) + 0xfe018000)
//Bit 31:8        reserved
//Bit 7:0         reg_hi_edp_lvds_tx_phy0_cntl1               // unsigned ,  RW, default = 0
//Bit 7           wr_enable                                   // start to write de-couple fifo
//Bit 6           fifo_enable                                 // De-couple FIFO enable
//Bit 5           sel_hdmi_clk                                // select vid_pll_div_clk_out source from cts_hdmi_pll_clk
//Bit 4           sel_edp_clk                                 // select vid_pll_div_clk_out source from edptx_pixel_clk
//Bit [3:1]       reserved
//Bit 0           phy_pll_clk_in_en                           // Enable phy_pll_clk input
#define COMBO_DPHY_EDP_LVDS_TX_PHY1_CNTL1          ((0x000a  << 2) + 0xfe018000)
//Bit 31:8        reserved
//Bit 7:0         reg_hi_edp_lvds_tx_phy1_cntl1               // unsigned ,  RW, default = 0
//Bit 7           wr_enable                                   // start to write de-couple fifo
//Bit 6           fifo_enable                                 // De-couple FIFO enable
//Bit 5           sel_hdmi_clk                                // select vid_pll_div_clk_out source from cts_hdmi_pll_clk
//Bit 4           sel_edp_clk                                 // select vid_pll_div_clk_out source from edptx_pixel_clk
//Bit [3:1]       reserved
//Bit 0           phy_pll_clk_in_en                           // Enable phy_pll_clk input
#define COMBO_DPHY_EDP_LVDS_TX_PHY2_CNTL1          ((0x000b  << 2) + 0xfe018000)
//Bit 31:8        reserved
//Bit 7:0         reg_hi_edp_lvds_tx_phy2_cntl1               // unsigned ,  RW, default = 0
//Bit 7           wr_enable                                   // start to write de-couple fifo
//Bit 6           fifo_enable                                 // De-couple FIFO enable
//Bit 5           sel_hdmi_clk                                // select vid_pll_div_clk_out source from cts_hdmi_pll_clk
//Bit 4           sel_edp_clk                                 // select vid_pll_div_clk_out source from edptx_pixel_clk
#define COMBO_DPHY_RO_EDP_LVDS_TX_PHY0_CNTL1       ((0x0010  << 2) + 0xfe018000)
//Bit 31:16       reserved
//Bit 15:0        ro_hi_edp_lvds_tx_phy0_cntl1_o          // unsigned ,  RO, default = 0
#define COMBO_DPHY_RO_EDP_LVDS_TX_PHY1_CNTL1       ((0x0011  << 2) + 0xfe018000)
//Bit 31:20       reserved
//Bit 15:0        ro_hi_edp_lvds_tx_phy1_cntl1_o          // unsigned ,  RO, default = 0
#define COMBO_DPHY_RO_EDP_LVDS_TX_PHY2_CNTL1       ((0x0012  << 2) + 0xfe018000)
//Bit 31:16       reserved
//Bit 19:0        ro_hi_edp_lvds_tx_phy2_cntl1_o          // unsigned ,  RO, default = 0
#define COMBO_DPHY_PROD_TEST0                      ((0x0013  << 2) + 0xfe018000)
//Bit 31:0        reg_int_prod_test0                       // unsigned ,  RW, default = 0
#define COMBO_DPHY_PROD_TEST1                      ((0x0014  << 2) + 0xfe018000)
//Bit 31:0        reg_int_prod_test1                       // unsigned ,  RW, default = 0
#define COMBO_DPHY_PROD_TEST2                      ((0x0015  << 2) + 0xfe018000)
//Bit 20:0        reg_int_prod_test2                       // unsigned ,  RW, default = 0
#define COMBO_DPHY_RO_PROD_TEST                    ((0x0016  << 2) + 0xfe018000)
//Bit 31:10       reserved
//Bit 9:0        ro_prod_sig                              // unsigned ,  RO, default = 0
//
// Closing file:  ./combo_dphy_regs.h
//
//========================================================================
//  PDM
//========================================================================
//`include "../audio/rtl/pdm_reg.vh"
//
// Reading file:  ./REG_LIST_AUDIO_RTL.h
//
//========================================================================
//  AUDIO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe330000
// -----------------------------------------------
#define EE_AUDIO_CLK_GATE_EN0                      ((0x0000  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_GATE_EN1                      ((0x0001  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_A_CTRL                       ((0x0002  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_B_CTRL                       ((0x0003  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_C_CTRL                       ((0x0004  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_D_CTRL                       ((0x0005  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_E_CTRL                       ((0x0006  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_F_CTRL                       ((0x0007  << 2) + 0xfe330000)
#define EE_AUDIO_SW_RESET0                         ((0x000a  << 2) + 0xfe330000)
#define EE_AUDIO_SW_RESET1                         ((0x000b  << 2) + 0xfe330000)
#define EE_AUDIO_CLK81_CTRL                        ((0x000c  << 2) + 0xfe330000)
#define EE_AUDIO_CLK81_EN                          ((0x000d  << 2) + 0xfe330000)
#define EE_AUDIO_MST_A_SCLK_CTRL0                  ((0x0010  << 2) + 0xfe330000)
#define EE_AUDIO_MST_A_SCLK_CTRL1                  ((0x0011  << 2) + 0xfe330000)
#define EE_AUDIO_MST_B_SCLK_CTRL0                  ((0x0012  << 2) + 0xfe330000)
#define EE_AUDIO_MST_B_SCLK_CTRL1                  ((0x0013  << 2) + 0xfe330000)
#define EE_AUDIO_MST_C_SCLK_CTRL0                  ((0x0014  << 2) + 0xfe330000)
#define EE_AUDIO_MST_C_SCLK_CTRL1                  ((0x0015  << 2) + 0xfe330000)
#define EE_AUDIO_MST_D_SCLK_CTRL0                  ((0x0016  << 2) + 0xfe330000)
#define EE_AUDIO_MST_D_SCLK_CTRL1                  ((0x0017  << 2) + 0xfe330000)
#define EE_AUDIO_MST_E_SCLK_CTRL0                  ((0x0018  << 2) + 0xfe330000)
#define EE_AUDIO_MST_E_SCLK_CTRL1                  ((0x0019  << 2) + 0xfe330000)
#define EE_AUDIO_MST_F_SCLK_CTRL0                  ((0x001a  << 2) + 0xfe330000)
#define EE_AUDIO_MST_F_SCLK_CTRL1                  ((0x001b  << 2) + 0xfe330000)
#define EE_AUDIO_MST_DLY_CTRL0                     ((0x001c  << 2) + 0xfe330000)
#define EE_AUDIO_MST_DLY_CTRL1                     ((0x001d  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_A_CTRL                  ((0x0020  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_B_CTRL                  ((0x0021  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_C_CTRL                  ((0x0022  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_LB_CTRL                 ((0x0023  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_A_CTRL                 ((0x0024  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_B_CTRL                 ((0x0025  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_C_CTRL                 ((0x0026  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFIN_CTRL                  ((0x0027  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFOUT_CTRL                 ((0x0028  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_RESAMPLEA_CTRL                ((0x0029  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_LOCKER_CTRL                   ((0x002a  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL0                   ((0x002b  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL1                   ((0x002c  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFOUT_B_CTRL               ((0x002d  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_RESAMPLEB_CTRL                ((0x002e  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFIN_LB_CTRL               ((0x002f  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_EQDRC_CTRL0                   ((0x0030  << 2) + 0xfe330000)
#define EE_AUDIO_VAD_CLK_CTRL                      ((0x0031  << 2) + 0xfe330000)
#define EE_AUDIO_EARCTX_CMDC_CLK_CTRL              ((0x0032  << 2) + 0xfe330000)
#define EE_AUDIO_EARCTX_DMAC_CLK_CTRL              ((0x0033  << 2) + 0xfe330000)
#define EE_AUDIO_EARCRX_CMDC_CLK_CTRL              ((0x0034  << 2) + 0xfe330000)
#define EE_AUDIO_EARCRX_DMAC_CLK_CTRL              ((0x0035  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_LOCKERB_CTRL                  ((0x0036  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL0                     ((0x0040  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL1                     ((0x0041  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_START_ADDR                ((0x0042  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_FINISH_ADDR               ((0x0043  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_INT_ADDR                  ((0x0044  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_STATUS1                   ((0x0045  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_STATUS2                   ((0x0046  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_START_ADDRB               ((0x0047  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_FINISH_ADDRB              ((0x0048  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_INIT_ADDR                 ((0x0049  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL2                     ((0x004a  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL0                     ((0x0050  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL1                     ((0x0051  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_START_ADDR                ((0x0052  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_FINISH_ADDR               ((0x0053  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_INT_ADDR                  ((0x0054  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_STATUS1                   ((0x0055  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_STATUS2                   ((0x0056  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_START_ADDRB               ((0x0057  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_FINISH_ADDRB              ((0x0058  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_INIT_ADDR                 ((0x0059  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL2                     ((0x005a  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL0                     ((0x0060  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL1                     ((0x0061  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_START_ADDR                ((0x0062  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_FINISH_ADDR               ((0x0063  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_INT_ADDR                  ((0x0064  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_STATUS1                   ((0x0065  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_STATUS2                   ((0x0066  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_START_ADDRB               ((0x0067  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_FINISH_ADDRB              ((0x0068  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_INIT_ADDR                 ((0x0069  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL2                     ((0x006a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL0                     ((0x0070  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL1                     ((0x0071  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_START_ADDR                ((0x0072  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_FINISH_ADDR               ((0x0073  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_INT_ADDR                  ((0x0074  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_STATUS1                   ((0x0075  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_STATUS2                   ((0x0076  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_START_ADDRB               ((0x0077  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_FINISH_ADDRB              ((0x0078  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_INIT_ADDR                 ((0x0079  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL2                     ((0x007a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL0                     ((0x0080  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL1                     ((0x0081  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_START_ADDR                ((0x0082  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_FINISH_ADDR               ((0x0083  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_INT_ADDR                  ((0x0084  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_STATUS1                   ((0x0085  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_STATUS2                   ((0x0086  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_START_ADDRB               ((0x0087  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_FINISH_ADDRB              ((0x0088  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_INIT_ADDR                 ((0x0089  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL2                     ((0x008a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL0                     ((0x0090  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL1                     ((0x0091  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_START_ADDR                ((0x0092  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_FINISH_ADDR               ((0x0093  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_INT_ADDR                  ((0x0094  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_STATUS1                   ((0x0095  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_STATUS2                   ((0x0096  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_START_ADDRB               ((0x0097  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_FINISH_ADDRB              ((0x0098  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_INIT_ADDR                 ((0x0099  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL2                     ((0x009a  << 2) + 0xfe330000)
#define EE_AUDIO_ARB_CTRL0                         ((0x00a0  << 2) + 0xfe330000)
#define EE_AUDIO_ARB_CTRL1                         ((0x00a1  << 2) + 0xfe330000)
#define EE_AUDIO_ARB_STS                           ((0x00a8  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL0                        ((0x00b0  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL1                        ((0x00b1  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL2                        ((0x00b2  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL3                        ((0x00b3  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID0                   ((0x00b4  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID1                   ((0x00b5  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID2                   ((0x00b6  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID3                   ((0x00b7  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID0                    ((0x00b8  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID1                    ((0x00b9  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID2                    ((0x00ba  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID3                    ((0x00bb  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_STS                          ((0x00bc  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CHSYNC_CTRL_INSERT           ((0x00bd  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CHSYNC_CTRL_ORIG             ((0x00be  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL4                        ((0x00bf  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_CTRL                      ((0x00c0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_SWAP0                     ((0x00c1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK0                     ((0x00c2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK1                     ((0x00c3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK2                     ((0x00c4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK3                     ((0x00c5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_STAT                      ((0x00c6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE_VAL                  ((0x00c7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE0                     ((0x00c8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE1                     ((0x00c9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE2                     ((0x00ca  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE3                     ((0x00cb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_CTRL                      ((0x00d0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_SWAP0                     ((0x00d1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK0                     ((0x00d2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK1                     ((0x00d3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK2                     ((0x00d4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK3                     ((0x00d5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_STAT                      ((0x00d6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE_VAL                  ((0x00d7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE0                     ((0x00d8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE1                     ((0x00d9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE2                     ((0x00da  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE3                     ((0x00db  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_CTRL                      ((0x00e0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_SWAP0                     ((0x00e1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK0                     ((0x00e2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK1                     ((0x00e3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK2                     ((0x00e4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK3                     ((0x00e5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_STAT                      ((0x00e6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE_VAL                  ((0x00e7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE0                     ((0x00e8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE1                     ((0x00e9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE2                     ((0x00ea  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE3                     ((0x00eb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_CTRL                     ((0x00f0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_SWAP0                    ((0x00f1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK0                    ((0x00f2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK1                    ((0x00f3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK2                    ((0x00f4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK3                    ((0x00f5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_STAT                     ((0x00f6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE_VAL                 ((0x00f7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE0                    ((0x00f8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE1                    ((0x00f9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE2                    ((0x00fa  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE3                    ((0x00fb  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL0                     ((0x0100  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL1                     ((0x0101  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL2                     ((0x0102  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL3                     ((0x0103  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL4                     ((0x0104  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL5                     ((0x0105  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL6                     ((0x0106  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT0                     ((0x0107  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT1                     ((0x0108  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT2                     ((0x0109  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_MUTE_VAL                  ((0x010a  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL7                     ((0x010b  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL0                   ((0x0110  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL1                   ((0x0111  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL2                   ((0x0112  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL3                   ((0x0113  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF0                   ((0x0114  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF1                   ((0x0115  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF2                   ((0x0116  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF3                   ((0x0117  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF4                   ((0x0118  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_STATUS1                 ((0x0119  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_STAT                     ((0x0120  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN0                    ((0x0121  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN1                    ((0x0122  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CTRL0                    ((0x0123  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CTRL1                    ((0x0124  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_PREAMB                   ((0x0125  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_SWAP                     ((0x0126  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS0                   ((0x0127  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS1                   ((0x0128  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS2                   ((0x0129  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS3                   ((0x012a  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS4                   ((0x012b  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS5                   ((0x012c  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS6                   ((0x012d  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS7                   ((0x012e  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS8                   ((0x012f  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS9                   ((0x0130  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTSA                   ((0x0131  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTSB                   ((0x0132  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_MUTE_VAL                 ((0x0133  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN2                    ((0x0134  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN3                    ((0x0135  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN_EN                  ((0x0136  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN_CTRL                ((0x0137  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL0                    ((0x0140  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL1                    ((0x0141  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_SWAP0                    ((0x0142  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK0                    ((0x0143  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK1                    ((0x0144  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK2                    ((0x0145  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK3                    ((0x0146  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_STAT                     ((0x0147  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN0                    ((0x0148  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN1                    ((0x0149  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE_VAL                 ((0x014a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE0                    ((0x014b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE1                    ((0x014c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE2                    ((0x014d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE3                    ((0x014e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK_VAL                 ((0x014f  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL0                    ((0x0150  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL1                    ((0x0151  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_SWAP0                    ((0x0152  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK0                    ((0x0153  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK1                    ((0x0154  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK2                    ((0x0155  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK3                    ((0x0156  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_STAT                     ((0x0157  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN0                    ((0x0158  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN1                    ((0x0159  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE_VAL                 ((0x015a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE0                    ((0x015b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE1                    ((0x015c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE2                    ((0x015d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE3                    ((0x015e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK_VAL                 ((0x015f  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL0                    ((0x0160  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL1                    ((0x0161  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_SWAP0                    ((0x0162  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK0                    ((0x0163  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK1                    ((0x0164  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK2                    ((0x0165  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK3                    ((0x0166  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_STAT                     ((0x0167  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN0                    ((0x0168  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN1                    ((0x0169  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE_VAL                 ((0x016a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE0                    ((0x016b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE1                    ((0x016c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE2                    ((0x016d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE3                    ((0x016e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK_VAL                 ((0x016f  << 2) + 0xfe330000)
//`define EE_AUDIO_POW_DET_CTRL0          10'h180
//`define EE_AUDIO_POW_DET_CTRL1          10'h181
//`define EE_AUDIO_POW_DET_TH_HI          10'h182
//`define EE_AUDIO_POW_DET_TH_LO          10'h183
//`define EE_AUDIO_POW_DET_VALUE          10'h184
#define EE_AUDIO_SECURITY_CTRL0                    ((0x0190  << 2) + 0xfe330000)
#define EE_AUDIO_SECURITY_CTRL1                    ((0x0191  << 2) + 0xfe330000)
#define EE_AUDIO_SECURITY_CTRL2                    ((0x0192  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_STAT                   ((0x01a0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN0                  ((0x01a1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN1                  ((0x01a2  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CTRL0                  ((0x01a3  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CTRL1                  ((0x01a4  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_PREAMB                 ((0x01a5  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_SWAP                   ((0x01a6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS0                 ((0x01a7  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS1                 ((0x01a8  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS2                 ((0x01a9  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS3                 ((0x01aa  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS4                 ((0x01ab  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS5                 ((0x01ac  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS6                 ((0x01ad  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS7                 ((0x01ae  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS8                 ((0x01af  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS9                 ((0x01b0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTSA                 ((0x01b1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTSB                 ((0x01b2  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_MUTE_VAL               ((0x01b3  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN2                  ((0x01b4  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN3                  ((0x01b5  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN_EN                ((0x01b6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN_CTRL              ((0x01b7  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_CTRL0                       ((0x01c0  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_CTRL1                       ((0x01c1  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_START_ADDR                  ((0x01c2  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_FINISH_ADDR                 ((0x01c3  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_INT_ADDR                    ((0x01c4  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_STATUS1                     ((0x01c5  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_STATUS2                     ((0x01c6  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_INIT_ADDR                   ((0x01c7  << 2) + 0xfe330000)
#define EE_AUDIO_TOACODEC_CTRL0                    ((0x01d0  << 2) + 0xfe330000)
#define EE_AUDIO_TOHDMITX_CTRL0                    ((0x01d1  << 2) + 0xfe330000)
#define EE_AUDIO_TOVAD_CTRL0                       ((0x01d2  << 2) + 0xfe330000)
#define EE_AUDIO_FRATV_CTRL0                       ((0x01d3  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL0                   ((0x01e0  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL1                   ((0x01e1  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL2                   ((0x01e2  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL3                   ((0x01e3  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF0                   ((0x01e4  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF1                   ((0x01e5  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF2                   ((0x01e6  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF3                   ((0x01e7  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF4                   ((0x01e8  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_STATUS1                 ((0x01e9  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL0                  ((0x01f0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL1                  ((0x01f1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL6                  ((0x01f6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_STAT0                  ((0x01f7  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_STAT1                  ((0x01f8  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_MUTE_VAL               ((0x01fa  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL0                    ((0x0200  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL1                    ((0x0201  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL2                    ((0x0202  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL3                    ((0x0203  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL4                    ((0x0204  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL5                    ((0x0205  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL6                    ((0x0206  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL7                    ((0x0207  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT0                    ((0x020a  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT1                    ((0x020b  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT2                    ((0x020c  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL0                     ((0x0210  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL1                     ((0x0211  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_START_ADDR                ((0x0212  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_FINISH_ADDR               ((0x0213  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_INT_ADDR                  ((0x0214  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_STATUS1                   ((0x0215  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_STATUS2                   ((0x0216  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_START_ADDRB               ((0x0217  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_FINISH_ADDRB              ((0x0218  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_INIT_ADDR                 ((0x0219  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL2                     ((0x021a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL0                     ((0x0220  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL1                     ((0x0221  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_START_ADDR                ((0x0222  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_FINISH_ADDR               ((0x0223  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_INT_ADDR                  ((0x0224  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_STATUS1                   ((0x0225  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_STATUS2                   ((0x0226  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_START_ADDRB               ((0x0227  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_FINISH_ADDRB              ((0x0228  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_INIT_ADDR                 ((0x0229  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL2                     ((0x022a  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL0                        ((0x0230  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL1                        ((0x0231  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL2                        ((0x0232  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL3                        ((0x0233  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID0                   ((0x0234  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID1                   ((0x0235  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID2                   ((0x0236  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID3                   ((0x0237  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID0                    ((0x0238  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID1                    ((0x0239  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID2                    ((0x023a  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID3                    ((0x023b  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_STS                          ((0x023c  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CHSYNC_CTRL_INSERT           ((0x023d  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CHSYNC_CTRL_ORIG             ((0x023e  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL4                        ((0x023f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL0                     ((0x0240  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL1                     ((0x0241  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_START_ADDR                ((0x0242  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_FINISH_ADDR               ((0x0243  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_INT_ADDR                  ((0x0244  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_STATUS1                   ((0x0245  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_STATUS2                   ((0x0246  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_START_ADDRB               ((0x0247  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_FINISH_ADDRB              ((0x0248  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_INIT_ADDR                 ((0x0249  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL2                     ((0x024a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL0                     ((0x0250  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL1                     ((0x0251  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_START_ADDR                ((0x0252  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_FINISH_ADDR               ((0x0253  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_INT_ADDR                  ((0x0254  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_STATUS1                   ((0x0255  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_STATUS2                   ((0x0256  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_START_ADDRB               ((0x0257  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_FINISH_ADDRB              ((0x0258  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_INIT_ADDR                 ((0x0259  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL2                     ((0x025a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_SWAP1                     ((0x0260  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK4                     ((0x0261  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK5                     ((0x0262  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK6                     ((0x0263  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK7                     ((0x0264  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE4                     ((0x0265  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE5                     ((0x0266  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE6                     ((0x0267  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE7                     ((0x0268  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_SWAP1                     ((0x0270  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK4                     ((0x0271  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK5                     ((0x0272  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK6                     ((0x0273  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK7                     ((0x0274  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE4                     ((0x0275  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE5                     ((0x0276  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE6                     ((0x0277  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE7                     ((0x0278  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_SWAP1                     ((0x0280  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK4                     ((0x0281  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK5                     ((0x0282  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK6                     ((0x0283  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK7                     ((0x0284  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE4                     ((0x0285  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE5                     ((0x0286  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE6                     ((0x0287  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE7                     ((0x0288  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_SWAP1                    ((0x0290  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK4                    ((0x0291  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK5                    ((0x0292  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK6                    ((0x0293  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK7                    ((0x0294  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE4                    ((0x0295  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE5                    ((0x0296  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE6                    ((0x0297  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE7                    ((0x0298  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL2                    ((0x02a0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_SWAP1                    ((0x02a1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN2                    ((0x02a2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN3                    ((0x02a3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK4                    ((0x02a4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK5                    ((0x02a5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK6                    ((0x02a6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK7                    ((0x02a7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE4                    ((0x02a8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE5                    ((0x02a9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE6                    ((0x02aa  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE7                    ((0x02ab  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN_EN                  ((0x02ac  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN_CTRL                ((0x02ad  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL2                    ((0x02b0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_SWAP1                    ((0x02b1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN2                    ((0x02b2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN3                    ((0x02b3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK4                    ((0x02b4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK5                    ((0x02b5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK6                    ((0x02b6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK7                    ((0x02b7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE4                    ((0x02b8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE5                    ((0x02b9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE6                    ((0x02ba  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE7                    ((0x02bb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN_EN                  ((0x02bc  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN_CTRL                ((0x02bd  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL2                    ((0x02c0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_SWAP1                    ((0x02c1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN2                    ((0x02c2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN3                    ((0x02c3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK4                    ((0x02c4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK5                    ((0x02c5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK6                    ((0x02c6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK7                    ((0x02c7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE4                    ((0x02c8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE5                    ((0x02c9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE6                    ((0x02ca  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE7                    ((0x02cb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN_EN                  ((0x02cc  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN_CTRL                ((0x02cd  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID0                 ((0x0300  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID1                 ((0x0301  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID2                 ((0x0302  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID3                 ((0x0303  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID4                 ((0x0304  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID5                 ((0x0305  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID6                 ((0x0306  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID7                 ((0x0307  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHSYNC_CTRL               ((0x030f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID0                 ((0x0310  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID1                 ((0x0311  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID2                 ((0x0312  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID3                 ((0x0313  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID4                 ((0x0314  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID5                 ((0x0315  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID6                 ((0x0316  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID7                 ((0x0317  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHSYNC_CTRL               ((0x031f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID0                 ((0x0320  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID1                 ((0x0321  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID2                 ((0x0322  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID3                 ((0x0323  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID4                 ((0x0324  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID5                 ((0x0325  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID6                 ((0x0326  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID7                 ((0x0327  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHSYNC_CTRL               ((0x032f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID0                 ((0x0330  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID1                 ((0x0331  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID2                 ((0x0332  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID3                 ((0x0333  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID4                 ((0x0334  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID5                 ((0x0335  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID6                 ((0x0336  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID7                 ((0x0337  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHSYNC_CTRL               ((0x033f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID0                 ((0x0340  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID1                 ((0x0341  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID2                 ((0x0342  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID3                 ((0x0343  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID4                 ((0x0344  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID5                 ((0x0345  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID6                 ((0x0346  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID7                 ((0x0347  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHSYNC_CTRL               ((0x034f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID0                 ((0x0350  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID1                 ((0x0351  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID2                 ((0x0352  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID3                 ((0x0353  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID4                 ((0x0354  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID5                 ((0x0355  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID6                 ((0x0356  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID7                 ((0x0357  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_CHSYNC_MASK                 ((0x035e  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHSYNC_CTRL               ((0x035f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID0                 ((0x0360  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID1                 ((0x0361  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID2                 ((0x0362  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID3                 ((0x0363  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID4                 ((0x0364  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID5                 ((0x0365  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID6                 ((0x0366  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID7                 ((0x0367  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHSYNC_CTRL               ((0x036f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID0                 ((0x0370  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID1                 ((0x0371  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID2                 ((0x0372  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID3                 ((0x0373  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID4                 ((0x0374  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID5                 ((0x0375  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID6                 ((0x0376  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID7                 ((0x0377  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHSYNC_CTRL               ((0x037f  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_STS0                ((0x0380  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_STS1                ((0x0381  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MASK0               ((0x0382  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MASK1               ((0x0383  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MODE0               ((0x0384  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MODE1               ((0x0385  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_CLR0                ((0x0386  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_CLR1                ((0x0387  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_INV0                ((0x0388  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_INV1                ((0x0389  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL0                     ((0x0390  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL1                     ((0x0391  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL2                     ((0x0392  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL3                     ((0x0393  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL4                     ((0x0394  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL5                     ((0x0395  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL6                     ((0x0396  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL7                     ((0x0397  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL8                     ((0x0398  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL9                     ((0x0399  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLA                     ((0x039a  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLB                     ((0x039b  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLC                     ((0x039c  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLD                     ((0x039d  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLE                     ((0x039e  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLF                     ((0x039f  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_PAD_CTRL0                    ((0x03a0  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_PAD_CTRL1                    ((0x03a1  << 2) + 0xfe330000)
#define EE_AUDIO_SCLK_PAD_CTRL0                    ((0x03a2  << 2) + 0xfe330000)
#define EE_AUDIO_LRCLK_PAD_CTRL0                   ((0x03a3  << 2) + 0xfe330000)
//========================================================================
//  PDM - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331000
// -----------------------------------------------
#define PDM_CTRL                                   ((0x0000  << 2) + 0xfe331000)
  //bit 31:   PDM enable.
  //bit 30:   invert the PDM_DCLK.
  //bit 29:   output mode:  1: 24bits. 0: 32 bits.
  //bit 28:   bypass mode. 1: bypass all filter. directly output the PDM input to DDR. 0: normal mode.
  //bit 27~9: not used.
  //bit 16:.   PDM Asynchronous FIFO soft reset.  write 1 to soft reset AFIFO.
  //bit 15:8   PDM channel reset.  0: to reset each PDM channel.  1: normal mode.
  //bit 7:0.  PDM channel enable. each bit for one channel.
#define PDM_HCIC_CTRL1                             ((0x0001  << 2) + 0xfe331000)
  //bit 31      hcic filter enable.  1 use sinc filter. 0 bypass input to output.
  //bit 29:24.  hcic final gain shift parameter.
  //bit 23:16   hcic final gain multiplier.
  //bit 8:4     hcic  down sample rate.
  //bit 3:0     hcic  stage number. must be between 3 to 9.
#define PDM_HCIC_CTRL2                             ((0x0002  << 2) + 0xfe331000)
  //Not used.
#define PDM_F1_CTRL                                ((0x0003  << 2) + 0xfe331000)
  //bit 31 .   filter 1 enable.
  //bit 16:15. f1 round mode.  2'b00 : sign bit at bit 49.  28bits output [49:22] round at bit 21. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b01 : sign bit at bit 50.  28bits output [50:23] round at bit 22. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b10 : sign bit at bit 51.  28bits output [51:24] round at bit 23 32bits output [49:18]. 24bits output [49:26].
  //bit 15:12. filter 1 down sample rate.
  //bit 8:0.   filter 1 stage number.
#define PDM_F2_CTRL                                ((0x0004  << 2) + 0xfe331000)
  //bit 31 .   filter 2 enable.
  //bit 16:15. f2 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 2 down sample rate.
  //bit 8:0.   filter 2 stage number.
#define PDM_F3_CTRL                                ((0x0005  << 2) + 0xfe331000)
  //bit 31 .   filter 3 enable.
  //bit 16:15. f3 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 3 down sample rate.
  //bit 8:0.   filter 3 stage number.
#define PDM_HPF_CTRL                               ((0x0006  << 2) + 0xfe331000)
  //bit 31  High pass filter enable.
  //bit 20:16 high pass filter shift steps. 6~19 steps.
  //bit 15:0 high pass filter output factor.
#define PDM_CHAN_CTRL                              ((0x0007  << 2) + 0xfe331000)
  //bit 31:24.  chan3 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan2 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan1 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan0 data sample pointer vs edge of the PDM_DCLK.
#define PDM_CHAN_CTRL1                             ((0x0008  << 2) + 0xfe331000)
  //bit 31:24.  chan7 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan6 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan5 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan4 data sample pointer vs edge of the PDM_DCLK.
#define PDM_COEFF_ADDR                             ((0x0009  << 2) + 0xfe331000)
  // address of the write/read of coeff data.
#define PDM_COEFF_DATA                             ((0x000a  << 2) + 0xfe331000)
  //write/read data to coeff memory.
#define PDM_CLKG_CTRL                              ((0x000b  << 2) + 0xfe331000)
  // auto clock gating control.  1: disable the clock gating function. the clock will awlays enabled. 0 : use RTL auto clock gating.
  //31:7 not used.
  //bit 6  filt_ctrl module auto clock gating control.
  //bit 5  sinc fifo module auto clock gating control.
  //bit 4  filter module auto clock gating control.
  //bit 3  apb module auto clock gating control.
  //bit 2  coeff memory module auto clock gating control.
  //bit 1  each channel module auto clock gating control.
  //bit 0 cts_pdm_clk   auto clock gating control.
#define PDM_STS                                    ((0x000c  << 2) + 0xfe331000)
//bit 1  HPF filter output overflow.  means the PCLK is too slow.
//bit 0  HCIC filter output overflow. means the CTS_PDM_CLK is too slow. can't finished the filter function.
#define PDM_MUTE_VALUE                             ((0x000d  << 2) + 0xfe331000)
#define PDM_MASK_NUM                               ((0x000e  << 2) + 0xfe331000)
#define PDM_CHAN_CTRL2                             ((0x000f  << 2) + 0xfe331000)
  //bit 7:0    second sample and start FSM point vs rise edge of PDM_DCLK
//========================================================================
//  EQ DRC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe332000
// -----------------------------------------------
#define AED_COEF_RAM_CNTL                          ((0x0000  << 2) + 0xfe332000)
#define AED_COEF_RAM_DATA                          ((0x0001  << 2) + 0xfe332000)
#define AED_EQ_EN                                  ((0x0002  << 2) + 0xfe332000)
#define AED_EQ_TAP_CNTL                            ((0x0003  << 2) + 0xfe332000)
#define AED_EQ_VOLUME                              ((0x0004  << 2) + 0xfe332000)
#define AED_EQ_VOLUME_SLEW_CNT                     ((0x0005  << 2) + 0xfe332000)
#define AED_MUTE                                   ((0x0006  << 2) + 0xfe332000)
#define AED_DRC_CNTL                               ((0x0007  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF0                          ((0x0008  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF1                          ((0x0009  << 2) + 0xfe332000)
#define AED_DRC_THD0                               ((0x000a  << 2) + 0xfe332000)
#define AED_DRC_THD1                               ((0x000b  << 2) + 0xfe332000)
#define AED_DRC_THD2                               ((0x000c  << 2) + 0xfe332000)
#define AED_DRC_THD3                               ((0x000d  << 2) + 0xfe332000)
#define AED_DRC_THD4                               ((0x000e  << 2) + 0xfe332000)
#define AED_DRC_K0                                 ((0x000f  << 2) + 0xfe332000)
#define AED_DRC_K1                                 ((0x0010  << 2) + 0xfe332000)
#define AED_DRC_K2                                 ((0x0011  << 2) + 0xfe332000)
#define AED_DRC_K3                                 ((0x0012  << 2) + 0xfe332000)
#define AED_DRC_K4                                 ((0x0013  << 2) + 0xfe332000)
#define AED_DRC_K5                                 ((0x0014  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT0                           ((0x0015  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT1                           ((0x0016  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT2                           ((0x0017  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT3                           ((0x0018  << 2) + 0xfe332000)
#define AED_DRC_OFFSET                             ((0x0019  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF00                     ((0x001a  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF01                     ((0x001b  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF10                     ((0x001c  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF11                     ((0x001d  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF20                     ((0x001e  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF21                     ((0x001f  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF30                     ((0x0020  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF31                     ((0x0021  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF40                     ((0x0022  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF41                     ((0x0023  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF50                     ((0x0024  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF51                     ((0x0025  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF00                      ((0x0026  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF01                      ((0x0027  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF10                      ((0x0028  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF11                      ((0x0029  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF20                      ((0x002a  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF21                      ((0x002b  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF30                      ((0x002c  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF31                      ((0x002d  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF40                      ((0x002e  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF41                      ((0x002f  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF50                      ((0x0030  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF51                      ((0x0031  << 2) + 0xfe332000)
#define AED_DRC_LOOPBACK_CNTL                      ((0x0032  << 2) + 0xfe332000)
#define AED_MDRC_CNTL                              ((0x0033  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF00                        ((0x0034  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF01                        ((0x0035  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF00                    ((0x0036  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF01                    ((0x0037  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF00                     ((0x0038  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF01                     ((0x0039  << 2) + 0xfe332000)
#define AED_MDRC_THD0                              ((0x003a  << 2) + 0xfe332000)
#define AED_MDRC_K0                                ((0x003b  << 2) + 0xfe332000)
#define AED_MDRC_LOW_GAIN                          ((0x003c  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET0                           ((0x003d  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF10                        ((0x003e  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF11                        ((0x003f  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF10                    ((0x0040  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF11                    ((0x0041  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF10                     ((0x0042  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF11                     ((0x0043  << 2) + 0xfe332000)
#define AED_MDRC_THD1                              ((0x0044  << 2) + 0xfe332000)
#define AED_MDRC_K1                                ((0x0045  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET1                           ((0x0046  << 2) + 0xfe332000)
#define AED_MDRC_MID_GAIN                          ((0x0047  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF20                        ((0x0048  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF21                        ((0x0049  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF20                    ((0x004a  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF21                    ((0x004b  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF20                     ((0x004c  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF21                     ((0x004d  << 2) + 0xfe332000)
#define AED_MDRC_THD2                              ((0x004e  << 2) + 0xfe332000)
#define AED_MDRC_K2                                ((0x004f  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET2                           ((0x0050  << 2) + 0xfe332000)
#define AED_MDRC_HIGH_GAIN                         ((0x0051  << 2) + 0xfe332000)
#define AED_ED_CNTL                                ((0x0052  << 2) + 0xfe332000)
#define AED_DC_EN                                  ((0x0053  << 2) + 0xfe332000)
#define AED_ND_LOW_THD                             ((0x0054  << 2) + 0xfe332000)
#define AED_ND_HIGH_THD                            ((0x0055  << 2) + 0xfe332000)
#define AED_ND_CNT_THD                             ((0x0056  << 2) + 0xfe332000)
#define AED_ND_SUM_NUM                             ((0x0057  << 2) + 0xfe332000)
#define AED_ND_CZ_NUM                              ((0x0058  << 2) + 0xfe332000)
#define AED_ND_SUM_THD0                            ((0x0059  << 2) + 0xfe332000)
#define AED_ND_SUM_THD1                            ((0x005a  << 2) + 0xfe332000)
#define AED_ND_CZ_THD0                             ((0x005b  << 2) + 0xfe332000)
#define AED_ND_CZ_THD1                             ((0x005c  << 2) + 0xfe332000)
#define AED_ND_COND_CNTL                           ((0x005d  << 2) + 0xfe332000)
#define AED_ND_RELEASE_COEF0                       ((0x005e  << 2) + 0xfe332000)
#define AED_ND_RELEASE_COEF1                       ((0x005f  << 2) + 0xfe332000)
#define AED_ND_ATTACK_COEF0                        ((0x0060  << 2) + 0xfe332000)
#define AED_ND_ATTACK_COEF1                        ((0x0061  << 2) + 0xfe332000)
#define AED_ND_CNTL                                ((0x0062  << 2) + 0xfe332000)
#define AED_MIX0_LL                                ((0x0063  << 2) + 0xfe332000)
#define AED_MIX0_RL                                ((0x0064  << 2) + 0xfe332000)
#define AED_MIX0_LR                                ((0x0065  << 2) + 0xfe332000)
#define AED_MIX0_RR                                ((0x0066  << 2) + 0xfe332000)
#define AED_CLIP_THD                               ((0x0067  << 2) + 0xfe332000)
#define AED_CH1_ND_SUM_OUT                         ((0x0068  << 2) + 0xfe332000)
#define AED_CH2_ND_SUM_OUT                         ((0x0069  << 2) + 0xfe332000)
#define AED_CH1_ND_CZ_OUT                          ((0x006a  << 2) + 0xfe332000)
#define AED_CH2_ND_CZ_OUT                          ((0x006b  << 2) + 0xfe332000)
#define AED_NOISE_STATUS                           ((0x006c  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S0                         ((0x006d  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S1                         ((0x006e  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S2                         ((0x006f  << 2) + 0xfe332000)
#define AED_POW_OUT0                               ((0x0070  << 2) + 0xfe332000)
#define AED_POW_OUT1                               ((0x0071  << 2) + 0xfe332000)
#define AED_POW_OUT2                               ((0x0072  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX0                         ((0x0073  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX1                         ((0x0074  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX2                         ((0x0075  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX0                        ((0x0076  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX1                        ((0x0077  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX2                        ((0x0078  << 2) + 0xfe332000)
#define AED_CH1_VOLUME_STATE                       ((0x0079  << 2) + 0xfe332000)
#define AED_CH2_VOLUME_STATE                       ((0x007a  << 2) + 0xfe332000)
#define AED_CH1_VOLUME_GAIN                        ((0x007b  << 2) + 0xfe332000)
#define AED_CH2_VOLUME_GAIN                        ((0x007c  << 2) + 0xfe332000)
#define AED_FULL_POW_CURRENT                       ((0x007d  << 2) + 0xfe332000)
#define AED_FULL_POW_OUT                           ((0x007e  << 2) + 0xfe332000)
#define AED_FULL_POW_ADJ                           ((0x007f  << 2) + 0xfe332000)
#define AED_FULL_DRC_GAIN                          ((0x0080  << 2) + 0xfe332000)
#define AED_MASTER_VOLUME_STATE                    ((0x0081  << 2) + 0xfe332000)
#define AED_MASTER_VOLUME_GAIN                     ((0x0082  << 2) + 0xfe332000)
#define AED_TOP_CTL0                               ((0x0083  << 2) + 0xfe332000)
#define AED_TOP_CTL1                               ((0x0084  << 2) + 0xfe332000)
#define AED_TOP_CTL2                               ((0x0085  << 2) + 0xfe332000)
#define AED_TOP_ST0                                ((0x0086  << 2) + 0xfe332000)
#define AED_TOP_ST1                                ((0x0087  << 2) + 0xfe332000)
#define AED_EQDRC_DYNAMIC_CNTL                     ((0x0090  << 2) + 0xfe332000)
#define AED_COEF_RAM_CNTL_B                        ((0x0091  << 2) + 0xfe332000)
#define AED_COEF_RAM_DATA_B                        ((0x0092  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF0_B                        ((0x0093  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF1_B                        ((0x0094  << 2) + 0xfe332000)
#define AED_DRC_THD0_B                             ((0x0095  << 2) + 0xfe332000)
#define AED_DRC_THD1_B                             ((0x0096  << 2) + 0xfe332000)
#define AED_DRC_THD2_B                             ((0x0097  << 2) + 0xfe332000)
#define AED_DRC_THD3_B                             ((0x0098  << 2) + 0xfe332000)
#define AED_DRC_THD4_B                             ((0x0099  << 2) + 0xfe332000)
#define AED_DRC_K0_B                               ((0x009a  << 2) + 0xfe332000)
#define AED_DRC_K1_B                               ((0x009b  << 2) + 0xfe332000)
#define AED_DRC_K2_B                               ((0x009c  << 2) + 0xfe332000)
#define AED_DRC_K3_B                               ((0x009d  << 2) + 0xfe332000)
#define AED_DRC_K4_B                               ((0x009e  << 2) + 0xfe332000)
#define AED_DRC_K5_B                               ((0x009f  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT0_B                         ((0x00a0  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT1_B                         ((0x00a1  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT2_B                         ((0x00a2  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT3_B                         ((0x00a3  << 2) + 0xfe332000)
#define AED_DRC_OFFSET_B                           ((0x00a4  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF00_B                   ((0x00a5  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF01_B                   ((0x00a6  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF10_B                   ((0x00a7  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF11_B                   ((0x00a8  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF20_B                   ((0x00a9  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF21_B                   ((0x00aa  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF30_B                   ((0x00ab  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF31_B                   ((0x00ac  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF40_B                   ((0x00ad  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF41_B                   ((0x00ae  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF50_B                   ((0x00af  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF51_B                   ((0x00b0  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF00_B                    ((0x00b1  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF01_B                    ((0x00b2  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF10_B                    ((0x00b3  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF11_B                    ((0x00b4  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF20_B                    ((0x00b5  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF21_B                    ((0x00b6  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF30_B                    ((0x00b7  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF31_B                    ((0x00b8  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF40_B                    ((0x00b9  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF41_B                    ((0x00ba  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF50_B                    ((0x00bb  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF51_B                    ((0x00bc  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF00_B                      ((0x00bd  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF01_B                      ((0x00be  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF10_B                      ((0x00bf  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF11_B                      ((0x00c0  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF20_B                      ((0x00c1  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF21_B                      ((0x00c2  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF00_B                  ((0x00c3  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF01_B                  ((0x00c4  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF10_B                  ((0x00c5  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF11_B                  ((0x00c6  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF20_B                  ((0x00c7  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF21_B                  ((0x00c8  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF00_B                   ((0x00c9  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF01_B                   ((0x00ca  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF10_B                   ((0x00cb  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF11_B                   ((0x00cc  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF20_B                   ((0x00cd  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF21_B                   ((0x00ce  << 2) + 0xfe332000)
#define AED_MDRC_THD0_B                            ((0x00cf  << 2) + 0xfe332000)
#define AED_MDRC_THD1_B                            ((0x00d0  << 2) + 0xfe332000)
#define AED_MDRC_THD2_B                            ((0x00d1  << 2) + 0xfe332000)
#define AED_MDRC_K0_B                              ((0x00d2  << 2) + 0xfe332000)
#define AED_MDRC_K1_B                              ((0x00d3  << 2) + 0xfe332000)
#define AED_MDRC_K2_B                              ((0x00d4  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET0_B                         ((0x00d5  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET1_B                         ((0x00d6  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET2_B                         ((0x00d7  << 2) + 0xfe332000)
#define AED_MDRC_LOW_GAIN_B                        ((0x00d8  << 2) + 0xfe332000)
#define AED_MDRC_MID_GAIN_B                        ((0x00d9  << 2) + 0xfe332000)
#define AED_MDRC_HIGH_GAIN_B                       ((0x00da  << 2) + 0xfe332000)
#define AED_DRC_CNTL_B                             ((0x00db  << 2) + 0xfe332000)
#define AED_DRC_LOOPBACK_CNTL_B                    ((0x00dc  << 2) + 0xfe332000)
#define AED_MDRC_CNTL_B                            ((0x00dd  << 2) + 0xfe332000)
#define AED_STATUS_REG                             ((0x00de  << 2) + 0xfe332000)
//========================================================================
//  AUDIO locker - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331400
// -----------------------------------------------
#define AUD_LOCK_EN                                ((0x0000  << 2) + 0xfe331400)
#define AUD_LOCK_SW_RESET                          ((0x0001  << 2) + 0xfe331400)
#define AUD_LOCK_SW_LATCH                          ((0x0002  << 2) + 0xfe331400)
#define AUD_LOCK_HW_LATCH                          ((0x0003  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_SRC                        ((0x0004  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_LAT_INT                    ((0x0005  << 2) + 0xfe331400)
#define AUD_LOCK_IMCLK_LAT_INT                     ((0x0006  << 2) + 0xfe331400)
#define AUD_LOCK_OMCLK_LAT_INT                     ((0x0007  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_DS_INT                     ((0x0008  << 2) + 0xfe331400)
#define AUD_LOCK_IMCLK_DS_INT                      ((0x0009  << 2) + 0xfe331400)
#define AUD_LOCK_OMCLK_DS_INT                      ((0x000a  << 2) + 0xfe331400)
#define AUD_LOCK_INT_CLR                           ((0x000b  << 2) + 0xfe331400)
#define AUD_LOCK_GCLK_CTRL                         ((0x000c  << 2) + 0xfe331400)
#define AUD_LOCK_INT_CTRL                          ((0x000d  << 2) + 0xfe331400)
#define RO_REF2IMCLK_CNT_L                         ((0x0010  << 2) + 0xfe331400)
#define RO_REF2IMCLK_CNT_H                         ((0x0011  << 2) + 0xfe331400)
#define RO_REF2OMCLK_CNT_L                         ((0x0012  << 2) + 0xfe331400)
#define RO_REF2OMCLK_CNT_H                         ((0x0013  << 2) + 0xfe331400)
#define RO_IMCLK2REF_CNT_L                         ((0x0014  << 2) + 0xfe331400)
#define RO_IMCLK2REF_CNT_H                         ((0x0015  << 2) + 0xfe331400)
#define RO_OMCLK2REF_CNT_L                         ((0x0016  << 2) + 0xfe331400)
#define RO_OMCLK2REF_CNT_H                         ((0x0017  << 2) + 0xfe331400)
#define RO_REFCLK_PKG_CNT                          ((0x0018  << 2) + 0xfe331400)
#define RO_IMCLK_PKG_CNT                           ((0x0019  << 2) + 0xfe331400)
#define RO_OMCLK_PKG_CNT                           ((0x001a  << 2) + 0xfe331400)
#define RO_AUD_LOCK_INT_STATUS                     ((0x001b  << 2) + 0xfe331400)
//========================================================================
//  AUDIO lockerB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334400
// -----------------------------------------------
#define AUD_LOCKB_EN                               ((0x0000  << 2) + 0xfe334400)
#define AUD_LOCKB_SW_RESET                         ((0x0001  << 2) + 0xfe334400)
#define AUD_LOCKB_SW_LATCH                         ((0x0002  << 2) + 0xfe334400)
#define AUD_LOCKB_HW_LATCH                         ((0x0003  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_SRC                       ((0x0004  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_LAT_INT                   ((0x0005  << 2) + 0xfe334400)
#define AUD_LOCKB_IMCLK_LAT_INT                    ((0x0006  << 2) + 0xfe334400)
#define AUD_LOCKB_OMCLK_LAT_INT                    ((0x0007  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_DS_INT                    ((0x0008  << 2) + 0xfe334400)
#define AUD_LOCKB_IMCLK_DS_INT                     ((0x0009  << 2) + 0xfe334400)
#define AUD_LOCKB_OMCLK_DS_INT                     ((0x000a  << 2) + 0xfe334400)
#define AUD_LOCKB_INT_CLR                          ((0x000b  << 2) + 0xfe334400)
#define AUD_LOCKB_GCLK_CTRL                        ((0x000c  << 2) + 0xfe334400)
#define AUD_LOCKB_INT_CTRL                         ((0x000d  << 2) + 0xfe334400)
#define ROB_REF2IMCLK_CNT_L                        ((0x0010  << 2) + 0xfe334400)
#define ROB_REF2IMCLK_CNT_H                        ((0x0011  << 2) + 0xfe334400)
#define ROB_REF2OMCLK_CNT_L                        ((0x0012  << 2) + 0xfe334400)
#define ROB_REF2OMCLK_CNT_H                        ((0x0013  << 2) + 0xfe334400)
#define ROB_IMCLK2REF_CNT_L                        ((0x0014  << 2) + 0xfe334400)
#define ROB_IMCLK2REF_CNT_H                        ((0x0015  << 2) + 0xfe334400)
#define ROB_OMCLK2REF_CNT_L                        ((0x0016  << 2) + 0xfe334400)
#define ROB_OMCLK2REF_CNT_H                        ((0x0017  << 2) + 0xfe334400)
#define ROB_REFCLK_PKG_CNT                         ((0x0018  << 2) + 0xfe334400)
#define ROB_IMCLK_PKG_CNT                          ((0x0019  << 2) + 0xfe334400)
#define ROB_OMCLK_PKG_CNT                          ((0x001a  << 2) + 0xfe334400)
#define ROB_AUD_LOCK_INT_STATUS                    ((0x001b  << 2) + 0xfe334400)
//========================================================================
//  AUDIO VAD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331800
// -----------------------------------------------
//
// Reading file:  ./VAD_REG.h
//
#define VAD_TOP_CTRL0                              ((0x0000  << 2) + 0xfe331800)
#define VAD_TOP_CTRL1                              ((0x0001  << 2) + 0xfe331800)
#define VAD_TOP_CTRL2                              ((0x0002  << 2) + 0xfe331800)
#define VAD_FIR_CTRL                               ((0x0003  << 2) + 0xfe331800)
#define VAD_FIR_EMP                                ((0x0004  << 2) + 0xfe331800)
#define VAD_FIR_COEF0                              ((0x0005  << 2) + 0xfe331800)
#define VAD_FIR_COEF1                              ((0x0006  << 2) + 0xfe331800)
#define VAD_FIR_COEF2                              ((0x0007  << 2) + 0xfe331800)
#define VAD_FIR_COEF3                              ((0x0008  << 2) + 0xfe331800)
#define VAD_FIR_COEF4                              ((0x0009  << 2) + 0xfe331800)
#define VAD_FIR_COEF5                              ((0x000a  << 2) + 0xfe331800)
#define VAD_FIR_COEF6                              ((0x000b  << 2) + 0xfe331800)
#define VAD_FIR_COEF7                              ((0x000c  << 2) + 0xfe331800)
#define VAD_FIR_COEF8                              ((0x000d  << 2) + 0xfe331800)
#define VAD_FIR_COEF9                              ((0x000e  << 2) + 0xfe331800)
#define VAD_FIR_COEF10                             ((0x000f  << 2) + 0xfe331800)
#define VAD_FIR_COEF11                             ((0x0010  << 2) + 0xfe331800)
#define VAD_FIR_COEF12                             ((0x0011  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL0                            ((0x0012  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL1                            ((0x0013  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL2                            ((0x0014  << 2) + 0xfe331800)
#define VAD_CEP_CTRL0                              ((0x0015  << 2) + 0xfe331800)
#define VAD_CEP_CTRL1                              ((0x0016  << 2) + 0xfe331800)
#define VAD_CEP_CTRL2                              ((0x0017  << 2) + 0xfe331800)
#define VAD_CEP_CTRL3                              ((0x0018  << 2) + 0xfe331800)
#define VAD_CEP_CTRL4                              ((0x0019  << 2) + 0xfe331800)
#define VAD_CEP_CTRL5                              ((0x001a  << 2) + 0xfe331800)
#define VAD_DEC_CTRL                               ((0x001b  << 2) + 0xfe331800)
#define VAD_TOP_STS0                               ((0x001c  << 2) + 0xfe331800)
#define VAD_TOP_STS1                               ((0x001d  << 2) + 0xfe331800)
#define VAD_TOP_STS2                               ((0x001e  << 2) + 0xfe331800)
#define VAD_FIR_STS0                               ((0x001f  << 2) + 0xfe331800)
#define VAD_FIR_STS1                               ((0x0020  << 2) + 0xfe331800)
#define VAD_POW_STS0                               ((0x0021  << 2) + 0xfe331800)
#define VAD_POW_STS1                               ((0x0022  << 2) + 0xfe331800)
#define VAD_POW_STS2                               ((0x0023  << 2) + 0xfe331800)
#define VAD_FFT_STS0                               ((0x0024  << 2) + 0xfe331800)
#define VAD_FFT_STS1                               ((0x0025  << 2) + 0xfe331800)
#define VAD_SPE_STS0                               ((0x0026  << 2) + 0xfe331800)
#define VAD_SPE_STS1                               ((0x0027  << 2) + 0xfe331800)
#define VAD_SPE_STS2                               ((0x0028  << 2) + 0xfe331800)
#define VAD_SPE_STS3                               ((0x0029  << 2) + 0xfe331800)
#define VAD_DEC_STS0                               ((0x002a  << 2) + 0xfe331800)
#define VAD_DEC_STS1                               ((0x002b  << 2) + 0xfe331800)
#define VAD_LUT_CTRL                               ((0x002c  << 2) + 0xfe331800)
#define VAD_LUT_WR                                 ((0x002d  << 2) + 0xfe331800)
#define VAD_LUT_RD                                 ((0x002e  << 2) + 0xfe331800)
#define VAD_IN_SEL0                                ((0x002f  << 2) + 0xfe331800)
#define VAD_IN_SEL1                                ((0x0030  << 2) + 0xfe331800)
#define VAD_TO_DDR                                 ((0x0031  << 2) + 0xfe331800)
#define VAD_SYNC_CTRL0                             ((0x0032  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID0                         ((0x0033  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID1                         ((0x0034  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID2                         ((0x0035  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID3                         ((0x0036  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID4                         ((0x0037  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID5                         ((0x0038  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID6                         ((0x0039  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID7                         ((0x003a  << 2) + 0xfe331800)
//
// Closing file:  ./VAD_REG.h
//
//========================================================================
//  AUDIO RESAMPLEA - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331c00
// -----------------------------------------------
//
// Reading file:  ./RESAMPLE.h
//
#define AUDIO_RSAMP_CTRL0                          ((0x0000  << 2) + 0xfe331c00)
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define AUDIO_RSAMP_CTRL1                          ((0x0001  << 2) + 0xfe331c00)
//Bit   31:27      reg_in_lsb        //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:5        reserved          //unsigned  , default =2;
//Bit   4:0        reg_inp_mux       //unsigned  , default =0;
#define AUDIO_RSAMP_CTRL2                          ((0x0002  << 2) + 0xfe331c00)
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define AUDIO_RSAMP_PHSINIT                        ((0x0003  << 2) + 0xfe331c00)
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define AUDIO_RSAMP_PHSSTEP                        ((0x0004  << 2) + 0xfe331c00)
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define AUDIO_RSAMP_SHIFT                          ((0x0005  << 2) + 0xfe331c00)
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define AUDIO_RSAMP_ADJ_CTRL0                      ((0x0006  << 2) + 0xfe331c00)
//Bit   31:7        reserved                //unsigned
//Bit   6           reg_lock_vld_sel        //unsigned , default = 0;
//Bit   5           reg_loop_dif_clr_en     //unsigned , default = 0;
//Bit   4           reg_aout_force_en       //unsigned , default = 0;
//Bit   3           reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define AUDIO_RSAMP_ADJ_CTRL1                      ((0x0007  << 2) + 0xfe331c00)
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define AUDIO_RSAMP_ADJ_SFT                        ((0x0008  << 2) + 0xfe331c00)
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define AUDIO_RSAMP_ADJ_IDET_LEN                   ((0x0009  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define AUDIO_RSAMP_ADJ_FORCE                      ((0x000a  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define AUDIO_RSAMP_ADJ_KI_FORCE                   ((0x000b  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define AUDIO_RSAMP_WATCHDOG_THRD                  ((0x000c  << 2) + 0xfe331c00)
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define AUDIO_RSAMP_DBG_INFO                       ((0x000d  << 2) + 0xfe331c00)
//Bit   31:16      reg_aout_force_hi        //unsigned , default = 0;
//Bit   15:7       reserved                 //unsigned , default = 0;
//Bit   6          reg_rsamp_dbgcnt_clr     //unsigned , default = 0;
//Bit   5          reg_rsamp_dbgcnt_vldsel  //unsigned , default = 0;
//Bit   4          reg_rsamp_dbgcnt_en      //unsigned , default = 0;
//Bit   3          reserved                 //unsigned , default = 0;
//Bit   2:0        reg_watchdog_rstsel      //unsigned , default = 4;
#define AUDIO_RSAMP_AOUT_FORCE                     ((0x000e  << 2) + 0xfe331c00)
//Bit   31:0       reg_aout_force_lo        //unsigned , default = 0;
#define AUDIO_RSAMP_IRQ_CTRL                       ((0x000f  << 2) + 0xfe331c00)
//Bit   31:16      reg_irq_thrd             //unsigned , default = 0;
//Bit   15:12      reserved                 //unsigned , default = 0;
//Bit   11:8       reg_irq_sel              //unsigned , default = 0;
//Bit   7:4        reg_irq_clr              //unsigned , default = 0;
//Bit   3:0        reg_irq_en               //unsigned , default = 0;
#define AUDIO_RSAMP_RO_STATUS                      ((0x0010  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define AUDIO_RSAMP_RO_ADJ_FREQ                    ((0x0011  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_adj_freq
#define AUDIO_RSAMP_RO_ADJ_DIFF_BAK                ((0x0012  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_diff_bak
#define AUDIO_RSAMP_RO_ADJ_DIFF_DLT                ((0x0013  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_diff_dlt
#define AUDIO_RSAMP_RO_ADJ_PHS_ERR                 ((0x0014  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_phase_err
#define AUDIO_RSAMP_RO_ADJ_KI_OUT                  ((0x0015  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_ki_out
#define AUDIO_RSAMP_RO_IN_CNT                      ((0x0016  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_in_cnt
#define AUDIO_RSAMP_RO_OUT_CNT                     ((0x0017  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_out_cnt
#define AUDIO_RSAMP_RO_ADJ_PHS_ERR_VAR             ((0x0018  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_phase_err_var
#define AUDIO_RSAMP_POST_COEF0                     ((0x0020  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF1                     ((0x0021  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF2                     ((0x0022  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF3                     ((0x0023  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF4                     ((0x0024  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define AUDIO_RSAMP_AA_COEF_ADDR                   ((0x0030  << 2) + 0xfe331c00)
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define AUDIO_RSAMP_AA_COEF_DATA                   ((0x0031  << 2) + 0xfe331c00)
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define AUDIO_RSAMP_SINC_COEF_ADDR                 ((0x0040  << 2) + 0xfe331c00)
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define AUDIO_RSAMP_SINC_COEF_DATA                 ((0x0041  << 2) + 0xfe331c00)
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  ./RESAMPLE.h
//
//========================================================================
//  AUDIO EARCTX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333000
// -----------------------------------------------
//
// Reading file:  ./earc_tx_cmdc.h
//
#define EARC_TX_CMDC_TOP_CTRL0                     ((0x0030  << 2) + 0xfe333000)
//Bit   31   ,      idle2_int          unsigned, default = 0, 1: enable
//Bit   30   ,      idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,      disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,      disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,      earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,      hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,      losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,      timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,      status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,      int_recv_finished  unsigned, default = 0, 1: enable
//Bit   21   ,      int_rdata          unsigned, default = 0, 1: enable
//Bit   20   ,      int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,      int_recv_norsp     unsigned, default = 0, 1: enable
//Bit   18   ,      int_recv_unexp     unsigned, default = 0, 1: enable
//Bit   17   ,      int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,      int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,      int_recv_ecc_err   unsigned, default = 0, 1: enable
//Bit   14   ,      int_recv_packet    unsigned, default = 0, 1: enable
//Bit   13:0 ,      reserved
#define EARC_TX_CMDC_TOP_CTRL1                     ((0x0031  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_top_ctrl1     //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TOP_CTRL2                     ((0x0032  << 2) + 0xfe333000)
//Bit   31   ,     reset_idle2_int              unsigned, default = 0, 1: enable
//Bit   30   ,     reset_idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,     reset_disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,     reset_disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,     reset_earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,     reset_hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,     reset_losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,     reset_timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,     reset_status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,     reset_int_recv_finished        unsigned, default = 0, 1: enable
//Bit   21   ,     reset_int_rdata              unsigned, default = 0, 1: enable
//Bit   20   ,     reset_int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,     reset_int_recv_norsp         unsigned, default = 0, 1: enable
//Bit   18   ,     reset_int_recv_unexp         unsigned, default = 0, 1: enable
//Bit   17   ,     reset_int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,     reset_int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,     reset_int_recv_ecc_err       unsigned, default = 0, 1: enable
//Bit   14   ,     reset_int_recv_packet        unsigned, default = 0, 1: enable
//Bit 13:0   ,     reserved
#define EARC_TX_CMDC_TIMER_CTRL0                   ((0x0033  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl0   //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL1                   ((0x0034  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl1  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL2                   ((0x0035  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl2  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL3                   ((0x0036  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl3  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_VSM_CTRL0                     ((0x0037  << 2) + 0xfe333000)
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state                 unsigned, default = 0,  XX
//Bit      27,      arc_initiated             unsigned, default = 0,  XX
//Bit      26,      arc_terminated             unsigned, default = 0,  XX
//Bit      25,      arc_enable                 unsigned, default = 1,  XX
//Bit      24,      man_hpd                 unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel                 unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state_en           unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en             unsigned, default = 0,  XX
//Bit      13,      noack_repeat_en            unsigned, default = 0,  XX
//Bit    12:0,      reserved
#define EARC_TX_CMDC_VSM_CTRL1                     ((0x0038  << 2) + 0xfe333000)
//Bit    31:9,      reserved
//Bit       8,      cntl_hpd_sel            unsigned, default = 0, 0:sel hd_hpd,1:sel hdmirx_hpd
//Bit     7:0,      comma_cnt_th            unsigned, default = 0, should bigger than 3 and small than 10
#define EARC_TX_CMDC_VSM_CTRL2                     ((0x0039  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc1 hpd_val timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc1 hpd_val timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc1 hpd_val timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc1 hpd_val timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc1 hpd_val timing
#define EARC_TX_CMDC_VSM_CTRL3                     ((0x003a  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc2 heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc2 heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc2 heartbeat act timing
#define EARC_TX_CMDC_VSM_CTRL4                     ((0x003b  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc2, no heartbeat ack timing
#define EARC_TX_CMDC_VSM_CTRL5                     ((0x003c  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc1 and disc2 timing out
#define EARC_TX_CMDC_VSM_CTRL6                     ((0x003d  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in earc heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in earc heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat act timing
#define EARC_TX_CMDC_VSM_CTRL7                     ((0x003e  << 2) + 0xfe333000)
//Bit    31:16,      reserved
//Bit     15:8,      status_soft_val       unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define EARC_TX_CMDC_VSM_CTRL8                     ((0x003f  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_vsm_ctrl8        //unsigned, RW, default = 0,
#define EARC_TX_CMDC_VSM_CTRL9                     ((0x0041  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_vsm_ctrl9        //unsigned, RW, default = 0
#define EARC_TX_CMDC_SENDER_CTRL0                  ((0x0042  << 2) + 0xfe333000)
//Bit      31:2,     sender_ctrl0                 unsigned,  default = 0,
//Bit      1,        hb_chg_conf_auto             unsigned,  default = 1,
//Bit      0,        hb_chg_auto                  unsigned,  default = 0,
#define EARC_TX_CMDC_PACKET_CTRL0                  ((0x0043  << 2) + 0xfe333000)
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst                    unsigned, default = 0,  packet control
//Bit     28:24,      tx_ready_threshold          unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_threshold          unsigned, default = 0,  packet control
//Bit       7:6,      reserved
//Bit         5,      state_auto_en               unsigned, default = 0, packet control
//Bit         4,      sw_state_update_en          unsigned, default = 0,  packet control
//Bit       3:0,      sw_state_value              unsigned, default = 0,  packet control
#define EARC_TX_CMDC_PACKET_CTRL1                  ((0x0044  << 2) + 0xfe333000)
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_start_value             unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_threshold              unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_threshold               unsigned, default = 0,  XX
//Bit       7:0,      post_flag                   unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL2                  ((0x0045  << 2) + 0xfe333000)
//Bit      31:0,      pre_flag                    unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL3                  ((0x0046  << 2) + 0xfe333000)
//Bit      31,       recv_en                      unsigned, default = 0,  XX
//Bit      30,       recv_parity_mask             unsigned, default = 0,  XX
//Bit      29,       recv_timeout_en              unsigned, default = 0,  XX
//Bit      28,       bch_ecc_en                   unsigned, default = 0, xx
//Bit     27:16,     reserved
//Bit      15:0,     recv_timeout_threshold       unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL4                  ((0x0047  << 2) + 0xfe333000)
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head             unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL5                  ((0x0048  << 2) + 0xfe333000)
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head_mask        unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL6                  ((0x0049  << 2) + 0xfe333000)
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:7,     reserved
//Bit         6,     recv_finished_int            unsigned, default = 0,  XX
//Bit         5,     recv_ecc_err_int             unsigned, default = 0,  XX
//Bit         4,     recv_ack_int                 unsigned, default = 0,  XX
//Bit         3,     recv_data_int                unsigned, default = 0,  XX
//Bit         2,     recv_unexp_int               unsigned, default = 0,  XX
//Bit         1,     recv_norsp_int               unsigned, default = 0,  XX
//Bit         0,     recv_nack_int                unsigned, default = 0,  XX
#define EARC_TX_CMDC_BIPHASE_CTRL0                 ((0x004a  << 2) + 0xfe333000)
//Bit     31:24,     reserved
//Bit     23:16,     ack delay threshold           unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define EARC_TX_CMDC_BIPHASE_CTRL1                 ((0x004b  << 2) + 0xfe333000)
//Bit     31:16,     reserved
//Bit        15,     ack_enable                    unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     wait_threshold before ack     unsigned, default = 0,  send
#define EARC_TX_CMDC_BIPHASE_CTRL2                 ((0x004c  << 2) + 0xfe333000)
//Bit        31,     comma_detection_enable        unsigned, default = 0, comma detection
//Bit        30,     manual_reset_enable           unsigned, default = 0, manual reset select, 1: manual
//Bit        29,     manual_reset_value            unsigned, default = 0, manual reset control
//Bit     28:16,     reserved
//Bit      15:0,     comma_detection_threshold     unsigned, default = 0,
#define EARC_TX_CMDC_BIPHASE_CTRL3                 ((0x004d  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_biphase_ctrl3            unsigned, default = 0,
#define EARC_TX_CMDC_DEVICE_ID_CTRL                ((0x004e  << 2) + 0xfe333000)
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_rw_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_rw_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:17,     reserved
//Bit        16,     hpb_rst_enable               unsigned, default = 1, hpd rst enable
//Bit      15:8,     apb_rwid                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apbrw_start_addr            unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_DEVICE_WDATA                  ((0x004f  << 2) + 0xfe333000)
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_DEVICE_RDATA                  ((0x0050  << 2) + 0xfe333000)
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_MASTER_CTRL                   ((0x0051  << 2) + 0xfe333000)
//Bit        31,     master_cmd_rw                 unsigned, default = 0, 1 write 0 read
//Bit        30,     master_hb_ignore              unsigned, default =0, 0:wait hb issued before pkt cmd, 1: pkt cmd issued immediately
//Bit        29,     master_idle                   unsigned, default = 0, master status
//Bit        28,     master_cmd_soft_rst           unsigned, default= 0,
//Bit     27:24,     hb_cmd_cal_th                 unsigned, default= 0,
//Bit     23:16,     master_cmd_count              unsigned, default = 0, cmd count -1
//Bit      15:8,     master_cmd_id                 unsigned, default = 0,
//Bit       7:0,     master_cmd_address            unsigned, default = 0,
#define EARC_TX_ANA_CTRL0                          ((0x0052  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl0       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL1                          ((0x0053  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl1       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL2                          ((0x0054  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl2       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL3                          ((0x0055  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl3       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL4                          ((0x0056  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl4       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL5                          ((0x0057  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl5       //unsigned, RW, default = 0,
#define EARC_TX_ANA_STAT0                          ((0x0058  << 2) + 0xfe333000)
//Bit      31:0,     ro_ANA_status0              //unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS0                       ((0x0059  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status0              //unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS1                       ((0x005a  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status1              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS2                       ((0x005b  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status2              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS3                       ((0x005c  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status3              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS4                       ((0x005d  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status4              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS5                       ((0x005e  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status5              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS6                       ((0x005f  << 2) + 0xfe333000)
//Bit   31   ,     ro_idle2_int            unsigned, RO, default = 0
//Bit   30   ,     ro_idle1_int            unsigned, RO, default = 0
//Bit   29   ,     ro_disc2_int            unsigned, RO, default = 0
//Bit   28   ,     ro_disc1_int            unsigned, RO, default = 0
//Bit   27   ,     ro_earc_int             unsigned, RO, default = 0
//Bit   26   ,     ro_hb_status_int        unsigned, RO, default = 0
//Bit   25   ,     ro_losthb_int           unsigned, RO, default = 0
//Bit   24   ,     ro_timeout_int          unsigned, RO, default = 0
//Bit   23   ,     ro_status_ch_int        unsigned, RO, default = 0
//Bit   22   ,     ro_int_recv_finished    unsigned, RO, default = 0
//Bit   21   ,     ro_int_rdata            unsigned, RO, default = 0
//Bit   20   ,     ro_int_recv_nack        unsigned, RO, default = 0
//Bit   19   ,     ro_int_recv_norsp       unsigned, RO, default = 0
//Bit   18   ,     ro_int_recv_unexp       unsigned, RO, default = 0
//Bit   17   ,     ro_int_recv_data        unsigned, RO, default = 0
//Bit   16   ,     ro_int_recv_ack         unsigned, RO, default = 0
//Bit   15   ,     ro_int_recv_ecc_err     unsigned, RO, default = 0
//Bit   14   ,     ro_int_recv_packet      unsigned, RO, default = 0
//Bit 13:0   ,     reserved
//
// Closing file:  ./earc_tx_cmdc.h
//
//========================================================================
//  AUDIO EARCTX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333400
// -----------------------------------------------
//
// Reading file:  ./earctx_dmac.h
//
#define EARCTX_DMAC_TOP_CTRL0                      ((0x0000  << 2) + 0xfe333400)
//Bit 31,       reg_top_reg_sync             ,default = 0,Bit 3:0 sync to clk10m,pluse auto clear
//Bit 30,       reg_top_soft_rst             ,default = 0
//Bit 29:26,    reserved
//Bit 25:24,    reg_debug_mux                ,default = 0
//Bit 23:21,    reserved
//Bit 20,       reg_slow_sync_scan_reg       ,default = 0
//Bit 19,       reg_fe_sf_scan_reg           ,default = 0
//Bit 18,       reg_fe_slow_sync_scan_reg    ,default = 0
//Bit 17,       reg_top_sf_scan_reg          ,default = 0
//Bit 16,       reg_top_slow_sync_scan_reg   ,default = 0
//Bit 15:4,     reserved
//Bit 3,        reg_spdif_tx_en_force        ,default = 0,spdif_tx_en force enable
//Bit 2,        reg_spdif_tx_en_force_value  ,default = 0,spdif_tx_en force value
//Bit 1,        reg_dmac_tx_en_force         ,default = 0,dmac_tx_en force enable
//Bit 0,        reg_dmac_tx_en_force_value   ,default = 0,dmac_tx_en force value
#define EARCTX_MUTE_VAL                            ((0x0001  << 2) + 0xfe333400)
//Bit 31:0,     reg_spdif_mute_val     ,default = 0,when biahpase encode mute,the channel value,with reg_mute_l/reg_mute_r
#define EARCTX_SPDIFOUT_GAIN0                      ((0x0002  << 2) + 0xfe333400)
//Bit 31:24,    reg_gain_ch3     ,default = 0,channel 3 gain
//Bit 23:16,    reg_gain_ch2     ,default = 0,channel 2 gain
//Bit 15:8,     reg_gain_ch1     ,default = 0,channel 1 gain
//Bit 7:0,      reg_gain_ch0     ,default = 0,channel 0 gain
#define EARCTX_SPDIFOUT_GAIN1                      ((0x0003  << 2) + 0xfe333400)
//Bit 31:24,    reg_gain_ch7     ,default = 0,channel 7 gain
//Bit 23:16,    reg_gain_ch6     ,default = 0,channel 6 gain
//Bit 15:8,     reg_gain_ch5     ,default = 0,channel 5 gain
//Bit 7:0,      reg_gain_ch4     ,default = 0,channel 4 gain
#define EARCTX_SPDIFOUT_CTRL0                      ((0x0004  << 2) + 0xfe333400)
//Bit 31,     reg_work_start      ,default = 0,biphase work start,pluse
//Bit 30,     reg_work_clr        ,default = 0,biphase work clear,pluse
//Bit 29,     reg_rst_afifo_out_n ,default = 0,afifo out reset
//Bit 28,     reg_rst_afifo_in_n  ,default = 0,afifo in reset
//Bit 27,     reg_hold_for_tdm    ,default = 0,add delay to mathc TDM out when share buff
//Bit 26,     reg_userdata_sel    ,default = 0,user Bit select : 0 from reg_userdata_set 1 from data[29]
//Bit 25,     reg_userdata_set    ,default = 0
//Bit 24,     reg_chdata_sel      ,default = 0,0 :from reg_chstst 1 from data[30]
//Bit 23,     reserved
//Bit 22,     reg_mute_l          ,default = 0,r channel mute ,with reg_mute_val
//Bit 21,     reg_mute_r          ,default = 0,l channel mute ,with reg_mute_val
//Bit 20,     reg_data_sel        ,default = 0,0 data from 31Bit 1 data from 27bit
//Bit 19,     reg_out_msb_first   ,default = 0,0 lsb first 1 msb first
//Bit 18,     reg_valid_sel       ,default = 0,biphase encode valid Bit value sel : 0 from data 1 from reg_valid_set
//Bit 17,     reg_valid_set       ,default = 0,biphase encode valid Bit value
//Bit 16,     reg_mute_hold_init_en  ,default = 0,when c_mute_hold_last_err_corrt valid,clear work enable, initial biphase encode
//Bit 15:12,  reserved
//Bit 0,      reg_parity_mask     ,default = 0,Bit 0 is initial parity value
#define EARCTX_SPDIFOUT_CTRL1                      ((0x0005  << 2) + 0xfe333400)
//Bit 31,     reg_eq_drc_sel      ,default = 0,set 1 select eq_drc data
//Bit 30,     reg_keep_req_ddr_init ,default = 0,reg_keep_req_ddr_init
//Bit 29:28,  reserved
//Bit 27,     reg_gain_en         ,default = 0,gain enable
//Bit 26:24,  reg_frddr_sel       ,default = 0,from ddr select
//Bit 23:16,  reg_wait_cnt        ,default = 0,wait some time when enable set to 1
//Bit 15:13,  reserved
//Bit 12:8,   reg_frddr_msb       ,default = 0,msb position of data
//Bit 7,      reg_force_start     ,default = 0,set 1 no need ack from frddr to transmit channel status
//Bit 6:4,    reg_frddr_type      ,default = 0
//Bit 3:0,    reserved
#define EARCTX_SPDIFOUT_PREAMB                     ((0x0006  << 2) + 0xfe333400)
//Bit 31,     reg_premable_Z_set      ,default = 0,user 8'b11101000 1 user 7:0
//Bit 30,     reg_premable_Y_set      ,default = 0,user 8'b11100100 1 user 15:8
//Bit 29,     reg_premable_X_set      ,default = 0,user 8'b11100010 1 user 23:16
//Bit 28:24,  reserved
//Bit 23:16,  reg_premable_X_value    ,default = 0
//Bit 15:8,   reg_premable_Y_value    ,default = 0
//Bit 7:0,    reg_premable_Z_value    ,default = 0
#define EARCTX_SPDIFOUT_SWAP                       ((0x0007  << 2) + 0xfe333400)
//Bit 31:16,  reg_hold_cnt        ,default = 0,hold start cnt ,valid when reg_hold_for_tdm set 1
//Bit 15,     reg_init_send_en    ,default = 0,send 01 sequence some times after intial done from frddr set
//Bit 14:0,   reg_init_send_cnt   ,default = 0,send 01 sequence time ,valid when reg_init_send_en set 1
#define EARCTX_ERR_CORRT_CTRL0                     ((0x0008  << 2) + 0xfe333400)
//Bit 31:24,  reserved
//Bit 23,     reg_bch_in_reverse       ,default = 0,bch input data generate in 24it data reverse
//Bit 22,     reg_bch_out_ecc_reverse  ,default = 0,bch output ecc  reverse
//Bit 21,     reg_bch_out_data_reverse ,default = 0,bch output data reverse
//Bit 20,     reg_bch_out_ecc_msb      ,default = 0,bch output ecc position
//Bit 19:17,  reserved
//Bit 16,     reg_ubit_fifo_init_n,default = 0,fifo in  initial
//Bit 15:14,  reserved
//Bit 13:12,  reg_gain_shift      ,default = 0,gain x 1/2/4/8
//Bit 11,     reg_mix_lr          ,default = 0,l/r mix
//Bit 10:8,   reg_spdifout_r_sel  ,default = 0,r channel select
//Bit 7,      reserved
//Bit 6:4,    reg_spdifout_l_sel  ,default = 0,l channel select
//Bit 3:0,    reg_iu_interval     ,default = 0,iu transmit interval
#define EARCTX_ERR_CORRT_CTRL1                     ((0x0009  << 2) + 0xfe333400)
//Bit 31,     reg_ubit_fifo_wr    ,default = 0,iu data write enable,pluse,auto clr in reg.v
//Bit 30:8,   reserved
//Bit 7:0,    reg_ubit_fifo_wdata ,default = 0,iu data
#define EARCTX_ERR_CORRT_CTRL2                     ((0x000a  << 2) + 0xfe333400)
//Bit 31,     reg_mute_clear       ,default = 0,mute clear,pluse,auto clr in reg.v
//Bit 30,     reg_mute_start       ,default = 0,mute start,pluse,auto clr in reg.v
//Bit 29:28,  reserved
//Bit 27:16,  reg_mute_block_num   ,default = 0,mute block number
//Bit 15:8,   reg_mute_ch_Bit      ,default = 0,mute Bit at channel statue which bit
//Bit 7:3,    reserved
//Bit 2,      reg_mute_data_sel    ,default = 0,mute data sel: 0 data 1 reg_mute_data_value
//Bit 1:0,    reg_mute_mode        ,default = 0,0:always mute 1:mute block number and dis mute 2:mute block number and hold bus
#define EARCTX_ERR_CORRT_CTRL3                     ((0x000b  << 2) + 0xfe333400)
//Bit 31:30,  reserved
//Bit 29,     reg_bch_en           ,default = 0,bch generate enable
//Bit 28:24,  reg_bch_msb          ,default = 0,bch data msb position in audio data
//Bit 23:0,   reg_mute_data_value  ,default = 0,mute value,only for audio data part
#define EARCTX_ERR_CORRT_CTRL4                     ((0x000c  << 2) + 0xfe333400)
//Bit 31,    reg_ubit_fifo_lr_swap        ,default = 0,//user Bit lr swap
//Bit 30,    reg_ubit_fifo_lr_same        ,default = 0,//l/r channel use same Bit user bit
//Bit 29:25, reg_data_msb                 ,default = 0,audio data msb postion in input data
//Bit 24,    reg_data_rsv                 ,default = 0,audio data msb/lsb
//Bit 23,    reg_ubit_value               ,default = 0,user Bit value
//Bit 22,    reg_vbit_value               ,default = 0,valid Bit value
//Bit 21,    reg_data_sel                 ,default = 0,//data sel: 0 data 1 reg_mute_data_value
//Bit 20:19, reg_ubit_sel                 ,default = 0,//userBit sel: 0 data 1 reg_value 2 fifo data
//Bit 18,    reg_vbit_sel                 ,default = 0,//validBit sel: 0 data 1 reg_value
//Bit 17,    reg_chst_sel                 ,default = 0,//chanel status sel: 0 data 1 reg_value
//Bit 16,    reg_ubit_fifo_less_irq_en    ,default = 0,fifo_less_thd irq enable
//Bit 15:8,  reg_ubit_fifo_start_thd      ,default = 0,start transmit iu after fifo level greater than this value
//Bit 7:0,   reg_ubit_fifo_less_thd       ,default = 0,generate irq,when fifo level less than this value
#define EARCTX_ERR_CORRT_STAT0                     ((0x000d  << 2) + 0xfe333400)
//Bit 31:0,  ro_err_corrt_stat0          ,default = 0,
#define EARCTX_SPDIFOUT_CHSTS0                     ((0x000e  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[31:0]
#define EARCTX_SPDIFOUT_CHSTS1                     ((0x000f  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[63:32]
#define EARCTX_SPDIFOUT_CHSTS2                     ((0x0010  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[95:64]
#define EARCTX_SPDIFOUT_CHSTS3                     ((0x0011  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[127:96]
#define EARCTX_SPDIFOUT_CHSTS4                     ((0x0012  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[159:128]
#define EARCTX_SPDIFOUT_CHSTS5                     ((0x0013  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[191:160]
#define EARCTX_SPDIFOUT_CHSTS6                     ((0x0014  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[31:0]
#define EARCTX_SPDIFOUT_CHSTS7                     ((0x0015  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[63:32]
#define EARCTX_SPDIFOUT_CHSTS8                     ((0x0016  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[95:64]
#define EARCTX_SPDIFOUT_CHSTS9                     ((0x0017  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[127:96]
#define EARCTX_SPDIFOUT_CHSTSA                     ((0x0018  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[159:128]
#define EARCTX_SPDIFOUT_CHSTSB                     ((0x0019  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[191:160]
#define EARCTX_FE_CTRL0                            ((0x001a  << 2) + 0xfe333400)
//Bit 31,    reg_mute_hold_clr      ,default = 0,clear mute hold statues,pluse, auto clr
//Bit 30,    reg_work_enable        ,default = 0,wore enable
//Bit 29,    reg_dmac_invt          ,default = 0,fe out invent
//Bit 28,    reg_hold_time_en       ,default = 0,hold min time enable
//Bit 27,    reg_hold_soft_clr_en   ,default = 0,0 auto clear hold at next valid 1 clear hold with reg_mute_hold_clr
//Bit 26:24, reg_hold_time_tick_sel ,default = 0,hold min time tick select
//Bit 23:0,  reg_hold_min_time      ,default = 0,hold min time
#define EARCTX_FE_STAT0                            ((0x001b  << 2) + 0xfe333400)
//Bit 31:0,  ro_fe_stat0          ,default = 0,
#define EARCTX_SPDIFOUT_STAT                       ((0x001c  << 2) + 0xfe333400)
//Bit 31:0,  ro_spdifout_stat     ,default = 0,
#define EARCTX_SPDIFOUT_CTRL2                      ((0x001d  << 2) + 0xfe333400)
//Bit 31:28,  reserved
//Bit 27:16,  reg_clr_by_init      ,default = 0,reg_clr_by_init
//Bit 15:0 ,  reg_mask             ,default = 0,reg_mask
#define EARCTX_SPDIFOUT_GAIN2                      ((0x001e  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain2        ,default = 0,spdifout gain2
#define EARCTX_SPDIFOUT_GAIN3                      ((0x001f  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain3        ,default = 0,spdifout gain3
#define EARCTX_SPDIFOUT_GAIN4                      ((0x0020  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain4        ,default = 0,spdifout gain4
#define EARCTX_SPDIFOUT_GAIN5                      ((0x0021  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain5        ,default = 0,spdifout gain5
//
//
// Closing file:  ./earctx_dmac.h
//
//========================================================================
//  AUDIO EARCTX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333600
// -----------------------------------------------
//
// Reading file:  ./earctx_top.h
//
#define EARCTX_TOP_CTRL0                           ((0x0000  << 2) + 0xfe333600)
//Bit   31:18,   reserved
//Bit   17:16,   reg_earctx_debug_mux     unsigned, default = 0, debug mux
//Bit   15,      reg_slow_sync_scan_reg   unsigned, default = 0, reg_slow_sync_scan_reg
//Bit   14:12,   reserved
//Bit   11,      reg_hdmi_hpd_invt        unsigned, default = 0, hdmi_hpd invent
//Bit   10,      reg_hdmi_hpd_value       unsigned, default = 0, hdmi_hpd mux = 3,register value
//Bit   9:8,     reg_hdmi_hpd_mux         unsigned, default = 0, hdmi_hpd mux
//Bit   7,       reg_earctx_hd_hpd_invt   unsigned, default = 0, earctx_hd_hdp invent
//Bit   6,       reg_earctx_hd_hpd_value  unsigned, default = 0, earctx_hd_hdp mux = 3,register value
//Bit   5:4,     reg_earctx_hd_hdp_mux    unsigned, default = 0, earctx_hd_hdp mux
//Bit   3:2,     reserved
//Bit   1,       reg_earctx_force_mode_en unsigned, default = 0, force mode enale
//Bit   0,       reg_earctx_force_mode    unsigned, default = 0, force mode value
#define EARCTX_DMAC_INT_MASK                       ((0x0001  << 2) + 0xfe333600)
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define EARCTX_DMAC_INT_PENDING                    ((0x0002  << 2) + 0xfe333600)
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define EARCTX_CMDC_INT_MASK                       ((0x0003  << 2) + 0xfe333600)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define EARCTX_CMDC_INT_PENDING                    ((0x0004  << 2) + 0xfe333600)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define EARCTX_ANA_CTRL0                           ((0x0005  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_CTRL1                           ((0x0006  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_CTRL2                           ((0x0007  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_STAT0                           ((0x0008  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  ./earctx_top.h
//
//========================================================================
//  AUDIO EARCRX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333800
// -----------------------------------------------
//
// Reading file:  ./earc_rx_cmdc.h
//
#define EARC_RX_CMDC_TOP_CTRL0                     ((0x0000  << 2) + 0xfe333800)
//Bit   31   ,     idle2_int                 unsigned, default = 0, 1: enable
//Bit   30   ,     idle1_int     	         unsigned, default = 0, 1: enable
//Bit   29   ,     disc2_int     	         unsigned, default = 0, 1: enable
//Bit   28   ,     disc1_int     	         unsigned, default = 0, 1: enable
//Bit   27   ,     earc_int      	         unsigned, default = 0, 1: enable
//Bit   26   ,     hb_status_int 	         unsigned, default = 0, 1: enable
//Bit   25   ,     losthb_int    	         unsigned, default = 0, 1: enable
//Bit   24   ,     timeout_int   	         unsigned, default = 0, 1: enable
//Bit   23   ,     status_ch_int 	         unsigned, default = 0, 1: enable
//Bit   22   ,     int_rec_invalid_id        unsigned, default = 0, 1: enable
//Bit   21   ,     int_rec_invalid_offset    unsigned, default = 0, 1: enable
//Bit   20   ,     int_rec_unexp             unsigned, default = 0, 1: enable
//Bit   19   ,     int_rec_ecc_err           unsigned, default = 0, 1: enable
//Bit   18   ,     int_rec_parity_err        unsigned, default = 0, 1: enable
//Bit   17   ,     int_recv_packet           unsigned, default = 0, 1: enable
//Bit   16   ,     int_rec_time_out          unsigned, default = 0, 1: enable
//Bit   15   ,     cmdc_debug0               unsigned, default = 0, 1: enable
//Bit   14   ,     cmdc_debug1               unsigned, default = 0, 1: enable
//Bit   13   ,     cmdc_debug2               unsigned, default = 0, 1: enable
//Bit   12:7 ,     reserved
//Bit    6   ,     mute_select               unsigned, default = 0, 1: use bit5, 0: earc off
//Bit    5   ,     mute_contrl               unsigned, default = 0, value of manual mute control
//Bit    4:0 ,     reserved
#define EARC_RX_CMDC_TOP_CTRL1                     ((0x0001  << 2) + 0xfe333800)
//Bit      31:13,  reserved
//Bit      12:8,   reg_scan_reg             unsigned, RW, default = 0,
//Bit      7:5,    reserved
//Bit      4:0,    reg_top_soft_rst         unsigned, RW, default = 0,
#define EARC_RX_CMDC_TOP_CTRL2                     ((0x0002  << 2) + 0xfe333800)
//Bit      31,         reset_idle2_int                unsigned, default =0
//Bit      30,         reset_idle1_int                unsigned, default =0
//Bit      29,         reset_disc2_int                unsigned, default =0
//Bit      28,         reset_disc1_int                unsigned, default =0
//Bit      27,         reset_earc_int                 unsigned, default =0
//Bit      26,         reset_hb_status_int            unsigned, default =0
//Bit      25,         reset_losthb_int               unsigned, default =0
//Bit      24,         reset_timeout_int              unsigned, default =0
//Bit      23,         reset_status_ch_int            unsigned, default =0
//Bit      22,         reset_int_rec_invalid_id       unsigned, default =0
//Bit      21,         reset_int_rec_invalid_offset   unsigned, default =0
//Bit      20,         reset_int_rec_unexp            unsigned, default =0
//Bit      19,         reset_int_rec_ecc_err          unsigned, default =0
//Bit      18,         reset_int_rec_parity_err       unsigned, default =0
//Bit      17,         reset_int_recv_packet          unsigned, default =0
//Bit      16,         reset_int_rec_time_out         unsigned, default =0
//Bit      15:0,       reserved
#define EARC_RX_CMDC_TIMER_CTRL0                   ((0x0003  << 2) + 0xfe333800)
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL1                   ((0x0004  << 2) + 0xfe333800)
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL2                   ((0x0005  << 2) + 0xfe333800)
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL3                   ((0x0006  << 2) + 0xfe333800)
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_VSM_CTRL0                     ((0x0007  << 2) + 0xfe333800)
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state 		        unsigned, default = 0,  XX
//Bit      27,      arc_initiated 	        unsigned, default = 0,  XX
//Bit      26,      arc_terminated 	        unsigned, default = 0,  XX
//Bit      25,      arc_enable 		        unsigned, default = 0,  XX
//Bit      24,      man_hpd 		        unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel 		        unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state              unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en 	        unsigned, default = 0,  XX
//Bit    13:0,      reserved
#define EARC_RX_CMDC_VSM_CTRL1                     ((0x0008  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  idle done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  idle done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  idle done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  idle done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  idle done timing
#define EARC_RX_CMDC_VSM_CTRL2                     ((0x0009  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  comma off done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  comma off done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  comma off done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  comma off done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  comma off done timing
#define EARC_RX_CMDC_VSM_CTRL3                     ((0x000a  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  earc_time out timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  earc_time out timing
//Bit      6:4,      time_sel              unsigned, default = 0,  earc_time out timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  earc_time out timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  earc_time out timing
#define EARC_RX_CMDC_VSM_CTRL4                     ((0x000b  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  heartbeat lost timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  heartbeat lost timing
//Bit      6:4,      time_sel              unsigned, default = 0,  heartbeat lost timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  heartbeat lost timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  heartbeat lost timing
#define EARC_RX_CMDC_VSM_CTRL5                     ((0x000c  << 2) + 0xfe333800)
//Bit    31:16,      reserved
//Bit     15:8,      status_soft           unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define EARC_RX_CMDC_VSM_CTRL6                     ((0x000d  << 2) + 0xfe333800)
//Bit    31:17,      reserved
//Bit        16,     cntl_hpd_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      15:4,     cntl_hpd_valid_width  unsigned, default = 0,  in earc heartbeat det timing
//Bit      3:0,      cntl_hpd_glitch_width unsigned, default = 0,  in earc heartbeat det timing
#define EARC_RX_CMDC_VSM_CTRL7                     ((0x000e  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl7             unsigned,  default = 0,
#define EARC_RX_CMDC_VSM_CTRL8                     ((0x000f  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl8             unsigned,  default = 0,
#define EARC_RX_CMDC_VSM_CTRL9                     ((0x0010  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl9             unsigned,  default = 0,
#define EARC_RX_CMDC_SENDER_CTRL0                  ((0x0011  << 2) + 0xfe333800)
//Bit      31:2,     reserved
//Bit      1,        hb_chg_conf_auto          unsigned,  default = 0,
//Bit      0,        hb_chg_auto               unsigned,  default = 1,
#define EARC_RX_CMDC_PACKET_CTRL0                  ((0x0012  << 2) + 0xfe333800)
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst_man                unsigned, default = 0,  packet control
//Bit     28:24,      ready_th                    unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_th                 unsigned, default = 0,  packet control
//Bit       7:5,      reserved
//Bit         4,      sw_state_update             unsigned, default = 0,  packet control
//Bit       3:0,      sw_state                    unsigned, default = 0,  packet control
#define EARC_RX_CMDC_PACKET_CTRL1                  ((0x0013  << 2) + 0xfe333800)
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_reg_st                  unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_th                     unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_th                      unsigned, default = 0,
//Bit       7:0,      post_flag                   unsigned, default = 0,
#define EARC_RX_CMDC_PACKET_CTRL2                  ((0x0014  << 2) + 0xfe333800)
//Bit      31:0,      pre_flag                    unsigned, default = 0,  X
#define EARC_RX_CMDC_PACKET_CTRL3                  ((0x0015  << 2) + 0xfe333800)
//Bit      31,       cmdc_en                      unsigned, default = 0,  XX
//Bit      30,       cmdc_parity_mask             unsigned, default = 0,  XX
//Bit      29,       imeout_en                    unsigned, default = 0,  XX
//Bit      28,       ecc_check_en                 unsigned, default = 0,  XX
//Bit      27,       rev_debug_en                 unsigned, default = 0,  XX
//Bit     26:16,     reserved
//Bit      15:0,     timeout_th                   unsigned, default = 0,  X
#define EARC_RX_CMDC_PACKET_CTRL4                  ((0x0016  << 2) + 0xfe333800)
//Bit      31,       ack_ignore                   unsigned, default = 0,  XX
//Bit      30,       cmdc_tail_check_mask         unsigned, default = 0,  XX
//Bit     29:20,     reserved
//Bit      19:0,     cmdc_packet_head             unsigned, default = 0,  XX
#define EARC_RX_CMDC_PACKET_CTRL5                  ((0x0017  << 2) + 0xfe333800)
//Bit     31:24,     rev_debug_mask               unsigned, default = 0,  XX
//Bit     23:20,     reserved
//Bit      19:0,     cmdc_packet_head_mask        unsigned, default = 0,  XX
#define EARC_RX_CMDC_PACKET_CTRL6                  ((0x0018  << 2) + 0xfe333800)
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:9,     reserved
//Bit         8,     rec_packet_d                 unsigned, default = 0,  XX
//Bit         7,     rec_parity_err_cnt		      unsigned, default = 0,  XX
//Bit         6,     rec_ecc_err_cnt		      unsigned, default = 0,  XX
//Bit         5,     rec_unexp_cnt			      unsigned, default = 0,  XX
//Bit         4,     rec_invalid_offset_cnt	      unsigned, default = 0,  XX
//Bit         3,     rec_invalid_id_cnt		      unsigned, default = 0,  XX
//Bit         2,     rec_timeout_cnt		      unsigned, default = 0,  XX
//Bit         1,     rec_w_cnt				      unsigned, default = 0,  XX
//Bit         0,     rec_r_cnt				      unsigned, default = 0,  X
#define EARC_RX_CMDC_BIPHASE_CTRL0                 ((0x0019  << 2) + 0xfe333800)
//Bit     31:24,     reg_tns                       unsigned, default = 7, xx
//Bit     23:16,     delay_th                      unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define EARC_RX_CMDC_BIPHASE_CTRL1                 ((0x001a  << 2) + 0xfe333800)
//Bit     31:16,     reserved
//Bit        15,     ack_val_en                      unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     width                        unsigned, default = 0,  send
#define EARC_RX_CMDC_BIPHASE_CTRL2                 ((0x001b  << 2) + 0xfe333800)
//Bit      31,        ack_val_en                  unsigned, default = 0,  send
//Bit      30:20,     reserved
//Bit       19:16,    ack_rate                   unsigned, default = 0,  comma send
//Bit       15:0,     width                         unsigned, default = 0,  comma sen
#define EARC_RX_CMDC_BIPHASE_CTRL3                 ((0x001c  << 2) + 0xfe333800)
//Bit      31:0,     biphase_ctrl3                 unsigned, default = 0,
#define EARC_RX_CMDC_DEVICE_ID_CTRL                ((0x001d  << 2) + 0xfe333800)
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_w_r_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_w_r_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:16,     reserved
//Bit      15:8,     apb_w_r_id                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apb_w_r_start_addr            unsigned, default = 0, apb bus wr/read
#define EARC_RX_CMDC_DEVICE_WDATA                  ((0x001e  << 2) + 0xfe333800)
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/rea
#define EARC_RX_CMDC_DEVICE_RDATA                  ((0x001f  << 2) + 0xfe333800)
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/rea
#define EARC_RX_ANA_CTRL0                          ((0x0020  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl0                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL1                          ((0x0021  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl1                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL2                          ((0x0022  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl2                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL3                          ((0x0023  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl3                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL4                          ((0x0024  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl4                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL5                          ((0x0025  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl5                     unsigned, default = 0,
#define EARC_RX_ANA_STAT0                          ((0x0026  << 2) + 0xfe333800)
//Bit      31:0,     ro_ANA_status0              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS0                       ((0x0027  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status0              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS1                       ((0x0028  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status1              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS2                       ((0x0029  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status2              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS3                       ((0x002a  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status3              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS4                       ((0x002b  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status4              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS5                       ((0x002c  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status5              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS6                       ((0x002d  << 2) + 0xfe333800)
//Bit      31,         ro_idle2_int                unsigned, RO, dfault =0
//Bit      30,         ro_idle1_int                unsigned, RO, dfault =0
//Bit      29,         ro_disc2_int                unsigned, RO, dfault =0
//Bit      28,         ro_disc1_int                unsigned, RO, dfault =0
//Bit      27,         ro_earc_int                 unsigned, RO, dfault =0
//Bit      26,         ro_hb_status_int            unsigned, RO, dfault =0
//Bit      25,         ro_losthb_int               unsigned, RO, dfault =0
//Bit      24,         ro_timeout_int              unsigned, RO, dfault =0
//Bit      23,         ro_status_ch_int            unsigned, RO, dfault =0
//Bit      22,         ro_int_rec_invalid_id       unsigned, RO, dfault =0
//Bit      21,         ro_int_rec_invalid_offset   unsigned, RO, dfault =0
//Bit      20,         ro_int_rec_unexp            unsigned, RO, dfault =0
//Bit      19,         ro_int_rec_ecc_err          unsigned, RO, dfault =0
//Bit      18,         ro_int_rec_parity_err       unsigned, RO, dfault =0
//Bit      17,         ro_int_recv_packet          unsigned, RO, dfault =0
//Bit      16,         ro_int_rec_time_out         unsigned, RO, dfault =0
//Bit      15:0,       reserved
//
// Closing file:  ./earc_rx_cmdc.h
//
//========================================================================
//  AUDIO EARCRX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333c00
// -----------------------------------------------
//
// Reading file:  ./earcrx_dmac.h
//
#define EARCRX_DMAC_TOP_CTRL0                      ((0x0000  << 2) + 0xfe333c00)
//Bit   31,     reg_top_work_en               unsigned, default = 0, top work enable
//Bit   30,     reg_top_soft_rst              unsigned, default = 0, top soft reset
//Bit   29:23,  reserved
//Bit   22:20,  reg_dmac_debug_sel            unsigned, default = 0, dmac debug select
//Bit   19:18,  reserved
//Bit   17,     reg_dmac_valid_sel            unsigned, default = 0, dmac sync without clk
//Bit   16,     reg_dmac_without_clk          unsigned, default = 0, dmac sync without clk
//Bit   15,     reg_sf_sync_scan_reg          unsigned, default = 0, rst_n soft reset scan reg
//Bit   14,     reserved
//Bit   13,     reg_slow_sync_scan_reg        unsigned, default = 0, rst_n sync clk_slow scan reg
//Bit   12,     reg_a_sync_scan_reg           unsigned, default = 0, rst_n sync clk_analog scan reg
//Bit   11,     reg_slow_auto_gate            unsigned, default = 0, clk_slow auto gate
//Bit   10,     reg_a_auto_gate               unsigned, default = 0, clk_analog auto gate
//Bit   9:0,    reserved
#define EARCRX_DMAC_SYNC_CTRL0                     ((0x0001  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac sync module work enable
//Bit   30,     reg_rst_afifo_out_n           unsigned, default = 0, afifo out reset
//Bit   29,     reg_rst_afifo_in_n            unsigned, default = 0, afifo in reset
//Bit   28:17,  reserved
//Bit   16,     reg_ana_buf_data_sel_en       unsigned, default = 0, data from analog delay enable
//Bit   15,     reserved
//Bit   14:12,  reg_ana_buf_data_sel          unsigned, default = 0, delay cycles
//Bit   11,     reserved
//Bit   10:8,   reg_ana_clr_cnt               unsigned, default = 0, valid last how many 0 will clear
//Bit   7,      reserved
//Bit   6:4,    reg_ana_set_cnt               unsigned, default = 0, valid last how may 1 will set
//Bit   3:2,    reg_dmac_sync_valid_sel       unsigned, default = 0,
//Bit   1,      reserved
//Bit   0,      reg_dmacin_phase              unsigned, default = 0, dmac data invert
#define EARCRX_DMAC_SYNC_STAT0                     ((0x0002  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat0           unsigned, default = 0
#define EARCRX_SPDIFIN_SAMPLE_CTRL0                ((0x0003  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, spdif in sample enable
//Bit   30,     reg_spdifin_phase             unsigned, default = 0, spdif in invert
//Bit   29,     reg_debug_en                  unsigned, default = 0, debug single enable
//Bit   28,     reg_width_sel                 unsigned, default = 0, 0 detect by max_width 1 detect by min_width
//Bit   27:23,  reserved
//Bit   22:20,  reg_sample_mode               unsigned, default = 0, value
//Bit   19:0,   reg_base_timer                unsigned, default = 0, base timer to detect sample mode change
#define EARCRX_SPDIFIN_SAMPLE_CTRL1                ((0x0004  << 2) + 0xfe333c00)
//Bit   31,     reg_force_sample_mode         unsigned, default = 0, 0 auto detect sample mode 1 force a fixed sample mode with reg_sample_mode
//Bit   30,     reserved
//Bit   29:20,  reg_sample_mode0_timer_th     unsigned, default = 0, mode0 threathold time
//Bit   19:10,  reg_sample_mode1_timer_th     unsigned, default = 0, mode1 threathold time
//Bit   9:0,    reg_sample_mode2_timer_th     unsigned, default = 0, mode2 threathold time
#define EARCRX_SPDIFIN_SAMPLE_CTRL2                ((0x0005  << 2) + 0xfe333c00)
//Bit   31:30,  reserved
//Bit   29:20,  reg_sample_mode3_timer_th     unsigned, default = 0, mode3 threathold time
//Bit   19:10,  reg_sample_mode4_timer_th     unsigned, default = 0, mode4 threathold time
//Bit   9:0,    reg_sample_mode5_timer_th     unsigned, default = 0, mode5 threathold time
#define EARCRX_SPDIFIN_SAMPLE_CTRL3                ((0x0006  << 2) + 0xfe333c00)
//Bit   31:24,  reg_sample_mode0_timer        unsigned, default = 0, mode0 sample time
//Bit   23:16,  reg_sample_mode1_timer        unsigned, default = 0, mode1 sample time
//Bit   15:8,   reg_sample_mode2_timer        unsigned, default = 0, mode2 sample time
//Bit   7:0,    reg_sample_mode3_timer        unsigned, default = 0, mode3 sample time
#define EARCRX_SPDIFIN_SAMPLE_CTRL4                ((0x0007  << 2) + 0xfe333c00)
//Bit   31:24,  reg_sample_mode4_timer        unsigned, default = 0, mode4 sample time
//Bit   23:16,  reg_sample_mode5_timer        unsigned, default = 0, mode5 sample time
//Bit   15:8,   reg_sample_mode6_timer        unsigned, default = 0, mode6 sample time
//Bit   7:0,    reserved
#define EARCRX_SPDIFIN_SAMPLE_CTRL5                ((0x0008  << 2) + 0xfe333c00)
//Bit   31,     reg_sq_filt_en                unsigned, default = 0, dmac_sqout filter enable
//Bit   30,     reg_spdif_sqout_phase         unsigned, default = 0, dmac_sqout invert
//Bit   29:27,  reg_filter_tick_sel           unsigned, default = 0, dmac_sqout filter tick select
//Bit   26:24,  reg_filter_sel                unsigned, default = 0, dmac_sqout filter select
//Bit   23:20,  reserved
//Bit   19:0,   reg_sq_filt_timer             unsigned, default = 0, dmac_sqout filter tick
#define EARCRX_SPDIFIN_SAMPLE_STAT0                ((0x0009  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_sample_stat0      unsigned, default = 0
#define EARCRX_SPDIFIN_SAMPLE_STAT1                ((0x000a  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_sample_stat1      unsigned, default = 0
#define EARCRX_SPDIFIN_MUTE_VAL                    ((0x000b  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_mute_val          unsigned, default = 0, spdif in mute value
#define EARCRX_SPDIFIN_CTRL0                       ((0x000c  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, spdifin wore enable
//Bit   30,     reg_chnum_sel                 unsigned, default = 0, 0 ch_num = 0~383  1 ch_num = 0~1
//Bit   29:28,  reserved
//Bit   27,     reg_debug_en                  unsigned, default = 0, debug enable
//Bit   26,     reg_chnum_en                  unsigned, default = 0, star add ch_cnt to ch_num
//Bit   25,     reg_findpapb_en               unsigned, default = 0, papb check enalbe
//Bit   24,     reg_nonpcm2pcm_en             unsigned, default = 0, nonpcm2pcm_th enable
//Bit   23:12,  reg_nonpcm2pcm_th             unsigned, default = 0, if long time didn't detect PaPb again,will generate irq
//Bit   11:8,   reg_ch_status_sel             unsigned, default = 0, for stat1/stat2
//Bit   7,      reg_mute_l                    unsigned, default = 0, mute channel l
//Bit   6,      reg_mute_r                    unsigned, default = 0, mute channel r
//Bit   5:4,    reserved
//Bit   3,      reg_check_valid               unsigned, default = 0, valid check enable
//Bit   2,      reg_check_parity              unsigned, default = 0, parity check enable
//Bit   1,      reg_invert_data               unsigned, default = 0, spdif data invert
//Bit   0,      reserved
#define EARCRX_SPDIFIN_CTRL1                       ((0x000d  << 2) + 0xfe333c00)
//Bit   31:24,  reserved
//Bit   31:24,  reg_clr_internal_sts          unsigned, default = 0, internal irq status clear
//Bit   23:12,  reg_mute_block_check_thd      unsigned, default = 0, mute block check time thd
//Bit   11:9,   reg_mute_block_check_tick_sel unsigned, default = 0, mute block check tick sel
//Bit   8,      reg_papb_ext_sync             unsigned, default = 0, ext 0 sync check for papb
//Bit   7:0,    reg_papb_ext_mask             unsigned, default = 0, sync 0 mask
#define EARCRX_SPDIFIN_CTRL2                       ((0x000e  << 2) + 0xfe333c00)
//Bit   31:24,  reg_mute_bit                   unsigned, default = 0, mute bit in channel st
//Bit   23:19,  reg_mute_block_num             unsigned, default = 0, mute min block number to declare
//Bit   18,     reg_mute_lr_ch_sel             unsigned, default = 0, mute bit in channel st L or R
//Bit   17,     reg_mute_block_check_en        unsigned, default = 0, mute block number check enable
//Bit   16,     reg_earc_cps_chst_clr_en       unsigned, default = 0, auto clear compress mode when channel status not compress
//Bit   15,     reg_earc_cps_nonpcm2pcm_clr_en unsigned, default = 0, auto clear compress mode when nonpcm2pcm
//Bit   14,     reg_earc_auto                  unsigned, default = 0, auto change earc/arc
//Bit   13,     reg_earcin_papb_lr             unsigned, default = 0, user l or r channle status to check papb
//Bit   12,     reg_earcin_check_papb          unsigned, default = 0, 0:data valid after 1 block;1: in 1st block if exit papb ,data valid after papb
//Bit   11,     reg_earcin_start_papb          unsigned, default = 0, start write toddr 1:from papb check,0 from preamble Z,valid when reg_earcin_check_papb set
//Bit   10,     reg_formatchange_auto_rst      unsigned, default = 0, auto reset will detect format change
//Bit   9,      reg_earcin_cpsb_pcpd_sel      unsigned, default = 0, compress B pcpd select : 1:next 4th subframe data 0:next sub frame data
//Bit   8:4,    reg_earc_papb_msb             unsigned, default = 0, papb msb position in data
//Bit   3,      reg_earcin_spdif_force        unsigned, default = 0, when in arc mode,spdif on force enable
//Bit   2,      reg_earcin_spdif_force_set    unsigned, default = 0, force value
//Bit   1,      reg_earcin_mode_force         unsigned, default = 0, earc mode force enable
//Bit   0,      reg_earcin_mode_force_set     unsigned, default = 0, force value
#define EARCRX_SPDIFIN_CTRL3                       ((0x000f  << 2) + 0xfe333c00)
//Bit   31:16,  reg_earc_pa_value             unsigned, default = 0, earc mode pa value
//Bit   15:0,   reg_earc_pb_value             unsigned, default = 0, earc mode pb value
#define EARCRX_SPDIFIN_STAT0                       ((0x0010  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat0             unsigned, default = 0
#define EARCRX_SPDIFIN_STAT1                       ((0x0011  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat1             unsigned, default = 0
#define EARCRX_SPDIFIN_STAT2                       ((0x0012  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat2             unsigned, default = 0
#define EARCRX_DMAC_UBIT_CTRL0                     ((0x0013  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac user bit decode enable
//Bit   30:24,  reg_iu_sync                   unsigned, default = 0, iu sync value
//Bit   23:16,  reg_fifo_thd                  unsigned, default = 0, generate irq when fifo level pass some threshold
//Bit   15,     reg_max_dist_en               unsigned, default = 0, max distance bewteen IUs to set lost
//Bit   14,     reg_iu_sync_en                unsigned, default = 0, iu sync code enable 0 : all iu to fifo 1 only sync iu packet to fifo
//Bit   13:12,  reg_user_lr                   unsigned, default = 0, 00 off 01 use l channel userbit 10 use r channel userbit 11 user lr channel userbit
//Bit   11:8,   reg_max_dist                  unsigned, default = 0, max distance bewteen IUs value
//Bit   7,      reg_fifo_thd_en               unsigned, default = 0, fifo_thd irq enable
//Bit   6,      reg_fifo_lost_init_en         unsigned, default = 0, when lost,initial fifo
//Bit   5,      reg_fifo_init                 unsigned, default = 0, fifo initial
//Bit   4:0,    reg_data_bit                  unsigned, default = 0, user bit position in data
#define EARCRX_IU_RDATA                            ((0x0014  << 2) + 0xfe333c00)
//Bit   31:8,   reserved
//Bit   7:0,    i_iu_rdata                    unsigned, default = 0, iu data,read only
#define EARCRX_DMAC_UBIT_STAT0                     ((0x0015  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_ubit_stat0           unsigned, default = 0
#define EARCRX_ERR_CORRECT_CTRL0                   ((0x0016  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, err correct work enable
//Bit   30,     reserved
//Bit   29,     reg_rst_afifo_out_n           unsigned, default = 0, reset afifo out side
//Bit   28,     reg_rst_afifo_in_n            unsigned, default = 0, reset afifo in side
//Bit   27,     reg_lr_check                  unsigned, default = 0, enable lr_check
//Bit   26:7,   reserved
//Bit   6,      reg_bchout_data_ml            unsigned, default = 0, bch output 16bit data msb is 27 or 19
//Bit   5,      reg_bchout_data_rsv           unsigned, default = 0, bch output data revers
//Bit   4,      reg_bchin_ecc_ml              unsigned, default = 0, bch input ecc msb/lsb
//Bit   3,      reg_bchin_ecc_rsv             unsigned, default = 0, bch input ecc revers
//Bit   2,      reg_bchin_data_rsv            unsigned, default = 0, bch input data revers
//Bit   1,      reg_force_set                 unsigned, default = 0, 0 off 1 compress audio mode
//Bit   0,      reg_force_en                  unsigned, default = 0, force work mode enable
#define EARCRX_ERR_CORRECT_STAT0                   ((0x0017  << 2) + 0xfe333c00)
//Bit   31:0,   reg_err_correct_stat0         unsigned, default = 0
#define EARCRX_ANA_RST_CTRL0                       ((0x0018  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, analog reset check work enable
//Bit   30,     reg_ana_rst_sf_en             unsigned, default = 0, analog reset from register enable
//Bit   29,     reg_ana_rst_sf                unsigned, default = 0, soft reset value
//Bit   28,     reserved
//Bit   27:23,  reg_new_format_pos_num        unsigned, default = 0, when new format data in, hold reset after N posedge
//Bit   22:20,  reg_dmacrx_div2_thd_tick_sel  unsigned, default = 0, earcrx_div2 hold threshold tick select
//Bit   19:0,   reg_earcrx_div2_thd           unsigned, default = 0, earcrx_div2 hold threshold
#define EARCRX_ANA_RST_CTRL1                       ((0x0019  << 2) + 0xfe333c00)
//Bit   31,     reg_dmacrx_data_filt_en       unsigned, default = 0, filter enable
//Bit   30:28,  reg_dmacrx_data_filter_sel    unsigned, default = 0, filter select
//Bit   27:25,  reg_dmacrx_data_tick_sel      unsigned, default = 0, filter tick sel
//Bit   24:16,  reg_dmacrx_data_time          unsigned, default = 0, filter tick time
//Bit   15,     reg_dmacrx_sqout_filt_en      unsigned, default = 0, filter enable
//Bit   14:12,  reg_dmacrx_sqout_filter_sel   unsigned, default = 0, filter select
//Bit   11:9,   reg_dmacrx_sqout_tick_sel     unsigned, default = 0, filter tick sel
//Bit   8:0,    reg_dmacrx_sqout_time         unsigned, default = 0, filter tick time
#define EARCRX_SPDIFIN_CTRL4                       ((0x0020  << 2) + 0xfe333c00)
//Bit   31,     reserved
//Bit   30,     reg_add_ch_r                        unsigned, default = 0, reg_add_ch_r
//Bit   29,     reg_bc_val0_en                      unsigned, default = 0, reg_bc_val0_en
//Bit   28:20,  reg_stable_mask                     unsigned, default = 0, reg_stable_mask
//Bit   19:16,  reg_stable_zcnt                     unsigned, default = 0, reg_stable_zcnt
//Bit   15:0 ,  reserved
#define EARCRX_SPDIFIN_CTRL5                       ((0x0021  << 2) + 0xfe333c00)
//Bit   31,     reg_st_timeout_sts_clr              unsigned, default = 0, reg_st_timeout_sts_clr
//Bit   30:28,  reserved
//Bit   27:16,  reg_st_timeout_check_thd            unsigned, default = 0, reg_st_timeout_check_thd
//Bit   15,     reserved
//Bit   14:12,  reg_st_timeout_check_tick_sel       unsigned, default = 0, reg_st_timeout_check_tick_sel
//Bit   11,     reg_st_timeout_check_en             unsigned, default = 0, reg_st_timeout_check_en
//Bit   10:9,   reserved
//Bit   8:0,    reg_stable_int_mask                 unsigned, default = 0, reg_stable_int_mask
#define EARCRX_SPDIFIN_CTRL6                       ((0x0022  << 2) + 0xfe333c00)
//Bit   31:28,  reserved
//Bit   27      reg_chnum_mult_mode                 unsigned, default = 0
//Bit   26      reg_chnum_max_force                  unsigned, default = 0
//Bit   25:20   reg_chnum_max_val                   unsigned, default = 0
//Bit   19:17   reserved
//Bit   16,     reg_check_time_en                   unsigned, default = 0, reg_check_time_en
//Bit   15:0,   reg_check_time_thd                  unsigned, default = 0, reg_check_time_thd
#define EARCRX_DMAC_SYNC_CTRL1                     ((0x0023  << 2) + 0xfe333c00)
//Bit   31:19,  reserved
//Bit   18,     reg_auto_neg_int_en                 unsigned, default = 0, reg_auto_neg_int_en
//Bit   17,     reg_auto_stable_clr                 unsigned, default = 0, reg_auto_stable_clr
//Bit   16,     reg_auto_stable_en                  unsigned, default = 0, reg_auto_stable_en
//Bit   15:0,   reg_auto_stable_thd                 unsigned, default = 0, reg_auto_stable_thd
#define EARCRX_SPDIFIN_SAMPLE_CTRL6                ((0x0024  << 2) + 0xfe333c00)
//Bit   31:18,  reserved
//Bit   17,     reg_hold_tri_sample                 unsigned, default = 0, reg_hold_tri_sample
//Bit   16,     reg_sample_mode_filter_en           unsigned, default = 0, reg_sample_mode_filter_en
//Bit   15:8,   reg_stable_cyc_min                  unsigned, default = 0, reg_stable_cyc_min
//Bit   7:0,    reg_stable_cyc_max                  unsigned, default = 0, reg_stable_cyc_max
#define EARCRX_DMAC_SYNC_CTRL2                     ((0x0025  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t0_err_clr             unsigned, default = 0, reg_unstable_t0_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t0_check_en            unsigned, default = 0, reg_unstable_t0_check_en
//Bit   18:16,  reg_unstable_t0_tick_sel            unsigned, default = 0, reg_unstable_t0_tick_sel
//Bit   15:0,   reg_unstable_t0_thd                 unsigned, default = 0, reg_unstable_t0_thd
#define EARCRX_DMAC_SYNC_CTRL3                     ((0x0026  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t1_err_clr             unsigned, default = 0, reg_unstable_t1_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t1_check_en            unsigned, default = 0, reg_unstable_t1_check_en
//Bit   18:16,  reg_unstable_t1_tick_sel            unsigned, default = 0, reg_unstable_t1_tick_sel
//Bit   15:0,   reg_unstable_t1_thd                 unsigned, default = 0, reg_unstable_t1_thd
#define EARCRX_DMAC_SYNC_CTRL4                     ((0x0027  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t2_err_clr             unsigned, default = 0, reg_unstable_t2_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t2_check_en            unsigned, default = 0, reg_unstable_t2_check_en
//Bit   18:16,  reg_unstable_t2_tick_sel            unsigned, default = 0, reg_unstable_t2_tick_sel
//Bit   15:0,   reg_unstable_t2_thd                 unsigned, default = 0, reg_unstable_t2_thd
#define EARCRX_DMAC_SYNC_STAT1                     ((0x0028  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat1           unsigned, default = 0
#define EARCRX_DMAC_SYNC_STAT2                     ((0x0029  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat2           unsigned, default = 0
#define EARCRX_DMAC_SYNC_STAT3                     ((0x002a  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat3           unsigned, default = 0
//
// Closing file:  ./earcrx_dmac.h
//
//========================================================================
//  AUDIO EARCRX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333e00
// -----------------------------------------------
//
// Reading file:  ./earcrx_top.h
//
#define EARCRX_TOP_CTRL0                           ((0x0000  << 2) + 0xfe333e00)
//Bit   31:10,  reserved
//Bit   9:8,    reg_top_debug_sel             unsigned, default = 0, top debug select
//Bit   7,      reg_spdif_rx_en_force         unsigned, default = 0, force spdif_rx_en to reg_spdif_rx_en_force_value
//Bit   6,      reg_spdif_rx_en_force_value   unsigned, default = 0, value
//Bit   5,      reg_spdif_rx_sqen_force       unsigned, default = 0, force spdif_rx_sqen to reg_spdif_rx_sqe
//Bit   4,      reg_spdif_rx_sqen_force_value unsigned, default = 0, value
//Bit   3,      reg_dmacrx_en_force           unsigned, default = 0, force dmacrx_en to reg_dmacrx_en_force_value
//Bit   2,      reg_dmacrx_en_force_value     unsigned, default = 0, value
//Bit   1,      reg_dmacrx_sqen_force         unsigned, default = 0, force dmacrx_sqen to reg_dmacrx_sqen_force_value
//Bit   0,      reg_dmacrx_sqen_force_value   unsigned, default = 0, value
#define EARCRX_DMAC_INT_MASK                       ((0x0001  << 2) + 0xfe333e00)
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define EARCRX_DMAC_INT_PENDING                    ((0x0002  << 2) + 0xfe333e00)
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define EARCRX_CMDC_INT_MASK                       ((0x0003  << 2) + 0xfe333e00)
//Bit   31:16,  reserved
//Bit   15:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define EARCRX_CMDC_INT_PENDING                    ((0x0004  << 2) + 0xfe333e00)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define EARCRX_ANA_CTRL0                           ((0x0005  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_ANA_CTRL1                           ((0x0006  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_ANA_STAT0                           ((0x0007  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL0                           ((0x0008  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL1                           ((0x0009  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL2                           ((0x000a  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL3                           ((0x000b  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_STAT0                           ((0x000c  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  ./earcrx_top.h
//
//========================================================================
//  AUDIO RESAMPLEB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334000
// -----------------------------------------------
//
// Reading file:  ./RESAMPLEB.h
//
#define AUDIO_RSAMPB_CTRL0                         ((0x0000  << 2) + 0xfe334000)
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define AUDIO_RSAMPB_CTRL1                         ((0x0001  << 2) + 0xfe334000)
//Bit   31:27      reg_in_lsb        //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:5        reserved          //unsigned  , default =2;
//Bit   4:0        reg_inp_mux       //unsigned  , default =0;
#define AUDIO_RSAMPB_CTRL2                         ((0x0002  << 2) + 0xfe334000)
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define AUDIO_RSAMPB_PHSINIT                       ((0x0003  << 2) + 0xfe334000)
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define AUDIO_RSAMPB_PHSSTEP                       ((0x0004  << 2) + 0xfe334000)
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define AUDIO_RSAMPB_SHIFT                         ((0x0005  << 2) + 0xfe334000)
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define AUDIO_RSAMPB_ADJ_CTRL0                     ((0x0006  << 2) + 0xfe334000)
//Bit   31:7        reserved                //unsigned
//Bit   6           reg_lock_vld_sel        //unsigned , default = 0;
//Bit   5           reg_loop_dif_clr_en     //unsigned , default = 0;
//Bit   4           reg_aout_force_en       //unsigned , default = 0;
//Bit   3           reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define AUDIO_RSAMPB_ADJ_CTRL1                     ((0x0007  << 2) + 0xfe334000)
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define AUDIO_RSAMPB_ADJ_SFT                       ((0x0008  << 2) + 0xfe334000)
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define AUDIO_RSAMPB_ADJ_IDET_LEN                  ((0x0009  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define AUDIO_RSAMPB_ADJ_FORCE                     ((0x000a  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define AUDIO_RSAMPB_ADJ_KI_FORCE                  ((0x000b  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define AUDIO_RSAMPB_WATCHDOG_THRD                 ((0x000c  << 2) + 0xfe334000)
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define AUDIO_RSAMPB_DBG_INFO                      ((0x000d  << 2) + 0xfe334000)
//Bit   31:16      reg_aout_force_hi        //unsigned , default = 0;
//Bit   15:7       reserved                 //unsigned , default = 0;
//Bit   6          reg_rsamp_dbgcnt_clr     //unsigned , default = 0;
//Bit   5          reg_rsamp_dbgcnt_vldsel  //unsigned , default = 0;
//Bit   4          reg_rsamp_dbgcnt_en      //unsigned , default = 0;
//Bit   3          reserved                 //unsigned , default = 0;
//Bit   2:0        reg_watchdog_rstsel      //unsigned , default = 4;
#define AUDIO_RSAMPB_AOUT_FORCE                    ((0x000e  << 2) + 0xfe334000)
//Bit   31:0       reg_aout_force_lo        //unsigned , default = 0;
#define AUDIO_RSAMPB_IRQ_CTRL                      ((0x000f  << 2) + 0xfe334000)
//Bit   31:16      reg_irq_thrd             //unsigned , default = 0;
//Bit   15:12      reserved                 //unsigned , default = 0;
//Bit   11:8       reg_irq_sel              //unsigned , default = 0;
//Bit   7:4        reg_irq_clr              //unsigned , default = 0;
//Bit   3:0        reg_irq_en               //unsigned , default = 0;
#define AUDIO_RSAMPB_RO_STATUS                     ((0x0010  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define AUDIO_RSAMPB_RO_ADJ_FREQ                   ((0x0011  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_adj_freq
#define AUDIO_RSAMPB_RO_ADJ_DIFF_BAK               ((0x0012  << 2) + 0xfe334000)
//Bit   31:0       ro_det_diff_bak
#define AUDIO_RSAMPB_RO_ADJ_DIFF_DLT               ((0x0013  << 2) + 0xfe334000)
//Bit   31:0       ro_det_diff_dlt
#define AUDIO_RSAMPB_RO_ADJ_PHS_ERR                ((0x0014  << 2) + 0xfe334000)
//Bit   31:0       ro_det_phase_err
#define AUDIO_RSAMPB_RO_ADJ_KI_OUT                 ((0x0015  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_ki_out
#define AUDIO_RSAMPB_RO_IN_CNT                     ((0x0016  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_in_cnt
#define AUDIO_RSAMPB_RO_OUT_CNT                    ((0x0017  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_out_cnt
#define AUDIO_RSAMPB_RO_ADJ_PHS_ERR_VAR            ((0x0018  << 2) + 0xfe334000)
//Bit   31:0       ro_det_phase_err_var
#define AUDIO_RSAMPB_POST_COEF0                    ((0x0020  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF1                    ((0x0021  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF2                    ((0x0022  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF3                    ((0x0023  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF4                    ((0x0024  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define AUDIO_RSAMPB_AA_COEF_ADDR                  ((0x0030  << 2) + 0xfe334000)
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define AUDIO_RSAMPB_AA_COEF_DATA                  ((0x0031  << 2) + 0xfe334000)
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define AUDIO_RSAMPB_SINC_COEF_ADDR                ((0x0040  << 2) + 0xfe334000)
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define AUDIO_RSAMPB_SINC_COEF_DATA                ((0x0041  << 2) + 0xfe334000)
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  ./RESAMPLEB.h
//
//
// Closing file:  ./REG_LIST_AUDIO_RTL.h
//
//
// Reading file:  ./REG_LIST_DSP_RTL.h
//
// synopsys translate_off
// synopsys translate_on
//========================================================================
//  DSPA - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe340000
// -----------------------------------------------
#define DSP_CFG0                                   ((0x0000  << 2) + 0xfe340000)
#define DSP_CFG1                                   ((0x0001  << 2) + 0xfe340000)
#define DSP_CFG2                                   ((0x0002  << 2) + 0xfe340000)
#define DSP_IMPWIRE                                ((0x0003  << 2) + 0xfe340000)
#define DSP_RESET_VEC                              ((0x0004  << 2) + 0xfe340000)
#define DSP_SEC_CFG0                               ((0x0006  << 2) + 0xfe340000)
#define DSP_SEC_CFG1                               ((0x0007  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL0                              ((0x0010  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL1                              ((0x0011  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL2                              ((0x0012  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL3                              ((0x0013  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL4                              ((0x0014  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL5                              ((0x0015  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL6                              ((0x0016  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL7                              ((0x0017  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL8                              ((0x0018  << 2) + 0xfe340000)
#define DSP_IRQ_CTRL9                              ((0x0019  << 2) + 0xfe340000)
#define DSP_IRQ_STS                                ((0x001f  << 2) + 0xfe340000)
#define DSP_REMAP0                                 ((0x0020  << 2) + 0xfe340000)
#define DSP_REMAP1                                 ((0x0021  << 2) + 0xfe340000)
#define DSP_REMAP2                                 ((0x0022  << 2) + 0xfe340000)
#define DSP_STS0                                   ((0x0040  << 2) + 0xfe340000)
#define DSP_STS1                                   ((0x0041  << 2) + 0xfe340000)
#define DSP_STS2                                   ((0x0042  << 2) + 0xfe340000)
#define DSP_STS3                                   ((0x0043  << 2) + 0xfe340000)
#define DSP_STS4                                   ((0x0044  << 2) + 0xfe340000)
#define DSP_STS5                                   ((0x0045  << 2) + 0xfe340000)
#define DSP_QIF_CTRL                               ((0x0080  << 2) + 0xfe340000)
#define DSP_QIF_STS                                ((0x0081  << 2) + 0xfe340000)
#define DSP_WRFIFO_TOCPUA                          ((0x0082  << 2) + 0xfe340000)
#define DSP_WRFIFO_TOCPUB                          ((0x0083  << 2) + 0xfe340000)
#define DSP_WRFIFO_TODSP                           ((0x0084  << 2) + 0xfe340000)
#define DSP_RDFIFO_FRCPUA                          ((0x0088  << 2) + 0xfe340000)
#define DSP_RDFIFO_FRCPUB                          ((0x0089  << 2) + 0xfe340000)
#define DSP_RDFIFO_FRDSP                           ((0x008a  << 2) + 0xfe340000)
#define DSP_PM_CTRL                                ((0x0090  << 2) + 0xfe340000)
#define DSP_PDEBUGDATA_STS                         ((0x0091  << 2) + 0xfe340000)
#define DSP_PDEBUGINST_STS                         ((0x0092  << 2) + 0xfe340000)
#define DSP_PDEBUGLS0STAT_STS                      ((0x0093  << 2) + 0xfe340000)
#define DSP_PDEBUGLS1STAT_STS                      ((0x0094  << 2) + 0xfe340000)
#define DSP_PDEBUGOUTPIF_STS                       ((0x0095  << 2) + 0xfe340000)
#define DSP_PDEBUGPC_STS                           ((0x0096  << 2) + 0xfe340000)
#define DSP_PDEBUGPREFETCHL1FILL_STS               ((0x0097  << 2) + 0xfe340000)
#define DSP_PDEBUGPREFETCHLOOKUP_STS               ((0x0098  << 2) + 0xfe340000)
#define DSP_PDEBUGSTATUS_STS                       ((0x0099  << 2) + 0xfe340000)
//========================================================================
//  DSPB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe350000
// -----------------------------------------------
#define DSPB_CFG0                                  ((0x0000  << 2) + 0xfe350000)
#define DSPB_CFG1                                  ((0x0001  << 2) + 0xfe350000)
#define DSPB_CFG2                                  ((0x0002  << 2) + 0xfe350000)
#define DSPB_IMPWIRE                               ((0x0003  << 2) + 0xfe350000)
#define DSPB_RESET_VEC                             ((0x0004  << 2) + 0xfe350000)
#define DSPB_SEC_CFG0                              ((0x0006  << 2) + 0xfe350000)
#define DSPB_SEC_CFG1                              ((0x0007  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL0                             ((0x0010  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL1                             ((0x0011  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL2                             ((0x0012  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL3                             ((0x0013  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL4                             ((0x0014  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL5                             ((0x0015  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL6                             ((0x0016  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL7                             ((0x0017  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL8                             ((0x0018  << 2) + 0xfe350000)
#define DSPB_IRQ_CTRL9                             ((0x0019  << 2) + 0xfe350000)
#define DSPB_IRQ_STS                               ((0x001f  << 2) + 0xfe350000)
#define DSPB_REMAP0                                ((0x0020  << 2) + 0xfe350000)
#define DSPB_REMAP1                                ((0x0021  << 2) + 0xfe350000)
#define DSPB_REMAP2                                ((0x0022  << 2) + 0xfe350000)
#define DSPB_STS0                                  ((0x0040  << 2) + 0xfe350000)
#define DSPB_STS1                                  ((0x0041  << 2) + 0xfe350000)
#define DSPB_STS2                                  ((0x0042  << 2) + 0xfe350000)
#define DSPB_STS3                                  ((0x0043  << 2) + 0xfe350000)
#define DSPB_STS4                                  ((0x0044  << 2) + 0xfe350000)
#define DSPB_STS5                                  ((0x0045  << 2) + 0xfe350000)
#define DSPB_QIF_CTRL                              ((0x0080  << 2) + 0xfe350000)
#define DSPB_QIF_STS                               ((0x0081  << 2) + 0xfe350000)
#define DSPB_WRFIFO_TOCPUA                         ((0x0082  << 2) + 0xfe350000)
#define DSPB_WRFIFO_TOCPUB                         ((0x0083  << 2) + 0xfe350000)
#define DSPB_WRFIFO_TODSP                          ((0x0084  << 2) + 0xfe350000)
#define DSPB_RDFIFO_FRCPUA                         ((0x0088  << 2) + 0xfe350000)
#define DSPB_RDFIFO_FRCPUB                         ((0x0089  << 2) + 0xfe350000)
#define DSPB_RDFIFO_FRDSP                          ((0x008a  << 2) + 0xfe350000)
#define DSPB_PM_CTRL                               ((0x0090  << 2) + 0xfe350000)
#define DSPB_PDEBUGDATA_STS                        ((0x0091  << 2) + 0xfe350000)
#define DSPB_PDEBUGINST_STS                        ((0x0092  << 2) + 0xfe350000)
#define DSPB_PDEBUGLS0STAT_STS                     ((0x0093  << 2) + 0xfe350000)
#define DSPB_PDEBUGLS1STAT_STS                     ((0x0094  << 2) + 0xfe350000)
#define DSPB_PDEBUGOUTPIF_STS                      ((0x0095  << 2) + 0xfe350000)
#define DSPB_PDEBUGPC_STS                          ((0x0096  << 2) + 0xfe350000)
#define DSPB_PDEBUGPREFETCHL1FILL_STS              ((0x0097  << 2) + 0xfe350000)
#define DSPB_PDEBUGPREFETCHLOOKUP_STS              ((0x0098  << 2) + 0xfe350000)
#define DSPB_PDEBUGSTATUS_STS                      ((0x0099  << 2) + 0xfe350000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./REG_LIST_DSP_RTL.h
//
//
// Reading file:  ./REG_LIST_SECURITY_RTL.h
//
//
//***************************************************************************
// Title:      REG_LIST_SECURITY_RTL.h
//
// Author:     shan.luan
//
// Created:    23:09:44 28/02/2020
//
// Description:
//
// Note:
//
// History:
//
//***************************************************************************
//========================================================================
//  TS_DEMUX_REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe444000
// -----------------------------------------------
#define RCH_READY_CHANNEL_0                        ((0x0000  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_1                        ((0x0008  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_2                        ((0x0010  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_3                        ((0x0018  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_4                        ((0x0020  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_5                        ((0x0028  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_6                        ((0x0030  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_7                        ((0x0038  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_8                        ((0x0040  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_9                        ((0x0048  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_10                       ((0x0050  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_11                       ((0x0058  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_12                       ((0x0060  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_13                       ((0x0068  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_14                       ((0x0070  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_15                       ((0x0078  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_16                       ((0x0080  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_17                       ((0x0088  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_18                       ((0x0090  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_19                       ((0x0098  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_20                       ((0x00a0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_21                       ((0x00a8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_22                       ((0x00b0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_23                       ((0x00b8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_24                       ((0x00c0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_25                       ((0x00c8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_26                       ((0x00d0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_27                       ((0x00d8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_28                       ((0x00e0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_29                       ((0x00e8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_30                       ((0x00f0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_31                       ((0x00f8  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_0                       ((0x0001  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_1                       ((0x0009  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_2                       ((0x0011  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_3                       ((0x0019  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_4                       ((0x0021  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_5                       ((0x0029  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_6                       ((0x0031  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_7                       ((0x0039  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_8                       ((0x0041  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_9                       ((0x0049  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_10                      ((0x0051  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_11                      ((0x0059  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_12                      ((0x0061  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_13                      ((0x0069  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_14                      ((0x0071  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_15                      ((0x0079  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_16                      ((0x0081  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_17                      ((0x0089  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_18                      ((0x0091  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_19                      ((0x0099  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_20                      ((0x00a1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_21                      ((0x00a9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_22                      ((0x00b1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_23                      ((0x00b9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_24                      ((0x00c1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_25                      ((0x00c9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_26                      ((0x00d1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_27                      ((0x00d9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_28                      ((0x00e1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_29                      ((0x00e9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_30                      ((0x00f1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_31                      ((0x00f9  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_0                          ((0x0002  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_1                          ((0x000a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_2                          ((0x0012  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_3                          ((0x001a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_4                          ((0x0022  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_5                          ((0x002a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_6                          ((0x0032  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_7                          ((0x003a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_8                          ((0x0042  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_9                          ((0x004a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_10                         ((0x0052  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_11                         ((0x005a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_12                         ((0x0062  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_13                         ((0x006a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_14                         ((0x0072  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_15                         ((0x007a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_16                         ((0x0082  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_17                         ((0x008a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_18                         ((0x0092  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_19                         ((0x009a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_20                         ((0x00a2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_21                         ((0x00aa  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_22                         ((0x00b2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_23                         ((0x00ba  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_24                         ((0x00c2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_25                         ((0x00ca  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_26                         ((0x00d2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_27                         ((0x00da  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_28                         ((0x00e2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_29                         ((0x00ea  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_30                         ((0x00f2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_31                         ((0x00fa  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_0                         ((0x0003  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_1                         ((0x000b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_2                         ((0x0013  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_3                         ((0x001b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_4                         ((0x0023  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_5                         ((0x002b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_6                         ((0x0033  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_7                         ((0x003b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_8                         ((0x0043  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_9                         ((0x004b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_10                        ((0x0053  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_11                        ((0x005b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_12                        ((0x0063  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_13                        ((0x006b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_14                        ((0x0073  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_15                        ((0x007b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_16                        ((0x0083  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_17                        ((0x008b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_18                        ((0x0093  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_19                        ((0x009b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_20                        ((0x00a3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_21                        ((0x00ab  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_22                        ((0x00b3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_23                        ((0x00bb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_24                        ((0x00c3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_25                        ((0x00cb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_26                        ((0x00d3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_27                        ((0x00db  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_28                        ((0x00e3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_29                        ((0x00eb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_30                        ((0x00f3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_31                        ((0x00fb  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_0                          ((0x0004  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_1                          ((0x000c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_2                          ((0x0014  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_3                          ((0x001c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_4                          ((0x0024  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_5                          ((0x002c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_6                          ((0x0034  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_7                          ((0x003c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_8                          ((0x0044  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_9                          ((0x004c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_10                         ((0x0054  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_11                         ((0x005c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_12                         ((0x0064  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_13                         ((0x006c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_14                         ((0x0074  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_15                         ((0x007c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_16                         ((0x0084  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_17                         ((0x008c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_18                         ((0x0094  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_19                         ((0x009c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_20                         ((0x00a4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_21                         ((0x00ac  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_22                         ((0x00b4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_23                         ((0x00bc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_24                         ((0x00c4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_25                         ((0x00cc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_26                         ((0x00d4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_27                         ((0x00dc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_28                         ((0x00e4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_29                         ((0x00ec  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_30                         ((0x00f4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_31                         ((0x00fc  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_0                       ((0x0005  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_1                       ((0x000d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_2                       ((0x0015  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_3                       ((0x001d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_4                       ((0x0025  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_5                       ((0x002d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_6                       ((0x0035  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_7                       ((0x003d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_8                       ((0x0045  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_9                       ((0x004d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_10                      ((0x0055  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_11                      ((0x005d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_12                      ((0x0065  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_13                      ((0x006d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_14                      ((0x0075  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_15                      ((0x007d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_16                      ((0x0085  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_17                      ((0x008d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_18                      ((0x0095  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_19                      ((0x009d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_20                      ((0x00a5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_21                      ((0x00ad  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_22                      ((0x00b5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_23                      ((0x00bd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_24                      ((0x00c5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_25                      ((0x00cd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_26                      ((0x00d5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_27                      ((0x00dd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_28                      ((0x00e5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_29                      ((0x00ed  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_30                      ((0x00f5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_31                      ((0x00fd  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_0                          ((0x0006  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_1                          ((0x000e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_2                          ((0x0016  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_3                          ((0x001e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_4                          ((0x0026  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_5                          ((0x002e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_6                          ((0x0036  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_7                          ((0x003e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_8                          ((0x0046  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_9                          ((0x004e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_10                         ((0x0056  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_11                         ((0x005e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_12                         ((0x0066  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_13                         ((0x006e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_14                         ((0x0076  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_15                         ((0x007e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_16                         ((0x0086  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_17                         ((0x008e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_18                         ((0x0096  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_19                         ((0x009e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_20                         ((0x00a6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_21                         ((0x00ae  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_22                         ((0x00b6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_23                         ((0x00be  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_24                         ((0x00c6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_25                         ((0x00ce  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_26                         ((0x00d6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_27                         ((0x00de  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_28                         ((0x00e6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_29                         ((0x00ee  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_30                         ((0x00f6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_31                         ((0x00fe  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_0              ((0x0007  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_1              ((0x000f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_2              ((0x0017  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_3              ((0x001f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_4              ((0x0027  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_5              ((0x002f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_6              ((0x0037  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_7              ((0x003f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_8              ((0x0047  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_9              ((0x004f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_10             ((0x0057  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_11             ((0x005f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_12             ((0x0067  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_13             ((0x006f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_14             ((0x0077  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_15             ((0x007f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_16             ((0x0087  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_17             ((0x008f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_18             ((0x0097  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_19             ((0x009f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_20             ((0x00a7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_21             ((0x00af  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_22             ((0x00b7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_23             ((0x00bf  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_24             ((0x00c7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_25             ((0x00cf  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_26             ((0x00d7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_27             ((0x00df  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_28             ((0x00e7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_29             ((0x00ef  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_30             ((0x00f7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_31             ((0x00ff  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_0                        ((0x0400  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_1                        ((0x0408  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_2                        ((0x0410  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_3                        ((0x0418  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_4                        ((0x0420  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_5                        ((0x0428  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_6                        ((0x0430  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_7                        ((0x0438  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_8                        ((0x0440  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_9                        ((0x0448  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_10                       ((0x0450  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_11                       ((0x0458  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_12                       ((0x0460  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_13                       ((0x0468  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_14                       ((0x0470  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_15                       ((0x0478  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_16                       ((0x0480  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_17                       ((0x0488  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_18                       ((0x0490  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_19                       ((0x0498  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_20                       ((0x04a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_21                       ((0x04a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_22                       ((0x04b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_23                       ((0x04b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_24                       ((0x04c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_25                       ((0x04c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_26                       ((0x04d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_27                       ((0x04d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_28                       ((0x04e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_29                       ((0x04e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_30                       ((0x04f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_31                       ((0x04f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_32                       ((0x0500  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_33                       ((0x0508  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_34                       ((0x0510  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_35                       ((0x0518  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_36                       ((0x0520  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_37                       ((0x0528  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_38                       ((0x0530  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_39                       ((0x0538  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_40                       ((0x0540  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_41                       ((0x0548  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_42                       ((0x0550  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_43                       ((0x0558  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_44                       ((0x0560  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_45                       ((0x0568  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_46                       ((0x0570  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_47                       ((0x0578  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_48                       ((0x0580  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_49                       ((0x0588  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_50                       ((0x0590  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_51                       ((0x0598  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_52                       ((0x05a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_53                       ((0x05a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_54                       ((0x05b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_55                       ((0x05b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_56                       ((0x05c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_57                       ((0x05c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_58                       ((0x05d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_59                       ((0x05d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_60                       ((0x05e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_61                       ((0x05e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_62                       ((0x05f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_63                       ((0x05f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_64                       ((0x0600  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_65                       ((0x0608  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_66                       ((0x0610  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_67                       ((0x0618  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_68                       ((0x0620  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_69                       ((0x0628  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_70                       ((0x0630  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_71                       ((0x0638  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_72                       ((0x0640  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_73                       ((0x0648  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_74                       ((0x0650  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_75                       ((0x0658  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_76                       ((0x0660  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_77                       ((0x0668  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_78                       ((0x0670  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_79                       ((0x0678  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_80                       ((0x0680  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_81                       ((0x0688  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_82                       ((0x0690  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_83                       ((0x0698  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_84                       ((0x06a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_85                       ((0x06a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_86                       ((0x06b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_87                       ((0x06b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_88                       ((0x06c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_89                       ((0x06c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_90                       ((0x06d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_91                       ((0x06d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_92                       ((0x06e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_93                       ((0x06e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_94                       ((0x06f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_95                       ((0x06f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_96                       ((0x0700  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_97                       ((0x0708  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_98                       ((0x0710  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_99                       ((0x0718  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_100                      ((0x0720  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_101                      ((0x0728  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_102                      ((0x0730  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_103                      ((0x0738  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_104                      ((0x0740  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_105                      ((0x0748  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_106                      ((0x0750  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_107                      ((0x0758  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_108                      ((0x0760  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_109                      ((0x0768  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_110                      ((0x0770  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_111                      ((0x0778  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_112                      ((0x0780  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_113                      ((0x0788  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_114                      ((0x0790  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_115                      ((0x0798  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_116                      ((0x07a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_117                      ((0x07a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_118                      ((0x07b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_119                      ((0x07b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_120                      ((0x07c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_121                      ((0x07c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_122                      ((0x07d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_123                      ((0x07d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_124                      ((0x07e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_125                      ((0x07e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_126                      ((0x07f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_127                      ((0x07f8  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_0                        ((0x0401  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_1                        ((0x0409  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_2                        ((0x0411  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_3                        ((0x0419  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_4                        ((0x0421  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_5                        ((0x0429  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_6                        ((0x0431  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_7                        ((0x0439  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_8                        ((0x0441  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_9                        ((0x0449  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_10                       ((0x0451  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_11                       ((0x0459  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_12                       ((0x0461  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_13                       ((0x0469  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_14                       ((0x0471  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_15                       ((0x0479  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_16                       ((0x0481  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_17                       ((0x0489  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_18                       ((0x0491  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_19                       ((0x0499  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_20                       ((0x04a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_21                       ((0x04a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_22                       ((0x04b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_23                       ((0x04b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_24                       ((0x04c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_25                       ((0x04c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_26                       ((0x04d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_27                       ((0x04d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_28                       ((0x04e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_29                       ((0x04e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_30                       ((0x04f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_31                       ((0x04f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_32                       ((0x0501  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_33                       ((0x0509  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_34                       ((0x0511  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_35                       ((0x0519  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_36                       ((0x0521  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_37                       ((0x0529  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_38                       ((0x0531  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_39                       ((0x0539  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_40                       ((0x0541  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_41                       ((0x0549  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_42                       ((0x0551  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_43                       ((0x0559  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_44                       ((0x0561  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_45                       ((0x0569  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_46                       ((0x0571  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_47                       ((0x0579  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_48                       ((0x0581  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_49                       ((0x0589  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_50                       ((0x0591  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_51                       ((0x0599  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_52                       ((0x05a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_53                       ((0x05a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_54                       ((0x05b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_55                       ((0x05b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_56                       ((0x05c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_57                       ((0x05c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_58                       ((0x05d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_59                       ((0x05d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_60                       ((0x05e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_61                       ((0x05e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_62                       ((0x05f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_63                       ((0x05f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_64                       ((0x0601  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_65                       ((0x0609  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_66                       ((0x0611  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_67                       ((0x0619  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_68                       ((0x0621  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_69                       ((0x0629  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_70                       ((0x0631  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_71                       ((0x0639  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_72                       ((0x0641  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_73                       ((0x0649  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_74                       ((0x0651  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_75                       ((0x0659  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_76                       ((0x0661  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_77                       ((0x0669  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_78                       ((0x0671  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_79                       ((0x0679  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_80                       ((0x0681  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_81                       ((0x0689  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_82                       ((0x0691  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_83                       ((0x0699  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_84                       ((0x06a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_85                       ((0x06a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_86                       ((0x06b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_87                       ((0x06b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_88                       ((0x06c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_89                       ((0x06c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_90                       ((0x06d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_91                       ((0x06d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_92                       ((0x06e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_93                       ((0x06e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_94                       ((0x06f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_95                       ((0x06f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_96                       ((0x0701  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_97                       ((0x0709  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_98                       ((0x0711  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_99                       ((0x0719  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_100                      ((0x0721  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_101                      ((0x0729  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_102                      ((0x0731  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_103                      ((0x0739  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_104                      ((0x0741  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_105                      ((0x0749  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_106                      ((0x0751  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_107                      ((0x0759  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_108                      ((0x0761  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_109                      ((0x0769  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_110                      ((0x0771  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_111                      ((0x0779  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_112                      ((0x0781  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_113                      ((0x0789  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_114                      ((0x0791  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_115                      ((0x0799  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_116                      ((0x07a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_117                      ((0x07a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_118                      ((0x07b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_119                      ((0x07b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_120                      ((0x07c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_121                      ((0x07c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_122                      ((0x07d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_123                      ((0x07d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_124                      ((0x07e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_125                      ((0x07e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_126                      ((0x07f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_127                      ((0x07f9  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_0                          ((0x0402  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_1                          ((0x040a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_2                          ((0x0412  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_3                          ((0x041a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_4                          ((0x0422  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_5                          ((0x042a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_6                          ((0x0432  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_7                          ((0x043a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_8                          ((0x0442  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_9                          ((0x044a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_10                         ((0x0452  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_11                         ((0x045a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_12                         ((0x0462  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_13                         ((0x046a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_14                         ((0x0472  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_15                         ((0x047a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_16                         ((0x0482  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_17                         ((0x048a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_18                         ((0x0492  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_19                         ((0x049a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_20                         ((0x04a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_21                         ((0x04aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_22                         ((0x04b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_23                         ((0x04ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_24                         ((0x04c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_25                         ((0x04ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_26                         ((0x04d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_27                         ((0x04da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_28                         ((0x04e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_29                         ((0x04ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_30                         ((0x04f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_31                         ((0x04fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_32                         ((0x0502  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_33                         ((0x050a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_34                         ((0x0512  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_35                         ((0x051a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_36                         ((0x0522  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_37                         ((0x052a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_38                         ((0x0532  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_39                         ((0x053a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_40                         ((0x0542  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_41                         ((0x054a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_42                         ((0x0552  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_43                         ((0x055a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_44                         ((0x0562  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_45                         ((0x056a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_46                         ((0x0572  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_47                         ((0x057a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_48                         ((0x0582  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_49                         ((0x058a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_50                         ((0x0592  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_51                         ((0x059a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_52                         ((0x05a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_53                         ((0x05aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_54                         ((0x05b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_55                         ((0x05ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_56                         ((0x05c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_57                         ((0x05ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_58                         ((0x05d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_59                         ((0x05da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_60                         ((0x05e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_61                         ((0x05ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_62                         ((0x05f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_63                         ((0x05fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_64                         ((0x0602  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_65                         ((0x060a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_66                         ((0x0612  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_67                         ((0x061a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_68                         ((0x0622  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_69                         ((0x062a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_70                         ((0x0632  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_71                         ((0x063a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_72                         ((0x0642  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_73                         ((0x064a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_74                         ((0x0652  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_75                         ((0x065a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_76                         ((0x0662  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_77                         ((0x066a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_78                         ((0x0672  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_79                         ((0x067a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_80                         ((0x0682  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_81                         ((0x068a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_82                         ((0x0692  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_83                         ((0x069a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_84                         ((0x06a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_85                         ((0x06aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_86                         ((0x06b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_87                         ((0x06ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_88                         ((0x06c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_89                         ((0x06ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_90                         ((0x06d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_91                         ((0x06da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_92                         ((0x06e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_93                         ((0x06ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_94                         ((0x06f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_95                         ((0x06fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_96                         ((0x0702  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_97                         ((0x070a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_98                         ((0x0712  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_99                         ((0x071a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_100                        ((0x0722  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_101                        ((0x072a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_102                        ((0x0732  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_103                        ((0x073a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_104                        ((0x0742  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_105                        ((0x074a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_106                        ((0x0752  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_107                        ((0x075a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_108                        ((0x0762  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_109                        ((0x076a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_110                        ((0x0772  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_111                        ((0x077a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_112                        ((0x0782  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_113                        ((0x078a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_114                        ((0x0792  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_115                        ((0x079a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_116                        ((0x07a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_117                        ((0x07aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_118                        ((0x07b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_119                        ((0x07ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_120                        ((0x07c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_121                        ((0x07ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_122                        ((0x07d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_123                        ((0x07da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_124                        ((0x07e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_125                        ((0x07ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_126                        ((0x07f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_127                        ((0x07fa  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_0                         ((0x0403  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_1                         ((0x040b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_2                         ((0x0413  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_3                         ((0x041b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_4                         ((0x0423  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_5                         ((0x042b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_6                         ((0x0433  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_7                         ((0x043b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_8                         ((0x0443  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_9                         ((0x044b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_10                        ((0x0453  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_11                        ((0x045b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_12                        ((0x0463  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_13                        ((0x046b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_14                        ((0x0473  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_15                        ((0x047b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_16                        ((0x0483  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_17                        ((0x048b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_18                        ((0x0493  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_19                        ((0x049b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_20                        ((0x04a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_21                        ((0x04ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_22                        ((0x04b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_23                        ((0x04bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_24                        ((0x04c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_25                        ((0x04cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_26                        ((0x04d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_27                        ((0x04db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_28                        ((0x04e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_29                        ((0x04eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_30                        ((0x04f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_31                        ((0x04fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_32                        ((0x0503  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_33                        ((0x050b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_34                        ((0x0513  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_35                        ((0x051b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_36                        ((0x0523  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_37                        ((0x052b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_38                        ((0x0533  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_39                        ((0x053b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_40                        ((0x0543  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_41                        ((0x054b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_42                        ((0x0553  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_43                        ((0x055b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_44                        ((0x0563  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_45                        ((0x056b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_46                        ((0x0573  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_47                        ((0x057b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_48                        ((0x0583  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_49                        ((0x058b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_50                        ((0x0593  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_51                        ((0x059b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_52                        ((0x05a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_53                        ((0x05ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_54                        ((0x05b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_55                        ((0x05bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_56                        ((0x05c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_57                        ((0x05cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_58                        ((0x05d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_59                        ((0x05db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_60                        ((0x05e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_61                        ((0x05eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_62                        ((0x05f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_63                        ((0x05fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_64                        ((0x0603  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_65                        ((0x060b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_66                        ((0x0613  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_67                        ((0x061b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_68                        ((0x0623  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_69                        ((0x062b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_70                        ((0x0633  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_71                        ((0x063b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_72                        ((0x0643  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_73                        ((0x064b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_74                        ((0x0653  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_75                        ((0x065b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_76                        ((0x0663  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_77                        ((0x066b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_78                        ((0x0673  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_79                        ((0x067b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_80                        ((0x0683  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_81                        ((0x068b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_82                        ((0x0693  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_83                        ((0x069b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_84                        ((0x06a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_85                        ((0x06ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_86                        ((0x06b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_87                        ((0x06bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_88                        ((0x06c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_89                        ((0x06cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_90                        ((0x06d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_91                        ((0x06db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_92                        ((0x06e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_93                        ((0x06eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_94                        ((0x06f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_95                        ((0x06fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_96                        ((0x0703  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_97                        ((0x070b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_98                        ((0x0713  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_99                        ((0x071b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_100                       ((0x0723  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_101                       ((0x072b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_102                       ((0x0733  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_103                       ((0x073b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_104                       ((0x0743  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_105                       ((0x074b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_106                       ((0x0753  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_107                       ((0x075b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_108                       ((0x0763  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_109                       ((0x076b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_110                       ((0x0773  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_111                       ((0x077b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_112                       ((0x0783  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_113                       ((0x078b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_114                       ((0x0793  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_115                       ((0x079b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_116                       ((0x07a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_117                       ((0x07ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_118                       ((0x07b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_119                       ((0x07bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_120                       ((0x07c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_121                       ((0x07cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_122                       ((0x07d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_123                       ((0x07db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_124                       ((0x07e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_125                       ((0x07eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_126                       ((0x07f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_127                       ((0x07fb  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_0                          ((0x0404  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_1                          ((0x040c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_2                          ((0x0414  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_3                          ((0x041c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_4                          ((0x0424  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_5                          ((0x042c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_6                          ((0x0434  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_7                          ((0x043c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_8                          ((0x0444  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_9                          ((0x044c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_10                         ((0x0454  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_11                         ((0x045c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_12                         ((0x0464  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_13                         ((0x046c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_14                         ((0x0474  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_15                         ((0x047c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_16                         ((0x0484  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_17                         ((0x048c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_18                         ((0x0494  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_19                         ((0x049c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_20                         ((0x04a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_21                         ((0x04ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_22                         ((0x04b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_23                         ((0x04bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_24                         ((0x04c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_25                         ((0x04cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_26                         ((0x04d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_27                         ((0x04dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_28                         ((0x04e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_29                         ((0x04ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_30                         ((0x04f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_31                         ((0x04fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_32                         ((0x0504  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_33                         ((0x050c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_34                         ((0x0514  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_35                         ((0x051c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_36                         ((0x0524  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_37                         ((0x052c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_38                         ((0x0534  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_39                         ((0x053c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_40                         ((0x0544  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_41                         ((0x054c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_42                         ((0x0554  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_43                         ((0x055c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_44                         ((0x0564  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_45                         ((0x056c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_46                         ((0x0574  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_47                         ((0x057c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_48                         ((0x0584  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_49                         ((0x058c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_50                         ((0x0594  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_51                         ((0x059c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_52                         ((0x05a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_53                         ((0x05ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_54                         ((0x05b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_55                         ((0x05bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_56                         ((0x05c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_57                         ((0x05cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_58                         ((0x05d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_59                         ((0x05dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_60                         ((0x05e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_61                         ((0x05ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_62                         ((0x05f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_63                         ((0x05fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_64                         ((0x0604  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_65                         ((0x060c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_66                         ((0x0614  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_67                         ((0x061c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_68                         ((0x0624  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_69                         ((0x062c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_70                         ((0x0634  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_71                         ((0x063c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_72                         ((0x0644  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_73                         ((0x064c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_74                         ((0x0654  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_75                         ((0x065c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_76                         ((0x0664  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_77                         ((0x066c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_78                         ((0x0674  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_79                         ((0x067c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_80                         ((0x0684  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_81                         ((0x068c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_82                         ((0x0694  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_83                         ((0x069c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_84                         ((0x06a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_85                         ((0x06ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_86                         ((0x06b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_87                         ((0x06bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_88                         ((0x06c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_89                         ((0x06cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_90                         ((0x06d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_91                         ((0x06dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_92                         ((0x06e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_93                         ((0x06ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_94                         ((0x06f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_95                         ((0x06fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_96                         ((0x0704  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_97                         ((0x070c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_98                         ((0x0714  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_99                         ((0x071c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_100                        ((0x0724  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_101                        ((0x072c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_102                        ((0x0734  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_103                        ((0x073c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_104                        ((0x0744  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_105                        ((0x074c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_106                        ((0x0754  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_107                        ((0x075c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_108                        ((0x0764  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_109                        ((0x076c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_110                        ((0x0774  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_111                        ((0x077c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_112                        ((0x0784  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_113                        ((0x078c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_114                        ((0x0794  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_115                        ((0x079c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_116                        ((0x07a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_117                        ((0x07ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_118                        ((0x07b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_119                        ((0x07bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_120                        ((0x07c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_121                        ((0x07cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_122                        ((0x07d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_123                        ((0x07dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_124                        ((0x07e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_125                        ((0x07ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_126                        ((0x07f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_127                        ((0x07fc  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_0                       ((0x0405  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_1                       ((0x040d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_2                       ((0x0415  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_3                       ((0x041d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_4                       ((0x0425  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_5                       ((0x042d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_6                       ((0x0435  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_7                       ((0x043d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_8                       ((0x0445  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_9                       ((0x044d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_10                      ((0x0455  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_11                      ((0x045d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_12                      ((0x0465  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_13                      ((0x046d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_14                      ((0x0475  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_15                      ((0x047d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_16                      ((0x0485  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_17                      ((0x048d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_18                      ((0x0495  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_19                      ((0x049d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_20                      ((0x04a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_21                      ((0x04ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_22                      ((0x04b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_23                      ((0x04bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_24                      ((0x04c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_25                      ((0x04cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_26                      ((0x04d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_27                      ((0x04dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_28                      ((0x04e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_29                      ((0x04ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_30                      ((0x04f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_31                      ((0x04fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_32                      ((0x0505  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_33                      ((0x050d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_34                      ((0x0515  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_35                      ((0x051d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_36                      ((0x0525  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_37                      ((0x052d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_38                      ((0x0535  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_39                      ((0x053d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_40                      ((0x0545  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_41                      ((0x054d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_42                      ((0x0555  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_43                      ((0x055d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_44                      ((0x0565  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_45                      ((0x056d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_46                      ((0x0575  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_47                      ((0x057d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_48                      ((0x0585  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_49                      ((0x058d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_50                      ((0x0595  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_51                      ((0x059d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_52                      ((0x05a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_53                      ((0x05ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_54                      ((0x05b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_55                      ((0x05bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_56                      ((0x05c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_57                      ((0x05cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_58                      ((0x05d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_59                      ((0x05dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_60                      ((0x05e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_61                      ((0x05ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_62                      ((0x05f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_63                      ((0x05fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_64                      ((0x0605  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_65                      ((0x060d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_66                      ((0x0615  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_67                      ((0x061d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_68                      ((0x0625  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_69                      ((0x062d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_70                      ((0x0635  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_71                      ((0x063d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_72                      ((0x0645  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_73                      ((0x064d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_74                      ((0x0655  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_75                      ((0x065d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_76                      ((0x0665  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_77                      ((0x066d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_78                      ((0x0675  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_79                      ((0x067d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_80                      ((0x0685  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_81                      ((0x068d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_82                      ((0x0695  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_83                      ((0x069d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_84                      ((0x06a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_85                      ((0x06ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_86                      ((0x06b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_87                      ((0x06bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_88                      ((0x06c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_89                      ((0x06cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_90                      ((0x06d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_91                      ((0x06dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_92                      ((0x06e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_93                      ((0x06ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_94                      ((0x06f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_95                      ((0x06fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_96                      ((0x0705  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_97                      ((0x070d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_98                      ((0x0715  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_99                      ((0x071d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_100                     ((0x0725  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_101                     ((0x072d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_102                     ((0x0735  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_103                     ((0x073d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_104                     ((0x0745  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_105                     ((0x074d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_106                     ((0x0755  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_107                     ((0x075d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_108                     ((0x0765  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_109                     ((0x076d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_110                     ((0x0775  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_111                     ((0x077d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_112                     ((0x0785  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_113                     ((0x078d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_114                     ((0x0795  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_115                     ((0x079d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_116                     ((0x07a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_117                     ((0x07ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_118                     ((0x07b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_119                     ((0x07bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_120                     ((0x07c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_121                     ((0x07cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_122                     ((0x07d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_123                     ((0x07dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_124                     ((0x07e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_125                     ((0x07ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_126                     ((0x07f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_127                     ((0x07fd  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_0                          ((0x0406  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_1                          ((0x040e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_2                          ((0x0416  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_3                          ((0x041e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_4                          ((0x0426  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_5                          ((0x042e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_6                          ((0x0436  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_7                          ((0x043e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_8                          ((0x0446  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_9                          ((0x044e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_10                         ((0x0456  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_11                         ((0x045e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_12                         ((0x0466  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_13                         ((0x046e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_14                         ((0x0476  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_15                         ((0x047e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_16                         ((0x0486  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_17                         ((0x048e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_18                         ((0x0496  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_19                         ((0x049e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_20                         ((0x04a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_21                         ((0x04ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_22                         ((0x04b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_23                         ((0x04be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_24                         ((0x04c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_25                         ((0x04ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_26                         ((0x04d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_27                         ((0x04de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_28                         ((0x04e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_29                         ((0x04ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_30                         ((0x04f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_31                         ((0x04fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_32                         ((0x0506  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_33                         ((0x050e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_34                         ((0x0516  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_35                         ((0x051e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_36                         ((0x0526  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_37                         ((0x052e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_38                         ((0x0536  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_39                         ((0x053e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_40                         ((0x0546  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_41                         ((0x054e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_42                         ((0x0556  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_43                         ((0x055e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_44                         ((0x0566  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_45                         ((0x056e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_46                         ((0x0576  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_47                         ((0x057e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_48                         ((0x0586  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_49                         ((0x058e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_50                         ((0x0596  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_51                         ((0x059e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_52                         ((0x05a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_53                         ((0x05ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_54                         ((0x05b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_55                         ((0x05be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_56                         ((0x05c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_57                         ((0x05ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_58                         ((0x05d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_59                         ((0x05de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_60                         ((0x05e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_61                         ((0x05ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_62                         ((0x05f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_63                         ((0x05fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_64                         ((0x0606  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_65                         ((0x060e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_66                         ((0x0616  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_67                         ((0x061e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_68                         ((0x0626  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_69                         ((0x062e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_70                         ((0x0636  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_71                         ((0x063e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_72                         ((0x0646  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_73                         ((0x064e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_74                         ((0x0656  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_75                         ((0x065e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_76                         ((0x0666  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_77                         ((0x066e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_78                         ((0x0676  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_79                         ((0x067e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_80                         ((0x0686  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_81                         ((0x068e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_82                         ((0x0696  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_83                         ((0x069e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_84                         ((0x06a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_85                         ((0x06ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_86                         ((0x06b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_87                         ((0x06be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_88                         ((0x06c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_89                         ((0x06ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_90                         ((0x06d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_91                         ((0x06de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_92                         ((0x06e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_93                         ((0x06ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_94                         ((0x06f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_95                         ((0x06fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_96                         ((0x0706  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_97                         ((0x070e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_98                         ((0x0716  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_99                         ((0x071e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_100                        ((0x0726  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_101                        ((0x072e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_102                        ((0x0736  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_103                        ((0x073e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_104                        ((0x0746  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_105                        ((0x074e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_106                        ((0x0756  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_107                        ((0x075e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_108                        ((0x0766  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_109                        ((0x076e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_110                        ((0x0776  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_111                        ((0x077e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_112                        ((0x0786  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_113                        ((0x078e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_114                        ((0x0796  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_115                        ((0x079e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_116                        ((0x07a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_117                        ((0x07ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_118                        ((0x07b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_119                        ((0x07be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_120                        ((0x07c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_121                        ((0x07ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_122                        ((0x07d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_123                        ((0x07de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_124                        ((0x07e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_125                        ((0x07ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_126                        ((0x07f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_127                        ((0x07fe  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_0                         ((0x0407  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_1                         ((0x040f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_2                         ((0x0417  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_3                         ((0x041f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_4                         ((0x0427  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_5                         ((0x042f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_6                         ((0x0437  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_7                         ((0x043f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_8                         ((0x0447  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_9                         ((0x044f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_10                        ((0x0457  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_11                        ((0x045f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_12                        ((0x0467  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_13                        ((0x046f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_14                        ((0x0477  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_15                        ((0x047f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_16                        ((0x0487  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_17                        ((0x048f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_18                        ((0x0497  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_19                        ((0x049f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_20                        ((0x04a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_21                        ((0x04af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_22                        ((0x04b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_23                        ((0x04bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_24                        ((0x04c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_25                        ((0x04cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_26                        ((0x04d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_27                        ((0x04df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_28                        ((0x04e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_29                        ((0x04ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_30                        ((0x04f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_31                        ((0x04ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_32                        ((0x0507  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_33                        ((0x050f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_34                        ((0x0517  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_35                        ((0x051f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_36                        ((0x0527  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_37                        ((0x052f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_38                        ((0x0537  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_39                        ((0x053f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_40                        ((0x0547  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_41                        ((0x054f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_42                        ((0x0557  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_43                        ((0x055f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_44                        ((0x0567  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_45                        ((0x056f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_46                        ((0x0577  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_47                        ((0x057f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_48                        ((0x0587  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_49                        ((0x058f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_50                        ((0x0597  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_51                        ((0x059f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_52                        ((0x05a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_53                        ((0x05af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_54                        ((0x05b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_55                        ((0x05bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_56                        ((0x05c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_57                        ((0x05cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_58                        ((0x05d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_59                        ((0x05df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_60                        ((0x05e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_61                        ((0x05ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_62                        ((0x05f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_63                        ((0x05ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_64                        ((0x0607  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_65                        ((0x060f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_66                        ((0x0617  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_67                        ((0x061f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_68                        ((0x0627  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_69                        ((0x062f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_70                        ((0x0637  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_71                        ((0x063f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_72                        ((0x0647  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_73                        ((0x064f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_74                        ((0x0657  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_75                        ((0x065f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_76                        ((0x0667  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_77                        ((0x066f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_78                        ((0x0677  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_79                        ((0x067f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_80                        ((0x0687  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_81                        ((0x068f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_82                        ((0x0697  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_83                        ((0x069f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_84                        ((0x06a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_85                        ((0x06af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_86                        ((0x06b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_87                        ((0x06bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_88                        ((0x06c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_89                        ((0x06cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_90                        ((0x06d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_91                        ((0x06df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_92                        ((0x06e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_93                        ((0x06ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_94                        ((0x06f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_95                        ((0x06ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_96                        ((0x0707  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_97                        ((0x070f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_98                        ((0x0717  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_99                        ((0x071f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_100                       ((0x0727  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_101                       ((0x072f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_102                       ((0x0737  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_103                       ((0x073f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_104                       ((0x0747  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_105                       ((0x074f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_106                       ((0x0757  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_107                       ((0x075f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_108                       ((0x0767  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_109                       ((0x076f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_110                       ((0x0777  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_111                       ((0x077f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_112                       ((0x0787  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_113                       ((0x078f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_114                       ((0x0797  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_115                       ((0x079f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_116                       ((0x07a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_117                       ((0x07af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_118                       ((0x07b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_119                       ((0x07bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_120                       ((0x07c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_121                       ((0x07cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_122                       ((0x07d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_123                       ((0x07df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_124                       ((0x07e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_125                       ((0x07ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_126                       ((0x07f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_127                       ((0x07ff  << 2) + 0xfe444000)
#define DMX_RDMA_INT_MASK                          ((0x0800  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_0                        ((0x0801  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_1                        ((0x0802  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_2                        ((0x0803  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_3                        ((0x0804  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_0                        ((0x0805  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_1                        ((0x0806  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_2                        ((0x0807  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_3                        ((0x0808  << 2) + 0xfe444000)
#define DMX_CLEAN_RDMA                             ((0x0809  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_0                           ((0x080a  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_1                           ((0x080b  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_2                           ((0x080c  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_3                           ((0x080d  << 2) + 0xfe444000)
#define DMX_RDMA_ACTIVE                            ((0x080e  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_0                          ((0x080f  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_1                          ((0x0810  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_2                          ((0x0811  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_3                          ((0x0812  << 2) + 0xfe444000)
#define DMX_DMA_RDONE                              ((0x0813  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_0                            ((0x0814  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_1                            ((0x0815  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_2                            ((0x0816  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_3                            ((0x0817  << 2) + 0xfe444000)
#define DMX_RDES_ERR                               ((0x0818  << 2) + 0xfe444000)
#define DMX_RDES_LEN_ERR                           ((0x0819  << 2) + 0xfe444000)
#define DMX_WDES_ERR_0                             ((0x081a  << 2) + 0xfe444000)
#define DMX_WDES_ERR_1                             ((0x081b  << 2) + 0xfe444000)
#define DMX_WDES_ERR_2                             ((0x081c  << 2) + 0xfe444000)
#define DMX_WDES_ERR_3                             ((0x081d  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_0                        ((0x081e  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_1                        ((0x081f  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_2                        ((0x0820  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_3                        ((0x0821  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_0                        ((0x0822  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_1                        ((0x0823  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_2                        ((0x0824  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_3                        ((0x0825  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR0                          ((0x0826  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR1                          ((0x0827  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR2                          ((0x0828  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR3                          ((0x0829  << 2) + 0xfe444000)
#define DMX_UPDT_PKT_SYNC                          ((0x0830  << 2) + 0xfe444000)
#define DMX_RCHN_CFG                               ((0x0831  << 2) + 0xfe444000)
#define DMX_WCHN_CFG                               ((0x0832  << 2) + 0xfe444000)
#define DMX_MEM_PD_CRTL                            ((0x0833  << 2) + 0xfe444000)
#define DMX_DMA_BUS_CFG                            ((0x0834  << 2) + 0xfe444000)
#define DMX_DMA_GMW_CFG                            ((0x0835  << 2) + 0xfe444000)
#define DMX_DMA_GMR_CFG                            ((0x0836  << 2) + 0xfe444000)
//========================================================================
//  TS OUTPUT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442c00
// -----------------------------------------------
#define TS_OUTPUT_PID_RDY                          ((0x0000  << 2) + 0xfe442c00)
#define TS_OUTPUT_TEE_LOCK                         ((0x0001  << 2) + 0xfe442c00)
#define TS_OUTPUT_PID_CFG                          ((0x0002  << 2) + 0xfe442c00)
#define TS_OUTPUT_PID_DAT                          ((0x0003  << 2) + 0xfe442c00)
#define TS_OUTPUT_OUT_CFG                          ((0x0004  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_0                  ((0x0010  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_1                  ((0x0011  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_2                  ((0x0012  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_3                  ((0x0013  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_4                  ((0x0014  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_5                  ((0x0015  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_6                  ((0x0016  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_7                  ((0x0017  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_8                  ((0x0018  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_9                  ((0x0019  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_10                 ((0x001a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_11                 ((0x001b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_12                 ((0x001c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_13                 ((0x001d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_14                 ((0x001e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_15                 ((0x001f  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_0_1                      ((0x0020  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_2_3                      ((0x0021  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_4_5                      ((0x0022  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_6_7                      ((0x0023  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_8_9                      ((0x0024  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_10_11                    ((0x0025  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_12_13                    ((0x0026  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_14_15                    ((0x0027  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_16_17                    ((0x0028  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_18_19                    ((0x0029  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_20_21                    ((0x002a  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_22_23                    ((0x002b  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_24_25                    ((0x002c  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_26_27                    ((0x002d  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_28_29                    ((0x002e  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_30_31                    ((0x002f  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_32_33                    ((0x0030  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_34_35                    ((0x0031  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_36_37                    ((0x0032  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_38_39                    ((0x0033  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_40_41                    ((0x0034  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_42_43                    ((0x0035  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_44_45                    ((0x0036  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_46_47                    ((0x0037  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_48_49                    ((0x0038  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_50_51                    ((0x0039  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_52_53                    ((0x003a  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_54_55                    ((0x003b  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_56_57                    ((0x003c  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_58_59                    ((0x003d  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_60_61                    ((0x003e  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_62_63                    ((0x003f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_0                         ((0x0040  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_1                         ((0x0041  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_2                         ((0x0042  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_3                         ((0x0043  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_4                         ((0x0044  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_5                         ((0x0045  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_6                         ((0x0046  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_7                         ((0x0047  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_8                         ((0x0048  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_9                         ((0x0049  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_10                        ((0x004a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_11                        ((0x004b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_12                        ((0x004c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_13                        ((0x004d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_14                        ((0x004e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_15                        ((0x004f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_16                        ((0x0050  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_17                        ((0x0051  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_18                        ((0x0052  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_19                        ((0x0053  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_20                        ((0x0054  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_21                        ((0x0055  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_22                        ((0x0056  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_23                        ((0x0057  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_24                        ((0x0058  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_25                        ((0x0059  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_26                        ((0x005a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_27                        ((0x005b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_28                        ((0x005c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_29                        ((0x005d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_30                        ((0x005e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_31                        ((0x005f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_32                        ((0x0060  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_33                        ((0x0061  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_34                        ((0x0062  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_35                        ((0x0063  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_36                        ((0x0064  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_37                        ((0x0065  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_38                        ((0x0066  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_39                        ((0x0067  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_40                        ((0x0068  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_41                        ((0x0069  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_42                        ((0x006a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_43                        ((0x006b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_44                        ((0x006c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_45                        ((0x006d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_46                        ((0x006e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_47                        ((0x006f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_48                        ((0x0070  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_49                        ((0x0071  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_50                        ((0x0072  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_51                        ((0x0073  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_52                        ((0x0074  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_53                        ((0x0075  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_54                        ((0x0076  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_55                        ((0x0077  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_56                        ((0x0078  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_57                        ((0x0079  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_58                        ((0x007a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_59                        ((0x007b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_60                        ((0x007c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_61                        ((0x007d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_62                        ((0x007e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_63                        ((0x007f  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_0                    ((0x0080  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_0                    ((0x0081  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_1                    ((0x0082  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_1                    ((0x0083  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_2                    ((0x0084  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_2                    ((0x0085  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_3                    ((0x0086  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_3                    ((0x0087  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_4                    ((0x0088  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_4                    ((0x0089  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_5                    ((0x008a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_5                    ((0x008b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_6                    ((0x008c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_6                    ((0x008d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_7                    ((0x008e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_7                    ((0x008f  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_8                    ((0x0090  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_8                    ((0x0091  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_9                    ((0x0092  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_9                    ((0x0093  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_10                   ((0x0094  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_10                   ((0x0095  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_11                   ((0x0096  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_11                   ((0x0097  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_12                   ((0x0098  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_12                   ((0x0099  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_13                   ((0x009a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_13                   ((0x009b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_14                   ((0x009c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_14                   ((0x009d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_15                   ((0x009e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_15                   ((0x009f  << 2) + 0xfe442c00)
//========================================================================
//  TSD DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442000
// -----------------------------------------------
#define TSD_PID_RDY                                ((0x0000  << 2) + 0xfe442000)
#define TSD_TEE_LOCK                               ((0x0001  << 2) + 0xfe442000)
#define TSD_PID_STS                                ((0x0003  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_0                        ((0x0004  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_0                        ((0x0005  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_1                        ((0x0006  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_1                        ((0x0007  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_2                        ((0x0008  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_2                        ((0x0009  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_3                        ((0x000a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_3                        ((0x000b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_4                        ((0x000c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_4                        ((0x000d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_5                        ((0x000e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_5                        ((0x000f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_6                        ((0x0010  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_6                        ((0x0011  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_7                        ((0x0012  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_7                        ((0x0013  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_8                        ((0x0014  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_8                        ((0x0015  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_9                        ((0x0016  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_9                        ((0x0017  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_10                       ((0x0018  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_10                       ((0x0019  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_11                       ((0x001a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_11                       ((0x001b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_12                       ((0x001c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_12                       ((0x001d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_13                       ((0x001e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_13                       ((0x001f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_14                       ((0x0020  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_14                       ((0x0021  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_15                       ((0x0022  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_15                       ((0x0023  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_16                       ((0x0024  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_16                       ((0x0025  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_17                       ((0x0026  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_17                       ((0x0027  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_18                       ((0x0028  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_18                       ((0x0029  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_19                       ((0x002a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_19                       ((0x002b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_20                       ((0x002c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_20                       ((0x002d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_21                       ((0x002e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_21                       ((0x002f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_22                       ((0x0030  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_22                       ((0x0031  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_23                       ((0x0032  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_23                       ((0x0033  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_24                       ((0x0034  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_24                       ((0x0035  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_25                       ((0x0036  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_25                       ((0x0037  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_26                       ((0x0038  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_26                       ((0x0039  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_27                       ((0x003a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_27                       ((0x003b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_28                       ((0x003c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_28                       ((0x003d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_29                       ((0x003e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_29                       ((0x003f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_30                       ((0x0040  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_30                       ((0x0041  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_31                       ((0x0042  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_31                       ((0x0043  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_32                       ((0x0044  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_32                       ((0x0045  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_33                       ((0x0046  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_33                       ((0x0047  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_34                       ((0x0048  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_34                       ((0x0049  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_35                       ((0x004a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_35                       ((0x004b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_36                       ((0x004c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_36                       ((0x004d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_37                       ((0x004e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_37                       ((0x004f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_38                       ((0x0050  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_38                       ((0x0051  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_39                       ((0x0052  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_39                       ((0x0053  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_40                       ((0x0054  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_40                       ((0x0055  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_41                       ((0x0056  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_41                       ((0x0057  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_42                       ((0x0058  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_42                       ((0x0059  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_43                       ((0x005a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_43                       ((0x005b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_44                       ((0x005c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_44                       ((0x005d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_45                       ((0x005e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_45                       ((0x005f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_46                       ((0x0060  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_46                       ((0x0061  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_47                       ((0x0062  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_47                       ((0x0063  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_48                       ((0x0064  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_48                       ((0x0065  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_49                       ((0x0066  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_49                       ((0x0067  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_50                       ((0x0068  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_50                       ((0x0069  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_51                       ((0x006a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_51                       ((0x006b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_52                       ((0x006c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_52                       ((0x006d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_53                       ((0x006e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_53                       ((0x006f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_54                       ((0x0070  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_54                       ((0x0071  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_55                       ((0x0072  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_55                       ((0x0073  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_56                       ((0x0074  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_56                       ((0x0075  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_57                       ((0x0076  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_57                       ((0x0077  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_58                       ((0x0078  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_58                       ((0x0079  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_59                       ((0x007a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_59                       ((0x007b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_60                       ((0x007c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_60                       ((0x007d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_61                       ((0x007e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_61                       ((0x007f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_62                       ((0x0080  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_62                       ((0x0081  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_63                       ((0x0082  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_63                       ((0x0083  << 2) + 0xfe442000)
//========================================================================
// SECURE TOP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440300
// -----------------------------------------------
#define SEC_TOP_CFG_LOCKABLE                       ((0x0000  << 2) + 0xfe440300)
#define SEC_TOP_CFG_LOCK                           ((0x0001  << 2) + 0xfe440300)
#define SEC_TOP_CFG_WTO                            ((0x0002  << 2) + 0xfe440300)
#define SEC_TOP_N2_GENOUT                          ((0x0003  << 2) + 0xfe440300)
#define SEC_TOP_CFG_REG                            ((0x0004  << 2) + 0xfe440300)
#define SEC_TOP_NSK_CTRL                           ((0x0005  << 2) + 0xfe440300)
#define SEC_TOP_AKL_STS                            ((0x0006  << 2) + 0xfe440300)
#define SEC_TOP_ND_STATUS                          ((0x0007  << 2) + 0xfe440300)
#define SEC_TOP_CFG_DEMUX                          ((0x0008  << 2) + 0xfe440300)
#define SEC_TOP_CFG_DIF                            ((0x000c  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH0                          ((0x0010  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH1                          ((0x0011  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH2                          ((0x0012  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH3                          ((0x0013  << 2) + 0xfe440300)
#define SEC_TOP_PATH0_CTRL                         ((0x0028  << 2) + 0xfe440300)
#define SEC_TOP_PATH1_CTRL                         ((0x0029  << 2) + 0xfe440300)
#define SEC_TOP_PATH2_CTRL                         ((0x002a  << 2) + 0xfe440300)
#define SEC_TOP_PATH3_CTRL                         ((0x002b  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG0                     ((0x002c  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG1                     ((0x002d  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG2                     ((0x002e  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG3                     ((0x002f  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_FIFO_CFG0                    ((0x0030  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_FIFO_CFG1                    ((0x0031  << 2) + 0xfe440300)
#define SEC_TOP_TS_O_PATH_CTRL                     ((0x0032  << 2) + 0xfe440300)
#define SEC_TOP_CLEAN_DEMOD_INT                    ((0x0033  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_INT_MASK                     ((0x0034  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_INT_STATUS                   ((0x0035  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN0_ERR_STATUS                 ((0x0036  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN1_ERR_STATUS                 ((0x0037  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN2_ERR_STATUS                 ((0x0038  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN3_ERR_STATUS                 ((0x0039  << 2) + 0xfe440300)
//========================================================================
// TSE DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442800
// -----------------------------------------------
#define TSE_PID_RDY                                ((0x0000  << 2) + 0xfe442800)
#define TSE_TEE_LOCK                               ((0x0001  << 2) + 0xfe442800)
#define TSE_PID_STS                                ((0x0003  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_0                        ((0x0004  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_0                        ((0x0005  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_1                        ((0x0006  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_1                        ((0x0007  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_2                        ((0x0008  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_2                        ((0x0009  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_3                        ((0x000a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_3                        ((0x000b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_4                        ((0x000c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_4                        ((0x000d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_5                        ((0x000e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_5                        ((0x000f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_6                        ((0x0010  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_6                        ((0x0011  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_7                        ((0x0012  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_7                        ((0x0013  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_8                        ((0x0014  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_8                        ((0x0015  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_9                        ((0x0016  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_9                        ((0x0017  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_10                       ((0x0018  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_10                       ((0x0019  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_11                       ((0x001a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_11                       ((0x001b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_12                       ((0x001c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_12                       ((0x001d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_13                       ((0x001e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_13                       ((0x001f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_14                       ((0x0020  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_14                       ((0x0021  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_15                       ((0x0022  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_15                       ((0x0023  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_16                       ((0x0024  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_16                       ((0x0025  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_17                       ((0x0026  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_17                       ((0x0027  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_18                       ((0x0028  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_18                       ((0x0029  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_19                       ((0x002a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_19                       ((0x002b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_20                       ((0x002c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_20                       ((0x002d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_21                       ((0x002e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_21                       ((0x002f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_22                       ((0x0030  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_22                       ((0x0031  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_23                       ((0x0032  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_23                       ((0x0033  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_24                       ((0x0034  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_24                       ((0x0035  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_25                       ((0x0036  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_25                       ((0x0037  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_26                       ((0x0038  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_26                       ((0x0039  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_27                       ((0x003a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_27                       ((0x003b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_28                       ((0x003c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_28                       ((0x003d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_29                       ((0x003e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_29                       ((0x003f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_30                       ((0x0040  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_30                       ((0x0041  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_31                       ((0x0042  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_31                       ((0x0043  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_32                       ((0x0044  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_32                       ((0x0045  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_33                       ((0x0046  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_33                       ((0x0047  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_34                       ((0x0048  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_34                       ((0x0049  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_35                       ((0x004a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_35                       ((0x004b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_36                       ((0x004c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_36                       ((0x004d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_37                       ((0x004e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_37                       ((0x004f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_38                       ((0x0050  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_38                       ((0x0051  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_39                       ((0x0052  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_39                       ((0x0053  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_40                       ((0x0054  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_40                       ((0x0055  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_41                       ((0x0056  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_41                       ((0x0057  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_42                       ((0x0058  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_42                       ((0x0059  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_43                       ((0x005a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_43                       ((0x005b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_44                       ((0x005c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_44                       ((0x005d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_45                       ((0x005e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_45                       ((0x005f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_46                       ((0x0060  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_46                       ((0x0061  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_47                       ((0x0062  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_47                       ((0x0063  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_48                       ((0x0064  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_48                       ((0x0065  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_49                       ((0x0066  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_49                       ((0x0067  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_50                       ((0x0068  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_50                       ((0x0069  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_51                       ((0x006a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_51                       ((0x006b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_52                       ((0x006c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_52                       ((0x006d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_53                       ((0x006e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_53                       ((0x006f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_54                       ((0x0070  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_54                       ((0x0071  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_55                       ((0x0072  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_55                       ((0x0073  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_56                       ((0x0074  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_56                       ((0x0075  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_57                       ((0x0076  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_57                       ((0x0077  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_58                       ((0x0078  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_58                       ((0x0079  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_59                       ((0x007a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_59                       ((0x007b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_60                       ((0x007c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_60                       ((0x007d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_61                       ((0x007e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_61                       ((0x007f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_62                       ((0x0080  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_62                       ((0x0081  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_63                       ((0x0082  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_63                       ((0x0083  << 2) + 0xfe442800)
//========================================================================
// TSN DESC REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442400
// -----------------------------------------------
#define TSN_PID_RDY                                ((0x0000  << 2) + 0xfe442400)
#define TSN_TEE_LOCK                               ((0x0001  << 2) + 0xfe442400)
#define TSN_PID_STS                                ((0x0003  << 2) + 0xfe442400)
#define TSN_PID_TABLE_0                            ((0x0004  << 2) + 0xfe442400)
#define TSN_PID_TABLE_1                            ((0x0005  << 2) + 0xfe442400)
#define TSN_PID_TABLE_2                            ((0x0006  << 2) + 0xfe442400)
#define TSN_PID_TABLE_3                            ((0x0007  << 2) + 0xfe442400)
#define TSN_PID_TABLE_4                            ((0x0008  << 2) + 0xfe442400)
#define TSN_PID_TABLE_5                            ((0x0009  << 2) + 0xfe442400)
#define TSN_PID_TABLE_6                            ((0x000a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_7                            ((0x000b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_8                            ((0x000c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_9                            ((0x000d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_10                           ((0x000e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_11                           ((0x000f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_12                           ((0x0010  << 2) + 0xfe442400)
#define TSN_PID_TABLE_13                           ((0x0011  << 2) + 0xfe442400)
#define TSN_PID_TABLE_14                           ((0x0012  << 2) + 0xfe442400)
#define TSN_PID_TABLE_15                           ((0x0013  << 2) + 0xfe442400)
#define TSN_PID_TABLE_16                           ((0x0014  << 2) + 0xfe442400)
#define TSN_PID_TABLE_17                           ((0x0015  << 2) + 0xfe442400)
#define TSN_PID_TABLE_18                           ((0x0016  << 2) + 0xfe442400)
#define TSN_PID_TABLE_19                           ((0x0017  << 2) + 0xfe442400)
#define TSN_PID_TABLE_20                           ((0x0018  << 2) + 0xfe442400)
#define TSN_PID_TABLE_21                           ((0x0019  << 2) + 0xfe442400)
#define TSN_PID_TABLE_22                           ((0x001a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_23                           ((0x001b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_24                           ((0x001c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_25                           ((0x001d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_26                           ((0x001e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_27                           ((0x001f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_28                           ((0x0020  << 2) + 0xfe442400)
#define TSN_PID_TABLE_29                           ((0x0021  << 2) + 0xfe442400)
#define TSN_PID_TABLE_30                           ((0x0022  << 2) + 0xfe442400)
#define TSN_PID_TABLE_31                           ((0x0023  << 2) + 0xfe442400)
#define TSN_PID_TABLE_32                           ((0x0024  << 2) + 0xfe442400)
#define TSN_PID_TABLE_33                           ((0x0025  << 2) + 0xfe442400)
#define TSN_PID_TABLE_34                           ((0x0026  << 2) + 0xfe442400)
#define TSN_PID_TABLE_35                           ((0x0027  << 2) + 0xfe442400)
#define TSN_PID_TABLE_36                           ((0x0028  << 2) + 0xfe442400)
#define TSN_PID_TABLE_37                           ((0x0029  << 2) + 0xfe442400)
#define TSN_PID_TABLE_38                           ((0x002a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_39                           ((0x002b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_40                           ((0x002c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_41                           ((0x002d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_42                           ((0x002e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_43                           ((0x002f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_44                           ((0x0030  << 2) + 0xfe442400)
#define TSN_PID_TABLE_45                           ((0x0031  << 2) + 0xfe442400)
#define TSN_PID_TABLE_46                           ((0x0032  << 2) + 0xfe442400)
#define TSN_PID_TABLE_47                           ((0x0033  << 2) + 0xfe442400)
#define TSN_PID_TABLE_48                           ((0x0034  << 2) + 0xfe442400)
#define TSN_PID_TABLE_49                           ((0x0035  << 2) + 0xfe442400)
#define TSN_PID_TABLE_50                           ((0x0036  << 2) + 0xfe442400)
#define TSN_PID_TABLE_51                           ((0x0037  << 2) + 0xfe442400)
#define TSN_PID_TABLE_52                           ((0x0038  << 2) + 0xfe442400)
#define TSN_PID_TABLE_53                           ((0x0039  << 2) + 0xfe442400)
#define TSN_PID_TABLE_54                           ((0x003a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_55                           ((0x003b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_56                           ((0x003c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_57                           ((0x003d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_58                           ((0x003e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_59                           ((0x003f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_60                           ((0x0040  << 2) + 0xfe442400)
#define TSN_PID_TABLE_61                           ((0x0041  << 2) + 0xfe442400)
#define TSN_PID_TABLE_62                           ((0x0042  << 2) + 0xfe442400)
#define TSN_PID_TABLE_63                           ((0x0043  << 2) + 0xfe442400)
#define TSN_PID_TABLE_64                           ((0x0044  << 2) + 0xfe442400)
#define TSN_PID_TABLE_65                           ((0x0045  << 2) + 0xfe442400)
#define TSN_PID_TABLE_66                           ((0x0046  << 2) + 0xfe442400)
#define TSN_PID_TABLE_67                           ((0x0047  << 2) + 0xfe442400)
#define TSN_PID_TABLE_68                           ((0x0048  << 2) + 0xfe442400)
#define TSN_PID_TABLE_69                           ((0x0049  << 2) + 0xfe442400)
#define TSN_PID_TABLE_70                           ((0x004a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_71                           ((0x004b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_72                           ((0x004c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_73                           ((0x004d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_74                           ((0x004e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_75                           ((0x004f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_76                           ((0x0050  << 2) + 0xfe442400)
#define TSN_PID_TABLE_77                           ((0x0051  << 2) + 0xfe442400)
#define TSN_PID_TABLE_78                           ((0x0052  << 2) + 0xfe442400)
#define TSN_PID_TABLE_79                           ((0x0053  << 2) + 0xfe442400)
#define TSN_PID_TABLE_80                           ((0x0054  << 2) + 0xfe442400)
#define TSN_PID_TABLE_81                           ((0x0055  << 2) + 0xfe442400)
#define TSN_PID_TABLE_82                           ((0x0056  << 2) + 0xfe442400)
#define TSN_PID_TABLE_83                           ((0x0057  << 2) + 0xfe442400)
#define TSN_PID_TABLE_84                           ((0x0058  << 2) + 0xfe442400)
#define TSN_PID_TABLE_85                           ((0x0059  << 2) + 0xfe442400)
#define TSN_PID_TABLE_86                           ((0x005a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_87                           ((0x005b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_88                           ((0x005c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_89                           ((0x005d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_90                           ((0x005e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_91                           ((0x005f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_92                           ((0x0060  << 2) + 0xfe442400)
#define TSN_PID_TABLE_93                           ((0x0061  << 2) + 0xfe442400)
#define TSN_PID_TABLE_94                           ((0x0062  << 2) + 0xfe442400)
#define TSN_PID_TABLE_95                           ((0x0063  << 2) + 0xfe442400)
#define TSN_PID_TABLE_96                           ((0x0064  << 2) + 0xfe442400)
#define TSN_PID_TABLE_97                           ((0x0065  << 2) + 0xfe442400)
#define TSN_PID_TABLE_98                           ((0x0066  << 2) + 0xfe442400)
#define TSN_PID_TABLE_99                           ((0x0067  << 2) + 0xfe442400)
#define TSN_PID_TABLE_100                          ((0x0068  << 2) + 0xfe442400)
#define TSN_PID_TABLE_101                          ((0x0069  << 2) + 0xfe442400)
#define TSN_PID_TABLE_102                          ((0x006a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_103                          ((0x006b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_104                          ((0x006c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_105                          ((0x006d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_106                          ((0x006e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_107                          ((0x006f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_108                          ((0x0070  << 2) + 0xfe442400)
#define TSN_PID_TABLE_109                          ((0x0071  << 2) + 0xfe442400)
#define TSN_PID_TABLE_110                          ((0x0072  << 2) + 0xfe442400)
#define TSN_PID_TABLE_111                          ((0x0073  << 2) + 0xfe442400)
#define TSN_PID_TABLE_112                          ((0x0074  << 2) + 0xfe442400)
#define TSN_PID_TABLE_113                          ((0x0075  << 2) + 0xfe442400)
#define TSN_PID_TABLE_114                          ((0x0076  << 2) + 0xfe442400)
#define TSN_PID_TABLE_115                          ((0x0077  << 2) + 0xfe442400)
#define TSN_PID_TABLE_116                          ((0x0078  << 2) + 0xfe442400)
#define TSN_PID_TABLE_117                          ((0x0079  << 2) + 0xfe442400)
#define TSN_PID_TABLE_118                          ((0x007a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_119                          ((0x007b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_120                          ((0x007c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_121                          ((0x007d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_122                          ((0x007e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_123                          ((0x007f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_124                          ((0x0080  << 2) + 0xfe442400)
#define TSN_PID_TABLE_125                          ((0x0081  << 2) + 0xfe442400)
#define TSN_PID_TABLE_126                          ((0x0082  << 2) + 0xfe442400)
#define TSN_PID_TABLE_127                          ((0x0083  << 2) + 0xfe442400)
//========================================================================
// RNG REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440700
// -----------------------------------------------
#define RNG_TEE_READY                              ((0x0000  << 2) + 0xfe440700)
#define RNG_TEE_LOCK                               ((0x0001  << 2) + 0xfe440700)
#define RNG_TEE_CFG                                ((0x0002  << 2) + 0xfe440700)
#define RNG_TEE_NIST_OUT                           ((0x0003  << 2) + 0xfe440700)
#define RNG_TEE_OUT0                               ((0x0004  << 2) + 0xfe440700)
#define RNG_TEE_OUT1                               ((0x0005  << 2) + 0xfe440700)
#define RNG_TEE_OUT2                               ((0x0006  << 2) + 0xfe440700)
#define RNG_TEE_OUT3                               ((0x0007  << 2) + 0xfe440700)
#define RNG_CFG_RING                               ((0x0010  << 2) + 0xfe440700)
#define RNG_CFG_RESEED                             ((0x0011  << 2) + 0xfe440700)
#define RNG_CFG_HEALTH                             ((0x0012  << 2) + 0xfe440700)
#define RNG_CFG_MISC                               ((0x0013  << 2) + 0xfe440700)
#define RNG_REE_READY                              ((0x0020  << 2) + 0xfe440700)
#define RNG_REE_DEBUG                              ((0x0021  << 2) + 0xfe440700)
#define RNG_REE_CFG                                ((0x0022  << 2) + 0xfe440700)
#define RNG_REE_OUT0                               ((0x0024  << 2) + 0xfe440700)
#define RNG_REE_OUT1                               ((0x0025  << 2) + 0xfe440700)
#define RNG_REE_OUT2                               ((0x0026  << 2) + 0xfe440700)
#define RNG_REE_OUT3                               ((0x0027  << 2) + 0xfe440700)
//========================================================================
// OTP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440000
// -----------------------------------------------
#define OTP_TEE_RDY                                ((0x0000  << 2) + 0xfe440000)
#define OTP_TEE_DEBUG                              ((0x0001  << 2) + 0xfe440000)
#define OTP_TEE_CFG                                ((0x0002  << 2) + 0xfe440000)
#define OTP_TEE_WR_DAT                             ((0x0004  << 2) + 0xfe440000)
#define OTP_TEE_RD_DAT                             ((0x0008  << 2) + 0xfe440000)
#define OTP_LIC                                    ((0x0010  << 2) + 0xfe440000)
#define OTP_AML_ID_L                               ((0x0020  << 2) + 0xfe440000)
#define OTP_AML_ID_H                               ((0x0021  << 2) + 0xfe440000)
#define OTP_ACGK_ID_L                              ((0x0022  << 2) + 0xfe440000)
#define OTP_ACGK_ID_H                              ((0x0023  << 2) + 0xfe440000)
#define OTP_DVGK_ID_L                              ((0x0024  << 2) + 0xfe440000)
#define OTP_DVGK_ID_H                              ((0x0025  << 2) + 0xfe440000)
#define OTP_DVUK_ID_L                              ((0x0026  << 2) + 0xfe440000)
#define OTP_DVUK_ID_H                              ((0x0027  << 2) + 0xfe440000)
#define OTP_DGPK_ID_L                              ((0x0028  << 2) + 0xfe440000)
#define OTP_DGPK_ID_H                              ((0x0029  << 2) + 0xfe440000)
#define OTP_SECPU_ID_L                             ((0x002a  << 2) + 0xfe440000)
#define OTP_SECPU_ID_H                             ((0x002b  << 2) + 0xfe440000)
#define OTP_ETSI012_ID_L                           ((0x002c  << 2) + 0xfe440000)
#define OTP_ETSI012_ID_H                           ((0x002d  << 2) + 0xfe440000)
#define OTP_ETSI3_ID_L                             ((0x002e  << 2) + 0xfe440000)
#define OTP_ETSI3_ID_H                             ((0x002f  << 2) + 0xfe440000)
#define OTP_MSR_ID_L                               ((0x0030  << 2) + 0xfe440000)
#define OTP_MSR_ID_H                               ((0x0031  << 2) + 0xfe440000)
#define OTP_VO_ID_L                                ((0x0032  << 2) + 0xfe440000)
#define OTP_VO_ID_H                                ((0x0033  << 2) + 0xfe440000)
#define OTP_NUID_ID_L                              ((0x0034  << 2) + 0xfe440000)
#define OTP_NUID_ID_H                              ((0x0035  << 2) + 0xfe440000)
#define OTP_CONAX_ID_L                             ((0x0036  << 2) + 0xfe440000)
#define OTP_CONAX_ID_H                             ((0x0037  << 2) + 0xfe440000)
#define OTP_NSK_ID_L                               ((0x0038  << 2) + 0xfe440000)
#define OTP_NSK_ID_H                               ((0x0039  << 2) + 0xfe440000)
#define OTP_REE_RDY                                ((0x0040  << 2) + 0xfe440000)
#define OTP_REE_DEBUG                              ((0x0041  << 2) + 0xfe440000)
#define OTP_REE_CFG                                ((0x0042  << 2) + 0xfe440000)
#define OTP_MRK_CHKNUM                             ((0x0043  << 2) + 0xfe440000)
#define OTP_REE_RD_DAT                             ((0x0048  << 2) + 0xfe440000)
//========================================================================
// KL REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440200
// -----------------------------------------------
#define MKL_TEE_RDY                                ((0x0000  << 2) + 0xfe440200)
#define MKL_TEE_DEBUG                              ((0x0001  << 2) + 0xfe440200)
#define MKL_TEE_CFG                                ((0x0002  << 2) + 0xfe440200)
#define MKL_TEE_CMD                                ((0x0003  << 2) + 0xfe440200)
#define MKL_TEE_EK                                 ((0x0004  << 2) + 0xfe440200)
#define MKL_TEE_CR_0                               ((0x001c  << 2) + 0xfe440200)
#define MKL_TEE_CR_1                               ((0x001d  << 2) + 0xfe440200)
#define MKL_TEE_CR_2                               ((0x001e  << 2) + 0xfe440200)
#define MKL_TEE_CR_3                               ((0x001f  << 2) + 0xfe440200)
#define MKL_REE_RDY                                ((0x0020  << 2) + 0xfe440200)
#define MKL_REE_DEBUG                              ((0x0021  << 2) + 0xfe440200)
#define MKL_REE_CFG                                ((0x0022  << 2) + 0xfe440200)
#define MKL_REE_CMD                                ((0x0023  << 2) + 0xfe440200)
#define MKL_REE_EK                                 ((0x0024  << 2) + 0xfe440200)
//========================================================================
// DMA REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440400
// -----------------------------------------------
#define DMA_CORE_DSC_0                             ((0x0000  << 2) + 0xfe440400)
#define DMA_CORE_DSC_1                             ((0x0001  << 2) + 0xfe440400)
#define DMA_CORE_DSC_2                             ((0x0002  << 2) + 0xfe440400)
#define DMA_CORE_DSC_3                             ((0x0003  << 2) + 0xfe440400)
#define DMA_CORE_DSC_4                             ((0x0004  << 2) + 0xfe440400)
#define DMA_CORE_DSC_5                             ((0x0005  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_0                         ((0x0008  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_1                         ((0x0009  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_2                         ((0x000a  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_3                         ((0x000b  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_4                         ((0x000c  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_5                         ((0x000d  << 2) + 0xfe440400)
#define DMA_CORE_CFG_REG                           ((0x0010  << 2) + 0xfe440400)
#define DMA_CORE_CFG_SEC_LSB                       ((0x0011  << 2) + 0xfe440400)
#define DMA_CORE_CFG_SEC_MSB                       ((0x0012  << 2) + 0xfe440400)
//========================================================================
// KT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440500
// -----------------------------------------------
#define KT_TEE_RDY                                 ((0x0000  << 2) + 0xfe440500)
#define KT_TEE_RDY2                                ((0x0001  << 2) + 0xfe440500)
#define KT_TEE_CFG                                 ((0x0002  << 2) + 0xfe440500)
#define KT_TEE_STS                                 ((0x0003  << 2) + 0xfe440500)
#define KT_TEE_KEY0                                ((0x0004  << 2) + 0xfe440500)
#define KT_TEE_KEY1                                ((0x0005  << 2) + 0xfe440500)
#define KT_TEE_KEY2                                ((0x0006  << 2) + 0xfe440500)
#define KT_TEE_KEY3                                ((0x0007  << 2) + 0xfe440500)
#define KT_REE_RDY                                 ((0x0020  << 2) + 0xfe440500)
#define KT_REE_RDY2                                ((0x0021  << 2) + 0xfe440500)
#define KT_REE_CFG                                 ((0x0022  << 2) + 0xfe440500)
#define KT_REE_STS                                 ((0x0023  << 2) + 0xfe440500)
#define KT_REE_KEY0                                ((0x0024  << 2) + 0xfe440500)
#define KT_REE_KEY1                                ((0x0025  << 2) + 0xfe440500)
#define KT_REE_KEY2                                ((0x0026  << 2) + 0xfe440500)
#define KT_REE_KEY3                                ((0x0027  << 2) + 0xfe440500)
//========================================================================
// CERT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440600
// -----------------------------------------------
//========================================================================
// SP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe441000
// -----------------------------------------------
//ree domain
#define REE_SCPU2REE_CSR_ADDR                      ((0x0300  << 2) + 0xfe441000)
#define REE_SCPU2REE_DATA_ST_ADDR                  ((0x0380  << 2) + 0xfe441000)
#define REE_SCPU2REE_DATA_ED_ADDR                  ((0x039f  << 2) + 0xfe441000)
#define REE_REE2SCPU_CSR_ADDR                      ((0x0200  << 2) + 0xfe441000)
#define REE_REE2SCPU_DATA_ST_ADDR                  ((0x0280  << 2) + 0xfe441000)
#define REE_REE2SCPU_DATA_ED_ADDR                  ((0x029f  << 2) + 0xfe441000)
//tee domain
#define TEE_SCPU2TEE_CSR_ADDR                      ((0x0100  << 2) + 0xfe441000)
#define TEE_SCPU2TEE_DATA_ST_ADDR                  ((0x0180  << 2) + 0xfe441000)
#define TEE_SCPU2TEE_DATA_ED_ADDR                  ((0x019f  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_CSR_ADDR                      ((0x0000  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_DATA_ST_ADDR                  ((0x0080  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_DATA_ED_ADDR                  ((0x009f  << 2) + 0xfe441000)
//========================================================================
// NSK REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe450000
// -----------------------------------------------
//
// Closing file:  ./REG_LIST_SECURITY_RTL.h
//
//
// Reading file:  ./REG_LIST_DEMUX_RTL.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe040000
// -----------------------------------------------
// There are two instantiations under one CBUS slave.  Each CBUS slave can support
// 256 registers.  Each demux is allocated 128 registers so set the offset in
// the middle
// Copy this define but don't add a base address
#define SECOND_DEMUX_OFFSET_0  0x50
#define THIRD_DEMUX_OFFSET_0   0xa0
//========================================================================
//  STB TOP Registers				    (8'hf0 - 8'hf7)
//========================================================================
// Bit 5:4 -- fec_sel_demux_2
// Bit 3:2 -- fec_sel_demux_1
// Bit 1:0 -- fec_sel_demux_0
#define TS_TOP_CONFIG1                             ((0x004f  << 2) + 0xfe040000)
// Bit 31:24 -- file_m2ts_skip_bytes_hiu1
// Bit 23:22 -- reserved
// Bit 21 -- ts_hiu_enable_hiu1
// Bit 20:16 -- fec_clk_div_hiu1
// Bit 15:8 -- TS_package_length_sub_1_hiu1 (default : 187)
// Bit 7:0 -- fec_sync_byte_hiu1 (default : 0x47)
#define TS_HIU1_CONFIG                             ((0x004e  << 2) + 0xfe040000)
//bit[1:0]--   stb_recorder2_sel
#define STB_RECORDER2_CNTL                         ((0x00ee  << 2) + 0xfe040000)
// bit [11]--   s2p2_disable
// bit [10:7]-- s2p2_clk_div
// bit [6:0]--  fec_serial_control_2
#define STB_S2P2_CONFIG                            ((0x00ef  << 2) + 0xfe040000)
// bit 30:28 -- ciplus_o_sel
// bit 27:26 -- ciplus_i_sel
// bit 25 -- use FAIL fro TS2
// bit 24 -- use FAIL fro TS1
// bit 23 -- use FAIL fro TS0
// bit 22 -- invert fec_error for S2P1
// bit 21 -- invert fec_data for S2P1
// bit 20 -- invert fec_sync for S2P1
// bit 19 -- invert fec_valid for S2P1
// bit 18 -- invert fec_clk for S2P1
// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
// Bit 15 -- enable_des_pl_clk
// Bit 14 -- ts_out_select[3]
// Bit 13 --  use FAIL for TS3
// Bit 12:10 -- ts_out_select[2:0], 0-TS0, 1-TS1, 2-TS2, 3-TS3, 4-S2P2, 5-S2P1, 6-S2P0, 7-File, 8-File1
// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
// bit 7 -- enable_des_pl
// bit 6 -- invert fec_error for S2P0
// bit 5 -- invert fec_data for S2P0
// bit 4 -- invert fec_sync for S2P0
// bit 3 -- invert fec_valid for S2P0
// bit 2 -- invert fec_clk for S2P0
// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
#define STB_TOP_CONFIG                             ((0x00f0  << 2) + 0xfe040000)
// 31:28 - s2p1_clk_div
// 27:24 - s2p0_clk_div
// 23    - s2p1_disable
// 22    - s2p0_disable
// 21    - Reserved
// 20 -- TS_OUT_error_INVERT
// 19 -- TS_OUT_data_INVERT
// 18 -- TS_OUT_sync_INVERT
// 17 -- TS_OUT_valid_INVERT
// 16 -- TS_OUT_clk_INVERT
// 15:8 -- TS_package_length_sub_1 (default : 187)
//  7:0 -- fec_sync_byte (default : 0x47)
#define TS_TOP_CONFIG                              ((0x00f1  << 2) + 0xfe040000)
// Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3
// Bit 23:16 -- file_m2ts_skip_bytes
// Bit 15:8 -- des_out_dly
// Bit 7:6 -- transport_scrambling_control_odd // should be 3
// Bit 5 -- ts_hiu_enable
// Bit 4:0 -- fec_clk_div
#define TS_FILE_CONFIG                             ((0x00f2  << 2) + 0xfe040000)
// Bit 19:14 -- des_2 ts pl state   -- Read Only
// Bit 13:8 -- des ts pl state   -- Read Only
// Bit 3:0 PID index to 8 PID to get key-set
// auto increse after TS_PL_PID_DATA read/write
#define TS_PL_PID_INDEX                            ((0x00f3  << 2) + 0xfe040000)
// Bit 13 -- PID match disble
// Bit 12:0 -- PID
#define TS_PL_PID_DATA                             ((0x00f4  << 2) + 0xfe040000)
#define COMM_DESC_KEY0                             ((0x00f5  << 2) + 0xfe040000)
#define COMM_DESC_KEY1                             ((0x00f6  << 2) + 0xfe040000)
#define COMM_DESC_KEY_RW                           ((0x00f7  << 2) + 0xfe040000)
// CI+ Register defines
// Bits[31:0] of the key
#define CIPLUS_KEY0                                ((0x00f8  << 2) + 0xfe040000)
// Bits[63:32] of the key
#define CIPLUS_KEY1                                ((0x00f9  << 2) + 0xfe040000)
// Bits[95:64] of the key
#define CIPLUS_KEY2                                ((0x00fa  << 2) + 0xfe040000)
// Bits[127:96] of the key
#define CIPLUS_KEY3                                ((0x00fb  << 2) + 0xfe040000)
// bit[5] write AES IV B value
// bit[4] write AES IV A value
// bit[3] write AES B key
// bit[2] write AES A key
// bit[1] write DES B key
// bit[0] write DES A key
#define CIPLUS_KEY_WR                              ((0x00fc  << 2) + 0xfe040000)
// [15:8]   TS out delay.  This controls the rate at which the CIplus module drives TS out
// [3]      General enable for the ciplus module
// [2]      AES CBC disable (default should be 0 to enable AES CBC)
// [1]      AES Enable
// [0]      DES Eanble
#define CIPLUS_CONFIG                              ((0x00fd  << 2) + 0xfe040000)
// bit[31:28] AES IV endian
// bit[27:24] AES message out endian
// bit[23:20] AES message in endian
// bit[19:16] AES key endian
// bit[15:11]  unused
// bit[10:8]  DES message out endian
// bit[6:4]   DES message in endian
// bit[2:0]   DES key endian
#define CIPLUS_ENDIAN                              ((0x00fe  << 2) + 0xfe040000)
// bit 15:8 - des_out_dly_2
// bit   7 - reserved
// Bit   6-- enable_des_pl_clk_2
// bit   5 - enable_des_pl_2
// bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2
// bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
#define COMM_DESC_2_CTL                            ((0x00ff  << 2) + 0xfe040000)
//
// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
//        Instead, since the demux has multiple instances (and many registers) use a separate
//        script to create a separate stb_define.h for C-code.
//========================================================================
//  STB Registers				    (8'h00 - 8'h4f)
//
//========================================================================
// STB registers are 8'h0x
// Bit 15:0 -- version number : 0x0002  (v0.01)
// Bit 16 -- fec_select[3]
// Bit 15 -- fec_core_select 1 - select descramble output
// Bit 14:12 -  fec_select[2:0] 0-TS0, 1-TS1, 2-TS2, 3-TS3, 4-S2P2, 5-S2P1, 6-S2P0, 7-File, 8-File1
// Bit 11 -- FEC_CLK
// Bit 10 -- SOP
// Bit 9 -- D_VALID
// Bit 8 -- D_FAIL
// Bit 7:0 -- D_DATA 7:0
// bit 31 -- enable_free_clk_fec_data_valid
// bit 30 -- enable_free_clk_stb_reg
// bit 29 -- always_use_pes_package_length
// bit 28 -- disable_pre_incomplete_section_fix
// bit 27 -- pointer_field_multi_pre_en
// bit 26 -- ignore_pre_incomplete_section
// bit 25 -- video2_enable
// bit 24:22 -- video2_type
// bit 21 -- do_not_trust_pes_package_length
// bit 20 (bit 4) -- Bypass use recoder path
// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
// bit 18 (bit 2) -- Disable Splicing
// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
// Bit 15 - do not trust section length
// Bit 14 - om cmd push even zero
// Bit 13 - set_buff_ready_even_not_busy
// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
// Bit 11 - discard_av_package -- for ts_recorder use only
// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
// Bit 9 - ts_recorder_enable
// Bit 8 - (table_id == 0xff) means section_end
// Bit 7 - do not send uncomplete section
// Bit 6 - do not discard duplicate package
// Bit 5 - search SOP when transport_error_indicator
// Bit 4 - stb demux enable
// Bit 3 - do not reset state machine on SOP
// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
// Bit 1 - do not use SOP input ( check FEC sync byte instead )
// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
// bit 15:8 demux package length - 1 ( default : 187 )
// bit 7:0 default is 0x47
// bit 31:16 -- filter memory write data hi[31:16]
// bit 15:0 -- filter memory write data low [15:0]
// bit 31:24 -- advanced setting hi
// bit 23:16 -- advanced setting low
// bit 15 -- filter memory write data request
// bit 7:0 -- filter memory write addr
// bit 13:8 demux state  -- read only
// bit 7:4 -- maxnum section filter compare address
// bit 3:0 -- maxnum PID filter compare address
// bit 15 - transport_error_indicator
// bit 14 - payload_unit_start_indicator
// bit 13 - transport_priority
// bit 12:0 - PID
// bit 7:6 transport_scrambling_control
// bit 5:4 adaptation_field_control
// bit 3:0 continuity_counter
// bit 15:12 -- om_cmd_count (read only)
// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
// bit   5:3 -- type_stb_om_w_rd (read only)
// bit     2 -- unit_start_stb_om_w_rd (read only)
// bit     1 -- om_cmd_overflow (read only)
// bit     0 -- om_cmd_pending (read)
// bit     0 -- om_cmd_read_finished (write)
// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
// bit 11:0 -- offset for section data
// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
// bit 7:4 -- section buffer size for group 1
// bit 11:8 -- section buffer size for group 2
// bit 15:12 -- section buffer size for group 3
// section buffer busy status for buff 31:0 ( Read Only )
// section buffer write status for buff 31:0 -- Read
// clear buffer status ( buff READY and BUSY ) -- write
// bit 4:0 -- SEC_BUFFER_INDEX   RW
// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
// bit 14 -- output_section_buffer_valid
// bit 15 -- section_reset_busy (Read Only)
// bit 9:5 -- BYPASS PID number
// bit 4:0 -- PCR PID number
// bit 15:0 -- stream_id filter bit enable
// bit 7:0 -- stream_id filter target
// bit 12 -- PCR_EN
// bit 11:0 -- PCR90K_DIV
// bit 31:0 -- PCR[31:0] R/W
// bit 31:0 -- VPTS[31:0] R/W
// bit 31:0 -- VDTS[31:0] R/W
// bit 31:0 -- APTS[31:0] R/W
// bit 31:0 -- SPTS[31:0] R/W
// read -- status, write 1 clear status
// bit 15 -- SUB_PTS[32]
// bit 14 -- AUDIO_PTS[32]
// bit 13 -- VIDEO_DTS[32]
// bit 12 -- VIDEO_PTS[32]
// bit 3 -- sub_pts_ready
// bit 2 -- audio_pts_ready
// bit 1 -- video_dts_ready
// bit 0 -- video_pts_ready
// bit 3:0 --
//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]
//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
//  2 -- pes_package_bytes_left[15:0]
//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
//
// read only
// bit[31] -- no_match_record_en
// bit[30:16] - reserved
// default : 0x807f
// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)
// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
// 15:0  WRITE 1 CLEAR to clear interrupt source
//12 -- INPUT_TIME_OUT
//11 -- PCR_ready
//10 -- audio_splicing_point
// 9 -- video_splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN
// Bit 5:3 - demux om write endian control for bypass
// Bit 2:0 - demux om write endian control for section
// When Bit 31 - 1 write will indicate all type use separate endian (Write Only)
// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
// Bit 17:15 - demux om write endian control for SUB_PACKET
// Bit 14:12 - demux om write endian control for AUDIO_PACKET
// Bit 11:9  - demux om write endian control for VIDEO_PACKET
//
// When Bit 31 - 0 write will indicate all type else use Bit 8:6
// Bit 8:6 - demux om write endian control for else
// Bit 10:9 -- sel DPTS_wr_ptr: 00 from parserA ; 01 from parserB
// Bit 8:7 -- use hi_bsf interface: 01 sel hiu0; 10 sel hiu1
// Bit 6:2 - Reserved
// Bit 1 - enable_halt_ts_hiu_fix
// Bit 0 - enable_halt_ts_hiu
// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
// bit 10 -- mask bit for SUB_AHB_DMA_EN
// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
// bit 8 -- mask bit for SECTION_AHB_DMA_EN
// bit 7 -- mask bit for recoder stream
// bit 6:0 -- mask bit for each type
// bit 31:0 -- vb_wr_ptr for video PDTS
// bit 31:0 -- ab_wr_ptr for audio PDTS
// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
// bit 19:0 -- SB_START (sb_start << 12 == byte address);
// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)
// bit 31:0 -- sb_wr_ptr for sub PES
// bit 31:16 -- ob_wr_ptr for other PES
// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
// bit 19:0 -- OB_START (ob_start << 12 == byte address);
// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)
// bit 31:0 -- ob_wr_ptr for sub PES
// 15:0  DEMUX interrupt MASK
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN
// 31:16 VIDEO PID filter data
//15 -- splicing VIDEO PID change enable
//14:10 -- VIDEO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only)
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 31:16 AUDIO PID filter data
//15 -- splicing AUDIO PID change enable
//14:10 -- AUDIO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only)
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 23:16 M2TS_SKIP_BYTES
// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
// 7:0  PACKAGE BYTE COUNT (Read Only)
// 15:0 2 bytes strong sync add to PES
// bit 15 -- stb_om_ren
// bit 14:11 -- reserved
// bit  10:0 -- OM_DATA_RD_ADDR
// bit 15:0 -- OM_DATA_RD
// AUTO STOP SETTING for 32 channels
// 4-nbits per channel
// when write
// bit 3 -- set section active
// bit 2:0 -- auto stop after count (0 means never stop)
// when read
// bit 3 -- current active status (1 - active, 0 - stopped )
// bit 2:0 -- count down to auto stop
// section 31:24
// section 23:16
// section 15:8
// section 7:0
// bit 31:0 reset channel status - each bit reset each channel
// read -- 32 channel status
// bit 4 -- video_stamp_use_dts
// bit 3 -- audio_stamp_sync_1_en
// bit 2 -- audio_stamp_insert_en
// bit 1 -- video_stamp_sync_1_en
// bit 0 -- video_stamp_insert_en
// Write : Bit[4:0] secter filter number for reset
// Read  : select according to output_section_buffer_valid :
//         per bit per section buffer valid status
//         or section_buffer_ignore
// bit[31:0] - channel_reset_timeout_disable
// bit[31] - no_match_reset_timeout_disable
// bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count
// bit[31:0] - channel_packet_count_disable
// bit[31] - no_match_packet_count_disable
// bit[30:0] input_packet_count
// bit[31:0] channel_record_enable
// bit[31:0] channel_process_enable
// bit[31:24] small_sec_size ((n+1) * 256 Bytes)
// bit[23:16] small_sec_rd_ptr
// bit[15:8]  small_sec_wr_ptr
// bit[7:2]   reserved
// bit[1] small_sec_wr_ptr_wr_enable
// bit[0] small_section_enable
// bit[31:0] small_sec_start_addr
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./REG_LIST_DEMUX_RTL.h
//
//
// Reading file:  ./adla_4tl_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
//========================================================================
//  ADLA_4TL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe371000
// -----------------------------------------------
#define ADLA_4TL_REV                               ((0x0000  << 2) + 0xfe371000)
//Bit 5:0    4TL      reg_imp_rev
//Bit 11:6   4TL      reg_minor_rev
//Bit 15:12  4TL      reg_major_rev
#define ADLA_4TL_WAIT_TIMER                        ((0x0001  << 2) + 0xfe371000)
//Bit 15:0   4TL      reg_wait_timer_val
#define ADLA_4TL_IRQ_MASKED                        ((0x0004  << 2) + 0xfe371000)
//Bit 15:0   4TL      reg_irqsts_masked
#define ADLA_4TL_IRQ_MASK                          ((0x0005  << 2) + 0xfe371000)
//Bit 15:0   4TL      reg_irqsts_mask
#define ADLA_4TL_IRQ_RAW                           ((0x0006  << 2) + 0xfe371000)
//Bit 15:0   4TL      reg_irqsts_raw
#define ADLA_4TL_STS_REPORT                        ((0x0007  << 2) + 0xfe371000)
//Bit 15:0   4TL      reg_sts_report
#define ADLA_4TL_SWRST                             ((0x0008  << 2) + 0xfe371000)
//Bit 0:0    4TL      reg_adla_swrst
#define ADLA_4TL_EN                                ((0x0009  << 2) + 0xfe371000)
//Bit 0:0    4TL      reg_adla_en
#define ADLA_4TL_CLK_AUTOCLK                       ((0x000a  << 2) + 0xfe371000)
//Bit 31:0   4TL      reg_adla_autoclk_en
#define ADLA_4TL_CLK_IDLE_CNT                      ((0x000b  << 2) + 0xfe371000)
//Bit 4:0    4TL      reg_adla_autoclk_idle_cnt
//Bit 12:8   4TL      reg_adla_autoclk_busy_cnt
#define ADLA_4TL_DBG_EN                            ((0x000c  << 2) + 0xfe371000)
//Bit 0:0    4TL      reg_dbg_en
#define ADLA_4TL_DBG_SEL                           ((0x000d  << 2) + 0xfe371000)
#define ADLA_4TL_DBG_SUB_SEL                       ((0x000e  << 2) + 0xfe371000)
#define ADLA_4TL_DBG_DAT                           ((0x000f  << 2) + 0xfe371000)
#define ADLA_4TL_SRAM_CTRL                         ((0x0010  << 2) + 0xfe371000)
#define ADLA_4TL_SRAM_ADDR                         ((0x0011  << 2) + 0xfe371000)
#define ADLA_4TL_SRAM_WDAT                         ((0x0012  << 2) + 0xfe371000)
#define ADLA_4TL_SRAM_RDAT                         ((0x0013  << 2) + 0xfe371000)
#define ADLA_4TL_PS_CTRL                           ((0x0014  << 2) + 0xfe371000)
#define ADLA_4TL_PS_STS                            ((0x0015  << 2) + 0xfe371000)
#define ADLA_4TL_PS_ERR_DAT                        ((0x0016  << 2) + 0xfe371000)
#define ADLA_4TL_PS_IDLE_STS                       ((0x0017  << 2) + 0xfe371000)
#define ADLA_4TL_PS_TIME_STAMP                     ((0x0018  << 2) + 0xfe371000)
#define ADLA_4TL_PS_RBF_BASE                       ((0x0019  << 2) + 0xfe371000)
#define ADLA_4TL_PS_RBF_SIZE                       ((0x001a  << 2) + 0xfe371000)
#define ADLA_4TL_PS_RBF_WPT                        ((0x001b  << 2) + 0xfe371000)
#define ADLA_4TL_PS_RBF_RPT                        ((0x001c  << 2) + 0xfe371000)
#define ADLA_4TL_PS_RBF_PPT                        ((0x001d  << 2) + 0xfe371000)
#define ADLA_4TL_PS_FINISH_ID                      ((0x001e  << 2) + 0xfe371000)
#define ADLA_4TL_PS_HCNT                           ((0x001f  << 2) + 0xfe371000)
#define ADLA_4TL_PS_OST                            ((0x0020  << 2) + 0xfe371000)
#define ADLA_4TL_PS_PEND_EN                        ((0x0021  << 2) + 0xfe371000)
#define ADLA_4TL_PS_PEND_VAL                       ((0x0022  << 2) + 0xfe371000)
#define ADLA_4TL_PS_MDL_IDLE_STS                   ((0x0023  << 2) + 0xfe371000)
#define ADLA_4TL_PS_DBG_SW_ID                      ((0x0024  << 2) + 0xfe371000)
#define ADLA_4TL_AB_AXI_PADDR                      ((0x0027  << 2) + 0xfe371000)
#define ADLA_4TL_AB_CTL                            ((0x0028  << 2) + 0xfe371000)
#define ADLA_4TL_AB_AXI_SADDR                      ((0x0029  << 2) + 0xfe371000)
#define ADLA_4TL_AB_AXI_EADDR                      ((0x002a  << 2) + 0xfe371000)
#define ADLA_4TL_AB_R_CS_PRIO                      ((0x002b  << 2) + 0xfe371000)
#define ADLA_4TL_AB_R_LS_PRIO                      ((0x002c  << 2) + 0xfe371000)
#define ADLA_4TL_AB_R_L2_PRIO                      ((0x002d  << 2) + 0xfe371000)
#define ADLA_4TL_AB_W_PRIO                         ((0x002e  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_EN                           ((0x0030  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_TTBR_L                       ((0x0031  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_TTBR_H                       ((0x0032  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_PRIO_POW2_0                  ((0x0033  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_PRIO_POW2_1                  ((0x0034  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_INV_CTL                      ((0x0035  << 2) + 0xfe371000)
#define ADLA_4TL_SMMU_INV_VA                       ((0x0036  << 2) + 0xfe371000)
#define ADLA_4TL_PM_EN                             ((0x003c  << 2) + 0xfe371000)
#define ADLA_4TL_PM_RBF_BASE                       ((0x003d  << 2) + 0xfe371000)
#define ADLA_4TL_PM_RBF_SIZE                       ((0x003e  << 2) + 0xfe371000)
#define ADLA_4TL_PM_RBF_WPT                        ((0x003f  << 2) + 0xfe371000)
#define ADLA_4TL_PM_RBF_RPT                        ((0x0040  << 2) + 0xfe371000)
#define ADLA_4TL_PM_STS                            ((0x0041  << 2) + 0xfe371000)
#define ADLA_4TL_AXXIBRG_DX_CTL                    ((0x0044  << 2) + 0xfe371000)
#define ADLA_4TL_AXXIBRG_DX_HOLD                   ((0x0045  << 2) + 0xfe371000)
#define ADLA_4TL_AXXIBRG_SX_CTL                    ((0x0046  << 2) + 0xfe371000)
#define ADLA_4TL_AXXIBRG_SX_HOLD                   ((0x0047  << 2) + 0xfe371000)
#define ADLA_4TL_MC_CTL                            ((0x0048  << 2) + 0xfe371000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./adla_4tl_regs.h
//
//========================================================================
//  MIPI_DSI_HOST
//========================================================================
//
// Reading file:  ./dsi_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// MIPI DSI HOST A CONTROLLER Registers 0xfe074000 - 0xfe074fff
//===========================================================================
//------------------------------------------------------------------------------
// DWC IP registers: Synopsys IP, please refer to MIPI DSI HOST Databook
//------------------------------------------------------------------------------
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe074000
// -----------------------------------------------
#define MIPI_DSI_DWC_VERSION_OS                    ((0x0000  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PWR_UP_OS                     ((0x0001  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_CLKMGR_CFG_OS                 ((0x0002  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_DPI_VCID_OS                   ((0x0003  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_DPI_COLOR_CODING_OS           ((0x0004  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_DPI_CFG_POL_OS                ((0x0005  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_DPI_LP_CMD_TIM_OS             ((0x0006  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PCKHDL_CFG_OS                 ((0x000b  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_GEN_VCID_OS                   ((0x000c  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_MODE_CFG_OS                   ((0x000d  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_MODE_CFG_OS               ((0x000e  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_PKT_SIZE_OS               ((0x000f  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_NUM_CHUNKS_OS             ((0x0010  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_NULL_SIZE_OS              ((0x0011  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_HSA_TIME_OS               ((0x0012  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_HBP_TIME_OS               ((0x0013  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_HLINE_TIME_OS             ((0x0014  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_VSA_LINES_OS              ((0x0015  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_VBP_LINES_OS              ((0x0016  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_VFP_LINES_OS              ((0x0017  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_VID_VACTIVE_LINES_OS          ((0x0018  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_EDPI_CMD_SIZE_OS              ((0x0019  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_CMD_MODE_CFG_OS               ((0x001a  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_GEN_HDR_OS                    ((0x001b  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_GEN_PLD_DATA_OS               ((0x001c  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_CMD_PKT_STATUS_OS             ((0x001d  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_TO_CNT_CFG_OS                 ((0x001e  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_HS_RD_TO_CNT_OS               ((0x001f  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_LP_RD_TO_CNT_OS               ((0x0020  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_HS_WR_TO_CNT_OS               ((0x0021  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_LP_WR_TO_CNT_OS               ((0x0022  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_BTA_TO_CNT_OS                 ((0x0023  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_SDF_3D_OS                     ((0x0024  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_LPCLK_CTRL_OS                 ((0x0025  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS          ((0x0026  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_TMR_CFG_OS                ((0x0027  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_RSTZ_OS                   ((0x0028  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_IF_CFG_OS                 ((0x0029  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_ULPS_CTRL_OS              ((0x002a  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_TX_TRIGGERS_OS            ((0x002b  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_STATUS_OS                 ((0x002c  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_TST_CTRL0_OS              ((0x002d  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_PHY_TST_CTRL1_OS              ((0x002e  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_INT_ST0_OS                    ((0x002f  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_INT_ST1_OS                    ((0x0030  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_INT_MSK0_OS                   ((0x0031  << 2) + 0xfe074000)
#define MIPI_DSI_DWC_INT_MSK1_OS                   ((0x0032  << 2) + 0xfe074000)
//------------------------------------------------------------------------------
// Top-level registers: AmLogic proprietary
//------------------------------------------------------------------------------
#define MIPI_DSI_TOP_SHADOW_HSA_TIME               ((0x00e8  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_HBP_TIME               ((0x00e9  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_HLINE_TIME             ((0x00ea  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_VSA_LINES              ((0x00eb  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_VBP_LINES              ((0x00ec  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_VFP_LINES              ((0x00ed  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_VACTIVE_LINES          ((0x00ee  << 2) + 0xfe074000)
#define MIPI_DSI_TOP_SHADOW_TIME_CTRL              ((0x00ef  << 2) + 0xfe074000)
// 31: 4    Reserved.                                                                           Default 0.
//     3 RW ~tim_rst_n:  1=Assert SW reset on mipi_dsi_host_timing block.   0=Release reset.    Default 1.
//     2 RW ~dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.      0=Release reset.    Default 1.
//     1 RW ~intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.     0=Release reset.    Default 1.
//     0 RW ~dwc_rst_n:  1=Assert SW reset on IP core.                      0=Release reset.    Default 1.
#define MIPI_DSI_TOP_SW_RESET                      ((0x00f0  << 2) + 0xfe074000)
// 31: 5    Reserved.                                                                                                       Default 0.
//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
//                          0=Default, use auto-clock gating to save power;
//                          1=use free-run clock, disable auto-clock gating, for debug mode.
//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
#define MIPI_DSI_TOP_CLK_CNTL                      ((0x00f1  << 2) + 0xfe074000)
// 31:27    Reserved.                                                                       Default 0.
//    26 RW de_dpi_pol:     1= Invert DE polarity from mipi_dsi_host_dpi.                   Default 0.
//    25 RW hsync_dpi_pol:  1= Invert HS polarity from mipi_dsi_host_dpi.                   Default 0.
//    24 RW vsync_dpi_pol:  1= Invert VS polarity from mipi_dsi_host_dpi.                   Default 0.
// 23:20 RW dpi_color_mode: Define DPI pixel format.                                        Default 0.
//                           0=16-bit RGB565 config 1;
//                           1=16-bit RGB565 config 2;
//                           2=16-bit RGB565 config 3;
//                           3=18-bit RGB666 config 1;
//                           4=18-bit RGB666 config 2;
//                           5=24-bit RGB888;
//                           6=20-bit YCbCr 4:2:2;
//                           7=24-bit YCbCr 4:2:2;
//                           8=16-bit YCbCr 4:2:2;
//                           9=30-bit RGB;
//                          10=36-bit RGB;
//                          11=12-bit YCbCr 4:2:0.
//    19    Reserved.                                                                       Default 0.
// 18:16 RW in_color_mode:  Define VENC data width.                                         Default 0.
//                          0=30-bit pixel;
//                          1=24-bit pixel;
//                          2=18-bit pixel, RGB666;
//                          3=16-bit pixel, RGB565.
// 15:14 RW chroma_subsample: Define method of chroma subsampling.                          Default 0.
//                            Applicable to YUV422 or YUV420 only.
//                            0=Use even pixel's chroma;
//                            1=Use odd pixel's chroma;
//                            2=Use averaged value between even and odd pair.
// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.    Default 2.
// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.    Default 1.
//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.    Default 0.
//     7    Reserved.                                                                       Default 0.
//     6 RW de_venc_pol:    1= Invert DE polarity from VENC.                                Default 0.
//     5 RW hsync_venc_pol: 1= Invert HS polarity from VENC.                                Default 0.
//     4 RW vsync_venc_pol: 1= Invert VS polarity from VENC.                                Default 0.
//     3 RW dpicolorm:      Signal to IP.                                                   Default 0.
//     2 RW dpishutdn:      Signal to IP.                                                   Default 0.
//     1    Reserved.                                                                       Default 0.
//     0    Reserved.                                                                       Default 0.
#define MIPI_DSI_TOP_CNTL                          ((0x00f2  << 2) + 0xfe074000)
// 31:16    Reserved.                                                                                                           Default 0.
// 15: 8 RW suspend_frame_rate: Define rate of timed-suspend.                                                                   Default 0.
//                              0=Execute suspend every frame; 1=Every other frame; ...; 255=Every 256 frame.
//  7: 4    Reserved.                                                                                                           Default 0.
//     3 RW disable suspend venc:   1=don`t support suspend VencL. 0=support suspend venc                                       Default 0.
//     2 RW timed_suspend_en:   1=Enable timed suspend VencL. 0=Disable timed suspend.                                          Default 0.
//     1 RW manual_suspend_en:  1=Enable manual suspend VencL. 1=Cancel manual suspend VencL.                                   Default 0.
//     0 RW suspend_on_edpihalt:1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL.   Default 1.
#define MIPI_DSI_TOP_SUSPEND_CNTL                  ((0x00f3  << 2) + 0xfe074000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_line_end:   Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_line_start: Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_TOP_SUSPEND_LINE                  ((0x00f4  << 2) + 0xfe074000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_pix_end:    Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_pix_start:  Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_TOP_SUSPEND_PIX                   ((0x00f5  << 2) + 0xfe074000)
// 31:20    Reserved.                                                                                                           Default 0.
// 19:10 RW meas_vsync:     Control on measuring Host Controller's vsync.                                                       Default 0.
//                          [   19] meas_en:        1=Enable measurement
//                          [   18] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [17:10] vsync_span:     Define the duration of a measure is to last for how many Vsyncs.
//  9: 0 RW meas_edpite:    Control on measuring Display Slave's edpite.                                                        Default 0.
//                          [    9] meas_en:        1=Enable measurement
//                          [    8] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [ 7: 0] edpite_span:    Define the duration of a measure is to last for how many edpite.
#define MIPI_DSI_TOP_MEAS_CNTL                     ((0x00f6  << 2) + 0xfe074000)
//    31 R  stat_edpihalt:  status of edpihalt signal from IP.              Default 0.
// 30:29    Reserved.                                                       Default 0.
// 28:16 R  stat_te_line:   Snapshot of Host's line position at edpite.     Default 0.
// 15:13    Reserved.                                                       Default 0.
// 12: 0 R  stat_te_pix:    Snapshot of Host's pixel position at edpite.    Default 0.
#define MIPI_DSI_TOP_STAT                          ((0x00f7  << 2) + 0xfe074000)
// To measure display slave's frame rate, we can use a reference clock to measure the duration of one of more edpite pulse(s).
// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[9:0].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_TE0 and MIPI_DSI_TOP_MEAS_STAT_TE1, as below:
// edpite_meas_count[47:0]: Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// edpite_meas_count_n[3:0]:Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  edpite_meas_count[31:0].    Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_TE0                 ((0x00f8  << 2) + 0xfe074000)
// 19:16 R  edpite_meas_count_n.        Default 0.
// 15: 0 R  edpite_meas_count[47:32].   Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_TE1                 ((0x00f9  << 2) + 0xfe074000)
// To measure Host's frame rate, we can use a reference clock to measure the duration of one of more Vsync pulse(s).
// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[19:10].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_VS0 and MIPI_DSI_TOP_MEAS_STAT_VS1, as below:
// vsync_meas_count[47:0]:  Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// vsync_meas_count_n[3:0]: Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  vsync_meas_count[31:0].     Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_VS0                 ((0x00fa  << 2) + 0xfe074000)
// 19:16 R  vsync_meas_count_n.         Default 0.
// 15: 0 R  vsync_meas_count[47:32].    Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_VS1                 ((0x00fb  << 2) + 0xfe074000)
// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
//                         Note: To clear the interrupt level, simply write 1 to the specific bit, no need to write 0 afterwards.
//          [31:22] Reserved
//          [   21] stat/clr of EOF interrupt
//          [   20] stat/clr of de_fall interrupt
//          [   19] stat/clr of de_rise interrupt
//          [   18] stat/clr of vs_fall interrupt
//          [   17] stat/clr of vs_rise interrupt
//          [   16] stat/clr of dwc_edpite interrupt
// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
//          [15: 6] Reserved
//          [    5] EOF (End_Of_Field) interrupt
//          [    4] de_fall interrupt
//          [    3] de_rise interrupt
//          [    2] vs_fall interrupt
//          [    1] vs_rise interrupt
//          [    0] dwc_edpite interrupt
#define MIPI_DSI_TOP_INTR_CNTL_STAT                ((0x00fc  << 2) + 0xfe074000)
// 31: 2    Reserved.   Default 0.
//  1: 0 RW mem_pd.     Default 3.
#define MIPI_DSI_TOP_MEM_PD                        ((0x00fd  << 2) + 0xfe074000)
//===========================================================================
// MIPI DSI HOST B CONTROLLER Registers 0xfe072000 - 0xfe072fff
//===========================================================================
//------------------------------------------------------------------------------
// DWC IP registers: Synopsys IP, please refer to MIPI DSI HOST Databook
//------------------------------------------------------------------------------
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe072000
// -----------------------------------------------
#define MIPI_DSI_B_DWC_VERSION_OS                  ((0x0000  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PWR_UP_OS                   ((0x0001  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CLKMGR_CFG_OS               ((0x0002  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_VCID_OS                 ((0x0003  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_COLOR_CODING_OS         ((0x0004  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_CFG_POL_OS              ((0x0005  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_LP_CMD_TIM_OS           ((0x0006  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PCKHDL_CFG_OS               ((0x000b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_VCID_OS                 ((0x000c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_MODE_CFG_OS                 ((0x000d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_MODE_CFG_OS             ((0x000e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_PKT_SIZE_OS             ((0x000f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_NUM_CHUNKS_OS           ((0x0010  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_NULL_SIZE_OS            ((0x0011  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HSA_TIME_OS             ((0x0012  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HBP_TIME_OS             ((0x0013  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HLINE_TIME_OS           ((0x0014  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VSA_LINES_OS            ((0x0015  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VBP_LINES_OS            ((0x0016  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VFP_LINES_OS            ((0x0017  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VACTIVE_LINES_OS        ((0x0018  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_EDPI_CMD_SIZE_OS            ((0x0019  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CMD_MODE_CFG_OS             ((0x001a  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_HDR_OS                  ((0x001b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_PLD_DATA_OS             ((0x001c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CMD_PKT_STATUS_OS           ((0x001d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_TO_CNT_CFG_OS               ((0x001e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_HS_RD_TO_CNT_OS             ((0x001f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LP_RD_TO_CNT_OS             ((0x0020  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_HS_WR_TO_CNT_OS             ((0x0021  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LP_WR_TO_CNT_OS             ((0x0022  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_BTA_TO_CNT_OS               ((0x0023  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_SDF_3D_OS                   ((0x0024  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LPCLK_CTRL_OS               ((0x0025  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TMR_LPCLK_CFG_OS        ((0x0026  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TMR_CFG_OS              ((0x0027  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_RSTZ_OS                 ((0x0028  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_IF_CFG_OS               ((0x0029  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_ULPS_CTRL_OS            ((0x002a  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TX_TRIGGERS_OS          ((0x002b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_STATUS_OS               ((0x002c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TST_CTRL0_OS            ((0x002d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TST_CTRL1_OS            ((0x002e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_ST0_OS                  ((0x002f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_ST1_OS                  ((0x0030  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_MSK0_OS                 ((0x0031  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_MSK1_OS                 ((0x0032  << 2) + 0xfe072000)
//------------------------------------------------------------------------------
// Top-level registers: AmLogic proprietary
//------------------------------------------------------------------------------
#define MIPI_DSI_B_TOP_SHADOW_HSA_TIME             ((0x00e8  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_HBP_TIME             ((0x00e9  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_HLINE_TIME           ((0x00ea  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VSA_LINES            ((0x00eb  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VBP_LINES            ((0x00ec  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VFP_LINES            ((0x00ed  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VACTIVE_LINES        ((0x00ee  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_TIME_CTRL            ((0x00ef  << 2) + 0xfe072000)
// 31: 4    Reserved.                                                                           Default 0.
//     3 RW ~tim_rst_n:  1=Assert SW reset on mipi_dsi_host_timing block.   0=Release reset.    Default 1.
//     2 RW ~dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.      0=Release reset.    Default 1.
//     1 RW ~intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.     0=Release reset.    Default 1.
//     0 RW ~dwc_rst_n:  1=Assert SW reset on IP core.                      0=Release reset.    Default 1.
#define MIPI_DSI_B_TOP_SW_RESET                    ((0x00f0  << 2) + 0xfe072000)
// 31: 5    Reserved.                                                                                                       Default 0.
//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
//                          0=Default, use auto-clock gating to save power;
//                          1=use free-run clock, disable auto-clock gating, for debug mode.
//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
#define MIPI_DSI_B_TOP_CLK_CNTL                    ((0x00f1  << 2) + 0xfe072000)
// 31:27    Reserved.                                                                       Default 0.
//    26 RW de_dpi_pol:     1= Invert DE polarity from mipi_dsi_host_dpi.                   Default 0.
//    25 RW hsync_dpi_pol:  1= Invert HS polarity from mipi_dsi_host_dpi.                   Default 0.
//    24 RW vsync_dpi_pol:  1= Invert VS polarity from mipi_dsi_host_dpi.                   Default 0.
// 23:20 RW dpi_color_mode: Define DPI pixel format.                                        Default 0.
//                           0=16-bit RGB565 config 1;
//                           1=16-bit RGB565 config 2;
//                           2=16-bit RGB565 config 3;
//                           3=18-bit RGB666 config 1;
//                           4=18-bit RGB666 config 2;
//                           5=24-bit RGB888;
//                           6=20-bit YCbCr 4:2:2;
//                           7=24-bit YCbCr 4:2:2;
//                           8=16-bit YCbCr 4:2:2;
//                           9=30-bit RGB;
//                          10=36-bit RGB;
//                          11=12-bit YCbCr 4:2:0.
//    19    Reserved.                                                                       Default 0.
// 18:16 RW in_color_mode:  Define VENC data width.                                         Default 0.
//                          0=30-bit pixel;
//                          1=24-bit pixel;
//                          2=18-bit pixel, RGB666;
//                          3=16-bit pixel, RGB565.
// 15:14 RW chroma_subsample: Define method of chroma subsampling.                          Default 0.
//                            Applicable to YUV422 or YUV420 only.
//                            0=Use even pixel's chroma;
//                            1=Use odd pixel's chroma;
//                            2=Use averaged value between even and odd pair.
// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.    Default 2.
// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.    Default 1.
//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.    Default 0.
//     7    Reserved.                                                                       Default 0.
//     6 RW de_venc_pol:    1= Invert DE polarity from VENC.                                Default 0.
//     5 RW hsync_venc_pol: 1= Invert HS polarity from VENC.                                Default 0.
//     4 RW vsync_venc_pol: 1= Invert VS polarity from VENC.                                Default 0.
//     3 RW dpicolorm:      Signal to IP.                                                   Default 0.
//     2 RW dpishutdn:      Signal to IP.                                                   Default 0.
//     1    Reserved.                                                                       Default 0.
//     0    Reserved.                                                                       Default 0.
#define MIPI_DSI_B_TOP_CNTL                        ((0x00f2  << 2) + 0xfe072000)
// 31:16    Reserved.                                                                                                           Default 0.
// 15: 8 RW suspend_frame_rate: Define rate of timed-suspend.                                                                   Default 0.
//                              0=Execute suspend every frame; 1=Every other frame; ...; 255=Every 256 frame.
//  7: 4    Reserved.                                                                                                           Default 0.
//     3 RW disable suspend venc:   1=don`t support suspend VencL. 0=support suspend venc                                       Default 0.
//     2 RW timed_suspend_en:   1=Enable timed suspend VencL. 0=Disable timed suspend.                                          Default 0.
//     1 RW manual_suspend_en:  1=Enable manual suspend VencL. 1=Cancel manual suspend VencL.                                   Default 0.
//     0 RW suspend_on_edpihalt:1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL.   Default 1.
#define MIPI_DSI_B_TOP_SUSPEND_CNTL                ((0x00f3  << 2) + 0xfe072000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_line_end:   Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_line_start: Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_B_TOP_SUSPEND_LINE                ((0x00f4  << 2) + 0xfe072000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_pix_end:    Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_pix_start:  Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_B_TOP_SUSPEND_PIX                 ((0x00f5  << 2) + 0xfe072000)
// 31:20    Reserved.                                                                                                           Default 0.
// 19:10 RW meas_vsync:     Control on measuring Host Controller's vsync.                                                       Default 0.
//                          [   19] meas_en:        1=Enable measurement
//                          [   18] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [17:10] vsync_span:     Define the duration of a measure is to last for how many Vsyncs.
//  9: 0 RW meas_edpite:    Control on measuring Display Slave's edpite.                                                        Default 0.
//                          [    9] meas_en:        1=Enable measurement
//                          [    8] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [ 7: 0] edpite_span:    Define the duration of a measure is to last for how many edpite.
#define MIPI_DSI_B_TOP_MEAS_CNTL                   ((0x00f6  << 2) + 0xfe072000)
//    31 R  stat_edpihalt:  status of edpihalt signal from IP.              Default 0.
// 30:29    Reserved.                                                       Default 0.
// 28:16 R  stat_te_line:   Snapshot of Host's line position at edpite.     Default 0.
// 15:13    Reserved.                                                       Default 0.
// 12: 0 R  stat_te_pix:    Snapshot of Host's pixel position at edpite.    Default 0.
#define MIPI_DSI_B_TOP_STAT                        ((0x00f7  << 2) + 0xfe072000)
// To measure display slave's frame rate, we can use a reference clock to measure the duration of one of more edpite pulse(s).
// Measurement control is by register MIPI_DSI_B_TOP_MEAS_CNTL bit[9:0].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_B_TOP_MEAS_STAT_TE0 and MIPI_DSI_B_TOP_MEAS_STAT_TE1, as below:
// edpite_meas_count[47:0]: Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// edpite_meas_count_n[3:0]:Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  edpite_meas_count[31:0].    Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_TE0               ((0x00f8  << 2) + 0xfe072000)
// 19:16 R  edpite_meas_count_n.        Default 0.
// 15: 0 R  edpite_meas_count[47:32].   Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_TE1               ((0x00f9  << 2) + 0xfe072000)
// To measure Host's frame rate, we can use a reference clock to measure the duration of one of more Vsync pulse(s).
// Measurement control is by register MIPI_DSI_B_TOP_MEAS_CNTL bit[19:10].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_B_TOP_MEAS_STAT_VS0 and MIPI_DSI_B_TOP_MEAS_STAT_VS1, as below:
// vsync_meas_count[47:0]:  Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// vsync_meas_count_n[3:0]: Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  vsync_meas_count[31:0].     Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_VS0               ((0x00fa  << 2) + 0xfe072000)
// 19:16 R  vsync_meas_count_n.         Default 0.
// 15: 0 R  vsync_meas_count[47:32].    Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_VS1               ((0x00fb  << 2) + 0xfe072000)
// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
//                         Note: To clear the interrupt level, simply write 1 to the specific bit, no need to write 0 afterwards.
//          [31:22] Reserved
//          [   21] stat/clr of EOF interrupt
//          [   20] stat/clr of de_fall interrupt
//          [   19] stat/clr of de_rise interrupt
//          [   18] stat/clr of vs_fall interrupt
//          [   17] stat/clr of vs_rise interrupt
//          [   16] stat/clr of dwc_edpite interrupt
// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
//          [15: 6] Reserved
//          [    5] EOF (End_Of_Field) interrupt
//          [    4] de_fall interrupt
//          [    3] de_rise interrupt
//          [    2] vs_fall interrupt
//          [    1] vs_rise interrupt
//          [    0] dwc_edpite interrupt
#define MIPI_DSI_B_TOP_INTR_CNTL_STAT              ((0x00fc  << 2) + 0xfe072000)
// 31: 2    Reserved.   Default 0.
//  1: 0 RW mem_pd.     Default 3.
#define MIPI_DSI_B_TOP_MEM_PD                      ((0x00fd  << 2) + 0xfe072000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dsi_regs.h
//
//========================================================================
//  CVE
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe08e400
// -----------------------------------------------
//
// Reading file:  ./cve_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_TOP_CTRL_REG0                          ((0x0000  << 2) + 0xfe08e400)
//Bit 31: 1        reserved
//Bit  0           reg_cve_start             // unsigned ,    RW, default = 0  rising edge start cve core, need to implement this functionality
#define CVE_TOP_CTRL_REG1                          ((0x0001  << 2) + 0xfe08e400)
//Bit 31: 0        reserved
#define CVE_COMMON_CTRL_REG0                       ((0x0002  << 2) + 0xfe08e400)
//Bit 31:24        reg_cve_ops               // unsigned ,    RW, default = 0  which ops,default: 1
//Bit 23:21        reserved
//Bit 20:16        reg_src_image_type        // unsigned ,    RW, default = 0  1:S8C1,  2:YUV420SP,      3:YUV422SP,    4:YUV420P, 5:YUV422P, 6:S8C2_PACKAGE,  7:S8C2_PLANAR, 8:S16C1,
//Bit 15:13        reserved
//Bit 12: 8        reg_dst_image_type        // unsigned ,    RW, default = 0  same as reg_src_image_type
//Bit  7: 5        reserved
//Bit  4           reg_yuv_image_type        // unsigned ,    RW, default = 0  0: NV21, 1:Nv12, default: 0
//Bit  3: 2        reserved
//Bit  1           reg_compat_input_mode     // unsigned ,    RW, default = 0  0: input data is u8 0 or 255 , 1: input data is u1, 0 or 1
//Bit  0           reg_compat_output_mode    // unsigned ,    RW, default = 0  0: output data is u8 0 or 255, 1: output data is u1, 0 or 1
#define CVE_COMMON_CTRL_REG1_0                     ((0x0003  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_0             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_1                     ((0x0004  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_1             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_2                     ((0x0005  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_2             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_3                     ((0x0006  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_3             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_4                     ((0x0007  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_4             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_5                     ((0x0008  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_5             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_6                     ((0x0009  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_6             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_7                     ((0x000a  << 2) + 0xfe08e400)
//Bit 31: 0        reg_src_ptr_7             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG2_0                     ((0x000b  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dst_ptr_0             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_1                     ((0x000c  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dst_ptr_1             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_2                     ((0x000d  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dst_ptr_2             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_3                     ((0x000e  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dst_ptr_3             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_4                     ((0x000f  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dst_ptr_4             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG3_0                     ((0x0010  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_0          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_1          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_1                     ((0x0011  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_2          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_3          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_2                     ((0x0012  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_4          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_5          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_3                     ((0x0013  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_6          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_7          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG4_0                     ((0x0014  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_0          // unsigned ,    RW, default = 1920  to dst image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_dst_stride_1          // unsigned ,    RW, default = 1920  to dst image stride
#define CVE_COMMON_CTRL_REG4_1                     ((0x0015  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_2          // unsigned ,    RW, default = 1920  to dst image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_dst_stride_3          // unsigned ,    RW, default = 1920  to dst image stride
#define CVE_COMMON_CTRL_REG5                       ((0x0016  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_4          // unsigned ,    RW, default = 1920
//Bit 15: 0        reserved
#define CVE_COMMON_CTRL_REG6                       ((0x0017  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:16        reg_src_width             // unsigned ,    RW, default = 1920  src image width , default:1920,use in dma
//Bit 15:14        reserved
//Bit 13: 0        reg_src_height            // unsigned ,    RW, default = 1080  src image height, default:1080,use in dma
#define CVE_COMMON_CTRL_REG7                       ((0x0018  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:16        reg_dst_width             // unsigned ,    RW, default = 1920  dst image width , default:1920,use in dma
//Bit 15:14        reserved
//Bit 13: 0        reg_dst_height            // unsigned ,    RW, default = 1080  dst image height, default:1080,use in dma
#define CVE_COMMON_CTRL_REG8                       ((0x0019  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:16        reg_cve_crop_xstart       // unsigned ,    RW, default = 0  crop image, start x, image size:1920x1080(2^11=2048),default : 0
//Bit 15:14        reserved
//Bit 13: 0        reg_cve_crop_ystart       // unsigned ,    RW, default = 0  start y,default:0
#define CVE_COMMON_CTRL_REG9                       ((0x001a  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:16        reg_cve_crop_xsize        // unsigned ,    RW, default = 1920  crop image, size  x,default:1920
//Bit 15:14        reserved
//Bit 13: 0        reg_cve_crop_ysize        // unsigned ,    RW, default = 1080  crop image, size  y,default:1080
#define CVE_DMA_REG0                               ((0x001b  << 2) + 0xfe08e400)
//Bit 31            reserved
//Bit 30:28        reg_dma_mode_ctrl         // unsigned ,    RW, default = 0  0:direct memory copy, 1:copy with interval bytes; 2,memset using 3 bytes; 3:memset using 8 bytes; 4:not; 5:luma; default:0
//Bit 27:25        reserved
//Bit 24           reg_dma_set_endmode       // unsigned ,    RW, default = 0  or smallend, 0,set 3byte,  u64val = 0x12345678,char[0]=0x78,char[1]=0x56,char[2]=0x34,char[3]=0x12,
//Bit 23:16        reg_dma_interval_elemsize // unsigned ,    RW, default = 1  default:1
//Bit 15: 8        reg_dma_interval_hsegsize // unsigned ,    RW, default = 2  default:2
//Bit  7: 0        reg_dma_interval_vsegsize // unsigned ,    RW, default = 1  default:1
#define CVE_DMA_REG1                               ((0x001c  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dma_set_u64val_lsb    // unsigned ,    RW, default = 32'h11223344
#define CVE_DMA_REG2                               ((0x001d  << 2) + 0xfe08e400)
//Bit 31: 0        reg_dma_set_u64val_msb    // unsigned ,    RW, default = 32'h55667788
#define CVE_DMA_REG3                               ((0x001e  << 2) + 0xfe08e400)
//Bit 31:30        reg_cve_caption_stat_step // unsigned ,    RW, default = 0  step: 0,1,2,3;  model:1/1, 1/2, 1/3,1/4
//Bit 29:16        reg_dma_interval_xlength  // unsigned ,    RW, default = 960
//Bit 15: 8        reg_cve_caption_stat_winidx // unsigned ,    RW, default = 0  [0,254], current window idx, reg_cve_caption_stat_winidx < reg_cve_caption_stat_wincnt
//Bit  7: 0        reg_cve_caption_stat_wincnt // unsigned ,    RW, default = 255  [1,255], maximum 255 windows
#define CVE_FILTER_REG2                            ((0x001f  << 2) + 0xfe08e400)
//Bit 31:25        reserved
//Bit 24           reg_filter_uv             // unsigned ,    RW, default = 0  uv, 1:filter, 0:no
//Bit 23:22        reserved
//Bit 21:16        reg_filter_norm_uv        // unsigned ,    RW, default = 0  then right shift for norm.
//Bit 15: 0        reserved
#define CVE_FILTER_REG1_0                          ((0x0020  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_uv_3      // signed ,    RW, default = 0  filter weight
//Bit 23:16        reg_filter_coef_uv_2      // signed ,    RW, default = 0  filter weight
//Bit 15: 8        reg_filter_coef_uv_1      // signed ,    RW, default = 0  filter weight
//Bit  7: 0        reg_filter_coef_uv_0      // signed ,    RW, default = 0  filter weight
#define CVE_FILTER_REG1_1                          ((0x0021  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_uv_7      // signed ,    RW, default = 0  filter weight
//Bit 23:16        reg_filter_coef_uv_6      // signed ,    RW, default = 0  filter weight
//Bit 15: 8        reg_filter_coef_uv_5      // signed ,    RW, default = 0  filter weight
//Bit  7: 0        reg_filter_coef_uv_4      // signed ,    RW, default = 0  filter weight
#define CVE_FILTER_REG2_3                          ((0x0022  << 2) + 0xfe08e400)
//Bit 31: 8        reserved
//Bit  7: 0        reg_filter_coef_uv_8      // signed ,    RW, default = 0  filter weight
#define CVE_CSC_REG0                               ((0x0023  << 2) + 0xfe08e400)
//Bit 31            reserved
//Bit 30:28        reg_csc_mode              // unsigned ,    RW, default = 0  1:YUV2HSV,2:YUV2LAB, 3:RGB2YUV, 4:RGB2HSV,5:RGB2LAB
//Bit 27:25        reserved
//Bit 24           reg_csc_gamma             // unsigned ,    RW, default = 1  gamma 1:have gamma
//Bit 23            reserved
//Bit 22:20        reg_csc_yuv422toyuv444_mode // unsigned ,    RW, default = 0  yuv4222yuv444,  0:repeat, 1:even repeat, odd avg, 2:even avg, odd repeat, 3:1:2:1, 4:3:1 5:3:1
//Bit 19            reserved
//Bit 18:16        reg_csc_yuv420toyuv422_mode // unsigned ,    RW, default = 0  yuv4202yuv422, 0:repeat, 1:even repeat, odd avg, 2:even avg, odd repeat, 3:1:3, 4:3:1
//Bit 15            reserved
//Bit 14:12        reg_csc_yuv444toyuv422_mode // unsigned ,    RW, default = 0  yuv4442yuv422, 0:even repeat, 1:odd repeat, 2:avg, 3:1:2:1 left center right, 4:1:2:1 center right right+1
//Bit 11            reserved
//Bit 10: 8        reg_csc_yuv422toyuv420_mode // unsigned ,    RW, default = 0  yuv4222yuv420,0:even repeat, 1:odd repeat, 2:1:2:1 even, 3:1:2:1 odd,  4:even avg, 5:odd avg
//Bit  7: 0        reserved
#define CVE_CSC_REG                                ((0x0024  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_src_u6order           // unsigned ,    RW, default = 6'h24
//Bit 23:22        reserved
//Bit 21:16        reg_dst_u6order           // unsigned ,    RW, default = 6'h24
//Bit 15: 0        reserved
#define CVE_SOBEL_REG0                             ((0x0025  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_sobel_output_mode     // unsigned ,    RW, default = 0  0: output  horizontal and vertical; 1:output horizontal; 2:output vertical, default:0
//Bit 23: 0        reserved
#define CVE_MAGANDANG_REG0                         ((0x0026  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_magandang_output_ctrl // unsigned ,    RW, default = 0  0: only magnitude output; 1:magnitude and angle output, 2: hog
//Bit 23:17        reserved
//Bit 16           reg_magandang_mode        // unsigned ,    RW, default = 0  0:8 directions, 1: 9 directions, default :0
//Bit 15: 0        reg_magandang_u16thr      // unsigned ,    RW, default = 1024
#define CVE_BGMODE_REG0                            ((0x0027  << 2) + 0xfe08e400)
//Bit 31:28        reserved
//Bit 27:16        reg_bgmodel_u8q4dist_thr  // unsigned ,    RW, default = 400  Threshold
//Bit 15: 8        reg_bgmodel_u8gray_thr    // unsigned ,    RW, default = 20  for current frame subtract background
//Bit  7: 6        reserved
//Bit  5: 4        reg_bgmodel_output_ctrl   // unsigned ,    RW, default = 2  fg;1:output fg and bg; 2:output fg,bg and fg_gray; 3:output fg,bg,fg_gray and two frame diff
//Bit  3: 2        reserved
//Bit  1: 0        reg_bgmodel_ds_mode       // unsigned ,    RW, default = 0  sample mode;0:not downsampling;1:2*2;2:4*4. default:0
#define CVE_BGMODE_REG1                            ((0x0028  << 2) + 0xfe08e400)
//Bit 31: 0        ro_bgmodel_fg_pix_num     // unsigned ,    RO, default = 0  of foreground pixel
#define CVE_BGMODE_REG2                            ((0x0029  << 2) + 0xfe08e400)
//Bit 31: 0        ro_bgmodel_sum_lum        // unsigned ,    RO, default = 0  of all pixel value
#define CVE_UPDATEBGMODE_REG0                      ((0x002a  << 2) + 0xfe08e400)
//Bit 31:16        reg_updatebgmodel_u16del_thr // unsigned ,    RW, default = 1000  threshold
//Bit 15: 0        reg_updatebgmodel_u16frq_thr // unsigned ,    RW, default = 200  threshold
#define CVE_UPDATEBGMODE_REG1                      ((0x002b  << 2) + 0xfe08e400)
//Bit 31:16        reg_updatebgmodel_u16interval_thr // unsigned ,    RW, default = 40  threshold
//Bit 15: 0        reg_updatebgmodel_u0q16lr // unsigned ,    RW, default = 1310  rate
#define CVE_UPDATEBGMODE_REG2                      ((0x002c  << 2) + 0xfe08e400)
//Bit 31: 0        ro_updatebgmodel_bg_pix_num // unsigned ,    RO, default = 0  of background pixel
#define CVE_UPDATEBGMODE_REG3                      ((0x002d  << 2) + 0xfe08e400)
//Bit 31: 0        ro_updatebgmodel_bg_sum_lum // unsigned ,    RO, default = 0  of background pixel value
#define CVE_ERODEDILATE_REG0                       ((0x002e  << 2) + 0xfe08e400)
//Bit 31: 1        reserved
//Bit  0           reg_erodedilate_sel       // unsigned ,    RW, default = 0  ErodeOrDilate op sel, 0: do Erode op, 1: do Dilate op
#define CVE_THRESH_REG0                            ((0x002f  << 2) + 0xfe08e400)
//Bit 31:27        reserved
//Bit 26:24        reg_thresh_mode           // unsigned ,    RW, default = 0  0:binary; 1:trunc; 2: TO_MINVAL, 3:MIN_MID_MAX; 4:ORI_MID_MAX; 5:MIN_MID_ORI; 6:MIN_ORI_MAX; 7: ORI_MID_ORI, default:0
//Bit 23:16        reg_thresh_u8max_val      // unsigned ,    RW, default = 128
//Bit 15: 0        reserved
#define CVE_THRESH_REG1                            ((0x0030  << 2) + 0xfe08e400)
//Bit 31:24        reg_thresh_u8low_thr      // unsigned ,    RW, default = 128
//Bit 23:16        reg_thresh_u8high_thr     // unsigned ,    RW, default = 128
//Bit 15: 8        reg_thresh_u8min_val      // unsigned ,    RW, default = 128
//Bit  7: 0        reg_thresh_u8mid_val      // unsigned ,    RW, default = 128
#define CVE_ALU_REG0                               ((0x0031  << 2) + 0xfe08e400)
//Bit 31:19        reserved
//Bit 18:16        reg_cve_alu_sel           // unsigned ,    RW, default = 0  0:sub, 1:or, 2:xor, 3:and, 4:add, 5:add_map_255to1
//Bit 15:10        reserved
//Bit  9: 8        reg_sub_output_mode       // unsigned ,    RW, default = 0  0:abs, 1:shift, 2: thresh, default:0
//Bit  7: 0        reserved
#define CVE_ALU_REG1                               ((0x0032  << 2) + 0xfe08e400)
//Bit 31:16        reg_add_u0q16x            // unsigned ,    RW, default = 0
//Bit 15: 0        reg_add_u0q16y            // unsigned ,    RW, default = 65535
#define CVE_INTEG_REG0                             ((0x0033  << 2) + 0xfe08e400)
//Bit 31:18        reserved
//Bit 17:16        reg_integ_out_ctrl        // unsigned ,    RW, default = 0  0: combine, 1:sum; 2:sqsum,default:0
//Bit 15: 1        reserved
//Bit  0           reg_eqhist_curv_mode      // unsigned ,    RW, default = 0  0:fw calc, 1:hw calc, default:0
#define CVE_EQHIST_REG0                            ((0x0034  << 2) + 0xfe08e400)
//Bit 31: 0        reg_eqhist_norm           // unsigned ,    RW, default = 2071  (1<<32) / height /width
#define CVE_THRESHS16_REG0                         ((0x0035  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_thresh_s16tos8oru8_mode // unsigned ,    RW, default = 0  default:0, 0:THRESH_S16TOS8_MIN_MID_MAX,1:THRESH_S16TOS8_MIN_ORI_MAX,2:THRESH_S16TOU8_MIN_MID_MAX,3:THRESH_S16TOU8_MIN_ORI_MAX
//Bit 23:16        reg_thresh_min_val        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_thresh_mid_val        // unsigned ,    RW, default = 128
//Bit  7: 0        reg_thresh_max_val        // unsigned ,    RW, default = 255
#define CVE_THRESHS16_REG1                         ((0x0036  << 2) + 0xfe08e400)
//Bit 31:16        reg_thresh_s16lowthr      // signed ,    RW, default = 0
//Bit 15: 0        reg_thresh_s16highthr     // signed ,    RW, default = 127
#define CVE_THRESHU16_REG0                         ((0x0037  << 2) + 0xfe08e400)
//Bit 31:25        reserved
//Bit 24           reg_thresh_u16tou8_mode   // unsigned ,    RW, default = 0  0:u16 To U8 Min_Mid_Max; 1:U16 To U8 Min_Ori_Max
//Bit 23:16        reg_thresh_u16_u8min_val  // unsigned ,    RW, default = 0
//Bit 15: 8        reg_thresh_u16_u8mid_val  // unsigned ,    RW, default = 0
//Bit  7: 0        reg_thresh_u16_u8max_val  // unsigned ,    RW, default = 0
#define CVE_THRESHU16_REG1                         ((0x0038  << 2) + 0xfe08e400)
//Bit 31:16        reg_thresh_u16_u16lowthr  // unsigned ,    RW, default = 0
//Bit 15: 0        reg_thresh_u16_u16highthr // unsigned ,    RW, default = 0
#define CVE_16BITTO8BIT_REG0                       ((0x0039  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_16bitto8bit_mode      // unsigned ,    RW, default = 0  1:S16TOU8_ABS; 2:S16TOU8_BIAS; 3:U16TOU8
//Bit 23: 0        reserved
#define CVE_16BITTO8BIT_REG1                       ((0x003a  << 2) + 0xfe08e400)
//Bit 31:16        reg_16bitto8bit_u0q16norm // unsigned ,    RW, default = 65535
//Bit 15: 8        reserved
//Bit  7: 0        reg_16bitto8bit_s8bias    // signed ,    RW, default = 20
#define CVE_STATFILTER_REG0                        ((0x003b  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_stat_filter_outnum    // unsigned ,    RW, default = 1  1:output a result 2:output two results 3:output three results
//Bit 23:20        reserved
//Bit 19:16        reg_stat_filter_outidx0   // unsigned ,    RW, default = 0  0:filter mode min, 4:filter mode median, 8:filter mode max
//Bit 15:12        reserved
//Bit 11: 8        reg_stat_filter_outidx1   // unsigned ,    RW, default = 4  0:filter mode min, 4:filter mode median, 8:filter mode max
//Bit  7: 4        reserved
//Bit  3: 0        reg_stat_filter_outidx2   // unsigned ,    RW, default = 8  0:filter mode min, 4:filter mode median, 8:filter mode max
#define CVE_MAP_REG0                               ((0x003c  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_map_mode              // unsigned ,    RW, default = 0  0:U8, 1:S16; 2:U16,default:0
//Bit 23:16        reg_ncc_offset0           // unsigned ,    RW, default = 0  only CVE_NCC_SIMILAR mode need to add a offset  //CVE_NCC
//Bit 15: 8        reg_ncc_offset1           // unsigned ,    RW, default = 0  only CVE_NCC_SIMILAR mode need to add a offset
//Bit  7: 1        reserved
//Bit  0           reg_ncc_mode              // unsigned ,    RW, default = 0  0:CVE_NCC_COM, 1:CVE_NCC_SIMILAR
#define CVE_NCC_U64NUM_0                           ((0x003d  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32numerator_lsb   // unsigned ,    RO, default = 0
#define CVE_NCC_U64NUM_1                           ((0x003e  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32numerator_msb   // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM1_0                      ((0x003f  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32quadsum1_lsb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM1_1                      ((0x0040  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32quadsum1_msb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM2_0                      ((0x0041  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32quadsum2_lsb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM2_1                      ((0x0042  << 2) + 0xfe08e400)
//Bit 31: 0        ro_ncc_u32quadsum2_msb    // unsigned ,    RO, default = 0
#define CVE_CCL_REG0                               ((0x0043  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reserved
//Bit 15: 9        reserved
//Bit  8: 0        ro_ccl_sum                // unsigned ,    RO, default = 128  max = 383,output,ro
#define CVE_GMM_REG0                               ((0x0044  << 2) + 0xfe08e400)
//Bit 31:16        reg_gmm_u0q16learnrate    // unsigned ,    RW, default = 1024  rate,default:1024
//Bit 15: 0        reg_gmm_u0q16initweight   // unsigned ,    RW, default = 1024  Weight,default:1024
#define CVE_GMM_REG1                               ((0x0045  << 2) + 0xfe08e400)
//Bit 31:29        reserved
//Bit 28           reg_gmm_output_bg_en      // unsigned ,    RW, default = 0  0:output fg only; 1:output fg and bg,default:0
//Bit 27:26        reserved
//Bit 25:24        reg_gmm_ds_mode           // unsigned ,    RW, default = 0  Down sample mode; 0: not downsampling;1:2*2;2:4*4,default:0
//Bit 23:16        reserved
//Bit 15: 0        reg_gmm_u10q6sigma_init   // unsigned ,    RW, default = 6400  Initial noise variance
#define CVE_GMM_REG2                               ((0x0046  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 8        reg_gmm_u10q6sigma_max    // unsigned ,    RW, default = 12800  Maximum variance
//Bit  7            reserved
//Bit  6: 4        reg_gmm_u3modelnum        // unsigned ,    RW, default = 5  The number of models per pixel,1~5, 3 or 5 is recommended
//Bit  3: 2        reserved
//Bit  1: 0        reg_gmm_u2nchannels       // unsigned ,    RW, default = 3  input channel
#define CVE_GMM_REG3                               ((0x0047  << 2) + 0xfe08e400)
//Bit 31:16        reg_gmm_u10q6sigma_min    // unsigned ,    RW, default = 3840  Minimum variance
//Bit 15:12        reserved
//Bit 11: 0        reg_gmm_modellen_in128b   // unsigned ,    RW, default = 0  much 16bytes is there in a row, rtl use, reg_gmm_modellen_in128b = (scale *xsize * (1 + reg_gmmu3modelnum*4) + 15 ) >> 4, scale = (reg_gmm_downsamplemode == 0) ? 1  : (reg_gmm_downsamplemode = 1) ? (1/2) : (1/4)
#define CVE_GMM_REG4                               ((0x0048  << 2) + 0xfe08e400)
//Bit 31:16        reg_gmm_u0q16weight_sum_thr // unsigned ,    RW, default = 58900  Weights threshold,
//Bit 15:10        reserved
//Bit  9: 0        reg_gmm_u3q7sigma_scale   // unsigned ,    RW, default = 256  scale,default:256
#define CVE_GMM_REG5                               ((0x0049  << 2) + 0xfe08e400)
//Bit 31           reg_gmm_sns_factor_mode_en // unsigned ,    RW, default = 0  0:global sensitivity mode; 1:pixel sensitivity mode
//Bit 30:24        reserved
//Bit 23           reg_gmm_acc_lr_en         // unsigned ,    RW, default = 1  1:Use fast learning; 0:not use                                                           //u1
//Bit 22:16        reserved
//Bit 15           reg_gmm_update_factor_mode_en // unsigned ,    RW, default = 0  0:global update mode; 1:pixel update mode
//Bit 14:12        reserved
//Bit 11: 0        reg_gmm_piclen_in128b     // unsigned ,    RW, default = 360  ceil(image_width*channel_num / 16)
#define CVE_CANNY_REG0                             ((0x004a  << 2) + 0xfe08e400)
//Bit 31:16        reg_canny_u16lowthr       // unsigned ,    RW, default = 30  Low threshold,default:30
//Bit 15: 0        reg_canny_u16highthr      // unsigned ,    RW, default = 70  high threshold,default:70
#define CVE_CANNY_REG1                             ((0x004b  << 2) + 0xfe08e400)
//Bit 31: 0        ro_canny_count            // unsigned ,    RO, default = 0  points count
#define CVE_CANNY_REG2                             ((0x004c  << 2) + 0xfe08e400)
//Bit 31:25        reserved
//Bit 24           reg_canny_gauss_en        // unsigned ,    RW, default = 0  [0,1] 0: don't need to do gaussian filter, 1: need to do gaussian filter
//Bit 23: 0        reserved
#define CVE_LBP_REG0                               ((0x004d  << 2) + 0xfe08e400)
//Bit 31:25        reserved
//Bit 24           reg_cmp_mode              // unsigned ,    RW, default = 0  0:P(x) - P(center) >= un8BitThr.s8Val, s(x) = 1 ;else s(x) = 0;  1:Abs(P(x) - P(center)) >= un8BitThr.u8Val, s(x) = 1; else s(x) = 0;
//Bit 23:16        reg_u8bitthr              // unsigned ,    RW, default = 40  thr, default:40
//Bit 15: 0        reserved
#define CVE_NORMGRAD_REG0                          ((0x004e  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:28        reg_normgrad_outmode      // unsigned ,    RW, default = 0  and ver out; 1:hor;  2: ver,  3:combine,default:0
//Bit 27:24        reserved
//Bit 23:16        reg_normgrad_u8norm       // unsigned ,    RW, default = 0
//Bit 15: 0        reserved
#define CVE_BDLK_REG0                              ((0x004f  << 2) + 0xfe08e400)
//Bit 31:27        reserved
//Bit 26:24        reg_bdlk_maxLevel         // unsigned ,    RW, default = 3  height [0,3]
//Bit 23:16        reserved
//Bit 15:10        reserved
//Bit  9: 0        reserved
#define CVE_LK_REG0                                ((0x0050  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_lk_mode               // unsigned ,    RW, default = 0  output error or not,0:not,2:output error,default:0
//Bit 23:17        reserved
//Bit 16           reg_lk_buseinitflow       // unsigned ,    RW, default = 0  Whether to use initial flow
//Bit 15:10        reserved
//Bit  9: 0        reg_lk_u10pstnum          // unsigned ,    RW, default = 100  of feature points, <=500
#define CVE_LK_REG1                                ((0x0051  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_lk_u2maxlevel         // unsigned ,    RW, default = 3  height [0,3]
//Bit 23:16        reg_lk_u8itercnt          // unsigned ,    RW, default = 10  iteration times,<=20
//Bit 15: 8        reg_u0q8eps               // unsigned ,    RW, default = 10  for exit criteria, dx^2+dy^2< u0q8eps
//Bit  7: 0        reserved
#define CVE_LK_REG2_0                              ((0x0052  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_0          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_1                              ((0x0053  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_1          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_2                              ((0x0054  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_2          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_3                              ((0x0055  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_3          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_4                              ((0x0056  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_4          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_5                              ((0x0057  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_5          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_6                              ((0x0058  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_6          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_7                              ((0x0059  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_7          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_8                              ((0x005a  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_8          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_9                              ((0x005b  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_9          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_10                             ((0x005c  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_10         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_11                             ((0x005d  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_11         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_12                             ((0x005e  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_12         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_13                             ((0x005f  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_13         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_14                             ((0x0060  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_14         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_15                             ((0x0061  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_15         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_16                             ((0x0062  << 2) + 0xfe08e400)
//Bit 31: 0        ro_lk_ststatus_16         // unsigned ,    RO, default = 32'hffffffff
#define CVE_STCORNER_REG0                          ((0x0063  << 2) + 0xfe08e400)
//Bit 31: 0        ro_st_u32pointnum         // unsigned ,    RO, default = 0  max corner number in image
#define CVE_SAD_REG0                               ((0x0064  << 2) + 0xfe08e400)
//Bit 31:16        reserved
//Bit 15:10        reserved
//Bit  9: 8        reg_sad_mode              // unsigned ,    RW, default = 0  0:4x4, 1:8x8, 2:16x16
//Bit  7: 0        reg_sad_u8minval          // unsigned ,    RW, default = 128
#define CVE_SAD_REG1                               ((0x0065  << 2) + 0xfe08e400)
//Bit 31:16        reg_sad_u16thr            // unsigned ,    RW, default = 128
//Bit 15: 8        reg_sad_u8maxval          // unsigned ,    RW, default = 128
//Bit  7: 4        reserved
//Bit  3: 0        reg_sad_u4rightshift      // unsigned ,    RW, default = 2
#define CVE_GRADFG_REG0                            ((0x0066  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:24        reg_gradfg_mode           // unsigned ,    RW, default = 0  output control
//Bit 23: 8        reserved
//Bit  7: 0        reg_gradfg_u8minmagdiff   // unsigned ,    RW, default = 100  gradient magnitude difference threshold
#define CVE_FILTER_REG0_0                          ((0x0067  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_3         // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_2         // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_1         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_0         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_1                          ((0x0068  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_7         // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_6         // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_5         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_4         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_2                          ((0x0069  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_11        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_10        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_9         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_8         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_3                          ((0x006a  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_15        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_14        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_13        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_12        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_4                          ((0x006b  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_19        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_18        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_17        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_16        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_5                          ((0x006c  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_23        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_22        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_21        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_20        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_6                          ((0x006d  << 2) + 0xfe08e400)
//Bit 31:24        reg_filter_coef_24        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reserved
//Bit 15: 6        reserved
//Bit  5: 0        reg_filter_norm           // unsigned ,    RW, default = 0  filter then right shift for norm.
#define CVE_CSC_REG1                               ((0x006e  << 2) + 0xfe08e400)
//Bit 31:20        reserved
//Bit 19:10        reg_csc_offset_inp_1      // signed ,    RW, default = 0
//Bit  9: 0        reg_csc_offset_inp_0      // signed ,    RW, default = 0
#define CVE_CSC_REG1_1                             ((0x006f  << 2) + 0xfe08e400)
//Bit 31:10        reserved
//Bit  9: 0        reg_csc_offset_inp_2      // signed ,    RW, default = 0
#define CVE_CSC_REG2_0                             ((0x0070  << 2) + 0xfe08e400)
//Bit 31:22        reg_csc_3x3matrix_0_0     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_0     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_0     // signed ,    RW, default = 0
#define CVE_CSC_REG2_1                             ((0x0071  << 2) + 0xfe08e400)
//Bit 31:22        reg_csc_3x3matrix_0_1     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_1     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_1     // signed ,    RW, default = 0
#define CVE_CSC_REG2_2                             ((0x0072  << 2) + 0xfe08e400)
//Bit 31:22        reg_csc_3x3matrix_0_2     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_2     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_2     // signed ,    RW, default = 0
#define CVE_CSC_REG3                               ((0x0073  << 2) + 0xfe08e400)
//Bit 31:20        reserved
//Bit 19:10        reg_csc_offset_oup_1      // signed ,    RW, default = 0
//Bit  9: 0        reg_csc_offset_oup_0      // signed ,    RW, default = 0
#define CVE_CSC_REG3_1                             ((0x0074  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:16        reg_csc_offset_oup_2      // signed ,    RW, default = 0
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
#define CVE_SOBEL_REG1_0                           ((0x0075  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_3        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_2        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_1        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_0        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_1                           ((0x0076  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_7        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_6        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_5        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_4        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_2                           ((0x0077  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_11       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_10       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_9        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_8        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_3                           ((0x0078  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_15       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_14       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_13       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_12       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_4                           ((0x0079  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_19       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_18       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_17       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_16       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_5                           ((0x007a  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_23       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_22       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_21       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_20       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_6                           ((0x007b  << 2) + 0xfe08e400)
//Bit 31: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_24       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_0                           ((0x007c  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_3        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_2        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_1        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_0        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_1                           ((0x007d  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_7        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_6        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_5        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_4        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_2                           ((0x007e  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_11       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_10       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_9        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_8        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_3                           ((0x007f  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_15       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_14       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_13       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_12       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_4                           ((0x0080  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_19       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_18       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_17       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_16       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_5                           ((0x0081  << 2) + 0xfe08e400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_23       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_22       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_21       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_20       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_6                           ((0x0082  << 2) + 0xfe08e400)
//Bit 31: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_24       // signed ,    RW, default = 0
#define CVE_TOF_REG0                               ((0x0083  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:16        reg_cve_tof_hist_x_start  // unsigned ,    RW, default = 0  range for calc hist,start x, default:0
//Bit 15:10        reserved
//Bit  9: 0        reg_cve_tof_hist_y_start  // unsigned ,    RW, default = 0  range for calc hist,start y, default:0
#define CVE_TOF_REG1                               ((0x0084  << 2) + 0xfe08e400)
//Bit 31:26        reserved
//Bit 25:16        reg_cve_tof_hist_x_end    // unsigned ,    RW, default = 320  range for calc hist,end x, default:320
//Bit 15:10        reserved
//Bit  9: 0        reg_cve_tof_hist_y_end    // unsigned ,    RW, default = 240  range for calc hist,end y, default:240
#define CVE_TOF_REG3_0                             ((0x0085  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_0      // signed ,    RW, default = 0
#define CVE_TOF_REG3_1                             ((0x0086  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_1      // signed ,    RW, default = 0
#define CVE_TOF_REG3_2                             ((0x0087  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_2      // signed ,    RW, default = 0
#define CVE_TOF_REG3_3                             ((0x0088  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_3      // signed ,    RW, default = 0
#define CVE_TOF_REG3_4                             ((0x0089  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_4      // signed ,    RW, default = 0
#define CVE_TOF_REG4                               ((0x008a  << 2) + 0xfe08e400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_t_coef1_0     // signed ,    RW, default = 0
//Bit 15: 9        reserved
//Bit  8: 0        reg_cve_tof_t_coef1_1     // signed ,    RW, default = 0  s7q2
#define CVE_TOF_REG5                               ((0x008b  << 2) + 0xfe08e400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_t_coef1_2     // signed ,    RW, default = 0
//Bit 15: 9        reserved
//Bit  8: 0        reg_cve_tof_t_coef1_3     // signed ,    RW, default = 0
#define CVE_TOF_REG9_0                             ((0x008c  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_0    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_1    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_2    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_1                             ((0x008d  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_3    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_4    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_5    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_2                             ((0x008e  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_6    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_7    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_8    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_3                             ((0x008f  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_9    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_10   // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_11   // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_4                             ((0x0090  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_12   // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_13   // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_14   // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG10                              ((0x0091  << 2) + 0xfe08e400)
//Bit 31:27        reserved
//Bit 26:24        reg_cve_tof_raw_mode      // unsigned ,    RW, default = 4  0:RAW6,1:RAW7,2:RAW8,3:RWA10,4:RWA12,5:RAW14
//Bit 23:16        reg_cve_tof_spa_norm      // unsigned ,    RW, default = 0  coefficient,up to spa_mask
//Bit 15: 9        reserved
//Bit  8           reg_cve_tof_raw_shift_12bit_en // unsigned ,    RW, default = 0  1:convert pixel data to 12 bit,0:not
//Bit  7: 0        reg_cve_tof_bp_num        // unsigned ,    RW, default = 0  count of bad point
#define CVE_TOF_REG11                              ((0x0092  << 2) + 0xfe08e400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_temperature_int // signed ,    RW, default = 20  temperature
//Bit 15: 8        reserved
//Bit  7: 0        reg_cve_tof_temperature_ext // signed ,    RW, default = 20  temperature
#define CVE_TOF_REG12                              ((0x0093  << 2) + 0xfe08e400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_q1_high_thr   // unsigned ,    RW, default = 0
//Bit 15:12        reserved
//Bit 11: 0        reg_cve_tof_q23_high_thr  // unsigned ,    RW, default = 0
#define CVE_TOF_REG13                              ((0x0094  << 2) + 0xfe08e400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_ir_high_thr   // unsigned ,    RW, default = 0
//Bit 15:12        reserved
//Bit 11: 0        reg_cve_tof_ir_low_thr    // unsigned ,    RW, default = 0
#define CVE_TOF_REG14                              ((0x0095  << 2) + 0xfe08e400)
//Bit 31:16        reg_cve_tof_dis_max       // unsigned ,    RW, default = 0  depth
//Bit 15: 0        reg_cve_tof_dis_min       // unsigned ,    RW, default = 0  depth
#define CVE_TOF_REG15                              ((0x0096  << 2) + 0xfe08e400)
//Bit 31:25        reserved
//Bit 24           reg_cve_tof_spa1_en       // unsigned ,    RW, default = 0  space filter ctrl
//Bit 23:17        reserved
//Bit 16           reg_cve_tof_spa2_en       // unsigned ,    RW, default = 0  space filter ctrl
//Bit 15:10        reserved
//Bit  9: 8        reg_cve_tof_fpn_cali_mode // unsigned ,    RW, default = 1  0:bypass,1;fpn mode,2:fd mode
//Bit  7: 1        reserved
//Bit  0           reg_cve_tof_bypass_en     // unsigned ,    RW, default = 0  bypass or not,1:bypass,0:not,default:0;if bypass_en == 1,spa2_en and dis_min must be 0,dis_max must be 65535
#define CVE_ADD_DSTSUM                             ((0x0097  << 2) + 0xfe08e400)
//Bit 31: 0        ro_cve_add_dstsum         // unsigned ,    RO, default = 0
#define CVE_SUB_AREA                               ((0x0098  << 2) + 0xfe08e400)
//Bit 31: 0        ro_cve_sub_front_area     // unsigned ,    RO, default = 0
#define CVE_SUB_THRESH_RATIO                       ((0x0099  << 2) + 0xfe08e400)
//Bit 31:16        reg_sub_thresh_ratio      // unsigned ,    RW, default = 13107  norm 65536 to 1.0
//Bit 15: 0        reserved
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe08e000
// -----------------------------------------------
//
// Reading file:  ./cve_top_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_TOP_HW_CTRL_REG0                       ((0x0000  << 2) + 0xfe08e000)
//Bit 31:28        reserved
//Bit 27:24        reg_clk_gate_ctrl_intr       // unsigned ,    RW, default = 0
//Bit 23:22        reg_clk_gate_ctrl_lut        // unsigned ,    RW, default = 0
//Bit 21:20        reg_clk_gate_ctrl_reg_top_hw // unsigned ,    RW, default = 2
//Bit 19:18        reg_clk_gate_ctrl_reg_wrmif2 // unsigned ,    RW, default = 0
//Bit 17:16        reg_clk_gate_ctrl_reg_wrmif1 // unsigned ,    RW, default = 0
//Bit 15:14        reg_clk_gate_ctrl_reg_wrmif  // unsigned ,    RW, default = 0
//Bit 13:12        reg_clk_gate_ctrl_reg_rdmif2 // unsigned ,    RW, default = 0
//Bit 11:10        reg_clk_gate_ctrl_reg_rdmif1 // unsigned ,    RW, default = 0
//Bit 9:8          reg_clk_gate_ctrl_reg_rdmif  // unsigned ,    RW, default = 0
//Bit 7:6          reg_clk_gate_ctrl_reg_top    // unsigned ,    RW, default = 0
//Bit 5:4          reg_clk_gate_ctrl_cq         // unsigned ,    RW, default = 0
//Bit 3:3          reg_cve_sec_ctrl             // unsigned ,    RW, default = 0
//Bit 2:2          reg_cve_dbg_run_cycles_en // unsigned ,    RW, default = 0
//Bit 1:1          reg_ccl_dbg_dis_sec_pass // unsigned ,    RW, default = 0
//Bit 0:0          reg_sync_rst // unsigned ,    RW, default = 0
#define CVE_TOP_HW_CTRL_REG1                       ((0x0001  << 2) + 0xfe08e000)
//Bit 31:0         reg_clk_gate_ctrl_ops_lsb // unsigned ,    RW, default = 0
#define CVE_TOP_HW_CTRL_REG2                       ((0x0002  << 2) + 0xfe08e000)
//Bit 31:0         reg_clk_gate_ctrl_ops_msb // unsigned ,    RW, default = 0
#define CVE_CQ0                                    ((0x0003  << 2) + 0xfe08e000)
//Bit 31: 0        reg_cq0_baddr       // unsigned ,    RW, default = 0
#define CVE_CQ1                                    ((0x0004  << 2) + 0xfe08e000)
//Bit 31: 0        reg_cq1_baddr       // unsigned ,    RW, default = 0
#define CVE_CQ2                                    ((0x0005  << 2) + 0xfe08e000)
//Bit 31: 29       reserved
//Bit 28: 28       ro_cq1_done          // unsigned ,    RO, default = 0
//Bit 27: 27       ro_cq0_done          // unsigned ,    RO, default = 0
//Bit 26: 26       reg_cq_en            // unsigned ,    RW, default = 0
//Bit 25: 25       reg_sw_cq1_rdy       // unsigned ,    RW, default = 0
//Bit 24: 24       reg_sw_cq0_rdy       // unsigned ,    RW, default = 0
//Bit 23: 12       reg_cq1_len          // unsigned ,    RW, default = 0
//Bit 11: 0        reg_cq0_len          // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_WRITE0                       ((0x0006  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_stat_write0       // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_WRITE1                       ((0x0007  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_stat_write1       // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_CLR_WRITE0                   ((0x0008  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_stat_clr_write0   // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_CLR_WRITE1                   ((0x0009  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_stat_clr_write1   // unsigned ,    RW, default = 0
#define CVE_INTR_MASKN0                            ((0x000a  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_maskn0     // unsigned ,    RW, default = 0
#define CVE_INTR_MASKN1                            ((0x000b  << 2) + 0xfe08e000)
//Bit 31: 0        reg_intr_maskn1     // unsigned ,    RW, default = 0
#define CVE_INTR_STATUS0                           ((0x000c  << 2) + 0xfe08e000)
//Bit 31: 0        ro_intr_status0     // unsigned ,    RO, default = 0
#define CVE_INTR_STATUS1                           ((0x000d  << 2) + 0xfe08e000)
//Bit 31: 0        ro_intr_status1     // unsigned ,    RO, default = 0
#define CVE_OP_ONCE_RUN_CYCLES                     ((0x000e  << 2) + 0xfe08e000)
//Bit 31: 0        ro_op_once_run_cycles // unsigned ,RO, default = 0
#define CVE_CQ3                                    ((0x000f  << 2) + 0xfe08e000)
//Bit 31: 25       reserved
//Bit 24: 24       reg_cq_pingpong_mode //unsigned, RW, default = 0
//Bit 23: 21       reserved
//Bit 20: 12       reg_cq1_op_num   // unsigned ,    RW, default = 1
//Bit 11: 9        reserved
//Bit  8: 0        reg_cq0_op_num   // unsigned ,    RW, default = 1
#define CVE_CQ4                                    ((0x0010  << 2) + 0xfe08e000)
//Bit 31: 9        reserved
//Bit 8: 0         ro_cq_op_run_idx   // unsigned ,    RO, default = 0
#define CVE_ID_STA0                                ((0x0011  << 2) + 0xfe08e000)
//Bit 31:2       reserved
//Bit 1: 1       reg_cve_id_sta_en     // unsigned ,    RW, default = 0
//Bit 0: 0       reg_cve_id_sta_clr    // unsigned ,    RW, default = 0
#define CVE_ID_STA1                                ((0x0012  << 2) + 0xfe08e000)
//Bit 31:16      reserved
//Bit 15: 0      ro_cve_op_id          // unsigned ,    RO, default = 0
#define CVE_TIMEOUT0                               ((0x0013  << 2) + 0xfe08e000)
//Bit 31:1       reserved
//Bit 0: 0       reg_cve_timeout_intr_en // unsigned ,   RW, default = 0
#define CVE_TIMEOUT1                               ((0x0014  << 2) + 0xfe08e000)
//Bit 31: 0      reg_cve_op_time_thr     // unsigned ,   RW, default = 60000000
#define CVE_UTE0                                   ((0x0015  << 2) + 0xfe08e000)
//Bit 31:2       reg_cve_ute_sta_total_cycles // unsigned ,  RW, default = 600000000
//Bit 1: 1       reserved
//Bit 0: 0       reg_cve_ute_sta_en           // unsigned ,  RW, default = 0
#define CVE_UTE1                                   ((0x0016  << 2) + 0xfe08e000)
//Bit 31:30      reserved
//Bit 29: 0      ro_cve_ute_cycles_in_total // unsigned ,  RO, default = 0
#define CVE_STATUS                                 ((0x0017  << 2) + 0xfe08e000)
//Bit 31:4       reserved
//Bit 3: 0       ro_cve_status           // unsigned ,  RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_hw_reg.h
//
//
// Reading file:  ./cve_top_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_WMIF0_CTRL1                            ((0x00c0  << 2) + 0xfe08e000)
#define CVE_WMIF0_CTRL2                            ((0x00c1  << 2) + 0xfe08e000)
#define CVE_WMIF0_CTRL3                            ((0x00c2  << 2) + 0xfe08e000)
#define CVE_WMIF0_CTRL4                            ((0x00c3  << 2) + 0xfe08e000)
#define CVE_WMIF0_SCOPE_X                          ((0x00c4  << 2) + 0xfe08e000)
#define CVE_WMIF0_SCOPE_Y                          ((0x00c5  << 2) + 0xfe08e000)
#define CVE_WMIF0_RO_STAT                          ((0x00c6  << 2) + 0xfe08e000)
#define CVE_WMIF1_CTRL1                            ((0x00c8  << 2) + 0xfe08e000)
#define CVE_WMIF1_CTRL2                            ((0x00c9  << 2) + 0xfe08e000)
#define CVE_WMIF1_CTRL3                            ((0x00ca  << 2) + 0xfe08e000)
#define CVE_WMIF1_CTRL4                            ((0x00cb  << 2) + 0xfe08e000)
#define CVE_WMIF1_SCOPE_X                          ((0x00cc  << 2) + 0xfe08e000)
#define CVE_WMIF1_SCOPE_Y                          ((0x00cd  << 2) + 0xfe08e000)
#define CVE_WMIF1_RO_STAT                          ((0x00ce  << 2) + 0xfe08e000)
#define CVE_WMIF2_CTRL1                            ((0x00d0  << 2) + 0xfe08e000)
#define CVE_WMIF2_CTRL2                            ((0x00d1  << 2) + 0xfe08e000)
#define CVE_WMIF2_CTRL3                            ((0x00d2  << 2) + 0xfe08e000)
#define CVE_WMIF2_CTRL4                            ((0x00d3  << 2) + 0xfe08e000)
#define CVE_WMIF2_SCOPE_X                          ((0x00d4  << 2) + 0xfe08e000)
#define CVE_WMIF2_SCOPE_Y                          ((0x00d5  << 2) + 0xfe08e000)
#define CVE_WMIF2_RO_STAT                          ((0x00d6  << 2) + 0xfe08e000)
#define CVE_RMIF0_CTRL1                            ((0x00d8  << 2) + 0xfe08e000)
#define CVE_RMIF0_CTRL2                            ((0x00d9  << 2) + 0xfe08e000)
#define CVE_RMIF0_CTRL3                            ((0x00da  << 2) + 0xfe08e000)
#define CVE_RMIF0_CTRL4                            ((0x00db  << 2) + 0xfe08e000)
#define CVE_RMIF0_SCOPE_X                          ((0x00dc  << 2) + 0xfe08e000)
#define CVE_RMIF0_SCOPE_Y                          ((0x00dd  << 2) + 0xfe08e000)
#define CVE_RMIF0_RO_STAT                          ((0x00de  << 2) + 0xfe08e000)
#define CVE_RMIF1_CTRL1                            ((0x00e0  << 2) + 0xfe08e000)
#define CVE_RMIF1_CTRL2                            ((0x00e1  << 2) + 0xfe08e000)
#define CVE_RMIF1_CTRL3                            ((0x00e2  << 2) + 0xfe08e000)
#define CVE_RMIF1_CTRL4                            ((0x00e3  << 2) + 0xfe08e000)
#define CVE_RMIF1_SCOPE_X                          ((0x00e4  << 2) + 0xfe08e000)
#define CVE_RMIF1_SCOPE_Y                          ((0x00e5  << 2) + 0xfe08e000)
#define CVE_RMIF1_RO_STAT                          ((0x00e6  << 2) + 0xfe08e000)
#define CVE_RMIF2_CTRL1                            ((0x00e8  << 2) + 0xfe08e000)
#define CVE_RMIF2_CTRL2                            ((0x00e9  << 2) + 0xfe08e000)
#define CVE_RMIF2_CTRL3                            ((0x00ea  << 2) + 0xfe08e000)
#define CVE_RMIF2_CTRL4                            ((0x00eb  << 2) + 0xfe08e000)
#define CVE_RMIF2_SCOPE_X                          ((0x00ec  << 2) + 0xfe08e000)
#define CVE_RMIF2_SCOPE_Y                          ((0x00ed  << 2) + 0xfe08e000)
#define CVE_RMIF2_RO_STAT                          ((0x00ee  << 2) + 0xfe08e000)
#define CVE_LUT_APB_ADDR                           ((0x00f0  << 2) + 0xfe08e000)
#define CVE_LUT_APB_DATA                           ((0x00f1  << 2) + 0xfe08e000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_mif_reg.h
//
//========================================================================
//  MIPI_ISP
//========================================================================
//
// Reading file:  ./mipi_isp.h
//
#if 0
//below register for t7_revc
// synopsys translate_off
// synopsys translate_on
//========================================================================
// MIPI_ISP  adapt fe0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b0000
// -----------------------------------------------
//========================================================================
// MIPI_ISP  adapt fe1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b0400
// -----------------------------------------------
//========================================================================
// MIPI_ISP  adapt fe2
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b0800
// -----------------------------------------------
//========================================================================
// MIPI_ISP  adapt fe3
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b0c00
// -----------------------------------------------
//========================================================================
// MIPI_ISP  adapt cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1000
// -----------------------------------------------
#define MIPI_ADAPT_DDR_RD0_CNTL0                   ((0x0000  << 2) + 0xfe3b1000)
//Bit 31    ,frame_rd_start           ,default = 0 ,frame_rd_start       ,pluse,one cycle
//Bit 30    ,reserved
//Bit 29:28 ,burst_type               ,default = 0 ,burst_type
//Bit 27:26 ,reg_sample_sel           ,default = 0 ,reg_sample_sel
//Bit 25    ,soft_load                ,default = 0 ,soft_load
//Bit 24    ,continue_mode            ,default = 0 ,continue_mode
//Bit 23    ,dol_mode                 ,default = 0 ,dol_mode
//Bit 22    ,pingpong_mode            ,default = 0 ,pingpong_mode
//Bit 21    ,dol_time_out_en          ,default = 0 ,dol_time_out_en
//Bit 20    ,frame_wr_done_sel        ,default = 0 ,frame_wr_done_sel
//Bit 19    ,line_wr_done_sel         ,default = 0 ,line_wr_done_sel
//Bit 18    ,dol_frame_end_en         ,default = 0 ,dol_frame_end_en
//Bit 17    ,dol_vblank_clr_sel       ,default = 0 ,dol_vblank_clr_sel
//Bit 16    ,reserved
//Bit 15:14 ,dol_time_tick_sel        ,default = 0 ,dol_time_tick_sel
//Bit 13:4  ,line_stride              ,default = 0 ,line_stride
//Bit 3:2   ,lbuf_soft_rst_sel        ,default = 0 ,lbuf_soft_rst_sel
//Bit 1     ,frame_loop_enable        ,default = 0 ,frame_loop_enable
//Bit 0     ,enable                   ,default = 0 ,enable
#define MIPI_ADAPT_DDR_RD0_CNTL1                   ((0x0001  << 2) + 0xfe3b1000)
//Bit 31:30 ,port_sel                 ,default = 0 ,port_sel
//Bit   29  ,frame_vs_rst_en          ,default = 0 ,frame_vs_rst_en
//Bit 28:16 ,line_number              ,default = 0 ,line_number
//Bit 15:12 ,dol_line_threshold       ,default = 0 ,dol_line_threshold
//Bit 11:10 ,frame_vs_rst_sel         ,default = 0 ,frame_vs_rst_sel
//Bit 9:0   ,line_size                ,default = 0 ,line_size
#define MIPI_ADAPT_DDR_RD0_CNTL2                   ((0x0002  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_base_address_0     ,default = 0 ,frame_base_address_0
#define MIPI_ADAPT_DDR_RD0_CNTL3                   ((0x0003  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_base_address_1     ,default = 0 ,frame_base_address_1
#define MIPI_ADAPT_DDR_RD0_CNTL4                   ((0x0004  << 2) + 0xfe3b1000)
//Bit 31:13 ,dol_time_out             ,default = 0 ,dol_time_out
//Bit 12:0  ,line_threshold           ,default = 0 ,line_threshold
#define MIPI_ADAPT_DDR_RD0_CNTL5                   ((0x0005  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_end_address_0      ,default = 0 ,frame_end_address_0
#define MIPI_ADAPT_DDR_RD0_CNTL6                   ((0x0006  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_end_address_1      ,default = 0 ,frame_end_address_1
#define MIPI_ADAPT_DDR_RD0_UGT_CNTL0               ((0x0007  << 2) + 0xfe3b1000)
//Bit 31: 8, reserved
//Bit  7: 4, reg_rd0_qos_th_val      ,default = 0,reg_rd0_qos_th_val
//Bit  3: 0, reg_rd0_qos_default_val ,default = 0,reg_rd0_qos_default_val
#define MIPI_ADAPT_DDR_RD0_UGT_CNTL1               ((0x0008  << 2) + 0xfe3b1000)
//Bit 31   , reg_rd0_qos_auto_en     ,default = 0,reg_rd0_qos_auto_en
//Bit 30:16, reg_rd0_qos_th1         ,default = 0,reg_rd0_qos_th1
//Bit 15    ,reserved
//Bit 14: 0, reg_rd0_qos_th0         ,default = 0,reg_rd0_qos_th0
#define MIPI_ADAPT_DDR_RD0_ST0                     ((0x000a  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd0_st0   ,default = 0 ,mipi_adapt_ddr_rd0_st0
#define MIPI_ADAPT_DDR_RD0_ST1                     ((0x000b  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd0_st1   ,default = 0 ,mipi_adapt_ddr_rd0_st1
#define MIPI_ADAPT_DDR_RD0_ST2                     ((0x000c  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd0_st2   ,default = 0 ,mipi_adapt_ddr_rd0_st2
#define MIPI_ADAPT_DDR_RD0_UGT_ST                  ((0x000d  << 2) + 0xfe3b1000)
//Bit 31: 0, reg_rd0_qos_st ,default = 0 ,RO
#define MIPI_ADAPT_DDR_RD1_CNTL0                   ((0x0010  << 2) + 0xfe3b1000)
//Bit 31    ,frame_rd_start           ,default = 0 ,frame_rd_start       ,pluse,one cycle
//Bit 30    ,reserved
//Bit 29:28 ,burst_type               ,default = 0 ,burst_type
//Bit 27:26 ,reg_sample_sel           ,default = 0 ,reg_sample_sel
//Bit 25    ,soft_load                ,default = 0 ,soft_load
//Bit 24    ,continue_mode            ,default = 0 ,continue_mode
//Bit 23    ,dol_mode                 ,default = 0 ,dol_mode
//Bit 22    ,pingpong_mode            ,default = 0 ,pingpong_mode
//Bit 21    ,dol_time_out_en          ,default = 0 ,dol_time_out_en
//Bit 20    ,frame_wr_done_sel        ,default = 0 ,frame_wr_done_sel
//Bit 19    ,line_wr_done_sel         ,default = 0 ,line_wr_done_sel
//Bit 18    ,dol_frame_end_en         ,default = 0 ,dol_frame_end_en
//Bit 17    ,dol_vblank_clr_sel       ,default = 0 ,dol_vblank_clr_sel
//Bit 16    ,reserved
//Bit 15:14 ,dol_time_tick_sel        ,default = 0 ,dol_time_tick_sel
//Bit 13:4  ,line_stride              ,default = 0 ,line_stride
//Bit 3:2   ,lbuf_soft_rst_sel        ,default = 0 ,lbuf_soft_rst_sel
//Bit 1     ,frame_loop_enable        ,default = 0 ,frame_loop_enable
//Bit 0     ,enable                   ,default = 0 ,enable
#define MIPI_ADAPT_DDR_RD1_CNTL1                   ((0x0011  << 2) + 0xfe3b1000)
//Bit 31:30 ,port_sel                 ,default = 0 ,port_sel
//Bit   29  ,frame_vs_rst_en          ,default = 0 ,frame_vs_rst_en
//Bit 28:16 ,line_number              ,default = 0 ,line_number
//Bit 15:12 ,dol_line_threshold       ,default = 0 ,dol_line_threshold
//Bit 11:10 ,frame_vs_rst_sel         ,default = 0 ,frame_vs_rst_sel
//Bit 9:0   ,line_size                ,default = 0 ,line_size
#define MIPI_ADAPT_DDR_RD1_CNTL2                   ((0x0012  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_base_address_0     ,default = 0 ,frame_base_address_0
#define MIPI_ADAPT_DDR_RD1_CNTL3                   ((0x0013  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_base_address_1     ,default = 0 ,frame_base_address_1
#define MIPI_ADAPT_DDR_RD1_CNTL4                   ((0x0014  << 2) + 0xfe3b1000)
//Bit 31:13 ,dol_time_out             ,default = 0 ,dol_time_out
//Bit 12:0  ,line_threshold           ,default = 0 ,line_threshold
#define MIPI_ADAPT_DDR_RD1_CNTL5                   ((0x0015  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_end_address_0      ,default = 0 ,frame_end_address_0
#define MIPI_ADAPT_DDR_RD1_CNTL6                   ((0x0016  << 2) + 0xfe3b1000)
//Bit 31:0  ,frame_end_address_1      ,default = 0 ,frame_end_address_1
#define MIPI_ADAPT_DDR_RD1_UGT_CNTL0               ((0x0017  << 2) + 0xfe3b1000)
//Bit 31: 8, reserved
//Bit  7: 4, reg_rd1_qos_th_val      ,default = 0,reg_rd1_qos_th_val
//Bit  3: 0, reg_rd1_qos_default_val ,default = 0,reg_rd1_qos_default_val
#define MIPI_ADAPT_DDR_RD1_UGT_CNTL1               ((0x0018  << 2) + 0xfe3b1000)
//Bit 31   , reg_rd1_qos_auto_en     ,default = 0,reg_rd1_qos_auto_en
//Bit 30:16, reg_rd1_qos_th1         ,default = 0,reg_rd1_qos_th1
//Bit 15   ,reserved
//Bit 14: 0, reg_rd1_qos_th0         ,default = 0,reg_rd1_qos_th0
#define MIPI_ADAPT_DDR_RD1_ST0                     ((0x001a  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd1_st1   ,default = 0 ,mipi_adapt_ddr_rd1_st1
#define MIPI_ADAPT_DDR_RD1_ST1                     ((0x001b  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd1_st2   ,default = 0 ,mipi_adapt_ddr_rd1_st2
#define MIPI_ADAPT_DDR_RD1_ST2                     ((0x001c  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_ddr_rd1_st2   ,default = 0 ,mipi_adapt_ddr_rd1_st2
#define MIPI_ADAPT_DDR_RD1_UGT_ST                  ((0x001d  << 2) + 0xfe3b1000)
//Bit 31: 0, reg_rd1_qos_st ,default = 0 ,RO
#define MIPI_ADAPT_PIXEL0_CNTL0                    ((0x0020  << 2) + 0xfe3b1000)
//Bit 31    ,start_en                 ,default = 0        ,start_en     ,pluse,one cycle
//Bit 30    ,soft_load                ,default = 0        ,soft_load    ,pluse,one cycle
//Bit 29:26 ,reserved
//Bit 25:20 ,data_type                ,default = 0        ,data_type
//Bit 19:18 ,reserved
//Bit 17:16 ,data_mode                ,default = 0        ,data_mode
//Bit 15    ,reserved
//Bit 14    ,color_expand             ,default = 0        ,color_expand
//Bit 13    ,reserved
//Bit 12:0  ,fifo_threshold           ,default = 0        ,fifo_threshold
#define MIPI_ADAPT_PIXEL0_CNTL1                    ((0x0021  << 2) + 0xfe3b1000)
//Bit 31:16 ,pixel_x_start            ,default = 0        ,pixel_x_start
//Bit 15:0  ,pixel_x_end              ,default = 16'hffff ,pixel_x_end
#define MIPI_ADAPT_PIXEL0_CNTL2                    ((0x0022  << 2) + 0xfe3b1000)
//Bit 31:28 ,reserved
//Bit 27:15 ,pixel_num                ,default = 0        ,pixel_num
//Bit 14:10 ,reserved
//Bit 9:0   ,fifo_rd_size             ,default = 0        ,fifo_rd_size
#define MIPI_ADAPT_PIXEL0_CNTL3                    ((0x0023  << 2) + 0xfe3b1000)
//Bit 31    ,frame_sync_dely_en       ,default = 0        ,frame_sync_dely_en
//Bit 30:16 ,frame_sync_dely_time     ,default = 0        ,frame_sync_dely_time
//Bit 15:3  ,reserved
//Bit 2     ,frame_sync_en            ,default = 0        ,frame_sync_en
//Bit 1     ,frame_sync_rst_en        ,default = 0        ,frame_sync_rst_en
//Bit 0     ,frame_sync_load_en       ,default = 0        ,frame_sync_load_en
#define MIPI_ADAPT_PIXEL0_ST0                      ((0x002a  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_pixel0_st0    ,RO                 ,mipi_adapt_pixel0_st0
#define MIPI_ADAPT_PIXEL0_ST1                      ((0x002b  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_pixel0_st1    ,RO                 ,mipi_adapt_pixel0_st1
#define MIPI_ADAPT_PIXEL1_CNTL0                    ((0x0030  << 2) + 0xfe3b1000)
//Bit 31    ,start_en                 ,default = 0        ,start_en     ,pluse,one cycle
//Bit 30    ,soft_load                ,default = 0        ,soft_load    ,pluse,one cycle
//Bit 29:26 ,reserved
//Bit 25:20 ,data_type                ,default = 0        ,data_type
//Bit 19:18 ,reserved
//Bit 17:16 ,data_mode                ,default = 0        ,data_mode
//Bit 15    ,mode_422to444            ,default = 0        ,mode_422to444
//Bit 14    ,color_expand             ,default = 0        ,color_expand
//Bit 13    ,reserved
//Bit 12:0  ,fifo_threshold           ,default = 0        ,fifo_threshold
#define MIPI_ADAPT_PIXEL1_CNTL1                    ((0x0031  << 2) + 0xfe3b1000)
//Bit 31:16 ,pixel_x_start            ,default = 0        ,pixel_x_start
//Bit 15:0  ,pixel_x_end              ,default = 16'hffff ,pixel_x_end
#define MIPI_ADAPT_PIXEL1_CNTL2                    ((0x0032  << 2) + 0xfe3b1000)
//Bit 31:28 ,reserved
//Bit 27:15 ,pixel_num                ,default = 0        ,pixel_num
//Bit 14:10 ,reserved
//Bit 9:0   ,fifo_rd_size             ,default = 0        ,fifo_rd_size
#define MIPI_ADAPT_PIXEL1_CNTL3                    ((0x0033  << 2) + 0xfe3b1000)
//Bit 31    ,frame_sync_dely_en       ,default = 0        ,frame_sync_dely_en
//Bit 30:16 ,frame_sync_dely_time     ,default = 0        ,frame_sync_dely_time
//Bit 15:3  ,reserved
//Bit 2     ,frame_sync_en            ,default = 0        ,frame_sync_en
//Bit 1     ,frame_sync_rst_en        ,default = 0        ,frame_sync_rst_en
//Bit 0     ,frame_sync_load_en       ,default = 0        ,frame_sync_load_en
#define MIPI_ADAPT_PIXEL1_ST0                      ((0x003a  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_pixel1_st0    ,default = 0 ,mipi_adapt_pixel1_st0
#define MIPI_ADAPT_PIXEL1_ST1                      ((0x003b  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_pixel1_st1    ,default = 0 ,mipi_adapt_pixel1_st1
#define MIPI_ADAPT_ALIG_CNTL0                      ((0x0040  << 2) + 0xfe3b1000)
//Bit 31:16 ,v_num_a                   ,default = 0       ,v_num_a
//Bit 15:0  ,h_num_a                   ,default = 0       ,h_num_a
#define MIPI_ADAPT_ALIG_CNTL1                      ((0x0041  << 2) + 0xfe3b1000)
//Bit 31:16 ,hpe_num_a                 ,default = 0       ,hpe_num_a
//Bit 15:0  ,hps_num_a                 ,default = 0       ,hps_num_a
#define MIPI_ADAPT_ALIG_CNTL2                      ((0x0042  << 2) + 0xfe3b1000)
//Bit 31:16 ,vpe_num_a                 ,default = 0       ,vpe_num_a  // line valid end point for camera a
//Bit 15:0  ,vps_num_a                 ,default = 0       ,vps_num_a  // line valid start point for camera a
#define MIPI_ADAPT_ALIG_CNTL3                      ((0x0043  << 2) + 0xfe3b1000)
//Bit 31:16 ,frame_start_line          ,default = 0       ,frame_start_line // start line after frame_sync when frame_sync_rst_en is 1
//Bit 15:0  ,frame_start_pixel         ,default = 0       ,frame_start_pixel
#define MIPI_ADAPT_ALIG_CNTL4                      ((0x0044  << 2) + 0xfe3b1000)
//Bit 31:30 ,reserved
//Bit 29:0  ,fill_data                 ,default = 0       ,fill_data
#define MIPI_ADAPT_ALIG_CNTL5                      ((0x0045  << 2) + 0xfe3b1000)
//Bit 31:20 ,flow_done_src_en          ,default = 0       ,flow_done_src_en
//Bit 19:0  ,reserved
#define MIPI_ADAPT_ALIG_CNTL6                      ((0x0046  << 2) + 0xfe3b1000)
//Bit 31    ,yuvrgb_mode               ,default = 0       ,yuvrgb_mode  //
//Bit 30    ,frame_end_load_en         ,default = 0       ,frame_end_load_en  //
//Bit 29:16 ,reserved
//Bit 15    ,vdata3_en                 ,default = 0       ,vdata3_en  //vdata3 enable
//Bit 14    ,vdata2_en                 ,default = 0       ,vdata2_en  //vdata2 enable
//Bit 13    ,vdata1_en                 ,default = 0       ,vdata1_en  //vdata1 enable
//Bit 12    ,vdata0_en                 ,default = 0       ,vdata0_en  //vdata0 enable
//Bit 11    ,vdata3_sel                ,default = 0       ,vdata3_sel  //vdata3 select
//Bit 10    ,vdata2_sel                ,default = 0       ,vdata2_sel  //vdata2 select
//Bit 9     ,vdata1_sel                ,default = 0       ,vdata1_sel  //vdata1 select
//Bit 8     ,vdata0_sel                ,default = 0       ,vdata0_sel  //vdata0 select
//Bit 7:6   ,reserved
//Bit 5     ,pix_datamode_1            ,default = 0       ,pix_datamode_1  //
//Bit 4     ,pix_datamode_0            ,default = 0       ,pix_datamode_0  //
//Bit 3     ,lane1_sel                 ,default = 0       ,lane1_sel  //lane select
//Bit 2     ,lane1_en                  ,default = 0       ,lane1_en  //lane enable
//Bit 1     ,lane0_sel                 ,default = 0       ,lane0_sel  //lane select
//Bit 0     ,lane0_en                  ,default = 0       ,lane0_en  //lane enable
#define MIPI_ADAPT_ALIG_CNTL7                      ((0x0047  << 2) + 0xfe3b1000)
//Bit 31:16 ,inc_mask_timeout          ,default = 0       ,inc_mask_timeout
//Bit 15    ,inc_mask_timeout_en       ,default = 0       ,inc_mask_timeout_en
//Bit 14    ,frame_sync_rst_en         ,default = 0       ,frame_sync_rst_en
//Bit 13    ,frame_sync_load_en        ,default = 0       ,frame_sync_load_en
//Bit 12:2  ,reserved
//Bit 1 :0  ,inc_mask_tick_sel         ,default = 0       ,inc_mask_tick_sel
#define MIPI_ADAPT_ALIG_CNTL8                      ((0x0048  << 2) + 0xfe3b1000)
//Bit 31    ,start_en                  ,default = 0       ,start_en //no shadow
//Bit 30    ,reserved
//Bit 29    ,soft_load                 ,default = 0       ,soft_load //no shadow
//Bit 28:16 ,reserved
//Bit 15    ,hsync_irq_num_en          ,default = 0       ,hsync_irq_num_en
//Bit 14    ,reserved
//Bit 13    ,no_frame_sv_sync_en       ,default = 0       ,no_frame_sv_sync_en // reset hcnt to frame_start_pixel
//Bit 12    ,exc_mask_dis              ,default = 0       ,exc_mask_dis //disable inc_mask when exc happen
//Bit 11    ,mult_camera_req_sf_en     ,default = 0       ,mult_camera_req_sf_en //
//Bit 10    ,mult_camera_req_sf        ,default = 0       ,mult_camera_req_sf //
//Bit 9:7   ,reserved
//Bit 6     ,isp_mult_frame_req_en     ,default = 0       ,isp_mult_frame_req_en
//Bit 5     ,frame_continue            ,default = 0       ,frame_continue
//Bit 4:0   ,reserved
#define MIPI_ADAPT_ALIG_CNTL9                      ((0x0049  << 2) + 0xfe3b1000)
//Bit 31    ,frame_sync_dely_en        ,default = 0       ,frame_sync_dely_en
//Bit 30:16 ,frame_sync_dely_time      ,default = 0       ,frame_sync_dely_time
//Bit 15:0  ,hsync_irq_num             ,default = 0       ,hsync_irq_num
#define MIPI_ADAPT_ALIG_CNTL10                     ((0x004a  << 2) + 0xfe3b1000)
//Bit 31    ,isp_hold_src7_en          ,default = 0       ,isp_hold_src7_en
//Bit 30    ,isp_hold_src6_en          ,default = 0       ,isp_hold_src6_en
//Bit 29    ,isp_hold_src5_en          ,default = 0       ,isp_hold_src5_en
//Bit 28    ,isp_hold_src4_en          ,default = 0       ,isp_hold_src4_en
//Bit 27    ,isp_hold_src3_en          ,default = 0       ,isp_hold_src3_en
//Bit 26    ,isp_hold_src2_en          ,default = 0       ,isp_hold_src2_en
//Bit 25    ,isp_hold_src1_en          ,default = 0       ,isp_hold_src1_en
//Bit 24    ,isp_hold_src0_en          ,default = 0       ,isp_hold_src0_en
//Bit 23:19 ,reserved
//Bit 18:16 ,frame_vs_sel              ,default = 0       ,frame_vs_sel
//Bit 15:0  ,frame_vs_cke_delay        ,default = 0       ,frame_vs_cke_delay
#define MIPI_ADAPT_ALIG_CNTL11                     ((0x004b  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst0_sel         ,default = 0       ,frame_vs_dst0_sel
//Bit 15:0  ,frame_vs_dst0_cke_delay   ,default = 0       ,frame_vs_dst0_cke_delay
#define MIPI_ADAPT_ALIG_CNTL12                     ((0x004c  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst1_sel         ,default = 0       ,frame_vs_dst1_sel
//Bit 15:0  ,frame_vs_dst1_cke_delay   ,default = 0       ,frame_vs_dst1_cke_delay
#define MIPI_ADAPT_ALIG_CNTL13                     ((0x004d  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst2_sel         ,default = 0       ,frame_vs_dst2_sel
//Bit 15:0  ,frame_vs_dst2_cke_delay   ,default = 0       ,frame_vs_dst2_cke_delay
#define MIPI_ADAPT_ALIG_CNTL14                     ((0x004e  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst3_sel         ,default = 0       ,frame_vs_dst3_sel
//Bit 15:0  ,frame_vs_dst3_cke_delay   ,default = 0       ,frame_vs_dst3_cke_delay
#define MIPI_ADAPT_ALIG_CNTL15                     ((0x004f  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst4_sel         ,default = 0       ,frame_vs_dst4_sel
//Bit 15:0  ,frame_vs_dst4_cke_delay   ,default = 0       ,frame_vs_dst4_cke_delay
#define MIPI_ADAPT_ALIG_CNTL16                     ((0x0050  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst5_sel         ,default = 0       ,frame_vs_dst5_sel
//Bit 15:0  ,frame_vs_dst5_cke_delay   ,default = 0       ,frame_vs_dst5_cke_delay
#define MIPI_ADAPT_ALIG_CNTL17                     ((0x0051  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst6_sel         ,default = 0       ,frame_vs_dst6_sel
//Bit 15:0  ,frame_vs_dst6_cke_delay   ,default = 0       ,frame_vs_dst6_cke_delay
#define MIPI_ADAPT_ALIG_CNTL18                     ((0x0052  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst7_sel         ,default = 0       ,frame_vs_dst7_sel
//Bit 15:0  ,frame_vs_dst7_cke_delay   ,default = 0       ,frame_vs_dst7_cke_delay
#define MIPI_ADAPT_ALIG_CNTL19                     ((0x0053  << 2) + 0xfe3b1000)
//Bit 31:19 ,reserved
//Bit 18:16 ,frame_vs_dst8_sel         ,default = 0       ,frame_vs_dst8_sel
//Bit 15:0  ,frame_vs_dst8_cke_delay   ,default = 0       ,frame_vs_dst8_cke_delay
#define MIPI_ADAPT_ALIG_ST0                        ((0x005a  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_alig_st0       , RO               ,mipi_adapt_alig_st0
#define MIPI_ADAPT_ALIG_ST1                        ((0x005b  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_alig_st1       , RO               ,mipi_adapt_alig_st1
#define MIPI_ADAPT_ALIG_ST2                        ((0x005c  << 2) + 0xfe3b1000)
//Bit 31:0  ,mipi_adapt_alig_st2       , RO               ,mipi_adapt_alig_st2
#define MIPI_ADAPT_OTHER_CNTL0                     ((0x0060  << 2) + 0xfe3b1000)
//Bit 31:24 ,reserved
//Bit 23:20 ,reg_adapt_debug_sel       ,default = 0       ,reg_adapt_debug_sel
//Bit 19:18 ,reserved
//Bit 17    ,reg_lbuf1_clk_on          ,default = 0       ,reg_lbuf1_clk_on
//Bit 16    ,reg_lbuf0_clk_on          ,default = 0       ,reg_lbuf0_clk_on
//Bit 15:11 ,reserved
//Bit 10:0  ,reg_soft_rst              ,default = 0       ,reg_soft_rst
#define DDR_RD0_LBUF_STATUS                        ((0x007a  << 2) + 0xfe3b1000)
//Bit 31:0  ,ddr_rd_0_lbuf_status      ,RO                ,ddr_rd_0_lbuf_status
#define DDR_RD1_LBUF_STATUS                        ((0x007b  << 2) + 0xfe3b1000)
//Bit 31:0  ,ddr_rd_1_lbuf_status      ,RO                ,ddr_rd_1_lbuf_status
#define MIPI_ADAPT_FE_MUX_CTL0                     ((0x0090  << 2) + 0xfe3b1000)
//Bit 31:30 ,reserved
//Bit 29:28 ,reg_alig_frame_valid_en       ,default = 0       ,reg_alig_frame_valid_en
//Bit 27:24 ,reg_alig_vs_sel               ,default = 0       ,reg_alig_vs_sel
//Bit 23:20 ,reg_pixel1_vs_sel             ,default = 0       ,reg_pixel1_vs_sel
//Bit 19:16 ,reg_pixel0_vs_sel             ,default = 0       ,reg_pixel0_vs_sel
//Bit 15    ,reserved
//Bit 14    ,reg_ddr_rd1_line_wr_vs_sel    ,default = 0       ,reg_ddr_rd1_line_wr_vs_sel
//Bit 13    ,reg_ddr_rd1_frame_wr_done_sel ,default = 0       ,reg_ddr_rd1_frame_wr_done_sel
//Bit 12    ,reg_ddr_rd1_line_wr_done_sel  ,default = 0       ,reg_ddr_rd1_line_wr_done_sel
//Bit 11:10 ,reserved
//Bit 9:8   ,reg_ddr_rd1_fe_sel            ,default = 0       ,reg_ddr_rd1_fe_sel
//Bit 7     ,reserved
//Bit 6     ,reg_ddr_rd0_line_wr_vs_sel    ,default = 0       ,reg_ddr_rd0_line_wr_vs_sel
//Bit 5     ,reg_ddr_rd0_frame_wr_done_sel ,default = 0       ,reg_ddr_rd0_frame_wr_done_sel
//Bit 4     ,reg_ddr_rd0_line_wr_done_sel  ,default = 0       ,reg_ddr_rd0_line_wr_done_sel
//Bit 3:2   ,reserved
//Bit 1:0   ,reg_ddr_rd0_fe_sel            ,default = 0       ,reg_ddr_rd0_fe_sel
#define MIPI_ADAPT_FE_MUX_CTL1                     ((0x0091  << 2) + 0xfe3b1000)
//Bit 31:28 ,reserved
//Bit 27:24 ,reg_lbuf1_vs_sel              ,default = 0       ,reg_lbuf1_vs_sel
//Bit 23:20 ,reg_lbuf0_vs_sel              ,default = 0       ,reg_lbuf0_vs_sel
//Bit 19:17 ,reserved
//Bit 16    ,reg_de_rd_frame_valid_sel     ,default = 0       ,reg_de_rd_frame_valid_sel
//Bit 15:12 ,reg_de_rd_vs_sel              ,default = 0       ,reg_de_rd_vs_sel
//Bit 11: 8 ,reg_de_wr_vs_sel              ,default = 0       ,reg_de_wr_vs_sel
//Bit  7: 4 ,reg_ds_nb_vs_sel              ,default = 0       ,reg_ds_nb_vs_sel
//Bit  3: 0 ,reg_fr_nb_vs_sel              ,default = 0       ,reg_fr_nb_vs_sel
#define MIPI_ADAPT_FE_MUX0_DLY_CNTL0               ((0x0092  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux0_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux0_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux0_mont_en           ,default = 0 ,
//Bit 27    , reg_mux0_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux0_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux0_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux0_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX0_DLY_STAT0               ((0x0093  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux0_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux0_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux0_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux0_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX1_DLY_CNTL0               ((0x0094  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux1_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux1_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux1_mont_en           ,default = 0 ,
//Bit 27    , reg_mux1_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux1_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux1_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux1_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX1_DLY_STAT0               ((0x0095  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux1_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux1_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux1_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux1_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX2_DLY_CNTL0               ((0x0096  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux2_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux2_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux2_mont_en           ,default = 0 ,
//Bit 27    , reg_mux2_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux2_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux2_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux2_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX2_DLY_STAT0               ((0x0097  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux2_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux2_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux2_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux2_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX3_DLY_CNTL0               ((0x0098  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux3_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux3_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux3_mont_en           ,default = 0 ,
//Bit 27    , reg_mux3_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux3_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux3_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux3_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX3_DLY_STAT0               ((0x0099  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux3_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux3_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux3_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux3_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX4_DLY_CNTL0               ((0x009a  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux4_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux4_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux4_mont_en           ,default = 0 ,
//Bit 27    , reg_mux4_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux4_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux4_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux4_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX4_DLY_STAT0               ((0x009b  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux4_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux4_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux4_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux4_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX5_DLY_CNTL0               ((0x009c  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux5_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux5_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux5_mont_en           ,default = 0 ,
//Bit 27    , reg_mux5_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux5_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux5_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux5_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX5_DLY_STAT0               ((0x009d  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux5_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux5_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux5_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux5_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX6_DLY_CNTL0               ((0x009e  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux6_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux6_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux6_mont_en           ,default = 0 ,
//Bit 27    , reg_mux6_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux6_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux6_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux6_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX6_DLY_STAT0               ((0x009f  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux6_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux6_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux6_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux6_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX7_DLY_CNTL0               ((0x00a0  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux7_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux7_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux7_mont_en           ,default = 0 ,
//Bit 27    , reg_mux7_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux7_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux7_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux7_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX7_DLY_STAT0               ((0x00a1  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux7_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux7_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux7_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux7_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX8_DLY_CNTL0               ((0x00a2  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux8_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux8_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux8_mont_en           ,default = 0 ,
//Bit 27    , reg_mux8_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux8_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux8_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux8_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX8_DLY_STAT0               ((0x00a3  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux8_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux8_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux8_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux8_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX9_DLY_CNTL0               ((0x00a4  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux9_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux9_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux9_mont_en           ,default = 0 ,
//Bit 27    , reg_mux9_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux9_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux9_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux9_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX9_DLY_STAT0               ((0x00a5  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux9_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux9_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux9_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux9_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX10_DLY_CNTL0              ((0x00a6  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux10_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux10_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux10_mont_en           ,default = 0 ,
//Bit 27    , reg_mux10_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux10_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux10_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux10_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX10_DLY_STAT0              ((0x00a7  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux10_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux10_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux10_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux10_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_0_DLY_CNTL0              ((0x00a8  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig0_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig0_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig0_mont_en           ,default = 0 ,
//Bit 27    , reg_alig0_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig0_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig0_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig0_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_0_DLY_STAT0              ((0x00a9  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig0_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig0_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig0_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig0_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_1_DLY_CNTL0              ((0x00aa  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig1_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig1_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig1_mont_en           ,default = 0 ,
//Bit 27    , reg_alig1_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig1_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig1_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig1_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_1_DLY_STAT0              ((0x00ab  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig1_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig1_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig1_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig1_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_2_DLY_CNTL0              ((0x00ac  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig2_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig2_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig2_mont_en           ,default = 0 ,
//Bit 27    , reg_alig2_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig2_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig2_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig2_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_2_DLY_STAT0              ((0x00ad  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig2_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig2_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig2_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig2_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_3_DLY_CNTL0              ((0x00ae  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig3_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig3_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig3_mont_en           ,default = 0 ,
//Bit 27    , reg_alig3_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig3_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig3_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig3_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_3_DLY_STAT0              ((0x00af  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig3_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig3_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig3_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig3_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_4_DLY_CNTL0              ((0x00b0  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig4_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig4_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig4_mont_en           ,default = 0 ,
//Bit 27    , reg_alig4_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig4_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig4_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig4_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_4_DLY_STAT0              ((0x00b1  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig4_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig4_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig4_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig4_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_5_DLY_CNTL0              ((0x00b2  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig5_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig5_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig5_mont_en           ,default = 0 ,
//Bit 27    , reg_alig5_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig5_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig5_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig5_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_5_DLY_STAT0              ((0x00b3  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig5_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig5_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig5_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig5_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_6_DLY_CNTL0              ((0x00b4  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig6_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig6_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig6_mont_en           ,default = 0 ,
//Bit 27    , reg_alig6_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig6_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig6_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig6_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_6_DLY_STAT0              ((0x00b5  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig6_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig6_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig6_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig6_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_7_DLY_CNTL0              ((0x00b6  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig7_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig7_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig7_mont_en           ,default = 0 ,
//Bit 27    , reg_alig7_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig7_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig7_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig7_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_7_DLY_STAT0              ((0x00b7  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig7_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig7_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig7_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig7_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_DST_VS_8_DLY_CNTL0              ((0x00b8  << 2) + 0xfe3b1000)
//Bit 31    , reg_alig8_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_alig8_mont_clr          ,default = 0 ,
//Bit 28    , reg_alig8_mont_en           ,default = 0 ,
//Bit 27    , reg_alig8_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_alig8_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_alig8_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_alig8_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_DST_VS_8_DLY_STAT0              ((0x00b9  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig8_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig8_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig8_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig8_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX11_DLY_CNTL0              ((0x00ba  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux11_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux11_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux11_mont_en           ,default = 0 ,
//Bit 27    , reg_mux11_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux11_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux11_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux11_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX11_DLY_STAT0              ((0x00bb  << 2) + 0xfe3b1000)
//Bit 31    , ro_alig9_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_alig9_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_alig9_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_alig9_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX12_DLY_CNTL0              ((0x00bc  << 2) + 0xfe3b1000)
//Bit 31    , reg_mux12_soft_rst          ,default = 0 ,
//Bit 30    , reserved
//Bit 29    , reg_mux12_mont_clr          ,default = 0 ,
//Bit 28    , reg_mux12_mont_en           ,default = 0 ,
//Bit 27    , reg_mux12_vs_delay_exc_clr  ,default = 0 ,
//Bit 26:20 , reserved
//Bit 19    , reg_mux12_vs_delay_en       ,default = 0 ,
//Bit 18    , reserved
//Bit 17:16 , reg_mux12_vs_delay_tick_sel ,default = 0 ,
//Bit 15:0  , reg_mux12_vs_delay_num      ,default = 0 ,
#define MIPI_ADAPT_FE_MUX12_DLY_STAT0              ((0x00bd  << 2) + 0xfe3b1000)
//Bit 31    , ro_mux12_vs_delay_exc       ,default = 0 ,
//Bit 30:16 , ro_mux12_vs_mont_max        ,default = 0 ,
//Bit 15    , ro_mux12_vs_delay_cnt0      ,default = 0 ,
//Bit 14:0  , ro_mux12_vs_mon_min         ,default = 0 ,
#define MIPI_ADAPT_FE_MUX_CTL2                     ((0x00be  << 2) + 0xfe3b1000)
//Bit 31:30   ,reg_dst_vs_sel1               ,default = 0       ,reg_dst_vs_sel1
//Bit 29:24 ,reg_core_inf_sel1             ,default = 0       ,reg_core_inf_sel1
//Bit 23:22 ,reg_dst_vs_sel0               ,default = 0       ,reg_dst_vs_sel0
//Bit 21:16 ,reg_core_inf_sel0             ,default = 0       ,reg_core_inf_sel0
//Bit 15: 9 ,reserved
//Bit  8    ,reg_isp_core_inf_inv          ,default = 0       ,reg_isp_core_inf_inv
//Bit  7: 4 ,reg_mipi_csi_vs1_sel          ,default = 0       ,reg_mipi_csi_vs1_sel
//Bit  3: 0 ,reg_mipi_csi_vs0_sel          ,default = 0       ,reg_mipi_csi_vs0_sel
#define MIPI_ADAPT_FE_MUX_CTL3                     ((0x00bf  << 2) + 0xfe3b1000)
//Bit 31:30 ,reg_dst_vs_sel5               ,default = 0       ,reg_dst_vs_sel5
//Bit 29:24 ,reg_core_inf_sel5             ,default = 0       ,reg_core_inf_sel5
//Bit 23:22 ,reg_dst_vs_sel4               ,default = 0       ,reg_dst_vs_sel4
//Bit 21:16 ,reg_core_inf_sel4             ,default = 0       ,reg_core_inf_sel4
//Bit 15:14 ,reg_dst_vs_sel3               ,default = 0       ,reg_dst_vs_sel3
//Bit 13: 8 ,reg_core_inf_sel3             ,default = 0       ,reg_core_inf_sel3
//Bit 7:6   ,reg_dst_vs_sel2               ,default = 0       ,reg_dst_vs_sel2
//Bit  5: 0 ,reg_core_inf_sel2             ,default = 0       ,reg_core_inf_sel2
#define MIPI_ADAPT_FE_MUX_CTL4                     ((0x00c0  << 2) + 0xfe3b1000)
//Bit 31    ,reg_isp_core_end_sel          ,default = 0
//Bit 30    ,reserved
//Bit 29:24 ,reg_isp_core_end_inf_sel      ,default = 0
//Bit 23:22 ,reg_dst_vs_sel8               ,default = 0       ,reg_dst_vs_sel8
//Bit 21:16 ,reg_core_inf_sel8             ,default = 0       ,reg_core_inf_sel8
//Bit 15:14 ,reg_dst_vs_sel7               ,default = 0       ,reg_dst_vs_sel7
//Bit 13: 8 ,reg_core_inf_sel7             ,default = 0       ,reg_core_inf_sel7
//Bit 7:6   ,reg_dst_vs_sel6               ,default = 0       ,reg_dst_vs_sel6
//Bit  5: 0 ,reg_core_inf_sel6             ,default = 0       ,reg_core_inf_sel6
#define MIPI_ADAPT_FE_MUX_CTL5                     ((0x00c1  << 2) + 0xfe3b1000)
//Bit 31: 0 ,isp_tnr_wr_fail_mask31_0      ,default = 0       ,isp_tnr_wr_fail_mask31_0
#define MIPI_ADAPT_FE_MUX_CTL6                     ((0x00c2  << 2) + 0xfe3b1000)
//Bit  31   ,isp_tnr_wr_fail_en            ,default = 0       ,isp_tnr_wr_fail_en
//Bit 30    ,isp_tnr_wr_fail_sel           ,default = 0       ,isp_tnr_wr_fail_sel
//Bit 29: 11 ,reserved
//Bit 10: 0 ,isp_tnr_wr_fail_mask40_32     ,default = 0       ,isp_tnr_wr_fail_mask40_32
#define MIPI_ADAPT_FE_MUX_CTL7                     ((0x00c3  << 2) + 0xfe3b1000)
//Bit 31: 0 ,isp_tnr_rd_fail_mask31_0      ,default = 0       ,isp_tnr_rd_fail_mask31_0
#define MIPI_ADAPT_FE_MUX_CTL8                     ((0x00c4  << 2) + 0xfe3b1000)
//Bit  31   ,isp_tnr_rd_fail_en            ,default = 0       ,isp_tnr_rd_fail_en
//Bit  30   ,isp_tnr_rd_fail_sel           ,default = 0       ,isp_tnr_rd_fail_sel
//Bit 29: 11 ,reserved
//Bit 10: 0 ,isp_tnr_rd_fail_mask40_32     ,default = 0       ,isp_tnr_rd_fail_mask40_32
#define MIPI_ADAPT_FE_MUX_CTL9                     ((0x00c5  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL10                    ((0x00c6  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL11                    ((0x00c7  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL12                    ((0x00c8  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL13                    ((0x00c9  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL14                    ((0x00ca  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL15                    ((0x00cb  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL16                    ((0x00cc  << 2) + 0xfe3b1000)
#define CSI_VSYNC_DLY_STATO                        ((0x00cd  << 2) + 0xfe3b1000)
#define CSI_VSYNC_DLY_STAT1                        ((0x00ce  << 2) + 0xfe3b1000)
#define CSI_VSYNC_DLY_STAT2                        ((0x00cf  << 2) + 0xfe3b1000)
#define CSI_VSYNC_DLY_STAT3                        ((0x00d0  << 2) + 0xfe3b1000)
#define CSI_HSYNC_DLY_STAT                         ((0x00d1  << 2) + 0xfe3b1000)
#define CSI_VFIFO_VS_DLY_STAT0                     ((0x00d2  << 2) + 0xfe3b1000)
#define MIPI_ADAPT_FE_MUX_CTL17                    ((0x00d3  << 2) + 0xfe3b1000)
//========================================================================
// MIPI_ISP  ds0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1400
// -----------------------------------------------
//========================================================================
// MIPI_ISP  ds1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//========================================================================
// MIPI_ISP  ds2
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1c00
// -----------------------------------------------
//========================================================================
// MIPI_ISP  crop_mif
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b2000
// -----------------------------------------------
//========================================================================
// MIPI_ISP  md0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b2400
// -----------------------------------------------
//`include "isp_md_reg.h"
//========================================================================
// MIPI_ISP  md1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b2800
// -----------------------------------------------
//`include "isp_md2_sta_regs.h"
//========================================================================
// MIPI_ISP  fliker
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b2c00
// -----------------------------------------------
//`include "isp_flicker_regs.h"
//========================================================================
// MIPI_ISP  top cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b3000
// -----------------------------------------------
//  `define   MIPI_BL_ISP_FR_PING_ADDR0_ST                   8'h0
//  `define   MIPI_BL_ISP_FR_PING_ADDR0_ED                   8'h1
//  `define   MIPI_BL_ISP_FR_PING_ADDR1_ST                   8'h2
//  `define   MIPI_BL_ISP_FR_PING_ADDR1_ED                   8'h3
//  `define   MIPI_BL_ISP_FR_PONG_ADDR0_ST                   8'h4
//  `define   MIPI_BL_ISP_FR_PONG_ADDR0_ED                   8'h5
//  `define   MIPI_BL_ISP_FR_PONG_ADDR1_ST                   8'h6
//  `define   MIPI_BL_ISP_FR_PONG_ADDR1_ED                   8'h7
//  `define   MIPI_BL_ISP_FR_FRAME_TH                        8'h8
//  `define   MIPI_BL_ISP_FR_FRAME_BUFFER_START_ADDR0        8'h9
//  `define   MIPI_BL_ISP_FR_FRAME_SIZE0                     8'ha
//  `define   MIPI_BL_ISP_FR_FRAME_BUF_SIZE0                 8'hb
//  `define   MIPI_BL_ISP_FR_FRAME_BUFFER_START_ADDR1        8'hc
//  `define   MIPI_BL_ISP_FR_FRAME_SIZE1                     8'hd
//  `define   MIPI_BL_ISP_FR_FRAME_BUF_SIZE1                 8'he
//  `define   MIPI_BL_ISP_FR_CTRL0                           8'hf
//  `define   MIPI_BL_ISP_FR_CTRL1                           8'h10
//  `define   MIPI_BL_ISP_FR_FRAME_COUNT                     8'h11
//  `define   MIPI_BL_ISP_FR_AWADDR_O                        8'h12
//  `define   MIPI_BL_ISP_FR_AWADDR_I                        8'h13
//  `define   MIPI_BL_ISP_FR_STAT0                           8'h14
//  `define   MIPI_BL_ISP_FR_STAT1                           8'h15
//  `define   MIPI_BL_ISP_FR_STAT2                           8'h16
//  `define   MIPI_BL_ISP_FR_STAT3                           8'h17
//  `define   MIPI_BL_ISP_FR_FRAME_BUFFER_START_ADDR0P       8'h18
//
//  `define   MIPI_BL_ISP_DS_PING_ADDR0_ST                   8'h20
//  `define   MIPI_BL_ISP_DS_PING_ADDR0_ED                   8'h21
//  `define   MIPI_BL_ISP_DS_PING_ADDR1_ST                   8'h22
//  `define   MIPI_BL_ISP_DS_PING_ADDR1_ED                   8'h23
//  `define   MIPI_BL_ISP_DS_PONG_ADDR0_ST                   8'h24
//  `define   MIPI_BL_ISP_DS_PONG_ADDR0_ED                   8'h25
//  `define   MIPI_BL_ISP_DS_PONG_ADDR1_ST                   8'h26
//  `define   MIPI_BL_ISP_DS_PONG_ADDR1_ED                   8'h27
//  `define   MIPI_BL_ISP_DS_FRAME_TH                        8'h28
//  `define   MIPI_BL_ISP_DS_FRAME_BUFFER_START_ADDR0        8'h29
//  `define   MIPI_BL_ISP_DS_FRAME_SIZE0                     8'h2a
//  `define   MIPI_BL_ISP_DS_FRAME_BUF_SIZE0                 8'h2b
//  `define   MIPI_BL_ISP_DS_FRAME_BUFFER_START_ADDR1        8'h2c
//  `define   MIPI_BL_ISP_DS_FRAME_SIZE1                     8'h2d
//  `define   MIPI_BL_ISP_DS_FRAME_BUF_SIZE1                 8'h2e
//  `define   MIPI_BL_ISP_DS_CTRL0                           8'h2f
//  `define   MIPI_BL_ISP_DS_CTRL1                           8'h30
//  `define   MIPI_BL_ISP_DS_FRAME_COUNT                     8'h31
//  `define   MIPI_BL_ISP_DS_AWADDR_O                        8'h32
//  `define   MIPI_BL_ISP_DS_AWADDR_I                        8'h33
//  `define   MIPI_BL_ISP_DS_STAT0                           8'h34
//  `define   MIPI_BL_ISP_DS_STAT1                           8'h35
//  `define   MIPI_BL_ISP_DS_STAT2                           8'h36
//  `define   MIPI_BL_ISP_DS_STAT3                           8'h37
//  `define   MIPI_BL_ISP_DS_FRAME_BUFFER_START_ADDR0P       8'h38
//
//  `define   MIPI_BL_DS0_PING_ADDR0_ST                      8'h40
//  `define   MIPI_BL_DS0_PING_ADDR0_ED                      8'h41
//  `define   MIPI_BL_DS0_PING_ADDR1_ST                      8'h42
//  `define   MIPI_BL_DS0_PING_ADDR1_ED                      8'h43
//  `define   MIPI_BL_DS0_PONG_ADDR0_ST                      8'h44
//  `define   MIPI_BL_DS0_PONG_ADDR0_ED                      8'h45
//  `define   MIPI_BL_DS0_PONG_ADDR1_ST                      8'h46
//  `define   MIPI_BL_DS0_PONG_ADDR1_ED                      8'h47
//  `define   MIPI_BL_DS0_FRAME_TH                           8'h48
//  `define   MIPI_BL_DS0_FRAME_BUFFER_START_ADDR0           8'h49
//  `define   MIPI_BL_DS0_FRAME_SIZE0                        8'h4a
//  `define   MIPI_BL_DS0_FRAME_BUF_SIZE0                    8'h4b
//  `define   MIPI_BL_DS0_FRAME_BUFFER_START_ADDR1           8'h4c
//  `define   MIPI_BL_DS0_FRAME_SIZE1                        8'h4d
//  `define   MIPI_BL_DS0_FRAME_BUF_SIZE1                    8'h4e
//  `define   MIPI_BL_DS0_CTRL0                              8'h4f
//  `define   MIPI_BL_DS0_CTRL1                              8'h50
//  `define   MIPI_BL_DS0_FRAME_COUNT                        8'h51
//  `define   MIPI_BL_DS0_AWADDR_O                           8'h52
//  `define   MIPI_BL_DS0_AWADDR_I                           8'h53
//  `define   MIPI_BL_DS0_STAT0                              8'h54
//  `define   MIPI_BL_DS0_STAT1                              8'h55
//  `define   MIPI_BL_DS0_STAT2                              8'h56
//  `define   MIPI_BL_DS0_STAT3                              8'h57
//  `define   MIPI_BL_DS0_FRAME_BUFFER_START_ADDR0P          8'h58
//
//  `define   MIPI_BL_DS1_PING_ADDR0_ST                      8'h60
//  `define   MIPI_BL_DS1_PING_ADDR0_ED                      8'h61
//  `define   MIPI_BL_DS1_PING_ADDR1_ST                      8'h62
//  `define   MIPI_BL_DS1_PING_ADDR1_ED                      8'h63
//  `define   MIPI_BL_DS1_PONG_ADDR0_ST                      8'h64
//  `define   MIPI_BL_DS1_PONG_ADDR0_ED                      8'h65
//  `define   MIPI_BL_DS1_PONG_ADDR1_ST                      8'h66
//  `define   MIPI_BL_DS1_PONG_ADDR1_ED                      8'h67
//  `define   MIPI_BL_DS1_FRAME_TH                           8'h68
//  `define   MIPI_BL_DS1_FRAME_BUFFER_START_ADDR0           8'h69
//  `define   MIPI_BL_DS1_FRAME_SIZE0                        8'h6a
//  `define   MIPI_BL_DS1_FRAME_BUF_SIZE0                    8'h6b
//  `define   MIPI_BL_DS1_FRAME_BUFFER_START_ADDR1           8'h6c
//  `define   MIPI_BL_DS1_FRAME_SIZE1                        8'h6d
//  `define   MIPI_BL_DS1_FRAME_BUF_SIZE1                    8'h6e
//  `define   MIPI_BL_DS1_CTRL0                              8'h6f
//  `define   MIPI_BL_DS1_CTRL1                              8'h70
//  `define   MIPI_BL_DS1_FRAME_COUNT                        8'h71
//  `define   MIPI_BL_DS1_AWADDR_O                           8'h72
//  `define   MIPI_BL_DS1_AWADDR_I                           8'h73
//  `define   MIPI_BL_DS1_STAT0                              8'h74
//  `define   MIPI_BL_DS1_STAT1                              8'h75
//  `define   MIPI_BL_DS1_STAT2                              8'h76
//  `define   MIPI_BL_DS1_STAT3                              8'h77
//  `define   MIPI_BL_DS1_FRAME_BUFFER_START_ADDR0P          8'h78
//
//  `define   MIPI_BL_DS2_PING_ADDR0_ST                      8'h80
//  `define   MIPI_BL_DS2_PING_ADDR0_ED                      8'h81
//  `define   MIPI_BL_DS2_PING_ADDR1_ST                      8'h82
//  `define   MIPI_BL_DS2_PING_ADDR1_ED                      8'h83
//  `define   MIPI_BL_DS2_PONG_ADDR0_ST                      8'h84
//  `define   MIPI_BL_DS2_PONG_ADDR0_ED                      8'h85
//  `define   MIPI_BL_DS2_PONG_ADDR1_ST                      8'h86
//  `define   MIPI_BL_DS2_PONG_ADDR1_ED                      8'h87
//  `define   MIPI_BL_DS2_FRAME_TH                           8'h88
//  `define   MIPI_BL_DS2_FRAME_BUFFER_START_ADDR0           8'h89
//  `define   MIPI_BL_DS2_FRAME_SIZE0                        8'h8a
//  `define   MIPI_BL_DS2_FRAME_BUF_SIZE0                    8'h8b
//  `define   MIPI_BL_DS2_FRAME_BUFFER_START_ADDR1           8'h8c
//  `define   MIPI_BL_DS2_FRAME_SIZE1                        8'h8d
//  `define   MIPI_BL_DS2_FRAME_BUF_SIZE1                    8'h8e
//  `define   MIPI_BL_DS2_CTRL0                              8'h8f
//  `define   MIPI_BL_DS2_CTRL1                              8'h90
//  `define   MIPI_BL_DS2_FRAME_COUNT                        8'h91
//  `define   MIPI_BL_DS2_AWADDR_O                           8'h92
//  `define   MIPI_BL_DS2_AWADDR_I                           8'h93
//  `define   MIPI_BL_DS2_STAT0                              8'h94
//  `define   MIPI_BL_DS2_STAT1                              8'h95
//  `define   MIPI_BL_DS2_STAT2                              8'h96
//  `define   MIPI_BL_DS2_STAT3                              8'h97
//  `define   MIPI_BL_DS2_FRAME_BUFFER_START_ADDR0P          8'h98
//
//  `define   MIPI_BL_CROP_MIF_PING_ADDR0_ST                 8'ha0
//  `define   MIPI_BL_CROP_MIF_PING_ADDR0_ED                 8'ha1
//  `define   MIPI_BL_CROP_MIF_PING_ADDR1_ST                 8'ha2
//  `define   MIPI_BL_CROP_MIF_PING_ADDR1_ED                 8'ha3
//  `define   MIPI_BL_CROP_MIF_PONG_ADDR0_ST                 8'ha4
//  `define   MIPI_BL_CROP_MIF_PONG_ADDR0_ED                 8'ha5
//  `define   MIPI_BL_CROP_MIF_PONG_ADDR1_ST                 8'ha6
//  `define   MIPI_BL_CROP_MIF_PONG_ADDR1_ED                 8'ha7
//  `define   MIPI_BL_CROP_MIF_FRAME_TH                      8'ha8
//  `define   MIPI_BL_CROP_MIF_FRAME_BUFFER_START_ADDR0      8'ha9
//  `define   MIPI_BL_CROP_MIF_FRAME_SIZE0                   8'haa
//  `define   MIPI_BL_CROP_MIF_FRAME_BUF_SIZE0               8'hab
//  `define   MIPI_BL_CROP_MIF_FRAME_BUFFER_START_ADDR1      8'hac
//  `define   MIPI_BL_CROP_MIF_FRAME_SIZE1                   8'had
//  `define   MIPI_BL_CROP_MIF_FRAME_BUF_SIZE1               8'hae
//  `define   MIPI_BL_CROP_MIF_CTRL0                         8'haf
//  `define   MIPI_BL_CROP_MIF_CTRL1                         8'hb0
//  `define   MIPI_BL_CROP_MIF_FRAME_COUNT                   8'hb1
//  `define   MIPI_BL_CROP_MIF_AWADDR_O                      8'hb2
//  `define   MIPI_BL_CROP_MIF_AWADDR_I                      8'hb3
//  `define   MIPI_BL_CROP_MIF_STAT0                         8'hb4
//  `define   MIPI_BL_CROP_MIF_STAT1                         8'hb5
//  `define   MIPI_BL_CROP_MIF_STAT2                         8'hb6
//  `define   MIPI_BL_CROP_MIF_STAT3                         8'hb7
//  `define   MIPI_BL_CROP_MIF_FRAME_BUFFER_START_ADDR0P     8'hb8
#define MIPI_TOP_CSI2_AXI_ST                       ((0x00b8  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL7                        ((0x00b9  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL6                        ((0x00ba  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL5                        ((0x00bb  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL4                        ((0x00bc  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL3                        ((0x00bd  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL2                        ((0x00be  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL1                        ((0x00bf  << 2) + 0xfe3b3000)
#define MIPI_TOP_CSI2_CTRL0                        ((0x00c0  << 2) + 0xfe3b3000)
#define MIPI_TOP_ADAPT_DE_CTRL0                    ((0x00c1  << 2) + 0xfe3b3000)
#define MIPI_TOP_ADAPT_DE_CTRL1                    ((0x00c2  << 2) + 0xfe3b3000)
#define MIPI_TOP_ADAPT_DE_CTRL2                    ((0x00c3  << 2) + 0xfe3b3000)
#define MIPI_TOP_ADAPT_DE_CTRL3                    ((0x00c4  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_DE_CTRL0                      ((0x00c5  << 2) + 0xfe3b3000)
#define MIPI_TOP_ARIBIT0_CTRL                      ((0x00c6  << 2) + 0xfe3b3000)
#define MIPI_TOP_ARIBIT1_CTRL                      ((0x00c7  << 2) + 0xfe3b3000)
#define MIPI_TOP_ARIBIT2_CTRL                      ((0x00c8  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_CMD_MASK_DDR_RD0_CNTL         ((0x00c9  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_CMD_MASK_DDR_RD1_CNTL         ((0x00ca  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_DS_WBUS_NOBLOCK_CNTL          ((0x00cb  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_FR_WBUS_NOBLOCK_CNTL          ((0x00cc  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_DS_WBUF_NOBLOCK_ST0           ((0x00cd  << 2) + 0xfe3b3000)
#define MIPI_TOP_AXI_FR_WBUF_NOBLOCK_ST0           ((0x00ce  << 2) + 0xfe3b3000)
#define MIPI_TOP_ADAPT_DE_STAT0                    ((0x00cf  << 2) + 0xfe3b3000)
#define MIPI_TOP_FR_WR_UGT_CNTL0                   ((0x00d0  << 2) + 0xfe3b3000)
#define MIPI_TOP_FR_WR_UGT_CNTL1                   ((0x00d1  << 2) + 0xfe3b3000)
#define MIPI_TOP_FR_WR_UGT_CNTL2                   ((0x00d2  << 2) + 0xfe3b3000)
#define MIPI_TOP_FR_WR_UGT_CNTL3                   ((0x00d3  << 2) + 0xfe3b3000)
#define MIPI_TOP_FR_WR_UGT_ST                      ((0x00d4  << 2) + 0xfe3b3000)
#define MIPI_TOP_DS_WR_UGT_CNTL0                   ((0x00d5  << 2) + 0xfe3b3000)
#define MIPI_TOP_DS_WR_UGT_CNTL1                   ((0x00d6  << 2) + 0xfe3b3000)
#define MIPI_TOP_DS_WR_UGT_CNTL2                   ((0x00d7  << 2) + 0xfe3b3000)
#define MIPI_TOP_DS_WR_UGT_CNTL3                   ((0x00d8  << 2) + 0xfe3b3000)
#define MIPI_TOP_DS_WR_UGT_ST                      ((0x00d9  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_WR_UGT_CNTL0                  ((0x00da  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_WR_UGT_CNTL1                  ((0x00db  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_WR_UGT_CNTL2                  ((0x00dc  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_WR_UGT_CNTL3                  ((0x00dd  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_WR_UGT_ST                     ((0x00de  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_RD_UGT_CNTL0                  ((0x00df  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_RD_UGT_CNTL1                  ((0x00e0  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_RD_UGT_CNTL2                  ((0x00e1  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_RD_UGT_CNTL3                  ((0x00e2  << 2) + 0xfe3b3000)
#define MIPI_TOP_TNR_RD_UGT_ST                     ((0x00e3  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_FR_AXI_CNTL0                  ((0x00e4  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_SIDEBAND_CNTL0                ((0x00e5  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_SIDEBAND_CNTL1                ((0x00e6  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING_MASK0                 ((0x00f0  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING_MASK1                 ((0x00f1  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING_MASK2                 ((0x00f2  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING0                      ((0x00f3  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING1                      ((0x00f4  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_PENDING2                      ((0x00f5  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_FR_WBUS_PROT_CNTL             ((0x00f6  << 2) + 0xfe3b3000)
#define MIPI_TOP_ISP_FR_WBUS_PROT_STAT             ((0x00f7  << 2) + 0xfe3b3000)
//========================================================================
// MIPI_ISP  isp ahb dma
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b3400
// -----------------------------------------------
#define ISP_DMA_BUS_CNTL                           ((0x0000  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL0                               ((0x0001  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR0                          ((0x0002  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR0                          ((0x0003  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK0                          ((0x0004  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR1                          ((0x0005  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR1                          ((0x0006  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK1                          ((0x0007  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR2                          ((0x0008  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR2                          ((0x0009  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK2                          ((0x000a  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR3                          ((0x000b  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR3                          ((0x000c  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK3                          ((0x000d  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR4                          ((0x000e  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR4                          ((0x000f  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK4                          ((0x0010  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR5                          ((0x0011  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR5                          ((0x0012  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK5                          ((0x0013  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR6                          ((0x0014  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR6                          ((0x0015  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK6                          ((0x0016  << 2) + 0xfe3b3400)
#define ISP_DMA_SRC_ADDR7                          ((0x0017  << 2) + 0xfe3b3400)
#define ISP_DMA_DST_ADDR7                          ((0x0018  << 2) + 0xfe3b3400)
#define ISP_DMA_CTL_TASK7                          ((0x0019  << 2) + 0xfe3b3400)
#define ISP_DMA_ST0                                ((0x001a  << 2) + 0xfe3b3400)
#define ISP_DMA_ST1                                ((0x001b  << 2) + 0xfe3b3400)
#define ISP_DMA_ST2                                ((0x001c  << 2) + 0xfe3b3400)
#define ISP_DMA_ST3                                ((0x001d  << 2) + 0xfe3b3400)
#define ISP_DMA_ST4                                ((0x001e  << 2) + 0xfe3b3400)
#define ISP_DMA_ST5                                ((0x001f  << 2) + 0xfe3b3400)
#define ISP_DMA_ST6                                ((0x0020  << 2) + 0xfe3b3400)
#define ISP_DMA_PENDING                            ((0x0023  << 2) + 0xfe3b3400)
#define ISP_DMA_IRQ_MASK                           ((0x0024  << 2) + 0xfe3b3400)
//========================================================================
// MIPI_ISP  axi arbit0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b3800
// -----------------------------------------------
//
// Reading file:  ./mipi_isp_arb_axi_regs.h
//
//========================================================================
// MIPI_ISP  axi arbit0
//========================================================================
#define MIPI_ISP_RDARB_MODE                        ((0x0000  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDARB_REQEN_SLV                   ((0x0001  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDARB_WEIGH0_SLV                  ((0x0002  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDARB_WEIGH1_SLV                  ((0x0003  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDARB_UGT                         ((0x0004  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDARB_LIMT0                       ((0x0005  << 2) + 0xfe3b3800)
#define MIPI_ISP_WRARB_MODE                        ((0x0006  << 2) + 0xfe3b3800)
#define MIPI_ISP_WRARB_REQEN_SLV                   ((0x0007  << 2) + 0xfe3b3800)
#define MIPI_ISP_WRARB_WEIGH0_SLV                  ((0x0008  << 2) + 0xfe3b3800)
#define MIPI_ISP_WRARB_WEIGH1_SLV                  ((0x0009  << 2) + 0xfe3b3800)
#define MIPI_ISP_WRARB_UGT                         ((0x000a  << 2) + 0xfe3b3800)
#define MIPI_ISP_RDWR_ARB_STATUS                   ((0x000b  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_DBG_CTRL                      ((0x000c  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_DBG_STAT                      ((0x000d  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_CNTL0               ((0x0080  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_CNTL0               ((0x0088  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT0               ((0x0090  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT1               ((0x0091  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT2               ((0x0092  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT3               ((0x0093  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT4               ((0x0094  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT5               ((0x0095  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT6               ((0x0096  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT7               ((0x0097  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT0               ((0x0098  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT1               ((0x0099  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT2               ((0x009a  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT3               ((0x009b  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT4               ((0x009c  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT5               ((0x009d  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT6               ((0x009e  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT7               ((0x009f  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_AXI_BUS_CNTL0                 ((0x00b0  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_AXI_BUS_CNTL1                 ((0x00b1  << 2) + 0xfe3b3800)
#define MIPI_ISP_ARB_AXI_BUS_STAT0                 ((0x00b2  << 2) + 0xfe3b3800)
//
// Closing file:  ./mipi_isp_arb_axi_regs.h
//
//========================================================================
// MIPI_ISP  axi arbit1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b3c00
// -----------------------------------------------
//========================================================================
// MIPI_ISP  data compress/decompress0_0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1400
// -----------------------------------------------
//
// Reading file:  ./mipi_adapt_cmpr_regs.h
//
// synopsys translate_off
// synopsys translate_on
//-------------------------------------------------
#define MIPI_ADAPT_CMPR_SPLIT_CTRL                 ((0x0000  << 2) + 0xfe3b1400)
//Bit 31:16 reg_split_sync_ctrl       // unsigned , RW, default = 0, register sync (shadow) ctrl
//Bit 15:8  reserved
//Bit 7 :4  reserved
//Bit    3  reg_split_ignore_frag_cmd // unsigned , RW, default = 1, ingore no used axi cmd before cmd with address = "reg_wsub0_iaddr_bgn"
//Bit    2  reserved
//Bit    1  reg_split_big_endian      // unsigned , RW, default = 0,  Big_endian
//Bit    0  reg_split_enable          // unsigned , RW, default = 1,  1 to enable
#define MIPI_ADAPT_CMPR_SPLIT_SIZE                 ((0x0001  << 2) + 0xfe3b1400)
//Bit 31:16 reg_split_gclk_ctrl       // unsigned , RW, default = 0
//Bit 15:0  reg_split_hsize           // unsigned , RW, default = 4608 hsize
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_CTRL          ((0x0002  << 2) + 0xfe3b1400)
//Bit 31:21 reserved
//Bit 20    reg_split_abort_after_cmd_1st    // unsigned , RW, default = 1
//Bit 19    reg_split_internal_abort_en      // unsigned , RW, default = 1
//Bit 18    reg_split_abort_hold_input       // unsigned , RW, default = 1
//Bit 17    reg_split_frmrst_hold_input      // unsigned , RW, default = 1, 1 to hold axi input during frmrst generate, only valid for reg_frmrst_mode =0/2
//Bit 16    reg_split_rdma_trigger_mode      // unsigned , RW, default = 0, 0 to use frmrst, 1 to use frame_end
//Bit 15    reg_split_rdma_enable            // unsigned , RW, default = 0, 1 to enable RDMA
//Bit 14    reserved
//Bit 13    reg_split_frmrst_hold4abort_mode // unsigned , RW, default = 0, 1 to start frmrst delay counter caused by abort after enc path idle.
//Bit 12    reg_split_frmrst_hold4gen_mode   // unsigned , RW, default = 0, 1 to start frmrst delay counter after enc path idle.
//Bit 11    reg_split_dis_abort              // unsigned , RW, default = 0, disable abnormal abort processing.
//Bit 10    reg_split_dis_frmrst_by_abort    // unsigned , RW, default = 0, disable frmrst generate caused by abnormal abort
//Bit 9     reg_split_wait_idle_for_abort    // unsigned , RW, default = 1, wait enc path idle before frmrst generate cause by abnormal abort.
//Bit 8     reg_split_wait_idle_for_frmrst   // unsigned , RW, default = 1, wait enc path idle before frmrst generate.
//Bit 7 : 6 reserved
//Bit 5 : 4 reg_split_frmrst_mode   // unsigned , RW, default = 0, frmrst mode, 0:use input frmrst; 1:use reg_soft_frmrst; 2: use axi iaddr_end to generate; 3: use iaddr_bgn to generate
//Bit 3 : 1 reserved
//Bit 0     reg_split_soft_frmrst   // unsigned , RW, default = 0, write 1 to generate a soft frmrst
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_DLY0          ((0x0003  << 2) + 0xfe3b1400)
//Bit 31:0  reg_split_frmrst_dlys4gen     // unsigned , RW, default = 0, clock delays for frmrst generate except caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_DLY1          ((0x0004  << 2) + 0xfe3b1400)
//Bit 31:0  reg_split_frmrst_dlys4abort   // unsigned , RW, default = 16, clock delays for frmrst generate caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_SPLIT_FRMHOLD              ((0x0005  << 2) + 0xfe3b1400)
//Bit 31:0  reg_split_frm_holds           // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define MIPI_ADAPT_CMPR_RO_SPLIT_STATS             ((0x0007  << 2) + 0xfe3b1400)
//Bit 31:0  ro_split_status               // unsigned , RW, default = 0
#define MIPI_ADAPT_CMPR_WSUB0_CTRL                 ((0x0008  << 2) + 0xfe3b1400)
//Bit 31:21 reserved
//Bit 20    reg_wsub0_raw67_ext           // unsigned , RW, default = 0,
//Bit 19    reserved
//Bit 18:16 reg_wsub0_raw_mode            // unsigned , RW, default = 1,  //raw6/7/8/10/12/14
//Bit 15:10 reserved
//Bit 9 : 0 reg_wsub0_dfifo_size          // unsigned , RW, default = 32
#define MIPI_ADAPT_CMPR_WSUB0_IADDRS               ((0x0009  << 2) + 0xfe3b1400)
//Bit 31:0  reg_wsub0_iaddr_bgn           // unsigned , RW, default =0, start address for WSUB0
#define MIPI_ADAPT_CMPR_WSUB0_IADDRE               ((0x000a  << 2) + 0xfe3b1400)
//Bit 31:0  reg_wsub0_iaddr_end           // unsigned , RW, default =0, end address for WSUB0
//-------------------------------------------------
#define MIPI_ADAPT_CMPR_PACK_CTRL                  ((0x0010  << 2) + 0xfe3b1400)
//Bit 31:16 reg_pack_sync_ctrl            // unsigned , RW, default = 0, register sync (shadow) ctrl
//Bit 15:7  reserved
//Bit    6  reg_pack_skip_flag_init       // unsigned , RW, default = 0, skip flag for pack, 1 to skip pack axi cmd for current frame
//Bit    5  reg_pack_skip_auto_ctrl       // unsigned , RW, default = 0, auto control for skip flag, if 1, the 1st frame use the reg_pack_skip_init as skip flag, and the next frames use 0 for skip flag
//Bit    4  reserved
//Bit    3  reg_pack_ignore_frag_cmd      // unsigned , RW, default = 1, ingore no used axi cmd before cmd with address = "reg_rsub0_iaddr_bgn"
//Bit    2  reserved
//Bit    1  reg_pack_big_endian           // unsigned , RW, default = 0,  Big_endian
//Bit    0  reg_pack_enable               // unsigned , RW, default = 1,  1 to enable
#define MIPI_ADAPT_CMPR_PACK_SIZE                  ((0x0011  << 2) + 0xfe3b1400)
//Bit 31:16 reg_pack_gclk_ctrl            // unsigned , RW, default = 0
//Bit 15:0  reg_pack_hsize                // unsigned , RW, default = 4608 hsize
#define MIPI_ADAPT_CMPR_PACK_FRMRST_CTRL           ((0x0012  << 2) + 0xfe3b1400)
//Bit 31:25 reserved
//Bit 24    reg_pack_busy_care_rdmif        // unsigned , RW, default = 0, 1 to take rdmif busy as pack busy
//Bit 23:21 reserved
//Bit 20    reg_pack_abort_after_cmd_1st    // unsigned , RW, default = 1
//Bit 19    reg_pack_internal_abort_en      // unsigned , RW, default = 1
//Bit 18    reg_pack_abort_hold_input       // unsigned , RW, default = 1
//Bit 17    reg_pack_frmrst_hold_input      // unsigned , RW, default = 1, 1 to hold axi input during frmrst generate, only valid for reg_frmrst_mode =0/2
//Bit 16    reg_pack_rdma_trigger_mode      // unsigned , RW, default = 0, 0 to use frmrst, 1 to use frame_end
//Bit 15    reg_pack_rdma_enable            // unsigned , RW, default = 0, 1 to enable RDMA
//Bit 14    reserved
//Bit 13    reg_pack_frmrst_hold4abort_mode // unsigned , RW, default = 0, 1 to start frmrst delay counter caused by abort after enc path idle.
//Bit 12    reg_pack_frmrst_hold4gen_mode   // unsigned , RW, default = 0, 1 to start frmrst delay counter after enc path idle.
//Bit 11    reg_pack_dis_abort              // unsigned , RW, default = 0, disable abnormal abort processing.
//Bit 10    reg_pack_dis_frmrst_by_abort    // unsigned , RW, default = 0, disable frmrst generate caused by abnormal abort
//Bit 9     reg_pack_wait_idle_for_abort    // unsigned , RW, default = 1, wait enc path idle before frmrst generate cause by abnormal abort.
//Bit 8     reg_pack_wait_idle_for_frmrst  // unsigned , RW, default = 1, wait enc path ready before frmrst generate.
//Bit 7 : 6 reserved
//Bit 5 : 4 reg_pack_frmrst_mode   // unsigned , RW, default = 0, frmrst mode, 0:use input frmrst; 1:use reg_soft_frmrst; 2: use axi iaddr_end to generate; 3: use iaddr_bgn to generate
//Bit 3 : 1 reserved
//Bit 0     reg_pack_soft_frmrst   // unsigned , RW, default = 0, write 1 to generate a soft frmrst
#define MIPI_ADAPT_CMPR_PACK_FRMRST_DLY0           ((0x0013  << 2) + 0xfe3b1400)
//Bit 31:0  reg_pack_frmrst_dlys4gen      // unsigned , RW, default = 0, clock delays for frmrst generate except caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_PACK_FRMRST_DLY1           ((0x0014  << 2) + 0xfe3b1400)
//Bit 31:0  reg_pack_frmrst_dlys4abort   // unsigned , RW, default = 16, clock delays for frmrst generate caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_PACK_FRMHOLD               ((0x0015  << 2) + 0xfe3b1400)
//Bit 31:0  reg_pack_frm_holds            // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define MIPI_ADAPT_CMPR_RO_PACK_STATS              ((0x0017  << 2) + 0xfe3b1400)
//Bit 31:0  ro_pack_status                 // unsigned , RW, default = 0
#define MIPI_ADAPT_CMPR_RSUB0_CTRL                 ((0x0018  << 2) + 0xfe3b1400)
//Bit 31:21 reserved
//Bit 20    reg_rsub0_raw67_ext           // unsigned , RW, default = 0,
//Bit 19    reserved
//Bit 18:16 reg_rsub0_raw_mode            // unsigned , RW, default = 1,  //raw6/7/8/10/12/14
//Bit 15:10 reserved
//Bit 9 : 0 reg_rsub0_dfifo_size          // unsigned , RW, default = 32
#define MIPI_ADAPT_CMPR_RSUB0_IADDRS               ((0x0019  << 2) + 0xfe3b1400)
//Bit 31:0  reg_rsub0_iaddr_bgn           // unsigned , RW, default =0, start address for RSUB0
#define MIPI_ADAPT_CMPR_RSUB0_IADDRE               ((0x001a  << 2) + 0xfe3b1400)
//Bit 31:0  reg_rsub0_iaddr_end           // unsigned , RW, default =0, end address for RSUB0
//--------------------------------------------------
#define MIPI_ADAPT_CMPR_INT_EN                     ((0x0020  << 2) + 0xfe3b1400)
//Bit 31:0  reg_adapt_int_en             // unsigned , RW default = 0, interrupt mask
#define MIPI_ADAPT_CMPR_RO_INT_STATUS              ((0x0021  << 2) + 0xfe3b1400)
//Bit 31:0  ro_adapt_int_status          // unsigned , RO, default 0, interrupt status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_adapt_cmpr_regs.h
//
//========================================================================
// MIPI_ISP  data compress/decompress0_1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//`include "mipi_adapt_cmpr_loss_sub0.h"
//========================================================================
// MIPI_ISP  data compress enc
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_raw_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define MIPI_LOSSE_RAW_CTRL                        ((0x0000  << 2) + 0xfe3b1800)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define MIPI_LOSSE_RAW_FRAME_HOLD                  ((0x0001  << 2) + 0xfe3b1800)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define MIPI_LOSSE_RAW_GCLK_CTRL                   ((0x0002  << 2) + 0xfe3b1800)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define MIPI_LOSSE_RAW_RO_CODEC_STATUS             ((0x0003  << 2) + 0xfe3b1800)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define MIPI_LOSSE_RAW_MISC                        ((0x0004  << 2) + 0xfe3b1800)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define MIPI_LOSSE_RAW_BASIS                       ((0x0008  << 2) + 0xfe3b1800)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define MIPI_LOSSE_RAW_OFST_BIT_DEPTH              ((0x0009  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define MIPI_LOSSE_RAW_PIC_SIZE                    ((0x000a  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define MIPI_LOSSE_RAW_SLICE_SIZE                  ((0x000b  << 2) + 0xfe3b1800)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_1                ((0x000c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_2                ((0x000d  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_3                ((0x000e  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_PRESL_LAST_BITS             ((0x000f  << 2) + 0xfe3b1800)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define MIPI_LOSSE_RAW_PRESL_FIFO_LEVEL            ((0x0010  << 2) + 0xfe3b1800)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define MIPI_LOSSE_RAW_DEBUG                       ((0x0011  << 2) + 0xfe3b1800)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_REF_DATA                    ((0x0012  << 2) + 0xfe3b1800)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_REF_DATA_1                  ((0x0013  << 2) + 0xfe3b1800)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_REF_DATA_2                  ((0x0014  << 2) + 0xfe3b1800)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_PRED_PROCE                  ((0x0015  << 2) + 0xfe3b1800)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define MIPI_LOSSE_RAW_GLOBAL_PHASE_LUT            ((0x0016  << 2) + 0xfe3b1800)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSE_RAW_GLOBAL_PHASE_LUT_1          ((0x0017  << 2) + 0xfe3b1800)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSE_RAW_PHASE_LUT                   ((0x0018  << 2) + 0xfe3b1800)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define MIPI_LOSSE_RAW_FLATNESS_0                  ((0x0019  << 2) + 0xfe3b1800)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define MIPI_LOSSE_RAW_FLATNESS_QP                 ((0x001a  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define MIPI_LOSSE_RAW_FLATNESS_TH0                ((0x001b  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_FLATNESS_TH1                ((0x001c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_FLATNESS_TH2                ((0x001d  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_QP_MAP_CHN0                 ((0x001e  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_1               ((0x001f  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_2               ((0x0020  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_3               ((0x0021  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_4               ((0x0022  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_5               ((0x0023  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_6               ((0x0024  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_7               ((0x0025  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_8               ((0x0026  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_9               ((0x0027  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1                 ((0x0028  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_1               ((0x0029  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_2               ((0x002a  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_3               ((0x002b  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_4               ((0x002c  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_5               ((0x002d  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_6               ((0x002e  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_7               ((0x002f  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_8               ((0x0030  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_9               ((0x0031  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2                 ((0x0032  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_1               ((0x0033  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_2               ((0x0034  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_3               ((0x0035  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_4               ((0x0036  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_5               ((0x0037  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_6               ((0x0038  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_7               ((0x0039  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_8               ((0x003a  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_9               ((0x003b  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_RC_GROUP_2                  ((0x003c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define MIPI_LOSSE_RAW_RC_BUDGET_0                 ((0x003d  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_3 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_2 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_1 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_0 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSE_RAW_RC_BUDGET_1                 ((0x003e  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_7 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_6 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_5 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_4 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSE_RAW_RC_BUDGET_2                 ((0x003f  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_11 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_10 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_9 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_8 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSE_RAW_RC_BUDGET_3                 ((0x0040  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_15 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_14 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_13 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_12 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSE_RAW_RC_BUDGET_4                 ((0x0041  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_16 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define MIPI_LOSSE_RAW_RC_BUDGET_5                 ((0x0042  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define MIPI_LOSSE_RAW_RC_BUDGET_6                 ((0x0043  << 2) + 0xfe3b1800)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define MIPI_LOSSE_RAW_RC_QP_MARGIN                ((0x0044  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_1              ((0x0045  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_2              ((0x0046  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_3              ((0x0047  << 2) + 0xfe3b1800)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_4              ((0x0048  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_5              ((0x0049  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSE_RAW_FLATNESS_ADJ0               ((0x004a  << 2) + 0xfe3b1800)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define MIPI_LOSSE_RAW_FLATNESS_ADJ1               ((0x004b  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define MIPI_LOSSE_RAW_FIFO_THD_0                  ((0x004c  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_THD_1                  ((0x004d  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_THD_2                  ((0x004e  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_AVG                    ((0x004f  << 2) + 0xfe3b1800)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define MIPI_LOSSE_RAW_FIFO_DLT                    ((0x0050  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_BITSGAP_THD_0               ((0x0051  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define MIPI_LOSSE_RAW_BITSGAP_THD_1               ((0x0052  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define MIPI_LOSSE_RAW_REF_ADJ                     ((0x0053  << 2) + 0xfe3b1800)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_0               ((0x0054  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_1               ((0x0055  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_2               ((0x0056  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_3               ((0x0057  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_4               ((0x0058  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_REF_ADJ_DLT_5           ((0x0059  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN0             ((0x005a  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN0_1           ((0x005b  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN1             ((0x005c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN1_1           ((0x005d  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN2             ((0x005e  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN2_1           ((0x005f  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define MIPI_LOSSE_RAW_ACCUM_OFSET_0               ((0x0060  << 2) + 0xfe3b1800)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_1               ((0x0061  << 2) + 0xfe3b1800)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_2               ((0x0062  << 2) + 0xfe3b1800)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_3               ((0x0063  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_WDR_LINE_DELAY              ((0x0064  << 2) + 0xfe3b1800)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define MIPI_LOSSE_RAW_CORING_TH_OFST              ((0x0065  << 2) + 0xfe3b1800)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define MIPI_LOSSE_RAW_CORING_RST                  ((0x0066  << 2) + 0xfe3b1800)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define MIPI_LOSSE_RAW_STATS_RAM_MODE              ((0x0067  << 2) + 0xfe3b1800)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define MIPI_LOSSE_RAW_STATS_RAM_ADDR              ((0x0068  << 2) + 0xfe3b1800)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define MIPI_LOSSE_RAW_RO_STATS_RAM_DATA           ((0x0069  << 2) + 0xfe3b1800)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_raw_enc_regs.h
//
//========================================================================
// MIPI_ISP  data compress mif enc
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_mif_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define AWSUB0_ISP_LOSS_MIF_CTRL                   ((0x0070  << 2) + 0xfe3b1800)
//Bit 31:24    reg_sync_sel                  // unsigned , RW, default = 0, sync with frm rst
//Bit 23:16    reg_canvas_id                 // unsigned , RW, default = 0, axi canvas id num
//Bit 15       reserved
//Bit 14:12    reg_cmd_intr_len              // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10    reserved
//Bit  9: 8    reg_cmd_req_size              // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=48 3=64
//Bit  7       reserved
//Bit  6: 4    reg_burst_len                 // unsigned , RW, default = 3, burst type: 0->1; 1->2; 2->4; 3->8; 4->16, others reserved
//Bit  3       reserved
//Bit  2       reg_check_resp_id             // unsigned , RW, default = 0
//Bit  1       reg_dol_mode                  // unsigned , RW, default = 0  1: DOL mode
//Bit  0       reg_mif_enable                // unsigned , RW, default = 1  1 to mif
#define AWSUB0_ISP_LOSS_MIF_QOS                    ((0x0071  << 2) + 0xfe3b1800)
//Bit 31:0     reg_qos_ctrl                  // unsigned , RW, default = 0, Qos control reg
                                             //18    reg_qos_auto_en
                                             //17    reg_qos_sup
                                             //16    reg_qos_ini
                                             //15:8  reg_qos_up_th
                                             // 7:0  reg_qos_dn_th
#define AWSUB0_ISP_LOSS_MIF_URGENT                 ((0x0072  << 2) + 0xfe3b1800)
//Bit 31:0     reg_urgent_ctrl               // unsigned , RW, default = 0, urgent control reg
                                             //18    reg_urgent_auto_en
                                             //17    reg_urgent_sup
                                             //16    reg_urgent_ini
                                             //15:8  reg_urgent_up_th
                                             // 7:0  reg_urgent_dn_th
#define AWSUB0_ISP_LOSS_MIF_MISC                   ((0x0073  << 2) + 0xfe3b1800)
//Bit 31:4  reserved
//Bit 3     reg_mif_busy_noresp_check       // unsigned , RW, default =1, for mif write, dont take "respond busy" as mif unit busy.
//Bit 2     reg_mif_wait_input4busy         // unsigned , RW, default =0, use in encoder, mif is busy till input data comming. only for mif wr
//Bit 1     reg_mif_dbl_baddr_init          // unsigned , RW, default =0, write 1 to use reg_mif_baddr as base-addr for next frame,it would be clear automatically.
//Bit 0     reg_mif_dbl_baddr_en            // unsigned , RW, default =0, 1 to use ping-pong base-addr based on frame.
#define AWSUB0_ISP_LOSS_MIF_BADDR                  ((0x0074  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_baddr                    // unsigned , RW, default = 0,  mif base address
#define AWSUB0_ISP_LOSS_MIF_BADDR1                 ((0x0075  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_baddr1                  // unsigned , RW, default = 0,  mif base address
#define AWSUB0_ISP_LOSS_MIF_FIFO_CTRL              ((0x0077  << 2) + 0xfe3b1800)
//Bit 31:16 reg_mif_gclk_ctrl                // unsigned , RW, default = 0, gate clock control
//Bit 15:8  reserved                         //
//Bit 7 :0  reg_mif_fifo_size                // unsigned , RW, data FIFO max size, default = 128,
#define AWSUB0_ISP_LOSS_MIF_FRM_HOLD               ((0x0078  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_frm_holds                // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define AWSUB0_ISP_LOSS_MIF_RO_STATS               ((0x0079  << 2) + 0xfe3b1800)
//Bit 31: 0  ro_mif_status                  // unsigned ,  RO, default = 0  mif status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_mif_enc_regs.h
//
//========================================================================
// MIPI_ISP  data compress dec
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_raw_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define MIPI_LOSSD_RAW_CTRL                        ((0x0080  << 2) + 0xfe3b1800)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define MIPI_LOSSD_RAW_FRAME_HOLD                  ((0x0081  << 2) + 0xfe3b1800)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define MIPI_LOSSD_RAW_GCLK_CTRL                   ((0x0082  << 2) + 0xfe3b1800)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define MIPI_LOSSD_RAW_RO_CODEC_STATUS             ((0x0083  << 2) + 0xfe3b1800)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define MIPI_LOSSD_RAW_MISC                        ((0x0084  << 2) + 0xfe3b1800)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define MIPI_LOSSD_RAW_BASIS                       ((0x0088  << 2) + 0xfe3b1800)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define MIPI_LOSSD_RAW_OFST_BIT_DEPTH              ((0x0089  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define MIPI_LOSSD_RAW_PIC_SIZE                    ((0x008a  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define MIPI_LOSSD_RAW_SLICE_SIZE                  ((0x008b  << 2) + 0xfe3b1800)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_1                ((0x008c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_2                ((0x008d  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_3                ((0x008e  << 2) + 0xfe3b1800)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_PRESL_LAST_BITS             ((0x008f  << 2) + 0xfe3b1800)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define MIPI_LOSSD_RAW_PRESL_FIFO_LEVEL            ((0x0090  << 2) + 0xfe3b1800)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define MIPI_LOSSD_RAW_DEBUG                       ((0x0091  << 2) + 0xfe3b1800)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_REF_DATA                    ((0x0092  << 2) + 0xfe3b1800)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_REF_DATA_1                  ((0x0093  << 2) + 0xfe3b1800)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_REF_DATA_2                  ((0x0094  << 2) + 0xfe3b1800)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_PRED_PROCE                  ((0x0095  << 2) + 0xfe3b1800)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define MIPI_LOSSD_RAW_GLOBAL_PHASE_LUT            ((0x0096  << 2) + 0xfe3b1800)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSD_RAW_GLOBAL_PHASE_LUT_1          ((0x0097  << 2) + 0xfe3b1800)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSD_RAW_PHASE_LUT                   ((0x0098  << 2) + 0xfe3b1800)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define MIPI_LOSSD_RAW_FLATNESS_0                  ((0x0099  << 2) + 0xfe3b1800)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define MIPI_LOSSD_RAW_FLATNESS_QP                 ((0x009a  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define MIPI_LOSSD_RAW_FLATNESS_TH0                ((0x009b  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_FLATNESS_TH1                ((0x009c  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_FLATNESS_TH2                ((0x009d  << 2) + 0xfe3b1800)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_QP_MAP_CHN0                 ((0x009e  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_1               ((0x009f  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_2               ((0x00a0  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_3               ((0x00a1  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_4               ((0x00a2  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_5               ((0x00a3  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_6               ((0x00a4  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_7               ((0x00a5  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_8               ((0x00a6  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_9               ((0x00a7  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1                 ((0x00a8  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_1               ((0x00a9  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_2               ((0x00aa  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_3               ((0x00ab  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_4               ((0x00ac  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_5               ((0x00ad  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_6               ((0x00ae  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_7               ((0x00af  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_8               ((0x00b0  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_9               ((0x00b1  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2                 ((0x00b2  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_1               ((0x00b3  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_2               ((0x00b4  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_3               ((0x00b5  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_4               ((0x00b6  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_5               ((0x00b7  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_6               ((0x00b8  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_7               ((0x00b9  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_8               ((0x00ba  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_9               ((0x00bb  << 2) + 0xfe3b1800)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_RC_GROUP_2                  ((0x00bc  << 2) + 0xfe3b1800)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define MIPI_LOSSD_RAW_RC_BUDGET_0                 ((0x00bd  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_3 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_2 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_1 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_0 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSD_RAW_RC_BUDGET_1                 ((0x00be  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_7 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_6 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_5 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_4 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSD_RAW_RC_BUDGET_2                 ((0x00bf  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_11 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_10 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_9 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_8 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSD_RAW_RC_BUDGET_3                 ((0x00c0  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_15 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_14 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_13 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_12 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
#define MIPI_LOSSD_RAW_RC_BUDGET_4                 ((0x00c1  << 2) + 0xfe3b1800)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_16 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 pieces.
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define MIPI_LOSSD_RAW_RC_BUDGET_5                 ((0x00c2  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define MIPI_LOSSD_RAW_RC_BUDGET_6                 ((0x00c3  << 2) + 0xfe3b1800)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define MIPI_LOSSD_RAW_RC_QP_MARGIN                ((0x00c4  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_1              ((0x00c5  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_2              ((0x00c6  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_3              ((0x00c7  << 2) + 0xfe3b1800)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_4              ((0x00c8  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_5              ((0x00c9  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSD_RAW_FLATNESS_ADJ0               ((0x00ca  << 2) + 0xfe3b1800)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define MIPI_LOSSD_RAW_FLATNESS_ADJ1               ((0x00cb  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define MIPI_LOSSD_RAW_FIFO_THD_0                  ((0x00cc  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_THD_1                  ((0x00cd  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_THD_2                  ((0x00ce  << 2) + 0xfe3b1800)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_AVG                    ((0x00cf  << 2) + 0xfe3b1800)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define MIPI_LOSSD_RAW_FIFO_DLT                    ((0x00d0  << 2) + 0xfe3b1800)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_BITSGAP_THD_0               ((0x00d1  << 2) + 0xfe3b1800)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define MIPI_LOSSD_RAW_BITSGAP_THD_1               ((0x00d2  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define MIPI_LOSSD_RAW_REF_ADJ                     ((0x00d3  << 2) + 0xfe3b1800)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_0               ((0x00d4  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_1               ((0x00d5  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_2               ((0x00d6  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_3               ((0x00d7  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_4               ((0x00d8  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_REF_ADJ_DLT_5           ((0x00d9  << 2) + 0xfe3b1800)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN0             ((0x00da  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN0_1           ((0x00db  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN1             ((0x00dc  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN1_1           ((0x00dd  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN2             ((0x00de  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN2_1           ((0x00df  << 2) + 0xfe3b1800)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define MIPI_LOSSD_RAW_ACCUM_OFSET_0               ((0x00e0  << 2) + 0xfe3b1800)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_1               ((0x00e1  << 2) + 0xfe3b1800)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_2               ((0x00e2  << 2) + 0xfe3b1800)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_3               ((0x00e3  << 2) + 0xfe3b1800)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_WDR_LINE_DELAY              ((0x00e4  << 2) + 0xfe3b1800)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define MIPI_LOSSD_RAW_CORING_TH_OFST              ((0x00e5  << 2) + 0xfe3b1800)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define MIPI_LOSSD_RAW_CORING_RST                  ((0x00e6  << 2) + 0xfe3b1800)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define MIPI_LOSSD_RAW_STATS_RAM_MODE              ((0x00e7  << 2) + 0xfe3b1800)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define MIPI_LOSSD_RAW_STATS_RAM_ADDR              ((0x00e8  << 2) + 0xfe3b1800)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define MIPI_LOSSD_RAW_RO_STATS_RAM_DATA           ((0x00e9  << 2) + 0xfe3b1800)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_raw_dec_regs.h
//
//========================================================================
// MIPI_ISP  data compress mif dec
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1800
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_mif_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ARSUB0_ISP_LOSS_MIF_CTRL                   ((0x00f0  << 2) + 0xfe3b1800)
//Bit 31:24    reg_sync_sel                  // unsigned , RW, default = 0, sync with frm rst
//Bit 23:16    reg_canvas_id                 // unsigned , RW, default = 0, axi canvas id num
//Bit 15       reserved
//Bit 14:12    reg_cmd_intr_len              // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10    reserved
//Bit  9: 8    reg_cmd_req_size              // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=48 3=64
//Bit  7       reserved
//Bit  6: 4    reg_burst_len                 // unsigned , RW, default = 3, burst type: 0->1; 1->2; 2->4; 3->8; 4->16, others reserved
//Bit  3       reserved
//Bit  2       reg_check_resp_id             // unsigned , RW, default = 0
//Bit  1       reg_dol_mode                  // unsigned , RW, default = 0  1: DOL mode
//Bit  0       reg_mif_enable                // unsigned , RW, default = 1  1 to mif
#define ARSUB0_ISP_LOSS_MIF_QOS                    ((0x00f1  << 2) + 0xfe3b1800)
//Bit 31:0     reg_qos_ctrl                  // unsigned , RW, default = 0, Qos control reg
                                             //18    reg_qos_auto_en
                                             //17    reg_qos_sup
                                             //16    reg_qos_ini
                                             //15:8  reg_qos_up_th
                                             // 7:0  reg_qos_dn_th
#define ARSUB0_ISP_LOSS_MIF_URGENT                 ((0x00f2  << 2) + 0xfe3b1800)
//Bit 31:0     reg_urgent_ctrl               // unsigned , RW, default = 0, urgent control reg
                                             //18    reg_urgent_auto_en
                                             //17    reg_urgent_sup
                                             //16    reg_urgent_ini
                                             //15:8  reg_urgent_up_th
                                             // 7:0  reg_urgent_dn_th
#define ARSUB0_ISP_LOSS_MIF_MISC                   ((0x00f3  << 2) + 0xfe3b1800)
//Bit 31:4  reserved
//Bit 3     reg_mif_busy_noresp_check       // unsigned , RW, default =1, for mif write, dont take "respond busy" as mif unit busy.
//Bit 2     reg_mif_wait_input4busy         // unsigned , RW, default =0, use in encoder, mif is busy till input data comming. only for mif wr
//Bit 1     reg_mif_dbl_baddr_init          // unsigned , RW, default =0, write 1 to use reg_mif_baddr as base-addr for next frame,it would be clear automatically.
//Bit 0     reg_mif_dbl_baddr_en            // unsigned , RW, default =0, 1 to use ping-pong base-addr based on frame.
#define ARSUB0_ISP_LOSS_MIF_BADDR                  ((0x00f4  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_baddr                    // unsigned , RW, default = 0,  mif base address
#define ARSUB0_ISP_LOSS_MIF_BADDR1                 ((0x00f5  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_baddr1                  // unsigned , RW, default = 0,  mif base address
#define ARSUB0_ISP_LOSS_MIF_FIFO_CTRL              ((0x00f7  << 2) + 0xfe3b1800)
//Bit 31:16 reg_mif_gclk_ctrl                // unsigned , RW, default = 0, gate clock control
//Bit 15:8  reserved                         //
//Bit 7 :0  reg_mif_fifo_size                // unsigned , RW, data FIFO max size, default = 128,
#define ARSUB0_ISP_LOSS_MIF_FRM_HOLD               ((0x00f8  << 2) + 0xfe3b1800)
//Bit 31:0  reg_mif_frm_holds                // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define ARSUB0_ISP_LOSS_MIF_RO_STATS               ((0x00f9  << 2) + 0xfe3b1800)
//Bit 31: 0  ro_mif_status                  // unsigned ,  RO, default = 0  mif status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_mif_dec_regs.h
//
//========================================================================
// MIPI_ISP  apb dma
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3b1c00
// -----------------------------------------------
//
// Reading file:  ./mipi_apb_dma.h
//
#define MIPI_DMA_AXI_CTL                           ((0x0000  << 2) + 0xfe3b1c00)
//Bit 31:28,     axi_rbus_prot_cntl         , default = 0, axi_rbus_prot_cntl
//Bit 27:24,     axi_wbus_prot_cntl         , default = 0, axi_wbus_prot_cntl
//Bit 23:22,     reserved
//Bit    21,     reg_axi_arugt              , default = 0, axi read urgent
//Bit    20,     reg_axi_awugt              , default = 0, axi write urgent
//Bit 19:11,     reserved
//Bit  12:8,     reg_axi_id                 , default = 0, axi id
//Bit   7:4,     reserved
//Bit   3:2,     reg_axi_wr_burst_type      , default = 0, axi wr burst type,00 single 01 incr2 10 incr4 11 incr8
//Bit   1:0,     reg_axi_rd_burst_type      , default = 0, axi rd burst type,00 single 01 incr2 10 incr4 11 incr8
#define MIPI_DMA_CTL0                              ((0x0001  << 2) + 0xfe3b1c00)
//Bit    31,     reg_dma_en                 , default = 0, dma enable
//Bit 30:28,     reserved
//Bit    27,     reg_soft_rst               , default = 0, soft reset
//Bit    26,     reg_trig_fifo_rst          , default = 0, trigger source fifo reset
//Bit    25,     reg_axi_rfifo_rst          , default = 0, axi rfifo reset
//Bit    24,     reg_axi_wfifo_rst          , default = 0, axi wfifo reset
//Bit 18:16,     reg_trig_fifo_stat_sel     , default = 0, reg_trig_fifo_stat_sel
//Bit  15:0,     reserved
#define MIPI_DMA_PENDING0                          ((0x0002  << 2) + 0xfe3b1c00)
//Bit 31:16,     c_src_trig_err_set        , default = 0, when current source task not completed ,next same trigger source in
//Bit 15:0 ,     c_src_done_set             , default = 0, trigger source all task done
#define MIPI_DMA_PENDING1                          ((0x0003  << 2) + 0xfe3b1c00)
//Bit 31:2 ,     reserved
//Bit     1,     bus_mon_fast_irq           , default = 0, apb arbit int
//Bit     0,     c_trig_fifo_overflow_set   , default = 0, trigger fifo overflow
#define MIPI_DMA_IRQ_MASK0                         ((0x0004  << 2) + 0xfe3b1c00)
//Bit 31:16,     c_src_trig_err_mask        , default = 0, when current source task not completed ,next same trigger source in
//Bit 15:0 ,     c_src_done_mask            , default = 0, trigger source all task done
#define MIPI_DMA_IRQ_MASK1                         ((0x0005  << 2) + 0xfe3b1c00)
//Bit 31:2 ,     reserved
//Bit     1,     bus_mon_fast_irq_mask      , default = 0, apb arbit int
//Bit     0,     c_trig_fifo_overflow_mask  , default = 0, trigger fifo overflow
#define MIPI_DMA_STAT0                             ((0x0010  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat0             , default = 0
#define MIPI_DMA_STAT1                             ((0x0011  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat1             , default = 0
#define MIPI_DMA_STAT2                             ((0x0012  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat2             , default = 0
#define MIPI_DMA_STAT3                             ((0x0013  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat3             , default = 0
#define MIPI_DMA_STAT4                             ((0x0014  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat4             , default = 0
#define MIPI_DMA_STAT5                             ((0x0015  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat5             , default = 0
#define MIPI_DMA_STAT6                             ((0x0016  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_dma_stat5             , default = 0
#define MIPI_DMA_TRIG_FIFO_STAT0                   ((0x0017  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_trig_fifo_stat0       , default = 0
#define MIPI_DMA_AXI_FIFO_STAT0                    ((0x0018  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_axi_fifo_stat0        , default = 0
#define MIPI_DMA_ARBIT_CNTL0                       ((0x0020  << 2) + 0xfe3b1c00)
//Bit  31:4,     reserved
//Bit   3:0,     bus_monitor_cntl          , default = 0,apb arbit bus_monitor_cntl
#define MIPI_DMA_ARBIT_CNTL1                       ((0x0021  << 2) + 0xfe3b1c00)
//Bit  31:0,     bus_mon_addr              , default = 0,apb arbit bus_mon_addr
#define MIPI_DMA_ARBIT_CNTL2                       ((0x0022  << 2) + 0xfe3b1c00)
//Bit  31:0,     bus_mon_data              , default = 0,apb arbit bus_mon_data
#define MIPI_DMA_ARBIT_CNTL3                       ((0x0023  << 2) + 0xfe3b1c00)
//Bit  31:0,     bus_mon_data_msk          , default = 0,apb arbit bus_mon_data_msk
#define MIPI_DMA_SRC0_CTL                          ((0x0030  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src0 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src0 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src0 pingpong initial sel
//Bit  0,     reg_src0_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC0_PING_CMD_ADDR0               ((0x0031  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC0_PING_DST_ADDR0               ((0x0032  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC0_PING_TASK0                   ((0x0033  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src0_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src0_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PING_CMD_ADDR1               ((0x0034  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC0_PING_DST_ADDR1               ((0x0035  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC0_PING_TASK1                   ((0x0036  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src0_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src0_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PONG_CMD_ADDR0               ((0x0037  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC0_PONG_DST_ADDR0               ((0x0038  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC0_PONG_TASK0                   ((0x0039  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src0_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src0_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PONG_CMD_ADDR1               ((0x003a  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC0_PONG_DST_ADDR1               ((0x003b  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src0_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC0_PONG_TASK1                   ((0x003c  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src0_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src0_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_CTL                          ((0x003d  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src1 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src1 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src1 pingpong initial sel
//Bit  0,     reg_src1_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC1_PING_CMD_ADDR0               ((0x003e  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC1_PING_DST_ADDR0               ((0x003f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC1_PING_TASK0                   ((0x0040  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src1_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src1_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PING_CMD_ADDR1               ((0x0041  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC1_PING_DST_ADDR1               ((0x0042  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC1_PING_TASK1                   ((0x0043  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src1_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src1_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PONG_CMD_ADDR0               ((0x0044  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC1_PONG_DST_ADDR0               ((0x0045  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC1_PONG_TASK0                   ((0x0046  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src1_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src1_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PONG_CMD_ADDR1               ((0x0047  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC1_PONG_DST_ADDR1               ((0x0048  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src1_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC1_PONG_TASK1                   ((0x0049  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src1_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src1_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_CTL                          ((0x004a  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src2 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src2 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src2 pingpong initial sel
//Bit  0,     reg_src2_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC2_PING_CMD_ADDR0               ((0x004b  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC2_PING_DST_ADDR0               ((0x004c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC2_PING_TASK0                   ((0x004d  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src2_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src2_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PING_CMD_ADDR1               ((0x004e  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC2_PING_DST_ADDR1               ((0x004f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC2_PING_TASK1                   ((0x0050  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src2_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src2_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PONG_CMD_ADDR0               ((0x0051  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC2_PONG_DST_ADDR0               ((0x0052  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC2_PONG_TASK0                   ((0x0053  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src2_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src2_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PONG_CMD_ADDR1               ((0x0054  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC2_PONG_DST_ADDR1               ((0x0055  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src2_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC2_PONG_TASK1                   ((0x0056  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src2_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src2_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_CTL                          ((0x0057  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src3 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src3 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src3 pingpong initial sel
//Bit  0,     reg_src3_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC3_PING_CMD_ADDR0               ((0x0058  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC3_PING_DST_ADDR0               ((0x0059  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC3_PING_TASK0                   ((0x005a  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src3_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src3_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PING_CMD_ADDR1               ((0x005b  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC3_PING_DST_ADDR1               ((0x005c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC3_PING_TASK1                   ((0x005d  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src3_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src3_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PONG_CMD_ADDR0               ((0x005e  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC3_PONG_DST_ADDR0               ((0x005f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC3_PONG_TASK0                   ((0x0060  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src3_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src3_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PONG_CMD_ADDR1               ((0x0061  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC3_PONG_DST_ADDR1               ((0x0062  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src3_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC3_PONG_TASK1                   ((0x0063  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src3_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src3_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_CTL                          ((0x0064  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src4 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src4 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src4 pingpong initial sel
//Bit  0,     reg_src4_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC4_PING_CMD_ADDR0               ((0x0065  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC4_PING_DST_ADDR0               ((0x0066  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC4_PING_TASK0                   ((0x0067  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src4_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src4_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PING_CMD_ADDR1               ((0x0068  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC4_PING_DST_ADDR1               ((0x0069  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC4_PING_TASK1                   ((0x006a  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src4_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src4_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PONG_CMD_ADDR0               ((0x006b  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC4_PONG_DST_ADDR0               ((0x006c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC4_PONG_TASK0                   ((0x006d  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src4_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src4_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PONG_CMD_ADDR1               ((0x006e  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC4_PONG_DST_ADDR1               ((0x006f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src4_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC4_PONG_TASK1                   ((0x0070  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src4_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src4_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_CTL                          ((0x0071  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src5 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src5 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src5 pingpong initial sel
//Bit  0,     reg_src5_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC5_PING_CMD_ADDR0               ((0x0072  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC5_PING_DST_ADDR0               ((0x0073  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC5_PING_TASK0                   ((0x0074  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src5_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src5_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PING_CMD_ADDR1               ((0x0075  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC5_PING_DST_ADDR1               ((0x0076  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC5_PING_TASK1                   ((0x0077  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src5_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src5_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PONG_CMD_ADDR0               ((0x0078  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC5_PONG_DST_ADDR0               ((0x0079  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC5_PONG_TASK0                   ((0x007a  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src5_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src5_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PONG_CMD_ADDR1               ((0x007b  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC5_PONG_DST_ADDR1               ((0x007c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src5_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC5_PONG_TASK1                   ((0x007d  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src5_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src5_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_CTL                          ((0x007e  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src6 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src6 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src6 pingpong initial sel
//Bit  0,     reg_src6_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC6_PING_CMD_ADDR0               ((0x007f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC6_PING_DST_ADDR0               ((0x0080  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC6_PING_TASK0                   ((0x0081  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src6_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src6_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PING_CMD_ADDR1               ((0x0082  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC6_PING_DST_ADDR1               ((0x0083  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC6_PING_TASK1                   ((0x0084  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src6_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src6_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PONG_CMD_ADDR0               ((0x0085  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC6_PONG_DST_ADDR0               ((0x0086  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC6_PONG_TASK0                   ((0x0087  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src6_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src6_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PONG_CMD_ADDR1               ((0x0088  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC6_PONG_DST_ADDR1               ((0x0089  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src6_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC6_PONG_TASK1                   ((0x008a  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src6_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src6_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_CTL                          ((0x008b  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src7 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src7 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src7 pingpong initial sel
//Bit  0,     reg_src7_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC7_PING_CMD_ADDR0               ((0x008c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC7_PING_DST_ADDR0               ((0x008d  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC7_PING_TASK0                   ((0x008e  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src7_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src7_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PING_CMD_ADDR1               ((0x008f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC7_PING_DST_ADDR1               ((0x0090  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC7_PING_TASK1                   ((0x0091  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src7_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src7_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PONG_CMD_ADDR0               ((0x0092  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC7_PONG_DST_ADDR0               ((0x0093  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC7_PONG_TASK0                   ((0x0094  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src7_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src7_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PONG_CMD_ADDR1               ((0x0095  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC7_PONG_DST_ADDR1               ((0x0096  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src7_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC7_PONG_TASK1                   ((0x0097  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src7_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src7_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC8_CTL                          ((0x0098  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src8 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src8 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src8 pingpong initial sel
//Bit  0,     reg_src8_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC8_PING_CMD_ADDR0               ((0x0099  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC8_PING_DST_ADDR0               ((0x009a  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC8_PING_TASK0                   ((0x009b  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src8_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src8_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src8_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC8_PING_CMD_ADDR1               ((0x009c  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC8_PING_DST_ADDR1               ((0x009d  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC8_PING_TASK1                   ((0x009e  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src8_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src8_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src8_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC8_PONG_CMD_ADDR0               ((0x009f  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC8_PONG_DST_ADDR0               ((0x00a0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC8_PONG_TASK0                   ((0x00a1  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src8_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src8_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src8_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC8_PONG_CMD_ADDR1               ((0x00a2  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC8_PONG_DST_ADDR1               ((0x00a3  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src8_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC8_PONG_TASK1                   ((0x00a4  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src8_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src8_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src8_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC9_CTL                          ((0x00a5  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src9 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src9 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src9 pingpong initial sel
//Bit  0,     reg_src9_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC9_PING_CMD_ADDR0               ((0x00a6  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC9_PING_DST_ADDR0               ((0x00a7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC9_PING_TASK0                   ((0x00a8  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src9_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src9_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src9_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC9_PING_CMD_ADDR1               ((0x00a9  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC9_PING_DST_ADDR1               ((0x00aa  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC9_PING_TASK1                   ((0x00ab  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src9_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src9_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src9_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC9_PONG_CMD_ADDR0               ((0x00ac  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC9_PONG_DST_ADDR0               ((0x00ad  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC9_PONG_TASK0                   ((0x00ae  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src9_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src9_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src9_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC9_PONG_CMD_ADDR1               ((0x00af  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC9_PONG_DST_ADDR1               ((0x00b0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src9_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC9_PONG_TASK1                   ((0x00b1  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src9_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src9_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src9_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC10_CTL                         ((0x00b2  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src10 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src10 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src10 pingpong initial sel
//Bit  0,     reg_src10_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC10_PING_CMD_ADDR0              ((0x00b3  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC10_PING_DST_ADDR0              ((0x00b4  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC10_PING_TASK0                  ((0x00b5  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src10_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src10_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src10_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC10_PING_CMD_ADDR1              ((0x00b6  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC10_PING_DST_ADDR1              ((0x00b7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC10_PING_TASK1                  ((0x00b8  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src10_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src10_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src10_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC10_PONG_CMD_ADDR0              ((0x00b9  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC10_PONG_DST_ADDR0              ((0x00ba  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC10_PONG_TASK0                  ((0x00bb  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src10_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src10_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src10_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC10_PONG_CMD_ADDR1              ((0x00bc  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC10_PONG_DST_ADDR1              ((0x00bd  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src10_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC10_PONG_TASK1                  ((0x00be  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src10_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src10_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src10_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC11_CTL                         ((0x00bf  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src11 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src11 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src11 pingpong initial sel
//Bit  0,     reg_src11_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC11_PING_CMD_ADDR0              ((0x00c0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC11_PING_DST_ADDR0              ((0x00c1  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC11_PING_TASK0                  ((0x00c2  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src11_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src11_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src11_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC11_PING_CMD_ADDR1              ((0x00c3  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC11_PING_DST_ADDR1              ((0x00c4  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC11_PING_TASK1                  ((0x00c5  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src11_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src11_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src11_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC11_PONG_CMD_ADDR0              ((0x00c6  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC11_PONG_DST_ADDR0              ((0x00c7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC11_PONG_TASK0                  ((0x00c8  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src11_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src11_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src11_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC11_PONG_CMD_ADDR1              ((0x00c9  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC11_PONG_DST_ADDR1              ((0x00ca  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src11_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC11_PONG_TASK1                  ((0x00cb  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src11_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src11_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src11_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC12_CTL                         ((0x00cc  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src12 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src12 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src12 pingpong initial sel
//Bit  0,     reg_src12_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC12_PING_CMD_ADDR0              ((0x00cd  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC12_PING_DST_ADDR0              ((0x00ce  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC12_PING_TASK0                  ((0x00cf  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src12_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src12_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src12_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC12_PING_CMD_ADDR1              ((0x00d0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC12_PING_DST_ADDR1              ((0x00d1  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC12_PING_TASK1                  ((0x00d2  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src12_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src12_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src12_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC12_PONG_CMD_ADDR0              ((0x00d3  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC12_PONG_DST_ADDR0              ((0x00d4  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC12_PONG_TASK0                  ((0x00d5  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src12_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src12_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src12_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC12_PONG_CMD_ADDR1              ((0x00d6  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC12_PONG_DST_ADDR1              ((0x00d7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src12_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC12_PONG_TASK1                  ((0x00d8  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src12_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src12_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src12_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC13_CTL                         ((0x00d9  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src13 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src13 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src13 pingpong initial sel
//Bit  0,     reg_src13_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC13_PING_CMD_ADDR0              ((0x00da  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC13_PING_DST_ADDR0              ((0x00db  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC13_PING_TASK0                  ((0x00dc  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src13_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src13_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src13_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC13_PING_CMD_ADDR1              ((0x00dd  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC13_PING_DST_ADDR1              ((0x00de  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC13_PING_TASK1                  ((0x00df  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src13_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src13_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src13_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC13_PONG_CMD_ADDR0              ((0x00e0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC13_PONG_DST_ADDR0              ((0x00e1  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC13_PONG_TASK0                  ((0x00e2  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src13_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src13_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src13_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC13_PONG_CMD_ADDR1              ((0x00e3  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC13_PONG_DST_ADDR1              ((0x00e4  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src13_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC13_PONG_TASK1                  ((0x00e5  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src13_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src13_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src13_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC14_CTL                         ((0x00e6  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src14 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src14 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src14 pingpong initial sel
//Bit  0,     reg_src14_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC14_PING_CMD_ADDR0              ((0x00e7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC14_PING_DST_ADDR0              ((0x00e8  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC14_PING_TASK0                  ((0x00e9  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src14_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src14_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src14_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC14_PING_CMD_ADDR1              ((0x00ea  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC14_PING_DST_ADDR1              ((0x00eb  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC14_PING_TASK1                  ((0x00ec  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src14_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src14_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src14_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC14_PONG_CMD_ADDR0              ((0x00ed  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC14_PONG_DST_ADDR0              ((0x00ee  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC14_PONG_TASK0                  ((0x00ef  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src14_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src14_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src14_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC14_PONG_CMD_ADDR1              ((0x00f0  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC14_PONG_DST_ADDR1              ((0x00f1  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src14_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC14_PONG_TASK1                  ((0x00f2  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src14_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src14_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src14_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC15_CTL                         ((0x00f3  << 2) + 0xfe3b1c00)
//Bit  3,     reg_src_pingpong_force_val   , default = 0, src15 pingpong force sel
//Bit  2,     reg_src_pingpong_force       , default = 0, src15 pingpong force enable
//Bit  1,     reg_src_pingpong_ini         , default = 0, src15 pingpong initial sel
//Bit  0,     reg_src15_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC15_PING_CMD_ADDR0              ((0x00f4  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC15_PING_DST_ADDR0              ((0x00f5  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC15_PING_TASK0                  ((0x00f6  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src15_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src15_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src15_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC15_PING_CMD_ADDR1              ((0x00f7  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC15_PING_DST_ADDR1              ((0x00f8  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC15_PING_TASK1                  ((0x00f9  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src15_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src15_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src15_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC15_PONG_CMD_ADDR0              ((0x00fa  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC15_PONG_DST_ADDR0              ((0x00fb  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC15_PONG_TASK0                  ((0x00fc  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src15_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src15_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src15_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC15_PONG_CMD_ADDR1              ((0x00fd  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC15_PONG_DST_ADDR1              ((0x00fe  << 2) + 0xfe3b1c00)
//Bit  31:0,     reg_src15_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC15_PONG_TASK1                  ((0x00ff  << 2) + 0xfe3b1c00)
//Bit    31,     reg_src15_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src15_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src15_pong_len1             , default = 0, cmd length,N-1 words
//
// Closing file:  ./mipi_apb_dma.h
//
//========================================================================
// MIPI_ISP  top wrapper cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bdc00
// -----------------------------------------------
#define MIPI_CSI_PHY_CNTL0                         ((0x0000  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL1                         ((0x0001  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL2                         ((0x0002  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL3                         ((0x0003  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL4                         ((0x0004  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL5                         ((0x0005  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL6                         ((0x0006  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL7                         ((0x0007  << 2) + 0xfe3bdc00)
#define MIPI_CSI_PHY_CNTL_I                        ((0x0010  << 2) + 0xfe3bdc00)
#define MIPI_ISP_MAX_ADDR_CNTL                     ((0x0020  << 2) + 0xfe3bdc00)
#define MIPI_CSI_CFG_CNTL0                         ((0x0021  << 2) + 0xfe3bdc00)
//========================================================================
// MIPI_ISP  HOST3
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3be000
// -----------------------------------------------
//========================================================================
// MIPI_ISP  HOST2
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3be400
// -----------------------------------------------
//========================================================================
// MIPI_ISP  HOST1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3be800
// -----------------------------------------------
//========================================================================
// MIPI_ISP  HOST0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bec00
// -----------------------------------------------
//========================================================================
// MIPI_ISP  DPHY3
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bf000
// -----------------------------------------------
//========================================================================
// MIPI_ISP  DPHY2
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bf400
// -----------------------------------------------
//========================================================================
// MIPI_ISP  DPHY1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bf800
// -----------------------------------------------
//========================================================================
// MIPI_ISP  DPHY0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe3bfc00
// -----------------------------------------------
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_isp.h
//
//`include "mipi_adapt_cmpr_regs.h"
//`include "mipi_tnr_cmpr_regs.h"
//`include "mipi_tnr_meta_mif_regs.h"
//========================================================================
// DEWRAP/AML_GDC
//========================================================================
//
// Reading file:  ./isp_dwap_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe040000
// -----------------------------------------------
#define ISP_DWAP_TOP_SRC_FSIZE                     ((0x0000  << 2) + 0xfe040000)
//Bit 31: 16        reg_src_frm_hsize               // unsigned , RW, default = 1280
//Bit 15: 0         reg_src_frm_vsize               // unsigned , RW, default = 720
//
#define ISP_DWAP_TOP_HDNUM                         ((0x0001  << 2) + 0xfe040000)
//Bit 31: 26        reserved
//Bit 25: 13        reg_hold_hnum               // unsigned , RW, default = 2
//Bit 12: 0         reg_hold_vnum               // unsigned , RW, default = 2
#define ISP_DWAP_TOP_CTRL0                         ((0x0002  << 2) + 0xfe040000)
//Bit 31            pls_frm_rst              //unsigned, RW, default=0
//Bit 30            pls_sw_rst              //unsigned, RW, default=0
//Bit 29            reserved
//Bit 28:16         reg_stdly_num           //unsigned, RW, default=2
//Bit 15:11         reserved
//Bit 10:7          reg_err_intr_sel        //unsigned, RW, default=15
//Bit 6             reg_err_intr_en         //unsigned, RW, default=1
//Bit 5             reg_sec_ctrl            //unsigned, RW, default=0
//Bit 4             reg_hs_sel              //unsigned, RW, default=0
//Bit 3:2           reg_din_sel             //unsigned, RW, default=1, dos vidin select
//Bit 1             reserved
//Bit 0             reg_frm_sel             //unsigned, RW, default=0, must be set before pls_frm_rst
#define ISP_DWAP_TOP_COEF_CTRL0                    ((0x0003  << 2) + 0xfe040000)
//Bit 31:0          reg_coef_baddr          //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_COEF_CTRL1                    ((0x0004  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_coef_size           //unsigned, RW, default=0
#define ISP_DWAP_TOP_CMD_CTRL0                     ((0x0005  << 2) + 0xfe040000)
//Bit 31:0          reg_cmd_baddr          //unsigned, RW, default=0
#define ISP_DWAP_TOP_CMD_CTRL1                     ((0x0006  << 2) + 0xfe040000)
//Bit 31:30         reg_src_bwidth          //unsigned, RW, default=0
//Bit 29            reg_data_test           //unsigned, RW, default=0
//Bit 28:22         reserved
//Bit 21:16         reg_rdmif_id            //unsigned, RW, default=6'h39;
//Bit 15:0          reg_cmd_size            //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_Y_CTRL0                   ((0x0007  << 2) + 0xfe040000)
//Bit 31:0          reg_src_y_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_Y_CTRL1                   ((0x0008  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_y_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_U_CTRL0                   ((0x0009  << 2) + 0xfe040000)
//Bit 31:0          reg_src_u_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_U_CTRL1                   ((0x000a  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_u_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_V_CTRL0                   ((0x000b  << 2) + 0xfe040000)
//Bit 31:0          reg_src_v_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_V_CTRL1                   ((0x000c  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_v_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_MESH_CTRL0                    ((0x000d  << 2) + 0xfe040000)
//Bit 31:0          reg_mesh_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_MESH_CTRL1                    ((0x000e  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_mesh_stride          //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_GCLK                          ((0x000f  << 2) + 0xfe040000)
//Bit 31:0           reg_gclk_ctrl           //unsigned, RW, default=0
#define ISP_DWAP_TOP_DST_FSIZE                     ((0x0010  << 2) + 0xfe040000)
//Bit 31: 16        reg_dst_frm_hsize               // unsigned , RW, default = 1280
//Bit 15: 0         reg_dst_frm_vsize               // unsigned , RW, default = 720
#define ISP_DWAP_TOP_BLK_NUM                       ((0x0011  << 2) + 0xfe040000)
//Bit 31: 16        reg_edge_num           // unsigned, RW, default = 0
//Bit 15: 0         reg_blk_num            // unsigned , RW, default = 256
#define ISP_DWAP_TOP_MESH_SIZE                     ((0x0012  << 2) + 0xfe040000)
//Bit 31: 16        reg_mesh_hsize            // unsigned, RW, default = 32
//Bit 15: 0         reg_mesh_vsize            // unsigned, RW, default = 32
#define ISP_DWAP_TOP_DST_Y_CTRL0                   ((0x0013  << 2) + 0xfe040000)
//Bit 31:0          reg_dst_y_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_Y_CTRL1                   ((0x0014  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_y_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_DST_U_CTRL0                   ((0x0015  << 2) + 0xfe040000)
//Bit 31:0          reg_dst_u_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_U_CTRL1                   ((0x0016  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_u_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_DST_V_CTRL0                   ((0x0017  << 2) + 0xfe040000)
//Bit 31:0          reg_dst_v_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_V_CTRL1                   ((0x0018  << 2) + 0xfe040000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_v_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_ERR_CTRL                      ((0x0019  << 2) + 0xfe040000)
//Bit 31:1          reserved
//Bit 0             pls_err_clr              // unsigned, RW, default=0
//
#define ISP_DWAP_TOP_CMD_ERR                       ((0x001a  << 2) + 0xfe040000)
//Bit 31:0          ro_cmd_err             // unsigned, RO, default=0
#define ISP_DWAP_TOP_MESH_ERR                      ((0x001b  << 2) + 0xfe040000)
//Bit 31:0          ro_mesh_num_err        // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR0                    ((0x001c  << 2) + 0xfe040000)
//Bit 31:0          ro_oflow_err0          // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR1                    ((0x001d  << 2) + 0xfe040000)
//Bit 31:0          ro_oflow_err1           // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR2                    ((0x001e  << 2) + 0xfe040000)
//Bit 31:0          ro_oflow_err2           // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR3                    ((0x001f  << 2) + 0xfe040000)
//Bit 31:0          ro_oflow_err3           // unsigned, RO, default=0
#define ISP_DWAP_TOP_VSPLT_8LN                     ((0x0020  << 2) + 0xfe040000)
//Bit 31:0          ro_vsplt_8ln            // unsigned, RO, default=0
#define ISP_DWAP_TOP_VSPLT_4LN                     ((0x0021  << 2) + 0xfe040000)
//Bit 31:0          ro_vsplt_4ln            // unsigned, RO, default=0
#define ISP_DWAP_WATCH_DOG                         ((0x0022  << 2) + 0xfe040000)
//Bit 31:0      reg_watch_dog           // unsigned, RW, default=32'hffffffff
#define ISP_DWAP_TOP_PERF                          ((0x0023  << 2) + 0xfe040000)
//Bit 31:0      ro_proc_time            // unsigned, RO, default=0
#define ISP_DWAP_DDR_VCNT                          ((0x0024  << 2) + 0xfe040000)
//Bit 31:17     reserved
//Bit 16        reg_ddr_vcnt_mode       // unsigned, RW, default=0
//Bit 15:0      reg_ddr_vcnt            // unsigned, RW, default=16'hffff
#define ISP_DWAP_COEF_LD_TIME                      ((0x0025  << 2) + 0xfe040000)
//Bit 31:0      ro_coef_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_MESH_LD_TIME                      ((0x0026  << 2) + 0xfe040000)
//Bit 31:0      ro_mesh_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_DATA_LD_TIME                      ((0x0027  << 2) + 0xfe040000)
//Bit 31:0      ro_data_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_TILE_PROC_TIME                    ((0x0028  << 2) + 0xfe040000)
//Bit 31:0      ro_tile_proc_time       // unsigned, RO, default=0
#define ISP_DWAP_EDGE_PROC_TIME                    ((0x0029  << 2) + 0xfe040000)
//Bit 31:0      ro_edge_proc_time       // unsigned, RO, default=0
#define ISP_DWAP_WAIT_RST_TIME                     ((0x002a  << 2) + 0xfe040000)
//Bit 31:0      ro_wait_rst_time        // unsigned, RO, default=0
#define ISP_DWAP_CMD_SWAP                          ((0x002b  << 2) + 0xfe040000)
//Bit 31:14     reserved
//Bit 13        reg_coef_little_endian  // unsigned, RW, default=1
//Bit 12        reg_mesh_little_endian  // unsigned, RW, default=1
//Bit 11        reg_data_swap64         // unsigned, RW, default=0
//Bit 10        reg_coef_swap64         // unsigned, RW, default=0
//Bit 9         reg_mesh_swap64         // unsigned, RW, default=0
//Bit 8         reg_wrmif_swap8         // unsigned, RW, default=0
//Bit 7         reg_wrmif_uvswap        // unsigned, RW, default=0
//Bit 6         reg_data_little_endian  // unsigned, RW, default=1
//Bit 5         reg_data_uvswap         // unsigned, RW, default=0
//Bit 4         reg_coef_swap32         // unsigned, RW, default=0
//Bit 3         reg_coef_swap16         // unsigned, RW, default=0
//Bit 2         reg_mesh_swap32         // unsigned, RW, default=0
//Bit 1         reg_cmd_swap64          // unsigned, RW, default=0
//Bit 0         reg_cmd_swap32          // unsigned, RW, default=0
#define ISP_DWAP_DBG_CTRL0                         ((0x002c  << 2) + 0xfe040000)
//Bit 31:16     reg_blk_cnt_sel         // unsigned, RW, default=0
//Bit 15:13     reg_cmd_idx             // unsigned, RW, default=0
//Bit 12:11     reg_cmd_sel             // unsigned, RW, default=3
//Bit 10:1      reserved
//Bit 0         reg_ram_dbg_mode        // unsigned, RW, default=0
#define ISP_DWAP_DBG_CTRL1                         ((0x002d  << 2) + 0xfe040000)
//Bit 31:16     reg_dbg_hidx            // unsigned, RW, default=0
//Bit 15:0      reg_dbg_vidx            // unsigned, RW, default=0
//
#define ISP_DWAP_DBG_CTRL2                         ((0x002e  << 2) + 0xfe040000)
//Bit 31:30     reg_dbg_en              // unsigned, RW, default=0
//Bit 29:23     reg_dbg_hscale          // unsigned, RW, default=0
//Bit 22:16     reg_dbg_vscale          // unsigned, RW, default=0
//Bit 15:8      reg_dbg_val0            // unsigned, RW, default=0
//Bit 7:0       reg_dbg_val1            // unsigned, RW, default=0
#define ISP_DWAP_CMD_DATA0                         ((0x002f  << 2) + 0xfe040000)
//Bit 31:0      ro_cmd_data0            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA1                         ((0x0030  << 2) + 0xfe040000)
//Bit 31:0      ro_cmd_data1            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA2                         ((0x0031  << 2) + 0xfe040000)
//Bit 31:0      ro_cmd_data2            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA3                         ((0x0032  << 2) + 0xfe040000)
//Bit 31:0      ro_cmd_data3            // unsigned, RO, default=0
#define ISP_DWAP_BLK_INFO                          ((0x0033  << 2) + 0xfe040000)
//Bit 31:16     ro_blk_cnt              // unsigned, RO, default=0
//Bit 15        ro_dwap_idle            // unsigned, RO, default=0
//Bit 14:12     ro_cmd_dec_st           // unsigned, RO, default=0
//Bit 11        ro_cfg_hold_f           // unsigned, RO, default=0
//Bit 10:2      reserved
//Bit 1         ro_ram_acc_err          // unsigned, RO, default=0
//Bit 0         ro_bresp_err            // unsigned, RO, default=0
#define ISP_DWAP_GAMMA_CTRL                        ((0x0060  << 2) + 0xfe040000)
//Bit 31:16     reg_dwgm_gain           //unsigned, RW, default=256
//Bit 15:5      reserved
//Bit 4:2       reg_output_bw_sel       //unsigned, RW, default=0
//Bit 1         reg_dwgm_lut_mode       //unsigned, RW, default=1
//Bit 0         reg_dwgm_en             //unsigned, RW, default=0
#define ISP_DWAP_GAMMA_OFST                        ((0x0061  << 2) + 0xfe040000)
//Bit 31:28     reserved
//Bit 27:16     reg_dwgm_pre_ofst       //unsigned, RW, default=0
//Bit 15:0      reg_dwgm_pst_ofst       //unsigned, RW, default=0
//
#define ISP_DWAP_GAMMA_NUM                         ((0x0062  << 2) + 0xfe040000)
//Bit 31:24     reserved
//Bit 23:0      reg_dwgm_lut_num        //unsigned, RW, default=24'hb1b645 //24'b1011_0001_1011_0110_1110_0101 //{5, 4, 3, 3, 3, 3, 4, 5}
#define ISP_DWAP_GAMMA_STP                         ((0x0063  << 2) + 0xfe040000)
//Bit 31:0      reg_dwgm_lut_stp        //unsigned, RW, default = 32'heeedcb98
#define ISP_DWAP_GAMMA_LUT_ADDR                    ((0x0064  << 2) + 0xfe040000)
//Bit 31:0      reg_dwgm_lut_addr       //unsigned, RW, default = 0
#define ISP_DWAP_GAMMA_LUT_DATA                    ((0x0065  << 2) + 0xfe040000)
//Bit 31:0      reg_dwgm_lut_data       //unsigned, RW, default = 0
//
// Reading file:  ./isp_dwap_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe040000
// -----------------------------------------------
#define ISP_DWAP_WMIF_CTRL1                        ((0x0040  << 2) + 0xfe040000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 1, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_DWAP_WMIF_CTRL2                        ((0x0041  << 2) + 0xfe040000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:22 reserved
//Bit 21:20 reg_int_clr       // unsigned , default = 0
//Bit 19:18 reg_gclk_ctrl     // unsigned , default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=wrmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_DWAP_WMIF_CTRL3                        ((0x0042  << 2) + 0xfe040000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , default = 0
//Bit 29:24 reg_pass_num      // unsigned , default = 1
//Bit 23:18 reg_hold_num      // unsigned , default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define ISP_DWAP_WMIF_CTRL4                        ((0x0043  << 2) + 0xfe040000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define ISP_DWAP_WMIF_SCOPE_X                      ((0x0044  << 2) + 0xfe040000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define ISP_DWAP_WMIF_SCOPE_Y                      ((0x0045  << 2) + 0xfe040000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define ISP_DWAP_WMIF_RO_STAT                      ((0x0046  << 2) + 0xfe040000)
//Bit 31:16 reserved
//Bit 15:0  reg_status        // unsigned , default = 0
#define ISP_DWAP_RMIF_CTRL1                        ((0x0050  << 2) + 0xfe040000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_DWAP_RMIF_CTRL2                        ((0x0051  << 2) + 0xfe040000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:26 reserved
//Bit 25:22 reg_vstep         // unsigned , default = 1
//Bit 21:20 reg_int_clr       // unsigned , default = 0
//Bit 19:18 reg_gclk_ctrl     // unsigned , default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_DWAP_RMIF_CTRL3                        ((0x0052  << 2) + 0xfe040000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , default = 0
//Bit 29:24 reg_pass_num      // unsigned , default = 1
//Bit 23:18 reg_hold_num      // unsigned , default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:14 reg_block_mode    // unsigned , default = 0
//Bit 13    reg_32b_align     // unsigned , default = 0
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define ISP_DWAP_RMIF_CTRL4                        ((0x0053  << 2) + 0xfe040000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define ISP_DWAP_RMIF_SCOPE_X                      ((0x0054  << 2) + 0xfe040000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define ISP_DWAP_RMIF_SCOPE_Y                      ((0x0055  << 2) + 0xfe040000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define ISP_DWAP_RMIF_RO_STAT                      ((0x0056  << 2) + 0xfe040000)
//Bit 31:16 reserved
//Bit 15:0  reg_status        // unsigned , default = 0
// synopsys translate_off
// synopsys translate_on
#endif
//
// Closing file:  ./isp_dwap_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_dwap_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./REG_LIST_RTL.h
//
//
// Reading file:  ./vcbus_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
//===========================================================================
//
// Reading file:  ./rdma_regs.h
//
//===========================================================================
// RDMA registers 0x00 - 0xff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  RDMA_VCBUS_BASE = 0x11
// -----------------------------------------------
// Bit 31: 0 RW AHB start address for manual start DMA
#define RDMA_AHB_START_ADDR_MAN                    ((0x1100  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for manual start DMA
#define RDMA_AHB_END_ADDR_MAN                      ((0x1101  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 1
#define RDMA_AHB_START_ADDR_1                      ((0x1102  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 1
#define RDMA_AHB_END_ADDR_1                        ((0x1103  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 2
#define RDMA_AHB_START_ADDR_2                      ((0x1104  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 2
#define RDMA_AHB_END_ADDR_2                        ((0x1105  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 3
#define RDMA_AHB_START_ADDR_3                      ((0x1106  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 3
#define RDMA_AHB_END_ADDR_3                        ((0x1107  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 4
#define RDMA_AHB_START_ADDR_4                      ((0x1108  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 4
#define RDMA_AHB_END_ADDR_4                        ((0x1109  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 5
#define RDMA_AHB_START_ADDR_5                      ((0x110a  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 5
#define RDMA_AHB_END_ADDR_5                        ((0x110b  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 6
#define RDMA_AHB_START_ADDR_6                      ((0x110c  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 6
#define RDMA_AHB_END_ADDR_6                        ((0x110d  << 2) + 0xff000000)
// Bit 31: 0 RW AHB start address for auto start source 7
#define RDMA_AHB_START_ADDR_7                      ((0x110e  << 2) + 0xff000000)
// Bit 31: 0 RW AHB end address for auto start source 7
#define RDMA_AHB_END_ADDR_7                        ((0x110f  << 2) + 0xff000000)
// Auto start DMA control:
// Bit 31:24 RW ctrl_enable_int_3. Interrupt inputs enable mask for source 3.
// Bit 23:16 RW ctrl_enable_int_2. Interrupt inputs enable mask for source 2.
// Bit 15: 8 RW ctrl_enable_int_1. Interrupt inputs enable mask for source 1.
// Bit     7 RW ctrl_cbus_write_3. Register read/write mode for auto-start 3. 1=Register write; 0=Register read.
// Bit     6 RW ctrl_cbus_write_3. Register read/write mode for auto-start 2. 1=Register write; 0=Register read.
// Bit     5 RW ctrl_cbus_write_3. Register read/write mode for auto-start 1. 1=Register write; 0=Register read.
// Bit     4 R  Rsrv.
// Bit     3 RW ctrl_cbus_addr_incr_3. 1=Incremental register access for auto-start 3; 0=Non-incremental (individual) register access.
// Bit     2 RW ctrl_cbus_addr_incr_2. 1=Incremental register access for auto-start 2; 0=Non-incremental (individual) register access.
// Bit     1 RW ctrl_cbus_addr_incr_1. 1=Incremental register access for auto-start 1; 0=Non-incremental (individual) register access.
// Bit     0 R  Rsrv.
#define RDMA_ACCESS_AUTO                           ((0x1110  << 2) + 0xff000000)
#define RDMA_ACCESS_AUTO2                          ((0x1111  << 2) + 0xff000000)
// Manual start DMA control:
// Bit 31: 3 R  Rsrv.
// Bit     2 RW ctrl_cbus_write_man. Register read/write mode for manual-start. 1=Register write; 0=Register read.
// Bit     1 RW ctrl_cbus_addr_incr_man. 1=Incremental register access for manual-start; 0=Non-incremental (individual) register access.
// Bit     0 W  ctrl_start_man. Write 1 to this bit to manual-start DMA. This bit always read back 0.
#define RDMA_ACCESS_MAN                            ((0x1113  << 2) + 0xff000000)
// RDMA general control:
// Bit 31:25 R  Rsrv.
// Bit    24 W  ctrl_clr_rdma_done_int. Write 1 to reset rdma_int level to 0. No need to clear this bit.
// Bit 23:19 R  Rsrv.
// Bit 18:13 R  Rsrv.
// Bit 12: 7 R  Rsrv.
// Bit     6 RW ctrl_ddr_urgent.
// Bit  5: 4 RW ctrl_ahb_wr_burst_size. 0=ABH write request burst size 16;
//                                      1=ABH write request burst size 24;
//                                      2=ABH write request burst size 32;
//                                      3=ABH write request burst size 48.
// Bit  3: 2 RW ctrl_ahb_rd_burst_size. 0=ABH read request burst size 16;
//                                      1=ABH read request burst size 24;
//                                      2=ABH read request burst size 32;
//                                      3=ABH read request burst size 48.
// Bit     1 RW ctrl_sw_reset. 1=Reset RDMA logics except register.
// Bit     0 RW ctrl_free_clk_enable. 0=Default, Enable clock gating. 1=No clock gating, enable free clock.
#define RDMA_CTRL                                  ((0x1114  << 2) + 0xff000000)
// Read only.
// Bit 31:29 R  Rsrv.
// Bit    28 R  rdma_done_int.
// Bit 27:25 R  Rsrv.
// Bit 24:18 R  ahb_wrfifo_cnt. FIFO for buffering CBus read data to be sent to AHB
// Bit 17:11 R  ahb_rdfifo_cnt. FIFO for buffering data read from AHB.
// Bit 10: 8 R  ddr_req_st. =0 -- Idle; !=0 -- AHB interfacing ongoing.
// Bit  7: 4 R  curr_req. Latest requests that is being/been serviced. E.g. 0000=Idle; 0010=Latest serviced request is Req 1.
// Bit  3: 0 R  req_latch. Requests that are yet to be serviced. E.g. 0000=No request; 0001=Req 0 waiting; 1100=Req 2 and 3 waiting.
#define RDMA_STATUS                                ((0x1115  << 2) + 0xff000000)
#define RDMA_STATUS2                               ((0x1116  << 2) + 0xff000000)
#define RDMA_STATUS3                               ((0x1117  << 2) + 0xff000000)
#define RDMA_ACCESS_AUTO4                          ((0x1118  << 2) + 0xff000000)
#define RDMA_SRAM_CNTL                             ((0x1120  << 2) + 0xff000000)
#define RDMA_SRAM_REGADDR                          ((0x1121  << 2) + 0xff000000)
#define RDMA_SRAM_REGDATA                          ((0x1122  << 2) + 0xff000000)
#define RDMA_AUTO_SRC1_SEL                         ((0x1123  << 2) + 0xff000000)
#define RDMA_AUTO_SRC2_SEL                         ((0x1124  << 2) + 0xff000000)
#define RDMA_AUTO_SRC3_SEL                         ((0x1125  << 2) + 0xff000000)
#define RDMA_AUTO_SRC4_SEL                         ((0x1126  << 2) + 0xff000000)
#define RDMA_AUTO_SRC5_SEL                         ((0x1127  << 2) + 0xff000000)
#define RDMA_AUTO_SRC6_SEL                         ((0x1128  << 2) + 0xff000000)
#define RDMA_AUTO_SRC7_SEL                         ((0x1129  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for manual start DMA
#define RDMA_AHB_START_ADDR_MAN_MSB                ((0x1130  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for manual start DMA
#define RDMA_AHB_END_ADDR_MAN_MSB                  ((0x1131  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 1
#define RDMA_AHB_START_ADDR_1_MSB                  ((0x1132  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 1
#define RDMA_AHB_END_ADDR_1_MSB                    ((0x1133  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 2
#define RDMA_AHB_START_ADDR_2_MSB                  ((0x1134  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 2
#define RDMA_AHB_END_ADDR_2_MSB                    ((0x1135  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 3
#define RDMA_AHB_START_ADDR_3_MSB                  ((0x1136  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 3
#define RDMA_AHB_END_ADDR_3_MSB                    ((0x1137  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 4
#define RDMA_AHB_START_ADDR_4_MSB                  ((0x1138  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 4
#define RDMA_AHB_END_ADDR_4_MSB                    ((0x1139  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 5
#define RDMA_AHB_START_ADDR_5_MSB                  ((0x113a  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 5
#define RDMA_AHB_END_ADDR_5_MSB                    ((0x113b  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 6
#define RDMA_AHB_START_ADDR_6_MSB                  ((0x113c  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 6
#define RDMA_AHB_END_ADDR_6_MSB                    ((0x113d  << 2) + 0xff000000)
// Bit  1: 0 RW AHB start address[33:32] for auto start source 7
#define RDMA_AHB_START_ADDR_7_MSB                  ((0x113e  << 2) + 0xff000000)
// Bit  1: 0 RW AHB end address[33:32] for auto start source 7
#define RDMA_AHB_END_ADDR_7_MSB                    ((0x113f  << 2) + 0xff000000)
//
// Closing file:  ./rdma_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_vdin0_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VDIN0_VCBUS_BASE = 0x12
// -----------------------------------------------
//
// Reading file:  ./vpu_vdin_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
#define VDIN_SCALE_COEF_IDX                        ((0x1200  << 2) + 0xff000000)
#define VDIN_SCALE_COEF                            ((0x1201  << 2) + 0xff000000)
//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
//bit 30,   mpeg_field info which can be written by software
//Bit 29,   force go_field, pulse signal
//Bit 28,   force go_line, pulse signal
//Bit 27,   enable mpeg_go_field input signal
//Bit 26:20, hold lines
//Bit 19,   delay go_field function enable
//Bit 18:12, delay go_field line number
//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in
//Bit 5,   input window selection function enable
//Bit 4, enable VDIN common data input, otherwise there will be no video data input
//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: bt656 input, 3: component input, 4: tvdecoder input, 5: hdmi rx input, 6: digtial video input, 7: loopback from Viu1, 8: MIPI.
#define VDIN_COM_CTRL0                             ((0x1202  << 2) + 0xff000000)
//Bit 28:16 active_max_pix_cnt, readonly
//Bit 12:0  active_max_pix_cnt_shadow, readonly
#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS             ((0x1203  << 2) + 0xff000000)
//Bit 28:16 go_line_cnt, readonly
//Bit 12:0  active_line_cnt, readonly
#define VDIN_LCNT_STATUS                           ((0x1204  << 2) + 0xff000000)
//Readonly
//Bit [14:3] lfifo_buf_cnt
//Bit 2, vdin_direct_done status
//Bit 1, vdin_nr_done status
//Bit 0, field
#define VDIN_COM_STATUS0                           ((0x1205  << 2) + 0xff000000)
//Readonly
//Bit 31, vdi4 fifo overflow
//Bit 29:24, vdi3_asfifo_cnt
//Bit 23, vdi3 fifo overflow
//Bit 21:16, vdi3_asfifo_cnt
//Bit 15, vdi2 fifo overflow
//Bit 13:8, vdi2_asfifo_cnt
//Bit 7, vdi1 fifo overflow
//Bit 5:0, vdi1_asfifo_cnt
#define VDIN_COM_STATUS1                           ((0x1206  << 2) + 0xff000000)
//Bit 28:16 go_line_cnt_shadow, readonly
//Bit 12:0  active_line_cnt_shadow, readonly
#define VDIN_LCNT_SHADOW_STATUS                    ((0x1207  << 2) + 0xff000000)
//each 8bit asfifo_ctrl is following:
//Bit 7, DE  enable
//Bit 6, go field enable
//Bit 5, go line enable
//Bit 4, if true, negative active input vsync
//Bit 3, if true, negative active input hsync
//Bit 2, vsync soft reset fifo enable
//Bit 1, overflow status clear
//Bit 0 asfifo soft reset, level signal
//Bit 7:0 vdi1 asfifo_ctrl
//Bit 23:16 vdi2 asfifo_ctrl
#define VDIN_ASFIFO_CTRL0                          ((0x1208  << 2) + 0xff000000)
//Bit 7:0 vdi3 asfifo_ctrl
//Bit 23:16 vdi4 asfifo_ctrl
#define VDIN_ASFIFO_CTRL1                          ((0x1209  << 2) + 0xff000000)
//Bit 28:16 input width minus 1, after the window function
//Bit 12:0  output width minus 1
#define VDIN_WIDTHM1I_WIDTHM1O                     ((0x120a  << 2) + 0xff000000)
//Bit 20:17 prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 16:15 sp422_mode, special mode for the component1 and component2, 00: normal case, 01: 32 64 32, 10: 0 64 64 0, 11: 16 96 16
//Bit 14:8, hsc_ini_pixi_ptr, signed data, only useful when short_lineo_en is true
//Bit 7, prehsc_en
//Bit 6, hsc_en,
//Bit 5, hsc_short_lineo_en, short line output enable
//Bit 4, hsc_nearest_en
//Bit 3, hsc_phase0_always_en
//Bit 2:0, hsc_bank_length
#define VDIN_SC_MISC_CTRL                          ((0x120b  << 2) + 0xff000000)
//Bit 28:24, integer portion
//Bit 23:0, fraction portion
#define VDIN_HSC_PHASE_STEP                        ((0x120c  << 2) + 0xff000000)
//Bit 30:29    hscale rpt_p0_num
//Bit 28:24    hscale ini_rcv_num
//Bit 23:0     hscale ini_phase
#define VDIN_HSC_INI_CTRL                          ((0x120d  << 2) + 0xff000000)
//Read only
//Bit 23, vdi7 fifo overflow
//Bit 21:16, vdi7_asfifo_cnt
//Bit 15, vdi6 fifo overflow
//Bit 13:8, vdi6_asfifo_cnt
//Bit 7, vdi5 fifo overflow
//Bit 5:0, vdi5_asfifo_cnt
#define VDIN_COM_STATUS2                           ((0x120e  << 2) + 0xff000000)
//Bit 25:16 asfifo decimate control
//Bit 25, if true, decimation counter sync with first valid DE in the field,
//otherwise the decimation counter is not sync with external signal
//Bit 24, decimation de enable
//Bit 23:20, decimation phase, which counter value use to decimate,
//Bit 19:16, decimation number, 0: not decimation, 1: decimation 2, 2: decimation 3 ....
//Bit 7:0 vdi5 asfifo_ctrl
#define VDIN_ASFIFO_CTRL2                          ((0x120f  << 2) + 0xff000000)
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define VDIN_MATRIX_CTRL                           ((0x1210  << 2) + 0xff000000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VDIN_MATRIX_COEF00_01                      ((0x1211  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VDIN_MATRIX_COEF02_10                      ((0x1212  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VDIN_MATRIX_COEF11_12                      ((0x1213  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VDIN_MATRIX_COEF20_21                      ((0x1214  << 2) + 0xff000000)
//BIt 18:16 conv_rs
//Bit 12:0  coef22
#define VDIN_MATRIX_COEF22                         ((0x1215  << 2) + 0xff000000)
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VDIN_MATRIX_OFFSET0_1                      ((0x1216  << 2) + 0xff000000)
//Bit 10:0  offset2
#define VDIN_MATRIX_OFFSET2                        ((0x1217  << 2) + 0xff000000)
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VDIN_MATRIX_PRE_OFFSET0_1                  ((0x1218  << 2) + 0xff000000)
//Bit 10:0  pre_offset2
#define VDIN_MATRIX_PRE_OFFSET2                    ((0x1219  << 2) + 0xff000000)
//12:0 lfifo_buf_size
#define VDIN_LFIFO_CTRL                            ((0x121a  << 2) + 0xff000000)
#define VDIN_COM_GCLK_CTRL                         ((0x121b  << 2) + 0xff000000)
//12:0 VDIN input interface width minus 1, before the window function, after the de decimation
#define VDIN_INTF_WIDTHM1                          ((0x121c  << 2) + 0xff000000)
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define VDIN_LFIFO_URG_CTRL                        ((0x121e  << 2) + 0xff000000)
//Bit 8, 1: discard data before line fifo, 0: normal mode
//Bit 7:0 Write chroma canvas address
#define VDIN_WR_CTRL2                              ((0x121f  << 2) + 0xff000000)
//Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2. 0: Output every even pixels' CbCr;
//                                                            1: Output every odd pixels' CbCr;
//                                                            2: Output an average value per even&odd pair of pixels;
//                                                            3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.)
//Bit 29 no_clk_gate: disable vid_wr_mif clock gating function.
//Bit 28 clear write response counter in the vdin write memory interface
//Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line end indication in the vdin write memory interface
//Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1.
//Bit 23 vdin frame reset enble, if true, it will provide frame reset during go_field(vsync) to the modules after that
//Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will reset during go_field (vsync)
//Bit 21 vdin direct write done status clear bit
//Bit 20 vdin NR write done status clear bit
//Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12); 1: Output CrCb (NV21).
//Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even lines' CbCr;
//                                                       1: Output every odd lines' CbCr;
//                                                       2: Reserved;
//                                                       3: Output all CbCr.
//Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4 to luma canvas,
//                             2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit 31:30, 17:16, and bit 18.
//Bit 11 vdin write canvas double buffer enable, means the canvas address will be latched by vsync before using
//Bit 10 1: disable ctrl_reg write pulse which will reset internal counter. when bit 11 is 1, this bit should be 1.
//Bit 9 vdin write request urgent
//Bit 8 vdin write request enable
//Bit 7:0 Write luma canvas address
#define VDIN_WR_CTRL                               ((0x1220  << 2) + 0xff000000)
//Bit 29, if true, horizontal reverse
//Bit 28:16 start
//Bit 12:0  end
#define VDIN_WR_H_START_END                        ((0x1221  << 2) + 0xff000000)
//Bit 29, if true, vertical reverse
//Bit 28:16 start
//Bit 15:13 field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//Bit 12:0  end
#define VDIN_WR_V_START_END                        ((0x1222  << 2) + 0xff000000)
//Bit 24:20, integer portion
//Bit 19:0, fraction portion
#define VDIN_VSC_PHASE_STEP                        ((0x1223  << 2) + 0xff000000)
//Bit 23, vsc_en, vertical scaler enable
//Bit 22  if true, repeat last line while scaling, otherwise use the dummy data to extend the input picture
//Bit 21 vsc_phase0_always_en, when scale up, you have to set it to 1
//Bit 20:16 ini skip_line_num
//Bit 15:0 vscaler ini_phase
#define VDIN_VSC_INI_CTRL                          ((0x1224  << 2) + 0xff000000)
//Bit 28:16, vshrink input height minus 1
//Bit 12:0, scaler input height minus 1
#define VDIN_SCIN_HEIGHTM1                         ((0x1225  << 2) + 0xff000000)
//Bit 23:16, dummy component 0
//Bit 15:8, dummy component 1
//Bit 7:0, dummy component 2
#define VDIN_DUMMY_DATA                            ((0x1226  << 2) + 0xff000000)
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VDIN_MATRIX_PROBE_COLOR                    ((0x1228  << 2) + 0xff000000)
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VDIN_MATRIX_HL_COLOR                       ((0x1229  << 2) + 0xff000000)
//28:16 probe x, postion
//12:0  probe y, position
#define VDIN_MATRIX_PROBE_POS                      ((0x122a  << 2) + 0xff000000)
#define VDIN_CHROMA_ADDR_PORT                      ((0x122b  << 2) + 0xff000000)
#define VDIN_CHROMA_DATA_PORT                      ((0x122c  << 2) + 0xff000000)
//
#define VDIN_CM_BRI_CON_CTRL                       ((0x122d  << 2) + 0xff000000)
//Bit 17  clk_cyc_cnt_clr, if true, clear this register
//Bit 16 if true, use vpu clock to count one line, otherwise use actually hsync to count line_cnt
//Bit 15:0   line width using vpu clk
#define VDIN_GO_LINE_CTRL                          ((0x122f  << 2) + 0xff000000)
//Bit 31:24 hist_pix_white_th, larger than this th is counted as white pixel
//Bit 23:16 hist_pix_black_th, less than this th is counted as black pixel
//Bit 11    hist_34bin_only,   34 bin only mode, including white/black
//Bit 10:9  ldim_stts_din_sel, 00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 8     ldim_stts_en
//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define VDIN_HIST_CTRL                             ((0x1230  << 2) + 0xff000000)
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define VDIN_HIST_H_START_END                      ((0x1231  << 2) + 0xff000000)
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define VDIN_HIST_V_START_END                      ((0x1232  << 2) + 0xff000000)
//Bit 15:8  hist_max    maximum value
//Bit 7:0   hist_min    minimum value
//read only
#define VDIN_HIST_MAX_MIN                          ((0x1233  << 2) + 0xff000000)
//Bit 31:0  hist_spl_rd
//counts for the total luma value
//read only
#define VDIN_HIST_SPL_VAL                          ((0x1234  << 2) + 0xff000000)
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define VDIN_HIST_SPL_PIX_CNT                      ((0x1235  << 2) + 0xff000000)
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value
//read only
#define VDIN_HIST_CHROMA_SUM                       ((0x1236  << 2) + 0xff000000)
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
//VDIN_DNLP_HIST00[31:16] counts for the second bin
//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define VDIN_DNLP_HIST00                           ((0x1237  << 2) + 0xff000000)
#define VDIN_DNLP_HIST01                           ((0x1238  << 2) + 0xff000000)
#define VDIN_DNLP_HIST02                           ((0x1239  << 2) + 0xff000000)
#define VDIN_DNLP_HIST03                           ((0x123a  << 2) + 0xff000000)
#define VDIN_DNLP_HIST04                           ((0x123b  << 2) + 0xff000000)
#define VDIN_DNLP_HIST05                           ((0x123c  << 2) + 0xff000000)
#define VDIN_DNLP_HIST06                           ((0x123d  << 2) + 0xff000000)
#define VDIN_DNLP_HIST07                           ((0x123e  << 2) + 0xff000000)
#define VDIN_DNLP_HIST08                           ((0x123f  << 2) + 0xff000000)
#define VDIN_DNLP_HIST09                           ((0x1240  << 2) + 0xff000000)
#define VDIN_DNLP_HIST10                           ((0x1241  << 2) + 0xff000000)
#define VDIN_DNLP_HIST11                           ((0x1242  << 2) + 0xff000000)
#define VDIN_DNLP_HIST12                           ((0x1243  << 2) + 0xff000000)
#define VDIN_DNLP_HIST13                           ((0x1244  << 2) + 0xff000000)
#define VDIN_DNLP_HIST14                           ((0x1245  << 2) + 0xff000000)
#define VDIN_DNLP_HIST15                           ((0x1246  << 2) + 0xff000000)
#define VDIN_DNLP_HIST16                           ((0x1247  << 2) + 0xff000000)
#define VDIN_DNLP_HIST17                           ((0x1248  << 2) + 0xff000000)
#define VDIN_DNLP_HIST18                           ((0x1249  << 2) + 0xff000000)
#define VDIN_DNLP_HIST19                           ((0x124a  << 2) + 0xff000000)
#define VDIN_DNLP_HIST20                           ((0x124b  << 2) + 0xff000000)
#define VDIN_DNLP_HIST21                           ((0x124c  << 2) + 0xff000000)
#define VDIN_DNLP_HIST22                           ((0x124d  << 2) + 0xff000000)
#define VDIN_DNLP_HIST23                           ((0x124e  << 2) + 0xff000000)
#define VDIN_DNLP_HIST24                           ((0x124f  << 2) + 0xff000000)
#define VDIN_DNLP_HIST25                           ((0x1250  << 2) + 0xff000000)
#define VDIN_DNLP_HIST26                           ((0x1251  << 2) + 0xff000000)
#define VDIN_DNLP_HIST27                           ((0x1252  << 2) + 0xff000000)
#define VDIN_DNLP_HIST28                           ((0x1253  << 2) + 0xff000000)
#define VDIN_DNLP_HIST29                           ((0x1254  << 2) + 0xff000000)
#define VDIN_DNLP_HIST30                           ((0x1255  << 2) + 0xff000000)
#define VDIN_DNLP_HIST31                           ((0x1256  << 2) + 0xff000000)
//Bit 31, local dimming statistic enable
//Bit 28, eol enable
//Bit 27:25, vertical line overlap number for max finding
//Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//Bit 15, 1: region read index auto increase per read to VDIN_LDIM_STTS_HIST_READ_REGION
//Bit 6:0, region read index
//`define VDIN_LDIM_STTS_HIST_REGION_IDX       8'h57
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
//`define VDIN_LDIM_STTS_HIST_SET_REGION       8'h58
//REGION STATISTIC DATA READ OUT PORT, bit 29:20 max_comp2, bit 19:10 max_comp1, bit 9:0 max_comp0
//`define VDIN_LDIM_STTS_HIST_READ_REGION      8'h59
//Bit 18, reset bit, high active
//Bit 17, if true, widen hs/vs pulse
//Bit 16  vsync total counter always accumulating enable
//Bit 14:12, select hs/vs of video input channel to measure, 0: no selection, 1: vdi1, 2: vid2, 3: vid3, 4:vid4, 5:vdi5, 6:vid6, 7:vdi7, 8: vdi8
//Bit 11:4, vsync_span, define how many vsync span need to measure
//Bit 2:0  meas_hs_index, index to select which HS counter/range
#define VDIN_MEAS_CTRL0                            ((0x125a  << 2) + 0xff000000)
//Read only
//19:16     meas_ind_total_count_n, every number of sync_span vsyncs, this count add 1
//15:0      high bit portion of vsync total counter
#define VDIN_MEAS_VS_COUNT_HI                      ((0x125b  << 2) + 0xff000000)
//Read only
//31:0, low bit portion of vsync total counter
#define VDIN_MEAS_VS_COUNT_LO                      ((0x125c  << 2) + 0xff000000)
//according to the meas_hs_index in register VDIN_MEAS_CTRL0
//meas_hs_index == 0, first hs range
//meas_hs_index == 1, second hs range
//meas_hs_index == 2, third hs range
//meas_hs_index == 3, fourth hs range
//bit 28:16 count_start
//bit 12:0 count_end
#define VDIN_MEAS_HS_RANGE                         ((0x125d  << 2) + 0xff000000)
//Read only
//according to the meas_hs_index in register VDIN_MEAS_CTRL0,
//meas_hs_index == 0, first range hs counter,
//meas_hs_index == 1, second range hs coutner
//meas_hs_index == 2, third range hs coutner
//meas_hs_index == 3, fourth range hs coutner
//23:0
#define VDIN_MEAS_HS_COUNT                         ((0x125e  << 2) + 0xff000000)
//Bit 8      white_enable
//Bit 7:0    blkbar_white_level
#define VDIN_BLKBAR_CTRL1                          ((0x125f  << 2) + 0xff000000)
// Bit 31:24 blkbar_black_level    threshold to judge a black point
// Bit 23:21 Reserved
// Bit 20:8  blkbar_hwidth         left and right region width
// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
// Bit 3     blkbar_det_en
// Bit 2:1   blkbar_din_sel
// bit blkbar_det_top_en
#define VDIN_BLKBAR_CTRL0                          ((0x1260  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 blkbar_hstart.        Left region start
// Bit 15:13 Reserved
// Bit 12:0  blkbar_hend.          Right region end
#define VDIN_BLKBAR_H_START_END                    ((0x1261  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 blkbar_vstart
// Bit 15:13 Reserved
// Bit 12:0  blkbar_vend
#define VDIN_BLKBAR_V_START_END                    ((0x1262  << 2) + 0xff000000)
// Bit 31:20 Reserved
// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black
#define VDIN_BLKBAR_CNT_THRESHOLD                  ((0x1263  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
// Bit 15:13 Reserved
// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
#define VDIN_BLKBAR_ROW_TH1_TH2                    ((0x1264  << 2) + 0xff000000)
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
#define VDIN_BLKBAR_IND_LEFT_START_END             ((0x1265  << 2) + 0xff000000)
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
#define VDIN_BLKBAR_IND_RIGHT_START_END            ((0x1266  << 2) + 0xff000000)
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
#define VDIN_BLKBAR_IND_LEFT1_CNT                  ((0x1267  << 2) + 0xff000000)
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. right part of the left region
#define VDIN_BLKBAR_IND_LEFT2_CNT                  ((0x1268  << 2) + 0xff000000)
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
#define VDIN_BLKBAR_IND_RIGHT1_CNT                 ((0x1269  << 2) + 0xff000000)
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
#define VDIN_BLKBAR_IND_RIGHT2_CNT                 ((0x126a  << 2) + 0xff000000)
//Readonly
// Bit 31:30 Reserved
// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
// Bit 28:16 blkbar_top_pos.            Top black bar position
// Bit 15:13 Reserved.
// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
#define VDIN_BLKBAR_STATUS0                        ((0x126b  << 2) + 0xff000000)
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_left_pos.       Left black bar position
// Bit 15:13 Reserved
// Bit 12:0  blkbar_right_pos.      Right black bar position
#define VDIN_BLKBAR_STATUS1                        ((0x126c  << 2) + 0xff000000)
//Bit 28:16 input window H start
//Bit 12:0  input window H end
#define VDIN_WIN_H_START_END                       ((0x126d  << 2) + 0xff000000)
//Bit 28:16 input window H start
//Bit 12:0  input window V start
#define VDIN_WIN_V_START_END                       ((0x126e  << 2) + 0xff000000)
//Bit 23:16 vdi8 asfifo_ctrl
//Bit 15:8 vdi7 asfifo_ctrl
//Bit 7:0 vdi6 asfifo_ctrl
#define VDIN_ASFIFO_CTRL3                          ((0x126f  << 2) + 0xff000000)
//Bit 3:2 vshrk_clk2_ctrl
//Bit 1:0 vshrk_clk1_ctrl
#define VDIN_COM_GCLK_CTRL2                        ((0x1270  << 2) + 0xff000000)
//Bit 27 vshrk_en
//Bit 26:25 vshrk_mode
//Bit 24 vshrk_lpf_mode
//Bit 23:0 vshrk_dummy
#define VDIN_VSHRK_CTRL                            ((0x1271  << 2) + 0xff000000)
#define VDIN_DNLP_HIST32                           ((0x1272  << 2) + 0xff000000)
//Read only
//Bit 7, vdi9 fifo overflow
//Bit 5:0, vdi9_asfifo_cnt
#define VDIN_COM_STATUS3                           ((0x1273  << 2) + 0xff000000)
#define VDIN_SYNC_MASK                             ((0x1274  << 2) + 0xff000000)
//Bit 7:0,  hsync_mask_num
//Bit 15:8, vsync_mask_num
//Bit 16,   hsync_mask_enable
//Bit 17,   vsync_mask_num
//dolby vdin
#define VDIN_DOLBY_DSC_CTRL0                       ((0x1275  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_CTRL1                       ((0x1276  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_CTRL2                       ((0x1277  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_CTRL3                       ((0x1278  << 2) + 0xff000000)
#define VDIN_DOLBY_AXI_CTRL0                       ((0x1279  << 2) + 0xff000000)
#define VDIN_DOLBY_AXI_CTRL1                       ((0x127a  << 2) + 0xff000000)
#define VDIN_DOLBY_AXI_CTRL2                       ((0x127b  << 2) + 0xff000000)
#define VDIN_DOLBY_AXI_CTRL3                       ((0x127c  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_STATUS0                     ((0x127d  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_STATUS1                     ((0x127e  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_STATUS2                     ((0x127f  << 2) + 0xff000000)
#define VDIN_DOLBY_DSC_STATUS3                     ((0x121d  << 2) + 0xff000000)
//hdr2 0x80 - -0xc0
#define VDIN_HDR2_CTRL                             ((0x1280  << 2) + 0xff000000)
#define VDIN_HDR2_CLK_GATE                         ((0x1281  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF00_01                ((0x1282  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF02_10                ((0x1283  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF11_12                ((0x1284  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF20_21                ((0x1285  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF22                   ((0x1286  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF30_31                ((0x1287  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF32_40                ((0x1288  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_COEF41_42                ((0x1289  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_OFFSET0_1                ((0x128a  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_OFFSET2                  ((0x128b  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_PRE_OFFSET0_1            ((0x128c  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_PRE_OFFSET2              ((0x128d  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF00_01                ((0x128e  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF02_10                ((0x128f  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF11_12                ((0x1290  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF20_21                ((0x1291  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF22                   ((0x1292  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF30_31                ((0x1293  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF32_40                ((0x1294  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_COEF41_42                ((0x1295  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_OFFSET0_1                ((0x1296  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_OFFSET2                  ((0x1297  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_PRE_OFFSET0_1            ((0x1298  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_PRE_OFFSET2              ((0x1299  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_CLIP                     ((0x129a  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_CLIP                     ((0x129b  << 2) + 0xff000000)
#define VDIN_HDR2_CGAIN_OFFT                       ((0x129c  << 2) + 0xff000000)
#define VDIN_EOTF_LUT_ADDR_PORT                    ((0x129e  << 2) + 0xff000000)
#define VDIN_EOTF_LUT_DATA_PORT                    ((0x129f  << 2) + 0xff000000)
#define VDIN_OETF_LUT_ADDR_PORT                    ((0x12a0  << 2) + 0xff000000)
#define VDIN_OETF_LUT_DATA_PORT                    ((0x12a1  << 2) + 0xff000000)
#define VDIN_CGAIN_LUT_ADDR_PORT                   ((0x12a2  << 2) + 0xff000000)
#define VDIN_CGAIN_LUT_DATA_PORT                   ((0x12a3  << 2) + 0xff000000)
#define VDIN_HDR2_CGAIN_COEF0                      ((0x12a4  << 2) + 0xff000000)
#define VDIN_HDR2_CGAIN_COEF1                      ((0x12a5  << 2) + 0xff000000)
#define VDIN_OGAIN_LUT_ADDR_PORT                   ((0x12a6  << 2) + 0xff000000)
#define VDIN_OGAIN_LUT_DATA_PORT                   ((0x12a7  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_CTRL                        ((0x12a8  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_ALPHA0                      ((0x12a9  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_ALPHA1                      ((0x12aa  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_BETA0                       ((0x12ab  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_BETA1                       ((0x12ac  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_BETA2                       ((0x12ad  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_COEF0                       ((0x12ae  << 2) + 0xff000000)
#define VDIN_HDR2_ADPS_COEF1                       ((0x12af  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_CTRL                        ((0x12b0  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_COEF0                       ((0x12b1  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_COEF1                       ((0x12b2  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_COEF2                       ((0x12b3  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_COEF3                       ((0x12b4  << 2) + 0xff000000)
#define VDIN_HDR2_GMUT_COEF4                       ((0x12b5  << 2) + 0xff000000)
#define VDIN_HDR2_PIPE_CTRL1                       ((0x12b6  << 2) + 0xff000000)
#define VDIN_HDR2_PIPE_CTRL2                       ((0x12b7  << 2) + 0xff000000)
#define VDIN_HDR2_PIPE_CTRL3                       ((0x12b8  << 2) + 0xff000000)
#define VDIN_HDR2_PROC_WIN1                        ((0x12b9  << 2) + 0xff000000)
#define VDIN_HDR2_PROC_WIN2                        ((0x12ba  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXI_EN_CTRL                  ((0x12bb  << 2) + 0xff000000)
#define VDIN_HDR2_MATRIXO_EN_CTRL                  ((0x12bc  << 2) + 0xff000000)
#define VDIN_HDR2_HIST_CTRL                        ((0x12bd  << 2) + 0xff000000)
#define VDIN_HDR2_HIST_H_START_END                 ((0x12be  << 2) + 0xff000000)
#define VDIN_HDR2_HIST_V_START_END                 ((0x12bf  << 2) + 0xff000000)
#define VDIN_HDR2_HIST_RD                          ((0x129d  << 2) + 0xff000000)
#define VDIN_WRARB_MODE                            ((0x12c0  << 2) + 0xff000000)
#define VDIN_WRARB_REQEN_SLV                       ((0x12c1  << 2) + 0xff000000)
#define VDIN_WRARB_WEIGH0_SLV                      ((0x12c2  << 2) + 0xff000000)
#define VDIN_WRARB_WEIGH1_SLV                      ((0x12c3  << 2) + 0xff000000)
#define VDIN_RDWR_ARB_STATUS                       ((0x12c4  << 2) + 0xff000000)
#define VDIN_ARB_DBG_CTRL                          ((0x12c5  << 2) + 0xff000000)
#define VDIN_ARB_DBG_STAT                          ((0x12c6  << 2) + 0xff000000)
#define VDIN_DBG_AXI_CMD_CNT                       ((0x12c7  << 2) + 0xff000000)
#define VDIN_DBG_AXI_DAT_CNT                       ((0x12c8  << 2) + 0xff000000)
#define VDIN_CRC_CTRL                              ((0x12c9  << 2) + 0xff000000)
#define VDIN_RO_CRC                                ((0x12ca  << 2) + 0xff000000)
#define VDIN_LINE_INT                              ((0x12cb  << 2) + 0xff000000)
#define VDIN_WR_URGENT_CTRL                        ((0x1257  << 2) + 0xff000000)
#define VDIN_RO_WRMIF_STATUS                       ((0x1258  << 2) + 0xff000000)
#define VDIN_WR_BADDR_LUMA                         ((0x12cc  << 2) + 0xff000000)
#define VDIN_WR_BADDR_CHROMA                       ((0x12cd  << 2) + 0xff000000)
#define VDIN_WR_STRIDE_LUMA                        ((0x12ce  << 2) + 0xff000000)
#define VDIN_WR_STRIDE_CHROMA                      ((0x12cf  << 2) + 0xff000000)
//for vdin dolby descramble start
#define VDIN_DSC_CTRL                              ((0x12d0  << 2) + 0xff000000)
//Bit   31:10     reserved
//Bit   9:4       reg_dithout_switch  ,uns, default = 36;//{2'h2,2'h1,2'h0}
//Bit   3,        reg_detunnel_en     ,uns, default = 1;
//Bit   2,        reg_detunnel_u_start,uns, default = 0;
//Bit   1,        reg_vdin_dith_en    ,uns, default = 1;
//Bit   0,        reg_descramble_en   ,uns, default = 1;
#define VDIN_CFMT_CTRL                             ((0x12d1  << 2) + 0xff000000)
//Bit 31:9  reserved
//Bit 8     reg_chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 7:4   reg_chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 3     reg_chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 2:1   reg_chfmt_yc_ratio         uns, default = 1    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 0     reg_chfmt_en               uns, default = 1    ; //  horizontal formatter enable
#define VDIN_CFMT_W                                ((0x12d2  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_chfmt_w                uns, default = 1920   ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  reg_cvfmt_w                uns, default = 960    ;vertical formatter width
#define VDIN_SCB_CTRL0                             ((0x12d3  << 2) + 0xff000000)
//Bit   31:24   reserved
//Bit   28      reg_scb2_enable             uns, default = 0;
//Bit   27      reg_scb2_444c422_gofield_en uns, default = 1;
//Bit   26      reg_scb2_tunnel_en          uns, default = 1;
//Bit   25:20   reg_scb2_tunnel_outswitch   uns, default = 36;//{2'h2,2'h1,2'h0}
//Bit   19:18   reg_scb2_444c422_mode       uns, default = 0; //0:left 1:right 2,3:avg
//Bit   17      reg_scb2_444c422_bypass     uns, default = 0; 1:bypass
//Bit   16      reserved                    //pulse for frm_en
//
//Bit   11      reg_444c422_gofield_en     uns, default = 1;
//Bit   10      reg_tunnel_en              uns, default = 1;
//Bit   9:4     reg_tunnel_outswitch       uns, default = 36;//{2'h2,2'h1,2'h0}
//Bit   3:2     reg_444c422_mode           uns, default = 0; //0:left 1:right 2,3:avg
//Bit   1       reg_444c422_bypass         uns, default = 0; 1:bypass
//Bit   0       reserved                   //pulse for frm_en
#define VDIN_SCB_CTRL1                             ((0x12d4  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_444c422_hsize    uns, default = 1920   ;horizontal size
//Bit 15:13 reserved
//Bit 12:0  reg_444c422_vsize    uns, default = 960    ;vertical size
#define VDIN_DSC_HSIZE                             ((0x12d5  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_detunnel_hsize uns, default = 1920   ;
//Bit 15:13 reserved
//Bit 12:0  reg_dither_hsize   uns, default = 1920   ;
#define VDIN_DSC_DETUNNEL_SEL                      ((0x12d6  << 2) + 0xff000000)
//Bit 31:18 reserved
//Bit 17:0  reg_detunnel_sel   uns, default = 34658;  //{3'h1,3'h0,3'h3  ,3'h5,3'h4,3'h2}
#define VDIN_DSC_TUNNEL_SEL                        ((0x12d7  << 2) + 0xff000000)
//Bit 31:18 reserved
//Bit 17:0  reg_tunnel_sel   uns, default = 69868;  //= {3'h2,3'h1  ,3'h0,3'h3  ,3'h5,3'h4};
#define VDIN_SCB_CTRL2                             ((0x12da  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_scb2_444c422_hsize    uns, default = 1920   ;horizontal size
//Bit 15:13 reserved
//Bit 12:0  reg_scb2_444c422_vsize    uns, default = 960    ;vertical size
#define VDIN_HDR2_SIZE                             ((0x12d8  << 2) + 0xff000000)
#define VDIN_VSHRK_SIZE_M1                         ((0x12d9  << 2) + 0xff000000)
//dither
#define VDIN_DITH_CTRL                             ((0x12e0  << 2) + 0xff000000)
#define VDIN_DITH_LUT_1                            ((0x12e1  << 2) + 0xff000000)
#define VDIN_DITH_LUT_2                            ((0x12e2  << 2) + 0xff000000)
#define VDIN_DITH_LUT_3                            ((0x12e3  << 2) + 0xff000000)
#define VDIN_DITH_LUT_4                            ((0x12e4  << 2) + 0xff000000)
#define VDIN_DITH_LUT_5                            ((0x12e5  << 2) + 0xff000000)
#define VDIN_DITH_LUT_6                            ((0x12e6  << 2) + 0xff000000)
#define VDIN_DITH_LUT_7                            ((0x12e7  << 2) + 0xff000000)
#define VDIN_DITH_LUT_8                            ((0x12e8  << 2) + 0xff000000)
#define VDIN_DITH_LUT_9                            ((0x12e9  << 2) + 0xff000000)
#define VDIN_DITH_LUT_10                           ((0x12ea  << 2) + 0xff000000)
#define VDIN_DITH_LUT_11                           ((0x12eb  << 2) + 0xff000000)
#define VDIN_DITH_LUT_12                           ((0x12ec  << 2) + 0xff000000)
//for vdin dolby descramble end
#define VDIN_HSK_CTRL                              ((0x12ef  << 2) + 0xff000000)
//Bit   31:23    reserved
//Bit   22:16    reg_hsk_size  ,uns, default = 4;
//Bit   15:13    reserved
//Bit   12:0     reg_frm_hsize ,uns, default = 1920;
#define VDIN_HSK_COEF_0                            ((0x12f0  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef00  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_1                            ((0x12f1  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef01  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_2                            ((0x12f2  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef02  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_3                            ((0x12f3  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef03  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define VDIN_HSK_COEF_4                            ((0x12f4  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef04  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_5                            ((0x12f5  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef05  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_6                            ((0x12f6  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef06  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_7                            ((0x12f7  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef07  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define VDIN_HSK_COEF_8                            ((0x12f8  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef08  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_9                            ((0x12f9  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef09  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_A                            ((0x12fa  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef10  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_B                            ((0x12fb  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef11  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
//
#define VDIN_HSK_COEF_C                            ((0x12fc  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef12  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_D                            ((0x12fd  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef13  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_E                            ((0x12fe  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef14  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
#define VDIN_HSK_COEF_F                            ((0x12ff  << 2) + 0xff000000)
//Bit  31:0   reg_hsk_coef15  ,uns, default = 0;//[29:24] [21:16] [13:8] [5:0] is used
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_vdin_regs.h
//

//8'h72 occupied by histogram 32
//VDIN0        8'h00 - 8'h7f
#define VDIN0_SCALE_COEF_IDX                    (VDIN_SCALE_COEF_IDX               )
#define VDIN0_SCALE_COEF                        (VDIN_SCALE_COEF                   )
#define VDIN0_COM_CTRL0                         (VDIN_COM_CTRL0                    )
#define VDIN0_ACTIVE_MAX_PIX_CNT_STATUS         (VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN0_LCNT_STATUS                       (VDIN_LCNT_STATUS                  )
#define VDIN0_COM_STATUS0                       (VDIN_COM_STATUS0                  )
#define VDIN0_COM_STATUS1                       (VDIN_COM_STATUS1                  )
#define VDIN0_LCNT_SHADOW_STATUS                (VDIN_LCNT_SHADOW_STATUS           )
#define VDIN0_ASFIFO_CTRL0                      (VDIN_ASFIFO_CTRL0                 )
#define VDIN0_ASFIFO_CTRL1                      (VDIN_ASFIFO_CTRL1                 )
#define VDIN0_WIDTHM1I_WIDTHM1O                 (VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN0_SC_MISC_CTRL                      (VDIN_SC_MISC_CTRL                 )
#define VDIN0_HSC_PHASE_STEP                    (VDIN_HSC_PHASE_STEP               )
#define VDIN0_HSC_INI_CTRL                      (VDIN_HSC_INI_CTRL                 )
#define VDIN0_COM_STATUS2                       (VDIN_COM_STATUS2                  )
#define VDIN0_COM_STATUS3                       (VDIN_COM_STATUS3                  )
#define VDIN0_ASFIFO_CTRL2                      (VDIN_ASFIFO_CTRL2                 )
#define VDIN0_MATRIX_CTRL                       (VDIN_MATRIX_CTRL                  )
#define VDIN0_MATRIX_COEF00_01                  (VDIN_MATRIX_COEF00_01             )
#define VDIN0_MATRIX_COEF02_10                  (VDIN_MATRIX_COEF02_10             )
#define VDIN0_MATRIX_COEF11_12                  (VDIN_MATRIX_COEF11_12             )
#define VDIN0_MATRIX_COEF20_21                  (VDIN_MATRIX_COEF20_21             )
#define VDIN0_MATRIX_COEF22                     (VDIN_MATRIX_COEF22                )
#define VDIN0_MATRIX_OFFSET0_1                  (VDIN_MATRIX_OFFSET0_1             )
#define VDIN0_MATRIX_OFFSET2                    (VDIN_MATRIX_OFFSET2               )
#define VDIN0_MATRIX_PRE_OFFSET0_1              (VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN0_MATRIX_PRE_OFFSET2                (VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN0_LFIFO_CTRL                        (VDIN_LFIFO_CTRL                   )
#define VDIN0_COM_GCLK_CTRL                     (VDIN_COM_GCLK_CTRL                )
#define VDIN0_INTF_WIDTHM1                      (VDIN_INTF_WIDTHM1                 )
#define VDIN0_WR_CTRL2                          (VDIN_WR_CTRL2                     )
#define VDIN0_WR_CTRL                           (VDIN_WR_CTRL                      )
#define VDIN0_WR_H_START_END                    (VDIN_WR_H_START_END               )
#define VDIN0_WR_V_START_END                    (VDIN_WR_V_START_END               )
#define VDIN0_VSC_PHASE_STEP                    (VDIN_VSC_PHASE_STEP               )
#define VDIN0_VSC_INI_CTRL                      (VDIN_VSC_INI_CTRL                 )
#define VDIN0_SCIN_HEIGHTM1                     (VDIN_SCIN_HEIGHTM1                )
#define VDIN0_DUMMY_DATA                        (VDIN_DUMMY_DATA                   )
#define VDIN0_MATRIX_PROBE_COLOR                (VDIN_MATRIX_PROBE_COLOR           )
#define VDIN0_MATRIX_HL_COLOR                   (VDIN_MATRIX_HL_COLOR              )
#define VDIN0_MATRIX_PROBE_POS                  (VDIN_MATRIX_PROBE_POS             )
#define VDIN0_CHROMA_ADDR_PORT                  (VDIN_CHROMA_ADDR_PORT             )
#define VDIN0_CHROMA_DATA_PORT                  (VDIN_CHROMA_DATA_PORT             )
#define VDIN0_CM_BRI_CON_CTRL                   (VDIN_CM_BRI_CON_CTRL              )
#define VDIN0_GO_LINE_CTRL                      (VDIN_GO_LINE_CTRL                 )
#define VDIN0_HIST_CTRL                         (VDIN_HIST_CTRL                    )
#define VDIN0_HIST_H_START_END                  (VDIN_HIST_H_START_END             )
#define VDIN0_HIST_V_START_END                  (VDIN_HIST_V_START_END             )
#define VDIN0_HIST_MAX_MIN                      (VDIN_HIST_MAX_MIN                 )
#define VDIN0_HIST_SPL_VAL                      (VDIN_HIST_SPL_VAL                 )
#define VDIN0_HIST_SPL_PIX_CNT                  (VDIN_HIST_SPL_PIX_CNT             )
#define VDIN0_HIST_CHROMA_SUM                   (VDIN_HIST_CHROMA_SUM              )
#define VDIN0_DNLP_HIST00                       (VDIN_DNLP_HIST00                  )
#define VDIN0_DNLP_HIST01                       (VDIN_DNLP_HIST01                  )
#define VDIN0_DNLP_HIST02                       (VDIN_DNLP_HIST02                  )
#define VDIN0_DNLP_HIST03                       (VDIN_DNLP_HIST03                  )
#define VDIN0_DNLP_HIST04                       (VDIN_DNLP_HIST04                  )
#define VDIN0_DNLP_HIST05                       (VDIN_DNLP_HIST05                  )
#define VDIN0_DNLP_HIST06                       (VDIN_DNLP_HIST06                  )
#define VDIN0_DNLP_HIST07                       (VDIN_DNLP_HIST07                  )
#define VDIN0_DNLP_HIST08                       (VDIN_DNLP_HIST08                  )
#define VDIN0_DNLP_HIST09                       (VDIN_DNLP_HIST09                  )
#define VDIN0_DNLP_HIST10                       (VDIN_DNLP_HIST10                  )
#define VDIN0_DNLP_HIST11                       (VDIN_DNLP_HIST11                  )
#define VDIN0_DNLP_HIST12                       (VDIN_DNLP_HIST12                  )
#define VDIN0_DNLP_HIST13                       (VDIN_DNLP_HIST13                  )
#define VDIN0_DNLP_HIST14                       (VDIN_DNLP_HIST14                  )
#define VDIN0_DNLP_HIST15                       (VDIN_DNLP_HIST15                  )
#define VDIN0_DNLP_HIST16                       (VDIN_DNLP_HIST16                  )
#define VDIN0_DNLP_HIST17                       (VDIN_DNLP_HIST17                  )
#define VDIN0_DNLP_HIST18                       (VDIN_DNLP_HIST18                  )
#define VDIN0_DNLP_HIST19                       (VDIN_DNLP_HIST19                  )
#define VDIN0_DNLP_HIST20                       (VDIN_DNLP_HIST20                  )
#define VDIN0_DNLP_HIST21                       (VDIN_DNLP_HIST21                  )
#define VDIN0_DNLP_HIST22                       (VDIN_DNLP_HIST22                  )
#define VDIN0_DNLP_HIST23                       (VDIN_DNLP_HIST23                  )
#define VDIN0_DNLP_HIST24                       (VDIN_DNLP_HIST24                  )
#define VDIN0_DNLP_HIST25                       (VDIN_DNLP_HIST25                  )
#define VDIN0_DNLP_HIST26                       (VDIN_DNLP_HIST26                  )
#define VDIN0_DNLP_HIST27                       (VDIN_DNLP_HIST27                  )
#define VDIN0_DNLP_HIST28                       (VDIN_DNLP_HIST28                  )
#define VDIN0_DNLP_HIST29                       (VDIN_DNLP_HIST29                  )
#define VDIN0_DNLP_HIST30                       (VDIN_DNLP_HIST30                  )
#define VDIN0_DNLP_HIST31                       (VDIN_DNLP_HIST31                  )
#define VDIN0_DNLP_HIST32                       (VDIN_DNLP_HIST32                  )
#define VDIN0_MEAS_CTRL0                        (VDIN_MEAS_CTRL0                   )
#define VDIN0_MEAS_VS_COUNT_HI                  (VDIN_MEAS_VS_COUNT_HI             )
#define VDIN0_MEAS_VS_COUNT_LO                  (VDIN_MEAS_VS_COUNT_LO             )
#define VDIN0_MEAS_HS_RANGE                     (VDIN_MEAS_HS_RANGE                )
#define VDIN0_MEAS_HS_COUNT                     (VDIN_MEAS_HS_COUNT                )
#define VDIN0_BLKBAR_CTRL1                      (VDIN_BLKBAR_CTRL1                 )
#define VDIN0_BLKBAR_CTRL0                      (VDIN_BLKBAR_CTRL0                 )
#define VDIN0_BLKBAR_H_START_END                (VDIN_BLKBAR_H_START_END           )
#define VDIN0_BLKBAR_V_START_END                (VDIN_BLKBAR_V_START_END           )
#define VDIN0_BLKBAR_CNT_THRESHOLD              (VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN0_BLKBAR_ROW_TH1_TH2                (VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN0_BLKBAR_IND_LEFT_START_END         (VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN0_BLKBAR_IND_RIGHT_START_END        (VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN0_BLKBAR_IND_LEFT1_CNT              (VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN0_BLKBAR_IND_LEFT2_CNT              (VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN0_BLKBAR_IND_RIGHT1_CNT             (VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN0_BLKBAR_IND_RIGHT2_CNT             (VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN0_BLKBAR_STATUS0                    (VDIN_BLKBAR_STATUS0               )
#define VDIN0_BLKBAR_STATUS1                    (VDIN_BLKBAR_STATUS1               )
#define VDIN0_WIN_H_START_END                   (VDIN_WIN_H_START_END              )
#define VDIN0_WIN_V_START_END                   (VDIN_WIN_V_START_END              )
#define VDIN0_ASFIFO_CTRL3                      (VDIN_ASFIFO_CTRL3                 )
#define VDIN0_LFIFO_URG_CTRL                    (VDIN_LFIFO_URG_CTRL               )
#define VDIN0_COM_GCLK_CTRL2                    (VDIN_COM_GCLK_CTRL2               )
#define VDIN0_VSHRK_CTRL                        (VDIN_VSHRK_CTRL                   )
#define VDIN0_SYNC_MASK                         (VDIN_SYNC_MASK                    )
#define VDIN0_DOLBY_DSC_CTRL0                   (VDIN_DOLBY_DSC_CTRL0  )
#define VDIN0_DOLBY_DSC_CTRL1                   (VDIN_DOLBY_DSC_CTRL1  )
#define VDIN0_DOLBY_DSC_CTRL2                   (VDIN_DOLBY_DSC_CTRL2  )
#define VDIN0_DOLBY_DSC_CTRL3                   (VDIN_DOLBY_DSC_CTRL3  )
#define VDIN0_DOLBY_AXI_CTRL0                   (VDIN_DOLBY_AXI_CTRL0  )
#define VDIN0_DOLBY_AXI_CTRL1                   (VDIN_DOLBY_AXI_CTRL1  )
#define VDIN0_DOLBY_AXI_CTRL2                   (VDIN_DOLBY_AXI_CTRL2  )
#define VDIN0_DOLBY_AXI_CTRL3                   (VDIN_DOLBY_AXI_CTRL3  )
#define VDIN0_DOLBY_DSC_STATUS0                 (VDIN_DOLBY_DSC_STATUS0)
#define VDIN0_DOLBY_DSC_STATUS1                 (VDIN_DOLBY_DSC_STATUS1)
#define VDIN0_DOLBY_DSC_STATUS2                 (VDIN_DOLBY_DSC_STATUS2)
#define VDIN0_DOLBY_DSC_STATUS3                 (VDIN_DOLBY_DSC_STATUS3)
#define VDIN0_HDR2_CTRL                           VDIN_HDR2_CTRL
#define VDIN0_HDR2_CLK_GATE                       VDIN_HDR2_CLK_GATE
#define VDIN0_HDR2_MATRIXI_COEF00_01              VDIN_HDR2_MATRIXI_COEF00_01
#define VDIN0_HDR2_MATRIXI_COEF02_10              VDIN_HDR2_MATRIXI_COEF02_10
#define VDIN0_HDR2_MATRIXI_COEF11_12              VDIN_HDR2_MATRIXI_COEF11_12
#define VDIN0_HDR2_MATRIXI_COEF20_21              VDIN_HDR2_MATRIXI_COEF20_21
#define VDIN0_HDR2_MATRIXI_COEF22                 VDIN_HDR2_MATRIXI_COEF22
#define VDIN0_HDR2_MATRIXI_COEF30_31              VDIN_HDR2_MATRIXI_COEF30_31
#define VDIN0_HDR2_MATRIXI_COEF32_40              VDIN_HDR2_MATRIXI_COEF32_40
#define VDIN0_HDR2_MATRIXI_COEF41_42              VDIN_HDR2_MATRIXI_COEF41_42
#define VDIN0_HDR2_MATRIXI_OFFSET0_1              VDIN_HDR2_MATRIXI_OFFSET0_1
#define VDIN0_HDR2_MATRIXI_OFFSET2                VDIN_HDR2_MATRIXI_OFFSET2
#define VDIN0_HDR2_MATRIXI_PRE_OFFSET0_1          VDIN_HDR2_MATRIXI_PRE_OFFSET0_1
#define VDIN0_HDR2_MATRIXI_PRE_OFFSET2            VDIN_HDR2_MATRIXI_PRE_OFFSET2
#define VDIN0_HDR2_MATRIXO_COEF00_01              VDIN_HDR2_MATRIXO_COEF00_01
#define VDIN0_HDR2_MATRIXO_COEF02_10              VDIN_HDR2_MATRIXO_COEF02_10
#define VDIN0_HDR2_MATRIXO_COEF11_12              VDIN_HDR2_MATRIXO_COEF11_12
#define VDIN0_HDR2_MATRIXO_COEF20_21              VDIN_HDR2_MATRIXO_COEF20_21
#define VDIN0_HDR2_MATRIXO_COEF22                 VDIN_HDR2_MATRIXO_COEF22
#define VDIN0_HDR2_MATRIXO_COEF30_31              VDIN_HDR2_MATRIXO_COEF30_31
#define VDIN0_HDR2_MATRIXO_COEF32_40              VDIN_HDR2_MATRIXO_COEF32_40
#define VDIN0_HDR2_MATRIXO_COEF41_42              VDIN_HDR2_MATRIXO_COEF41_42
#define VDIN0_HDR2_MATRIXO_OFFSET0_1              VDIN_HDR2_MATRIXO_OFFSET0_1
#define VDIN0_HDR2_MATRIXO_OFFSET2                VDIN_HDR2_MATRIXO_OFFSET2
#define VDIN0_HDR2_MATRIXO_PRE_OFFSET0_1          VDIN_HDR2_MATRIXO_PRE_OFFSET0_1
#define VDIN0_HDR2_MATRIXO_PRE_OFFSET2            VDIN_HDR2_MATRIXO_PRE_OFFSET2
#define VDIN0_HDR2_MATRIXI_CLIP                   VDIN_HDR2_MATRIXI_CLIP
#define VDIN0_HDR2_MATRIXO_CLIP                   VDIN_HDR2_MATRIXO_CLIP
#define VDIN0_HDR2_CGAIN_OFFT                     VDIN_HDR2_CGAIN_OFFT
#define VDIN0_EOTF_LUT_ADDR_PORT                  VDIN_EOTF_LUT_ADDR_PORT
#define VDIN0_EOTF_LUT_DATA_PORT                  VDIN_EOTF_LUT_DATA_PORT
#define VDIN0_OETF_LUT_ADDR_PORT                  VDIN_OETF_LUT_ADDR_PORT
#define VDIN0_OETF_LUT_DATA_PORT                  VDIN_OETF_LUT_DATA_PORT
#define VDIN0_OGAIN_LUT_ADDR_PORT                 VDIN_OGAIN_LUT_ADDR_PORT
#define VDIN0_OGAIN_LUT_DATA_PORT                 VDIN_OGAIN_LUT_DATA_PORT
#define VDIN0_CGAIN_LUT_ADDR_PORT                 VDIN_CGAIN_LUT_ADDR_PORT
#define VDIN0_CGAIN_LUT_DATA_PORT                 VDIN_CGAIN_LUT_DATA_PORT
#define VDIN0_HDR2_CGAIN_COEF0                    VDIN_HDR2_CGAIN_COEF0
#define VDIN0_HDR2_CGAIN_COEF1                    VDIN_HDR2_CGAIN_COEF1
#define VDIN0_HDR2_ADPS_CTRL                      VDIN_HDR2_ADPS_CTRL
#define VDIN0_HDR2_ADPS_ALPHA0                    VDIN_HDR2_ADPS_ALPHA0
#define VDIN0_HDR2_ADPS_ALPHA1                    VDIN_HDR2_ADPS_ALPHA1
#define VDIN0_HDR2_ADPS_BETA0                     VDIN_HDR2_ADPS_BETA0
#define VDIN0_HDR2_ADPS_BETA1                     VDIN_HDR2_ADPS_BETA1
#define VDIN0_HDR2_ADPS_BETA2                     VDIN_HDR2_ADPS_BETA2
#define VDIN0_HDR2_ADPS_COEF0                     VDIN_HDR2_ADPS_COEF0
#define VDIN0_HDR2_ADPS_COEF1                     VDIN_HDR2_ADPS_COEF1
#define VDIN0_HDR2_GMUT_CTRL                      VDIN_HDR2_GMUT_CTRL
#define VDIN0_HDR2_GMUT_COEF0                     VDIN_HDR2_GMUT_COEF0
#define VDIN0_HDR2_GMUT_COEF1                     VDIN_HDR2_GMUT_COEF1
#define VDIN0_HDR2_GMUT_COEF2                     VDIN_HDR2_GMUT_COEF2
#define VDIN0_HDR2_GMUT_COEF3                     VDIN_HDR2_GMUT_COEF3
#define VDIN0_HDR2_GMUT_COEF4                     VDIN_HDR2_GMUT_COEF4
#define VDIN0_HDR2_PIPE_CTRL1                     VDIN_HDR2_PIPE_CTRL1
#define VDIN0_HDR2_PIPE_CTRL2                     VDIN_HDR2_PIPE_CTRL2
#define VDIN0_HDR2_PIPE_CTRL3                     VDIN_HDR2_PIPE_CTRL3
#define VDIN0_HDR2_PROC_WIN1                      VDIN_HDR2_PROC_WIN1
#define VDIN0_HDR2_PROC_WIN2                      VDIN_HDR2_PROC_WIN2
#define VDIN0_HDR2_MATRIXI_EN_CTRL                VDIN_HDR2_MATRIXI_EN_CTRL
#define VDIN0_HDR2_MATRIXO_EN_CTRL                VDIN_HDR2_MATRIXO_EN_CTRL
#define VDIN0_HDR2_HIST_CTRL                      VDIN_HDR2_HIST_CTRL
#define VDIN0_HDR2_HIST_H_START_END               VDIN_HDR2_HIST_H_START_END
#define VDIN0_HDR2_HIST_V_START_END               VDIN_HDR2_HIST_V_START_END
#define VDIN0_HDR2_HIST_RD                        VDIN_HDR2_HIST_RD


#define VDIN0_CRC_CTRL                     (VDIN_CRC_CTRL)
#define VDIN0_RO_CRC                       (VDIN_RO_CRC  )
#define VDIN0_LINE_INT                     (VDIN_LINE_INT)
#define VDIN0_WR_URGENT_CTRL               (VDIN_WR_URGENT_CTRL)
#define VDIN0_RO_WRMIF_STATUS              (VDIN_RO_WRMIF_STATUS)

#define VDIN0_WR_BADDR_LUMA                (VDIN_WR_BADDR_LUMA   )
#define VDIN0_WR_BADDR_CHROMA              (VDIN_WR_BADDR_CHROMA )
#define VDIN0_WR_STRIDE_LUMA               (VDIN_WR_STRIDE_LUMA  )
#define VDIN0_WR_STRIDE_CHROMA             (VDIN_WR_STRIDE_CHROMA)

#define VDIN0_DSC_CTRL                      VDIN_DSC_CTRL
#define VDIN0_CFMT_CTRL                     VDIN_CFMT_CTRL
#define VDIN0_CFMT_W                        VDIN_CFMT_W
#define VDIN0_SCB_CTRL0                     VDIN_SCB_CTRL0
#define VDIN0_SCB_CTRL1                     VDIN_SCB_CTRL1
#define VDIN0_SCB_CTRL2                     VDIN_SCB_CTRL2
#define VDIN0_DSC_HSIZE                     VDIN_DSC_HSIZE
#define VDIN0_DSC_DETUNNEL_SEL              VDIN_DSC_DETUNNEL_SEL
#define VDIN0_DSC_TUNNEL_SEL                VDIN_DSC_TUNNEL_SEL
#define VDIN0_DITH_CTRL                     VDIN_DITH_CTRL
#define VDIN0_DITH_LUT_1                    VDIN_DITH_LUT_1
#define VDIN0_DITH_LUT_2                    VDIN_DITH_LUT_2
#define VDIN0_DITH_LUT_3                    VDIN_DITH_LUT_3
#define VDIN0_DITH_LUT_4                    VDIN_DITH_LUT_4
#define VDIN0_DITH_LUT_5                    VDIN_DITH_LUT_5
#define VDIN0_DITH_LUT_6                    VDIN_DITH_LUT_6
#define VDIN0_DITH_LUT_7                    VDIN_DITH_LUT_7
#define VDIN0_DITH_LUT_8                    VDIN_DITH_LUT_8
#define VDIN0_DITH_LUT_9                    VDIN_DITH_LUT_9
#define VDIN0_DITH_LUT_10                   VDIN_DITH_LUT_10
#define VDIN0_DITH_LUT_11                   VDIN_DITH_LUT_11
#define VDIN0_DITH_LUT_12                   VDIN_DITH_LUT_12

#define VDIN0_HSK_CTRL                      VDIN_HSK_CTRL
#define VDIN0_HSK_COEF_0                    VDIN_HSK_COEF_0
#define VDIN0_HSK_COEF_1                    VDIN_HSK_COEF_1
#define VDIN0_HSK_COEF_2                    VDIN_HSK_COEF_2
#define VDIN0_HSK_COEF_3                    VDIN_HSK_COEF_3
#define VDIN0_HSK_COEF_4                    VDIN_HSK_COEF_4
#define VDIN0_HSK_COEF_5                    VDIN_HSK_COEF_5
#define VDIN0_HSK_COEF_6                    VDIN_HSK_COEF_6
#define VDIN0_HSK_COEF_7                    VDIN_HSK_COEF_7
#define VDIN0_HSK_COEF_8                    VDIN_HSK_COEF_8
#define VDIN0_HSK_COEF_9                    VDIN_HSK_COEF_9
#define VDIN0_HSK_COEF_A                    VDIN_HSK_COEF_A
#define VDIN0_HSK_COEF_B                    VDIN_HSK_COEF_B
#define VDIN0_HSK_COEF_C                    VDIN_HSK_COEF_C
#define VDIN0_HSK_COEF_D                    VDIN_HSK_COEF_D
#define VDIN0_HSK_COEF_E                    VDIN_HSK_COEF_E
#define VDIN0_HSK_COEF_F                    VDIN_HSK_COEF_F

#define VDIN0_HDR2_SIZE                     VDIN_HDR2_SIZE
#define VDIN0_VSHRK_SIZE_M1                 VDIN_VSHRK_SIZE_M1

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_vdin0_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_vdin1_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VDIN1_VCBUS_BASE = 0x13
// -----------------------------------------------
#define  VDIN1_OFFSET   (0x100)
// `include "vpu_vdin_regs.h"
//8'h72 occupied by histogram 32
//VDIN1        8'h00 - 8'h7f
#define VDIN1_SCALE_COEF_IDX                    ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF_IDX               )
#define VDIN1_SCALE_COEF                        ((VDIN1_OFFSET << 2) + VDIN_SCALE_COEF                   )
#define VDIN1_COM_CTRL0                         ((VDIN1_OFFSET << 2) + VDIN_COM_CTRL0                    )
#define VDIN1_ACTIVE_MAX_PIX_CNT_STATUS         ((VDIN1_OFFSET << 2) + VDIN_ACTIVE_MAX_PIX_CNT_STATUS    )
#define VDIN1_LCNT_STATUS                       ((VDIN1_OFFSET << 2) + VDIN_LCNT_STATUS                  )
#define VDIN1_COM_STATUS0                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS0                  )
#define VDIN1_COM_STATUS1                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS1                  )
#define VDIN1_LCNT_SHADOW_STATUS                ((VDIN1_OFFSET << 2) + VDIN_LCNT_SHADOW_STATUS           )
#define VDIN1_ASFIFO_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL0                 )
#define VDIN1_ASFIFO_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL1                 )
#define VDIN1_WIDTHM1I_WIDTHM1O                 ((VDIN1_OFFSET << 2) + VDIN_WIDTHM1I_WIDTHM1O            )
#define VDIN1_SC_MISC_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_SC_MISC_CTRL                 )
#define VDIN1_HSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_HSC_PHASE_STEP               )
#define VDIN1_HSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_HSC_INI_CTRL                 )
#define VDIN1_COM_STATUS2                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS2                  )
#define VDIN1_COM_STATUS3                       ((VDIN1_OFFSET << 2) + VDIN_COM_STATUS3                  )
#define VDIN1_ASFIFO_CTRL2                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL2                 )
#define VDIN1_MATRIX_CTRL                       ((VDIN1_OFFSET << 2) + VDIN_MATRIX_CTRL                  )
#define VDIN1_MATRIX_COEF00_01                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF00_01             )
#define VDIN1_MATRIX_COEF02_10                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF02_10             )
#define VDIN1_MATRIX_COEF11_12                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF11_12             )
#define VDIN1_MATRIX_COEF20_21                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF20_21             )
#define VDIN1_MATRIX_COEF22                     ((VDIN1_OFFSET << 2) + VDIN_MATRIX_COEF22                )
#define VDIN1_MATRIX_OFFSET0_1                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET0_1             )
#define VDIN1_MATRIX_OFFSET2                    ((VDIN1_OFFSET << 2) + VDIN_MATRIX_OFFSET2               )
#define VDIN1_MATRIX_PRE_OFFSET0_1              ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET0_1         )
#define VDIN1_MATRIX_PRE_OFFSET2                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PRE_OFFSET2           )
#define VDIN1_LFIFO_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_LFIFO_CTRL                   )
#define VDIN1_COM_GCLK_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL                )
#define VDIN1_INTF_WIDTHM1                      ((VDIN1_OFFSET << 2) + VDIN_INTF_WIDTHM1                 )
#define VDIN1_WR_CTRL2                          ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL2                     )
#define VDIN1_WR_CTRL                           ((VDIN1_OFFSET << 2) + VDIN_WR_CTRL                      )
#define VDIN1_WR_H_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_H_START_END               )
#define VDIN1_WR_V_START_END                    ((VDIN1_OFFSET << 2) + VDIN_WR_V_START_END               )
#define VDIN1_VSC_PHASE_STEP                    ((VDIN1_OFFSET << 2) + VDIN_VSC_PHASE_STEP               )
#define VDIN1_VSC_INI_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_VSC_INI_CTRL                 )
#define VDIN1_SCIN_HEIGHTM1                     ((VDIN1_OFFSET << 2) + VDIN_SCIN_HEIGHTM1                )
#define VDIN1_DUMMY_DATA                        ((VDIN1_OFFSET << 2) + VDIN_DUMMY_DATA                   )
#define VDIN1_MATRIX_PROBE_COLOR                ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_COLOR           )
#define VDIN1_MATRIX_HL_COLOR                   ((VDIN1_OFFSET << 2) + VDIN_MATRIX_HL_COLOR              )
#define VDIN1_MATRIX_PROBE_POS                  ((VDIN1_OFFSET << 2) + VDIN_MATRIX_PROBE_POS             )
#define VDIN1_CHROMA_ADDR_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_ADDR_PORT             )
#define VDIN1_CHROMA_DATA_PORT                  ((VDIN1_OFFSET << 2) + VDIN_CHROMA_DATA_PORT             )
#define VDIN1_CM_BRI_CON_CTRL                   ((VDIN1_OFFSET << 2) + VDIN_CM_BRI_CON_CTRL              )
#define VDIN1_GO_LINE_CTRL                      ((VDIN1_OFFSET << 2) + VDIN_GO_LINE_CTRL                 )
#define VDIN1_HIST_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HIST_CTRL                    )
#define VDIN1_HIST_H_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_H_START_END             )
#define VDIN1_HIST_V_START_END                  ((VDIN1_OFFSET << 2) + VDIN_HIST_V_START_END             )
#define VDIN1_HIST_MAX_MIN                      ((VDIN1_OFFSET << 2) + VDIN_HIST_MAX_MIN                 )
#define VDIN1_HIST_SPL_VAL                      ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_VAL                 )
#define VDIN1_HIST_SPL_PIX_CNT                  ((VDIN1_OFFSET << 2) + VDIN_HIST_SPL_PIX_CNT             )
#define VDIN1_HIST_CHROMA_SUM                   ((VDIN1_OFFSET << 2) + VDIN_HIST_CHROMA_SUM              )
#define VDIN1_DNLP_HIST00                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST00                  )
#define VDIN1_DNLP_HIST01                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST01                  )
#define VDIN1_DNLP_HIST02                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST02                  )
#define VDIN1_DNLP_HIST03                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST03                  )
#define VDIN1_DNLP_HIST04                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST04                  )
#define VDIN1_DNLP_HIST05                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST05                  )
#define VDIN1_DNLP_HIST06                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST06                  )
#define VDIN1_DNLP_HIST07                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST07                  )
#define VDIN1_DNLP_HIST08                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST08                  )
#define VDIN1_DNLP_HIST09                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST09                  )
#define VDIN1_DNLP_HIST10                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST10                  )
#define VDIN1_DNLP_HIST11                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST11                  )
#define VDIN1_DNLP_HIST12                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST12                  )
#define VDIN1_DNLP_HIST13                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST13                  )
#define VDIN1_DNLP_HIST14                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST14                  )
#define VDIN1_DNLP_HIST15                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST15                  )
#define VDIN1_DNLP_HIST16                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST16                  )
#define VDIN1_DNLP_HIST17                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST17                  )
#define VDIN1_DNLP_HIST18                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST18                  )
#define VDIN1_DNLP_HIST19                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST19                  )
#define VDIN1_DNLP_HIST20                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST20                  )
#define VDIN1_DNLP_HIST21                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST21                  )
#define VDIN1_DNLP_HIST22                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST22                  )
#define VDIN1_DNLP_HIST23                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST23                  )
#define VDIN1_DNLP_HIST24                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST24                  )
#define VDIN1_DNLP_HIST25                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST25                  )
#define VDIN1_DNLP_HIST26                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST26                  )
#define VDIN1_DNLP_HIST27                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST27                  )
#define VDIN1_DNLP_HIST28                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST28                  )
#define VDIN1_DNLP_HIST29                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST29                  )
#define VDIN1_DNLP_HIST30                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST30                  )
#define VDIN1_DNLP_HIST31                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST31                  )
#define VDIN1_DNLP_HIST32                       ((VDIN1_OFFSET << 2) + VDIN_DNLP_HIST32                  )
#define VDIN1_MEAS_CTRL0                        ((VDIN1_OFFSET << 2) + VDIN_MEAS_CTRL0                   )
#define VDIN1_MEAS_VS_COUNT_HI                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_HI             )
#define VDIN1_MEAS_VS_COUNT_LO                  ((VDIN1_OFFSET << 2) + VDIN_MEAS_VS_COUNT_LO             )
#define VDIN1_MEAS_HS_RANGE                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_RANGE                )
#define VDIN1_MEAS_HS_COUNT                     ((VDIN1_OFFSET << 2) + VDIN_MEAS_HS_COUNT                )
#define VDIN1_BLKBAR_CTRL1                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL1                 )
#define VDIN1_BLKBAR_CTRL0                      ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CTRL0                 )
#define VDIN1_BLKBAR_H_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_H_START_END           )
#define VDIN1_BLKBAR_V_START_END                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_V_START_END           )
#define VDIN1_BLKBAR_CNT_THRESHOLD              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_CNT_THRESHOLD         )
#define VDIN1_BLKBAR_ROW_TH1_TH2                ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_ROW_TH1_TH2           )
#define VDIN1_BLKBAR_IND_LEFT_START_END         ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT_START_END    )
#define VDIN1_BLKBAR_IND_RIGHT_START_END        ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT_START_END   )
#define VDIN1_BLKBAR_IND_LEFT1_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT1_CNT         )
#define VDIN1_BLKBAR_IND_LEFT2_CNT              ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_LEFT2_CNT         )
#define VDIN1_BLKBAR_IND_RIGHT1_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT1_CNT        )
#define VDIN1_BLKBAR_IND_RIGHT2_CNT             ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_IND_RIGHT2_CNT        )
#define VDIN1_BLKBAR_STATUS0                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS0               )
#define VDIN1_BLKBAR_STATUS1                    ((VDIN1_OFFSET << 2) + VDIN_BLKBAR_STATUS1               )
#define VDIN1_WIN_H_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_H_START_END              )
#define VDIN1_WIN_V_START_END                   ((VDIN1_OFFSET << 2) + VDIN_WIN_V_START_END              )
#define VDIN1_ASFIFO_CTRL3                      ((VDIN1_OFFSET << 2) + VDIN_ASFIFO_CTRL3                 )
#define VDIN1_LFIFO_URG_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_LFIFO_URG_CTRL               )
#define VDIN1_COM_GCLK_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL2               )
#define VDIN1_VSHRK_CTRL                        ((VDIN1_OFFSET << 2) + VDIN_VSHRK_CTRL                   )
#define VDIN1_SYNC_MASK                         ((VDIN1_OFFSET << 2) + VDIN_SYNC_MASK                    )
#define VDIN1_DOLBY_DSC_CTRL0                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL0  )
#define VDIN1_DOLBY_DSC_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL1  )
#define VDIN1_DOLBY_DSC_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL2  )
#define VDIN1_DOLBY_DSC_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_CTRL3  )
#define VDIN1_DOLBY_AXI_CTRL0                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL0  )
#define VDIN1_DOLBY_AXI_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL1  )
#define VDIN1_DOLBY_AXI_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL2  )
#define VDIN1_DOLBY_AXI_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_DOLBY_AXI_CTRL3  )
#define VDIN1_DOLBY_DSC_STATUS0                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS0)
#define VDIN1_DOLBY_DSC_STATUS1                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS1)
#define VDIN1_DOLBY_DSC_STATUS2                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS2)
#define VDIN1_DOLBY_DSC_STATUS3                 ((VDIN1_OFFSET << 2) + VDIN_DOLBY_DSC_STATUS3)

#define VDIN1_HDR2_CTRL                         ((VDIN1_OFFSET << 2) + VDIN_HDR2_CTRL                   )
#define VDIN1_HDR2_CLK_GATE                     ((VDIN1_OFFSET << 2) + VDIN_HDR2_CLK_GATE               )
#define VDIN1_HDR2_MATRIXI_COEF00_01            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF00_01      )
#define VDIN1_HDR2_MATRIXI_COEF02_10            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF02_10      )
#define VDIN1_HDR2_MATRIXI_COEF11_12            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF11_12      )
#define VDIN1_HDR2_MATRIXI_COEF20_21            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF20_21      )
#define VDIN1_HDR2_MATRIXI_COEF22               ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF22         )
#define VDIN1_HDR2_MATRIXI_COEF30_31            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF30_31      )
#define VDIN1_HDR2_MATRIXI_COEF32_40            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF32_40      )
#define VDIN1_HDR2_MATRIXI_COEF41_42            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_COEF41_42      )
#define VDIN1_HDR2_MATRIXI_OFFSET0_1            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_OFFSET0_1      )
#define VDIN1_HDR2_MATRIXI_OFFSET2              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_OFFSET2        )
#define VDIN1_HDR2_MATRIXI_PRE_OFFSET0_1        ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_PRE_OFFSET0_1  )
#define VDIN1_HDR2_MATRIXI_PRE_OFFSET2          ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_PRE_OFFSET2    )
#define VDIN1_HDR2_MATRIXO_COEF00_01            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF00_01      )
#define VDIN1_HDR2_MATRIXO_COEF02_10            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF02_10      )
#define VDIN1_HDR2_MATRIXO_COEF11_12            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF11_12      )
#define VDIN1_HDR2_MATRIXO_COEF20_21            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF20_21      )
#define VDIN1_HDR2_MATRIXO_COEF22               ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF22         )
#define VDIN1_HDR2_MATRIXO_COEF30_31            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF30_31      )
#define VDIN1_HDR2_MATRIXO_COEF32_40            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF32_40      )
#define VDIN1_HDR2_MATRIXO_COEF41_42            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_COEF41_42      )
#define VDIN1_HDR2_MATRIXO_OFFSET0_1            ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_OFFSET0_1      )
#define VDIN1_HDR2_MATRIXO_OFFSET2              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_OFFSET2        )
#define VDIN1_HDR2_MATRIXO_PRE_OFFSET0_1        ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_PRE_OFFSET0_1  )
#define VDIN1_HDR2_MATRIXO_PRE_OFFSET2          ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_PRE_OFFSET2    )
#define VDIN1_HDR2_MATRIXI_CLIP                 ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_CLIP           )
#define VDIN1_HDR2_MATRIXO_CLIP                 ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_CLIP           )
#define VDIN1_HDR2_CGAIN_OFFT                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_OFFT             )
#define VDIN1_EOTF_LUT_ADDR_PORT                ((VDIN1_OFFSET << 2) + VDIN_EOTF_LUT_ADDR_PORT          )
#define VDIN1_EOTF_LUT_DATA_PORT                ((VDIN1_OFFSET << 2) + VDIN_EOTF_LUT_DATA_PORT          )
#define VDIN1_OETF_LUT_ADDR_PORT                ((VDIN1_OFFSET << 2) + VDIN_OETF_LUT_ADDR_PORT          )
#define VDIN1_OETF_LUT_DATA_PORT                ((VDIN1_OFFSET << 2) + VDIN_OETF_LUT_DATA_PORT          )
#define VDIN1_OGAIN_LUT_ADDR_PORT               ((VDIN1_OFFSET << 2) + VDIN_OGAIN_LUT_ADDR_PORT         )
#define VDIN1_OGAIN_LUT_DATA_PORT               ((VDIN1_OFFSET << 2) + VDIN_OGAIN_LUT_DATA_PORT         )
#define VDIN1_CGAIN_LUT_ADDR_PORT               ((VDIN1_OFFSET << 2) + VDIN_CGAIN_LUT_ADDR_PORT         )
#define VDIN1_CGAIN_LUT_DATA_PORT               ((VDIN1_OFFSET << 2) + VDIN_CGAIN_LUT_DATA_PORT         )
#define VDIN1_HDR2_CGAIN_COEF0                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_COEF0            )
#define VDIN1_HDR2_CGAIN_COEF1                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_CGAIN_COEF1            )
#define VDIN1_HDR2_ADPS_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_CTRL              )
#define VDIN1_HDR2_ADPS_ALPHA0                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_ALPHA0            )
#define VDIN1_HDR2_ADPS_ALPHA1                  ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_ALPHA1            )
#define VDIN1_HDR2_ADPS_BETA0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA0             )
#define VDIN1_HDR2_ADPS_BETA1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA1             )
#define VDIN1_HDR2_ADPS_BETA2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_BETA2             )
#define VDIN1_HDR2_ADPS_COEF0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_COEF0             )
#define VDIN1_HDR2_ADPS_COEF1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_ADPS_COEF1             )
#define VDIN1_HDR2_GMUT_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_CTRL              )
#define VDIN1_HDR2_GMUT_COEF0                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF0             )
#define VDIN1_HDR2_GMUT_COEF1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF1             )
#define VDIN1_HDR2_GMUT_COEF2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF2             )
#define VDIN1_HDR2_GMUT_COEF3                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF3             )
#define VDIN1_HDR2_GMUT_COEF4                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_GMUT_COEF4             )
#define VDIN1_HDR2_PIPE_CTRL1                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL1 )
#define VDIN1_HDR2_PIPE_CTRL2                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL2 )
#define VDIN1_HDR2_PIPE_CTRL3                   ((VDIN1_OFFSET << 2) + VDIN_HDR2_PIPE_CTRL3 )
#define VDIN1_HDR2_PROC_WIN1                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_PROC_WIN1  )
#define VDIN1_HDR2_PROC_WIN2                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_PROC_WIN2  )
#define VDIN1_HDR2_MATRIXI_EN_CTRL              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXI_EN_CTRL  )
#define VDIN1_HDR2_MATRIXO_EN_CTRL              ((VDIN1_OFFSET << 2) + VDIN_HDR2_MATRIXO_EN_CTRL  )
#define VDIN1_HDR2_HIST_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_CTRL        )
#define VDIN1_HDR2_HIST_H_START_END             ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_H_START_END )
#define VDIN1_HDR2_HIST_V_START_END             ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_V_START_END )
#define VDIN1_HDR2_HIST_RD                      ((VDIN1_OFFSET << 2) + VDIN_HDR2_HIST_RD          )



#define VDIN1_CRC_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_CRC_CTRL)
#define VDIN1_RO_CRC                       ((VDIN1_OFFSET << 2) + VDIN_RO_CRC  )
#define VDIN1_LINE_INT                     ((VDIN1_OFFSET << 2) + VDIN_LINE_INT)
#define VDIN1_WR_URGENT_CTRL               ((VDIN1_OFFSET << 2) + VDIN_WR_URGENT_CTRL)
#define VDIN1_RO_WRMIF_STATUS              ((VDIN1_OFFSET << 2) + VDIN_RO_WRMIF_STATUS)

#define VDIN1_WR_BADDR_LUMA                ((VDIN1_OFFSET << 2) + VDIN_WR_BADDR_LUMA   )
#define VDIN1_WR_BADDR_CHROMA              ((VDIN1_OFFSET << 2) + VDIN_WR_BADDR_CHROMA )
#define VDIN1_WR_STRIDE_LUMA               ((VDIN1_OFFSET << 2) + VDIN_WR_STRIDE_LUMA  )
#define VDIN1_WR_STRIDE_CHROMA             ((VDIN1_OFFSET << 2) + VDIN_WR_STRIDE_CHROMA)

#define VDIN1_DSC_CTRL                     ((VDIN1_OFFSET << 2) + VDIN_DSC_CTRL    )
#define VDIN1_CFMT_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_CFMT_CTRL   )
#define VDIN1_CFMT_W                       ((VDIN1_OFFSET << 2) + VDIN_CFMT_W      )
#define VDIN1_SCB_CTRL0                    ((VDIN1_OFFSET << 2) + VDIN_SCB_CTRL0   )
#define VDIN1_SCB_CTRL1                    ((VDIN1_OFFSET << 2) + VDIN_SCB_CTRL1   )
#define VDIN1_SCB_CTRL2                    ((VDIN1_OFFSET << 2) + VDIN_SCB_CTRL2   )
#define VDIN1_DSC_HSIZE                    ((VDIN1_OFFSET << 2) + VDIN_DSC_HSIZE   )
#define VDIN1_DSC_DETUNNEL_SEL             ((VDIN1_OFFSET << 2) + VDIN_DSC_DETUNNEL_SEL)
#define VDIN1_DSC_TUNNEL_SEL               ((VDIN1_OFFSET << 2) + VDIN_DSC_TUNNEL_SEL)
#define VDIN1_DITH_CTRL                    ((VDIN1_OFFSET << 2) + VDIN_DITH_CTRL   )
#define VDIN1_DITH_LUT_1                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_1  )
#define VDIN1_DITH_LUT_2                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_2  )
#define VDIN1_DITH_LUT_3                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_3  )
#define VDIN1_DITH_LUT_4                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_4  )
#define VDIN1_DITH_LUT_5                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_5  )
#define VDIN1_DITH_LUT_6                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_6  )
#define VDIN1_DITH_LUT_7                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_7  )
#define VDIN1_DITH_LUT_8                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_8  )
#define VDIN1_DITH_LUT_9                   ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_9  )
#define VDIN1_DITH_LUT_10                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_10 )
#define VDIN1_DITH_LUT_11                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_11 )
#define VDIN1_DITH_LUT_12                  ((VDIN1_OFFSET << 2) + VDIN_DITH_LUT_12 )

#define VDIN1_HSK_CTRL                     ((VDIN1_OFFSET << 2) +  VDIN_HSK_CTRL   )
#define VDIN1_HSK_COEF_0                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_0 )
#define VDIN1_HSK_COEF_1                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_1 )
#define VDIN1_HSK_COEF_2                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_2 )
#define VDIN1_HSK_COEF_3                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_3 )
#define VDIN1_HSK_COEF_4                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_4 )
#define VDIN1_HSK_COEF_5                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_5 )
#define VDIN1_HSK_COEF_6                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_6 )
#define VDIN1_HSK_COEF_7                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_7 )
#define VDIN1_HSK_COEF_8                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_8 )
#define VDIN1_HSK_COEF_9                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_9 )
#define VDIN1_HSK_COEF_A                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_A )
#define VDIN1_HSK_COEF_B                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_B )
#define VDIN1_HSK_COEF_C                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_C )
#define VDIN1_HSK_COEF_D                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_D )
#define VDIN1_HSK_COEF_E                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_E )
#define VDIN1_HSK_COEF_F                   ((VDIN1_OFFSET << 2) +  VDIN_HSK_COEF_F )

#define VDIN1_HDR2_SIZE                    ((VDIN1_OFFSET << 2) +  VDIN_HDR2_SIZE    )
#define VDIN1_VSHRK_SIZE_M1                ((VDIN1_OFFSET << 2) +  VDIN_VSHRK_SIZE_M1)



// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_vdin1_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  LCD0_VCBUS_BASE = 0x14
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./lcd_regs.h
//
// 0x00 - 0x9f
//
// Reading file:  ./ldc_cbus.h
//
// synopsys translate_off
// synopsys translate_on
#define LDC_REG_BLOCK_NUM                          ((0x1400  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_ldc_en                // unsigned ,    RW, default = 1  1:enable ldc ,0:disable ldc
//Bit 19:14        reg_ldc_seg_col           // unsigned ,    RW, default = 16  the number of col segments for calculate backlight
//Bit 13: 8        reg_ldc_seg_row           // unsigned ,    RW, default = 9  the number of row segments for calculate backlight
//Bit  7: 4        reg_ldc_blk_xnum          // unsigned ,    RW, default = 7  the number of col blocks for calculate intensity, 1<<blk_xnum
//Bit  3: 0        reg_ldc_blk_ynum          // unsigned ,    RW, default = 6  the number of row blocks for calculate intensity, 1<<blk_ynum
#define LDC_REG_SEG_Y_BOUNDARY_0_1                 ((0x1401  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_0  // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_1  // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_2_3                 ((0x1402  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_2  // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_3  // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_4_5                 ((0x1403  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_4  // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_5  // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_6_7                 ((0x1404  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_6  // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_7  // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_8_9                 ((0x1405  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_8  // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_9  // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_10_11               ((0x1406  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_10 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_11 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_12_13               ((0x1407  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_12 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_13 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_14_15               ((0x1408  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_14 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_15 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_16_17               ((0x1409  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_16 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_17 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_18_19               ((0x140a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_18 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_19 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_20_21               ((0x140b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_20 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_21 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_22_23               ((0x140c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_22 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_23 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_24_25               ((0x140d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_24 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_25 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_26_27               ((0x140e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_26 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_27 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_28_29               ((0x140f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_28 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_29 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_Y_BOUNDARY_30_31               ((0x1410  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:13        reg_ldc_seg_y_boundary_30 // unsigned ,    RW, default = 0  the segment row boundary
//Bit 12: 0        reg_ldc_seg_y_boundary_31 // unsigned ,    RW, default = 0  the segment row boundary
#define LDC_REG_SEG_X_BOUNDARY_0_1                 ((0x1411  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_0  // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_1  // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_2_3                 ((0x1412  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_2  // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_3  // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_4_5                 ((0x1413  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_4  // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_5  // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_6_7                 ((0x1414  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_6  // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_7  // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_8_9                 ((0x1415  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_8  // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_9  // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_10_11               ((0x1416  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_10 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_11 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_12_13               ((0x1417  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_12 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_13 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_14_15               ((0x1418  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_14 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_15 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_16_17               ((0x1419  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_16 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_17 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_18_19               ((0x141a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_18 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_19 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_20_21               ((0x141b  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_20 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_21 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_22_23               ((0x141c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_22 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_23 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_24_25               ((0x141d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_24 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_25 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_26_27               ((0x141e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_26 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_27 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_28_29               ((0x141f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_28 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_29 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_30_31               ((0x1420  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_30 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_31 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_32_33               ((0x1421  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_32 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_33 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_34_35               ((0x1422  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_34 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_35 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_36_37               ((0x1423  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_36 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_37 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_38_39               ((0x1424  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_38 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_39 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_40_41               ((0x1425  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_40 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_41 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_42_43               ((0x1426  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_42 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_43 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_44_45               ((0x1427  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_44 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_45 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_SEG_X_BOUNDARY_46_47               ((0x1428  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_ldc_seg_x_boundary_46 // unsigned ,    RW, default = 0  the segment col boundary
//Bit 13: 0        reg_ldc_seg_x_boundary_47 // unsigned ,    RW, default = 0  the segment col boundary
#define LDC_REG_PANEL_SIZE                         ((0x1429  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_panel_width       // unsigned ,    RW, default = 0  the panel width
//Bit 15: 0        reg_ldc_panel_height      // unsigned ,    RW, default = 0  the panel height
#define LDC_REG_DOWNSAMPLE                         ((0x142a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_ldc_h_downsample      // unsigned ,    RW, default = 1  horizontal downsample scale, 1:/4,  2:/8, 3:/16, 4:/32
//Bit 23           reg_ldc_ds_filter_mode    // unsigned ,    RW, default = 1  horizontal downsample filter mode, 0: avg 1: max
//Bit 22:15        reg_ldc_y_gain            // unsigned ,    RW, default = 8'h40  the gain for input pixel value, 0x40 ==1
//Bit 14:12        reg_ldc_hist_mode         // unsigned ,    RW, default = 3  the mode for hist statistic value to calculate initial backlight, 0:avg 1: max95, 2, max, 3:blend, 4: adaptive blend coef and blend target(max95 or max)
//Bit 11           reg_ldc_hist_blend_mode   // unsigned ,    RW, default = 1  the blend mode to calculate initial backlight when hist mode=3, 0: max + avg, 1:max95 + avg
//Bit 10: 4        reg_ldc_hist_blend_alpha  // unsigned ,    RW, default = 7'h60  the coef for blend when hist mode=3, 128 means "1"
//Bit  3: 0        reg_ldc_hist_adap_blend_max_gain // unsigned ,    RW, default = 13  the gain for blend max value when hist mode=4
#define LDC_REG_HIST_OVERLAP                       ((0x142b  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:18        reg_ldc_seg_x_overlap     // unsigned ,    RW, default = 0  the overlap pixel num for each segment in col
//Bit 17: 8        reg_ldc_seg_y_overlap     // unsigned ,    RW, default = 0  the overlap pixel num for each segment in row
//Bit  7: 0        reg_ldc_max95_ratio       // unsigned ,    RW, default = 10  max95 percentile  //10
#define LDC_REG_BLEND_DIFF_TH                      ((0x142c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ldc_hist_adap_blend_diff_th1 // unsigned ,    RW, default = 256  the threshold between max95 and average when hist mode=4, default= 4<<6
//Bit 11: 0        reg_ldc_hist_adap_blend_diff_th2 // unsigned ,    RW, default = 640  the threshold between max95 and average when hist mode=4, default= 10<<6
#define LDC_REG_CURVE_COEF                         ((0x142d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:18        reg_ldc_hist_adap_blend_gain_0 // unsigned ,    RW, default = 8'h70  the blend gain0 in curve when hist mode=4
//Bit 17:10        reg_ldc_hist_adap_blend_gain_1 // unsigned ,    RW, default = 8'h40  the blend gain1 in curve when hist mode=4
//Bit  9: 4        reg_ldc_hist_adap_blend_th0 // unsigned ,    RW, default = 2  the blend threshold base in curve when hist mode=4
//Bit  3: 0        reg_ldc_hist_adap_blend_thn // unsigned ,    RW, default = 4  the blend threshold increase step in curve when hist mode=4, th0+1<<thn
#define LDC_REG_INIT_BL                            ((0x142e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ldc_init_bl_min       // unsigned ,    RW, default = 0  the minimum value of init_bl
//Bit 11: 0        reg_ldc_init_bl_max       // unsigned ,    RW, default = 12'hfff  the maximum value of init_bl
#define LDC_REG_SF_MODE                            ((0x142f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_ldc_sf_mode           // unsigned ,    RW, default = 2  the mode for backlight spatial filter, 0: no filter, 1: TSF filter , 2: new spatial filter
//Bit 23:12        reg_ldc_sf_tsf_3x3        // unsigned ,    RW, default = 12'h600  smoothness control of the spatial filter at 3x3
//Bit 11: 0        reg_ldc_sf_tsf_5x5        // unsigned ,    RW, default = 12'hC00  smoothness control of the spatial filter at 5x5
#define LDC_REG_SF_GAIN                            ((0x1430  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ldc_sf_gain_up        // unsigned ,    RW, default = 8'h20  the gain for backlight up
//Bit  7: 0        reg_ldc_sf_gain_dn        // unsigned ,    RW, default = 8'h00  the gain for backlight down,256 as "1"
#define LDC_REG_BS_MODE                            ((0x1431  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_ldc_bs_bl_mode        // unsigned ,    RW, default = 0  the boost mode, 0:no boost,1:glb boost,2:local boost,3:max,4:min,5:avg
//Bit 11: 0        reg_ldc_glb_apl           // unsigned ,    RW, default = 4095  global apl for one channel
#define LDC_REG_APL                                ((0x1432  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ldc_bs_glb_apl_gain   // unsigned ,    RW, default = 8'h20  0x10 as "1"
#define LDC_REG_GLB_BOOST                          ((0x1433  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ldc_bs_dark_scene_bl_th // unsigned ,    RW, default = 12'h200  the global threshold for dark scene
//Bit 15: 8        reg_ldc_bs_gain           // unsigned ,    RW, default = 8'h20  the boost gain, default=0x20, 256 as "1"
//Bit  7: 0        reg_ldc_bs_limit_gain     // unsigned ,    RW, default = 8'h60  the boost limit gain, 0x40 as "1"
#define LDC_REG_LOCAL_BOOST                        ((0x1434  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:20        reg_ldc_bs_loc_apl_gain   // unsigned ,    RW, default = 8'h20  the local apl gain for dark scene, 0x10 as "1"
//Bit 19:12        reg_ldc_bs_loc_max_min_gain // unsigned ,    RW, default = 8'h20  the local boost gain,0x10 as "1"
//Bit 11: 0        reg_ldc_bs_loc_dark_scene_bl_th // unsigned ,    RW, default = 12'h600  the local threshold for dark scene
#define LDC_REG_TF                                 ((0x1435  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_tf_low_alpha      // unsigned ,    RW, default = 8'h20  the low alpha for temporal filter
//Bit 23:16        reg_ldc_tf_high_alpha     // unsigned ,    RW, default = 8'h20  the high alpha for temporal filter
//Bit 15: 8        reg_ldc_tf_low_alpha_sc   // unsigned ,    RW, default = 8'h40  the low alpha for temporal filter in scene change
//Bit  7: 0        reg_ldc_tf_high_alpha_sc  // unsigned ,    RW, default = 8'h40  the high alpha for temporal filter in scene change
#define LDC_REG_TF_SC                              ((0x1436  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8           reg_ldc_tf_sc_flag        // unsigned ,    RW, default = 0  the flag for scene change
//Bit  7: 4        reg_ldc_cmp_mask_x        // unsigned ,    RW, default = 7  the mask width from profile to calculate one block intensity
//Bit  3: 0        reg_ldc_cmp_mask_y        // unsigned ,    RW, default = 7  the mask height from profile to calculate one block intensity
#define LDC_REG_PROFILE_MODE                       ((0x1437  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 8        reg_ldc_profile_k         // unsigned ,    RW, default = 16'h240  the profile numerator coef
//Bit  7: 0        reg_ldc_profile_bits      // unsigned ,    RW, default = 8'h18  the profile denominator coef
#define LDC_REG_BLK_FILTER                         ((0x1438  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ldc_block_filter_a    // unsigned ,    RW, default = 56  the coef for block intensity filter
//Bit  7: 0        reg_ldc_block_filter_b    // unsigned ,    RW, default = 37  the coef for block intensity filter
#define LDC_REG_BLK_FILTER_COEF                    ((0x1439  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_block_filter_c    // unsigned ,    RW, default = 20  the coef for block intensity filter
//Bit 23:16        reg_ldc_block_filter_d    // unsigned ,    RW, default = 10  the coef for block intensity filter
//Bit 15: 8        reg_ldc_block_filter_e    // unsigned ,    RW, default = 5  the coef for block intensity filter
//Bit  7: 0        reg_ldc_block_filter_f    // unsigned ,    RW, default = 2  the coef for block intensity filter
#define LDC_REG_BL_MEMORY                          ((0x143a  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_ldc_bl_buf_diff       // unsigned ,    RW, default = 0  the memory diff frame
#define LDC_REG_FACTOR_DIV_0                       ((0x143b  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_factor_for_div_00 // unsigned ,    RW, default = 33893  the factor for divide,33893:2160; 34952:1080
//Bit 15: 0        reg_ldc_factor_for_div_01 // unsigned ,    RW, default = 33893  the factor for divide,33893:2160; 34952:1080
#define LDC_REG_FACTOR_DIV_1                       ((0x143c  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_factor_for_div_10 // unsigned ,    RW, default = 32896  the factor for divide
//Bit 15: 0        reg_ldc_factor_for_div_11 // unsigned ,    RW, default = 32896  the factor for divide
#define LDC_REG_BITS_DIV                           ((0x143d  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_bits_for_div_00   // unsigned ,    RW, default = 25  the bits for divide, 25:2160; 23:1080
//Bit 23:16        reg_ldc_bits_for_div_01   // unsigned ,    RW, default = 25  the bits for divide, 25:2160; 23:1080
//Bit 15: 8        reg_ldc_bits_for_div_10   // unsigned ,    RW, default = 25  the bits for divide, 25:2160; 23:1080
//Bit  7: 0        reg_ldc_bits_for_div_11   // unsigned ,    RW, default = 25  the bits for divide, 25:2160; 23:1080
#define LDC_REG_GLB_GAIN                           ((0x143e  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ldc_glb_gain          // unsigned ,    RW, default = 1024  the global coef for compensation gain
#define LDC_REG_DITHER                             ((0x143f  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_ldc_dth_en            // unsigned ,    RW, default = 0  the enable dither
//Bit  0           reg_ldc_dth_bw            // unsigned ,    RW, default = 0  0: 2bits, 1: 4bits
#define LDC_REG_MIN_GAIN_LUT_0                     ((0x1440  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_3    // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_2    // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_1    // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_0    // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_1                     ((0x1441  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_7    // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_6    // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_5    // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_4    // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_2                     ((0x1442  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_11   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_10   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_9    // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_8    // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_3                     ((0x1443  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_15   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_14   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_13   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_12   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_4                     ((0x1444  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_19   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_18   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_17   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_16   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_5                     ((0x1445  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_23   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_22   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_21   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_20   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_6                     ((0x1446  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_27   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_26   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_25   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_24   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_7                     ((0x1447  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_31   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_30   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_29   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_28   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_8                     ((0x1448  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_35   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_34   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_33   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_32   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_9                     ((0x1449  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_39   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_38   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_37   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_36   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_10                    ((0x144a  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_43   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_42   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_41   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_40   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_11                    ((0x144b  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_47   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_46   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_45   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_44   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_12                    ((0x144c  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_51   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_50   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_49   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_48   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_13                    ((0x144d  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_55   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_54   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_53   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_52   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_14                    ((0x144e  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_59   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_58   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_57   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_56   // unsigned ,    RW, default = 8'h40
#define LDC_REG_MIN_GAIN_LUT_15                    ((0x144f  << 2) + 0xff000000)
//Bit 31:24        reg_ldc_min_gain_lut_63   // unsigned ,    RW, default = 8'h40
//Bit 23:16        reg_ldc_min_gain_lut_62   // unsigned ,    RW, default = 8'h40
//Bit 15: 8        reg_ldc_min_gain_lut_61   // unsigned ,    RW, default = 8'h40
//Bit  7: 0        reg_ldc_min_gain_lut_60   // unsigned ,    RW, default = 8'h40
#define LDC_REG_DITHER_LUT_1_0                     ((0x1450  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_0         // unsigned ,    RW, default = 0  the reg dither lut_0
//Bit 15: 0        reg_ldc_dither_lut2_0         // unsigned ,    RW, default = 0  the reg dither lut_0
#define LDC_REG_LDC_DITHER_LUT_1_1                 ((0x1451  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_1         // unsigned ,    RW, default = 0  the reg dither lut_1
//Bit 15: 0        reg_ldc_dither_lut2_1         // unsigned ,    RW, default = 0  the reg dither lut_1
#define LDC_REG_LDC_DITHER_LUT_1_2                 ((0x1452  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_2         // unsigned ,    RW, default = 0  the reg dither lut_2
//Bit 15: 0        reg_ldc_dither_lut2_2         // unsigned ,    RW, default = 0  the reg dither lut_2
#define LDC_REG_LDC_DITHER_LUT_1_3                 ((0x1453  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_3         // unsigned ,    RW, default = 0  the reg dither lut_3
//Bit 15: 0        reg_ldc_dither_lut2_3         // unsigned ,    RW, default = 0  the reg dither lut_3
#define LDC_REG_LDC_DITHER_LUT_1_4                 ((0x1454  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_4         // unsigned ,    RW, default = 0  the reg dither lut_4
//Bit 15: 0        reg_ldc_dither_lut2_4         // unsigned ,    RW, default = 0  the reg dither lut_4
#define LDC_REG_LDC_DITHER_LUT_1_5                 ((0x1455  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_5         // unsigned ,    RW, default = 0  the reg dither lut_5
//Bit 15: 0        reg_ldc_dither_lut2_5         // unsigned ,    RW, default = 0  the reg dither lut_5
#define LDC_REG_LDC_DITHER_LUT_1_6                 ((0x1456  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_6         // unsigned ,    RW, default = 0  the reg dither lut_6
//Bit 15: 0        reg_ldc_dither_lut2_6         // unsigned ,    RW, default = 0  the reg dither lut_6
#define LDC_REG_LDC_DITHER_LUT_1_7                 ((0x1457  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_7         // unsigned ,    RW, default = 0  the reg dither lut_7
//Bit 15: 0        reg_ldc_dither_lut2_7         // unsigned ,    RW, default = 0  the reg dither lut_7
#define LDC_REG_LDC_DITHER_LUT_1_8                 ((0x1458  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_8         // unsigned ,    RW, default = 16'h8241  the reg dither lut_8
//Bit 15: 0        reg_ldc_dither_lut2_8         // unsigned ,    RW, default = 16'h8241  the reg dither lut_8
#define LDC_REG_LDC_DITHER_LUT_1_9                 ((0x1459  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_9         // unsigned ,    RW, default = 16'h4128  thereg    dither lut_9
//Bit 15: 0        reg_ldc_dither_lut2_9         // unsigned ,    RW, default = 16'h4128  thereg    dither lut_9
#define LDC_REG_LDC_DITHER_LUT_1_10                ((0x145a  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_10        // unsigned ,    RW, default = 16'h2814  thereg    dither lut_10
//Bit 15: 0        reg_ldc_dither_lut2_10        // unsigned ,    RW, default = 16'h2814  thereg    dither lut_10
#define LDC_REG_LDC_DITHER_LUT_1_11                ((0x145b  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_11        // unsigned ,    RW, default = 16'h1482  the reg dither lut_11
//Bit 15: 0        reg_ldc_dither_lut2_11        // unsigned ,    RW, default = 16'h1482  the reg dither lut_11
#define LDC_REG_LDC_DITHER_LUT_1_12                ((0x145c  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_12        // unsigned ,    RW, default = 16'h1482  the reg dither lut_12
//Bit 15: 0        reg_ldc_dither_lut2_12        // unsigned ,    RW, default = 16'h1482  the reg dither lut_12
#define LDC_REG_LDC_DITHER_LUT_1_13                ((0x145d  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_13        // unsigned ,    RW, default = 16'h2841  the reg dither lut_13
//Bit 15: 0        reg_ldc_dither_lut2_13        // unsigned ,    RW, default = 16'h2841  the reg dither lut_13
#define LDC_REG_LDC_DITHER_LUT_1_14                ((0x145e  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_14        // unsigned ,    RW, default = 16'h4128  the reg dither lut_14
//Bit 15: 0        reg_ldc_dither_lut2_14        // unsigned ,    RW, default = 16'h4128  the reg dither lut_14
#define LDC_REG_LDC_DITHER_LUT_1_15                ((0x145f  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_15        // unsigned ,    RW, default = 16'h8214  the reg dither lut_15
//Bit 15: 0        reg_ldc_dither_lut2_15        // unsigned ,    RW, default = 16'h8214  the reg dither lut_15
#define LDC_REG_LDC_DITHER_LUT_1_16                ((0x1460  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_16        // unsigned ,    RW, default = 16'h9696  the reg dither lut_16
//Bit 15: 0        reg_ldc_dither_lut2_16        // unsigned ,    RW, default = 16'h9696  the reg dither lut_16
#define LDC_REG_LDC_DITHER_LUT_1_17                ((0x1461  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_17        // unsigned ,    RW, default = 16'h6969  the reg dither lut_17
//Bit 15: 0        reg_ldc_dither_lut2_17        // unsigned ,    RW, default = 16'h6969  the reg dither lut_17
#define LDC_REG_LDC_DITHER_LUT_1_18                ((0x1462  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_18        // unsigned ,    RW, default = 16'h9696  the reg dither lut_18
//Bit 15: 0        reg_ldc_dither_lut2_18        // unsigned ,    RW, default = 16'h9696  the reg dither lut_18
#define LDC_REG_LDC_DITHER_LUT_1_19                ((0x1463  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_19        // unsigned ,    RW, default = 16'h6969  the reg dither lut_19
//Bit 15: 0        reg_ldc_dither_lut2_19        // unsigned ,    RW, default = 16'h6969  the reg dither lut_19
#define LDC_REG_LDC_DITHER_LUT_1_20                ((0x1464  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_20        // unsigned ,    RW, default = 16'h9669  the reg dither lut_20
//Bit 15: 0        reg_ldc_dither_lut2_20        // unsigned ,    RW, default = 16'h9669  the reg dither lut_20
#define LDC_REG_LDC_DITHER_LUT_1_21                ((0x1465  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_21        // unsigned ,    RW, default = 16'hc3c3  the reg dither lut_21
//Bit 15: 0        reg_ldc_dither_lut2_21        // unsigned ,    RW, default = 16'hc3c3  the reg dither lut_21
#define LDC_REG_LDC_DITHER_LUT_1_22                ((0x1466  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_22        // unsigned ,    RW, default = 16'h6996  the reg dither lut_22
//Bit 15: 0        reg_ldc_dither_lut2_22        // unsigned ,    RW, default = 16'h6996  the reg dither lut_22
#define LDC_REG_LDC_DITHER_LUT_1_23                ((0x1467  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_23        // unsigned ,    RW, default = 16'h3c3c  the reg dither lut_23
//Bit 15: 0        reg_ldc_dither_lut2_23        // unsigned ,    RW, default = 16'h3c3c  the reg dither lut_23
#define LDC_REG_LDC_DITHER_LUT_1_24                ((0x1468  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_24        // unsigned ,    RW, default = 16'h7dbe  the reg dither lut_24
//Bit 15: 0        reg_ldc_dither_lut2_24        // unsigned ,    RW, default = 16'h7dbe  the reg dither lut_24
#define LDC_REG_LDC_DITHER_LUT_1_25                ((0x1469  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_25        // unsigned ,    RW, default = 16'hbed7  the reg dither lut_25
//Bit 15: 0        reg_ldc_dither_lut2_25        // unsigned ,    RW, default = 16'hbed7  the reg dither lut_25
#define LDC_REG_LDC_DITHER_LUT_1_26                ((0x146a  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_26        // unsigned ,    RW, default = 16'hd7eb  the reg dither lut_26
//Bit 15: 0        reg_ldc_dither_lut2_26        // unsigned ,    RW, default = 16'hd7eb  the reg dither lut_26
#define LDC_REG_LDC_DITHER_LUT_1_27                ((0x146b  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_27        // unsigned ,    RW, default = 16'heb7d  the reg dither lut_27
//Bit 15: 0        reg_ldc_dither_lut2_27        // unsigned ,    RW, default = 16'heb7d  the reg dither lut_27
#define LDC_REG_LDC_DITHER_LUT_1_28                ((0x146c  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_28        // unsigned ,    RW, default = 16'heb7d  the reg dither lut_28
//Bit 15: 0        reg_ldc_dither_lut2_28        // unsigned ,    RW, default = 16'heb7d  the reg dither lut_28
#define LDC_REG_LDC_DITHER_LUT_1_29                ((0x146d  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_29        // unsigned ,    RW, default = 16'hd7be  the reg dither lut_29
//Bit 15: 0        reg_ldc_dither_lut2_29        // unsigned ,    RW, default = 16'hd7be  the reg dither lut_29
#define LDC_REG_LDC_DITHER_LUT_1_30                ((0x146e  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_30        // unsigned ,    RW, default = 16'hbed7  the reg dither lut_30
//Bit 15: 0        reg_ldc_dither_lut2_30        // unsigned ,    RW, default = 16'hbed7  the reg dither lut_30
#define LDC_REG_LDC_DITHER_LUT_1_31                ((0x146f  << 2) + 0xff000000)
//Bit 31:16        reg_ldc_dither_lut1_31        // unsigned ,    RW, default = 16'h7deb  the reg dither lut_31
//Bit 15: 0        reg_ldc_dither_lut2_31        // unsigned ,    RW, default = 16'h7deb  the reg dither lut_31
#define LDC_SEG_INFO_SEL                           ((0x1470  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit 0            reg_ldc_bl_duty_info_sft_upd  // unsigned ,  RW, default = 0  0:hardware update duty info; 1:software update duty info
#define LDC_DDR_ADDR_BASE                          ((0x1471  << 2) + 0xff000000)
//Bit 31:0         reg_ldc_ddr_addr_base       // unsigned ,    RW, default = 0  ldc ddr address base
#define LDC_GAIN_LUT_DATA                          ((0x1472  << 2) + 0xff000000)
//Bit 31:0         reg_ldc_gain_lut_data       // unsigned ,    RW, default = 0  gain lut address
#define LDC_GAIN_LUT_ADDR                          ((0x1473  << 2) + 0xff000000)
//Bit 31:0         reg_ldc_gain_lut_addr       // unsigned ,    RW, default = 0  gain lut data
#define LDC_GAIN_LUT_CTRL0                         ((0x1474  << 2) + 0xff000000)
//Bit 31:2         reserved
//Bit 1            reg_ldc_gain_lut_smp_data_en_clr // unsigned ,    RW, default = 0   clear reg_ldc_gain_lut_smp_data_en signal 1: enable 0:disable
//Bit 0            reg_ldc_gain_lut_wr              // unsigned ,    RW, default = 0  1:software write 0:software read.
#define LDC_GAIN_LUT_CTRL1                         ((0x1475  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit 0            reg_ldc_gain_lut_str             // unsigned ,    RW, default = 0  0->1:one software write/read start,postive edge valid.
#define LDC_ADJ_VS_CTRL                            ((0x1476  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:0          reg_ldc_blk_intsty_calc_intvl     // unsigned ,    RW, default = 200 delay for one block intensity calculation period
#define LDC_LOW_POWER_EN                           ((0x1477  << 2) + 0xff000000)
//Bit 31: 3       reserved
//Bit 2         reg_ldc_cbus_clk_gate_free         // unsigned ,    RW, default = 1 1:disable cbus        clock gate, 0: enable cbus         clock gate
//Bit 1         reg_ldc_calc_part_clk_gate_free    // unsigned ,    RW, default = 1 1:disable calculation clock gate, 0: enable calculation  clock gate
//Bit 0         reg_ldc_comp_part_clk_gate_free    // unsigned ,    RW, default = 1 1:disable compensation clock gate,0: enable compensation clock gate
#define LDC_CTRL_MISC0                             ((0x1478  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27    reg_ldc_frm_end_sel                     //unsigned , RW, default = 0   1: wait for all axi transfer finish 0:wait for last frame pixel
//Bit 26    reg_ldc_prt_func_en                     //unsigned , RW, default = 0   1: enable LDC output protect function 0:disable LDC output protect function
//Bit 25    reg_ldc_bl_input_sft_ctr_en             //unsigned , RW, default = 0   1: software control backlight info write index enable
//Bit 24:23 reg_ldc_bl_input_sft_wr_idx             //unsigned , RW, default = 0   backlight info write index, for debug only
//Bit 22    reg_ldc_vsync_get_bl_info_en            //unsigned , RW, default = 1   0:get backlight info every block line  (no vsync interrupt) 1:get  backlight info  accroding to vsync
//Bit 21:20 reg_ldc_hist_burst_len                  //unsigned , RW, default = 0   0:2 times 128bit 1:4 times 128bit 2,3:6 times      128bit
//Bit 19:18 reg_ldc_blk_intsty_burst_len            //unsigned , RW, default = 0   0:2 times 128bit 1:4 times 128bit 2:6   times      128bit 3:8        times 128bit
//Bit 17    reg_ldc_vs_edge_sel                     //unsigned , RW, default = 1   1:posedge vs sync   0:negedge vs sync
//Bit 16    reg_ldc_adj_vs_en                       //unsigned , RW, default = 0   move "vs" to frame end,so use front+back porch time to prefetch profile. 1:enable 0:disable;
//Bit 15:0  reg_ldc_adj_vs_delay_num                //unsigned , RW, default = 500 add a delay num to the frame end
#define LDC_CTRL_MISC1                             ((0x1479  << 2) + 0xff000000)
//Bit 31:4 reserved
//Bit 3    reg_ldc_sft_upd_glb_apl_en               //unsigned , RW, default = 1   update reg_ldc_glb_apl register every frame by .. 1: by software; 0: by hardware;
//Bit 2    reg_ldc_scn_chg_en                       //unsigned , RW, default = 0   positive edge available;
//Bit 1    reg_ldc_pref_chk_err_clr                 //unsigned , RW, default = 1   1:clear ldc_pref_chk_err signal; 0: no action;
//Bit 0    reg_ldc_pref_chk_err_det_mode            //unsigned , RW, default = 0   1:auto clear ldc_pref_chk_err  signal every frame; 0:no action;
#define LDC_DGB_CTRL                               ((0x147a  << 2) + 0xff000000)
//Bit 31:15      reserved
//Bit 14        reg_ldc_comp_en                    //unsigned,      RW, default = 1 1:enable ldc compensation   0:disable ldc compensation
//Bit 13        reg_ldc_comp_pxl_cmp_en            //unsigned,      RW, default = 1 1:enable comp_pxl_cmp_en    0:disable comp_pxl_cmp_en
//Bit 12        reg_ldc_comp_interp_pxl_en         //unsigned,      RW, default = 1 1:enable comp_interp_pxl_en 0:disable comp_interp_pxl_en
//Bit 11        reg_ldc_comp_blk_flt_en            //unsigned,      RW, default = 1 1:enable comp_blk_flt_en    0:disable comp_blk_flt_en
//Bit 10        reg_ldc_comp_blk_intsty_en         //unsigned,      RW, default = 1 1:enable comp_blk_intsty_en 0:disable comp_blk_intsty_en
//Bit 9        reg_ldc_calc_tmp_flt_en            //unsigned,      RW, default = 1 1:enable calc_tmp_flt_en    0:disable calc_tmp_flt_en
//Bit 8:5      reg_ldc_dbg_shft_num               //unsigned,      RW, default = 0 1:debug
//Bit 4:1       reg_ldc_dbg_pnt                    //unsigned,      RW, default = 0 detailed info,please refer to application note
//Bit 0         reg_ldc_dbg_en                     //unsigned,      RW, default = 0 0:normal mode 1: debug mode
#define LDC_RO_BL_MEMORY_IDX                       ((0x147b  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8           ro_ldc_seg_input_fid      // unsigned ,    RO, default = 0  the memory input segment info index
//Bit  7: 4        ro_ldc_bl_input_fid       // unsigned ,    RO, default = 0  the memory input frame backlight index
//Bit  3: 0        ro_ldc_bl_output_fid      // unsigned ,    RO, default = 0  the memory output frame backlight index
#define LDC_RO_GLB_HIST_SUM                        ((0x147c  << 2) + 0xff000000)
//Bit 31: 0        ro_ldc_glb_hist_data_sum  // unsigned ,    RO, default = 0  the global hist data sum
#define LDC_RO_GLB_HIST_CNT                        ((0x147d  << 2) + 0xff000000)
//Bit 31: 0        ro_ldc_glb_hist_cnt_sum   // unsigned ,    RO, default = 0  the global hist cnt sum
#define LDC_RO_GAIN_SMP_DATA                       ((0x147f  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           ro_ldc_gain_lut_smp_data_en           // unsigned ,    RO, default = 0  the output frame index
//Bit 23: 0        ro_ldc_gain_lut_smp_data              // unsigned ,    RO, default = 0  the output frame index
#define LDC_RO_PREF_CHK_ERROR                      ((0x1480  << 2) + 0xff000000)
//Bit 31:1        reserved
//Bit 0          ro_ldc_pref_chk_err      // unsigned ,    RO, 0:no error found; 1: found error ;
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./ldc_cbus.h
//
#define LCD_GAMMA_CNTL_PORT                        ((0x14a0  << 2) + 0xff000000)
#define LCD_GAMMA_DATA_PORT                        ((0x14a1  << 2) + 0xff000000)
#define LCD_GAMMA_ADDR_PORT                        ((0x14a2  << 2) + 0xff000000)
#define LCD_GAMMA_VCOM_HSWITCH_ADDR                ((0x14a3  << 2) + 0xff000000)
#define LCD_RGB_BASE_ADDR                          ((0x14a5  << 2) + 0xff000000)
#define LCD_RGB_COEFF_ADDR                         ((0x14a6  << 2) + 0xff000000)
#define LCD_POL_CNTL_ADDR                          ((0x14a7  << 2) + 0xff000000)
#define LCD_DITH_CNTL_ADDR                         ((0x14a8  << 2) + 0xff000000)
#define LCD_GAMMA_PROBE_CTRL                       ((0x14a9  << 2) + 0xff000000)
//read only
#define LCD_GAMMA_PROBE_COLOR_L                    ((0x14aa  << 2) + 0xff000000)
#define LCD_GAMMA_PROBE_COLOR_H                    ((0x14ab  << 2) + 0xff000000)
#define LCD_GAMMA_PROBE_HL_COLOR                   ((0x14ac  << 2) + 0xff000000)
#define LCD_GAMMA_PROBE_POS_X                      ((0x14ad  << 2) + 0xff000000)
#define LCD_GAMMA_PROBE_POS_Y                      ((0x14ae  << 2) + 0xff000000)
#define LCD_LCD_MCU_CTL                            ((0x14b0  << 2) + 0xff000000)
#define LCD_LCD_MCU_DATA_0                         ((0x14b1  << 2) + 0xff000000)
#define LCD_LCD_MCU_DATA_1                         ((0x14b2  << 2) + 0xff000000)
#define LCD_LCD_PORT_SWAP                          ((0x14b3  << 2) + 0xff000000)
#define LCD_GAMMA_CNTL_PORT0                       ((0x14b4  << 2) + 0xff000000)
#define LCD_GAMMA_DATA_PORT0                       ((0x14b5  << 2) + 0xff000000)
#define LCD_GAMMA_ADDR_PORT0                       ((0x14b6  << 2) + 0xff000000)
#define LCD_LDC_AXI_UGT                            ((0x14b7  << 2) + 0xff000000)
//
// Closing file:  ./lcd_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  LCD1_VCBUS_BASE = 0x15
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./lcd1_regs.h
//
#define LCD1_GAMMA_CNTL_PORT                       ((0x15a0  << 2) + 0xff000000)
#define LCD1_GAMMA_DATA_PORT                       ((0x15a1  << 2) + 0xff000000)
#define LCD1_GAMMA_ADDR_PORT                       ((0x15a2  << 2) + 0xff000000)
#define LCD1_GAMMA_VCOM_HSWITCH_ADDR               ((0x15a3  << 2) + 0xff000000)
#define LCD1_RGB_BASE_ADDR                         ((0x15a5  << 2) + 0xff000000)
#define LCD1_RGB_COEFF_ADDR                        ((0x15a6  << 2) + 0xff000000)
#define LCD1_POL_CNTL_ADDR                         ((0x15a7  << 2) + 0xff000000)
#define LCD1_DITH_CNTL_ADDR                        ((0x15a8  << 2) + 0xff000000)
#define LCD1_GAMMA_PROBE_CTRL                      ((0x15a9  << 2) + 0xff000000)
//read only
#define LCD1_GAMMA_PROBE_COLOR_L                   ((0x15aa  << 2) + 0xff000000)
#define LCD1_GAMMA_PROBE_COLOR_H                   ((0x15ab  << 2) + 0xff000000)
#define LCD1_GAMMA_PROBE_HL_COLOR                  ((0x15ac  << 2) + 0xff000000)
#define LCD1_GAMMA_PROBE_POS_X                     ((0x15ad  << 2) + 0xff000000)
#define LCD1_GAMMA_PROBE_POS_Y                     ((0x15ae  << 2) + 0xff000000)
#define LCD1_LCD_MCU_CTL                           ((0x15b0  << 2) + 0xff000000)
#define LCD1_LCD_MCU_DATA_0                        ((0x15b1  << 2) + 0xff000000)
#define LCD1_LCD_MCU_DATA_1                        ((0x15b2  << 2) + 0xff000000)
#define LCD1_LCD_PORT_SWAP                         ((0x15b3  << 2) + 0xff000000)
#define LCD1_GAMMA_CNTL_PORT0                      ((0x15b4  << 2) + 0xff000000)
#define LCD1_GAMMA_DATA_PORT0                      ((0x15b5  << 2) + 0xff000000)
#define LCD1_GAMMA_ADDR_PORT0                      ((0x15b6  << 2) + 0xff000000)
//
// Closing file:  ./lcd1_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  LCD2_VCBUS_BASE = 0x16
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./lcd2_regs.h
//
#define LCD2_GAMMA_CNTL_PORT                       ((0x16a0  << 2) + 0xff000000)
#define LCD2_GAMMA_DATA_PORT                       ((0x16a1  << 2) + 0xff000000)
#define LCD2_GAMMA_ADDR_PORT                       ((0x16a2  << 2) + 0xff000000)
#define LCD2_GAMMA_VCOM_HSWITCH_ADDR               ((0x16a3  << 2) + 0xff000000)
#define LCD2_RGB_BASE_ADDR                         ((0x16a5  << 2) + 0xff000000)
#define LCD2_RGB_COEFF_ADDR                        ((0x16a6  << 2) + 0xff000000)
#define LCD2_POL_CNTL_ADDR                         ((0x16a7  << 2) + 0xff000000)
#define LCD2_DITH_CNTL_ADDR                        ((0x16a8  << 2) + 0xff000000)
#define LCD2_GAMMA_PROBE_CTRL                      ((0x16a9  << 2) + 0xff000000)
//read only
#define LCD2_GAMMA_PROBE_COLOR_L                   ((0x16aa  << 2) + 0xff000000)
#define LCD2_GAMMA_PROBE_COLOR_H                   ((0x16ab  << 2) + 0xff000000)
#define LCD2_GAMMA_PROBE_HL_COLOR                  ((0x16ac  << 2) + 0xff000000)
#define LCD2_GAMMA_PROBE_POS_X                     ((0x16ad  << 2) + 0xff000000)
#define LCD2_GAMMA_PROBE_POS_Y                     ((0x16ae  << 2) + 0xff000000)
#define LCD2_LCD_MCU_CTL                           ((0x16b0  << 2) + 0xff000000)
#define LCD2_LCD_MCU_DATA_0                        ((0x16b1  << 2) + 0xff000000)
#define LCD2_LCD_MCU_DATA_1                        ((0x16b2  << 2) + 0xff000000)
#define LCD2_LCD_PORT_SWAP                         ((0x16b3  << 2) + 0xff000000)
#define LCD2_GAMMA_CNTL_PORT0                      ((0x16b4  << 2) + 0xff000000)
#define LCD2_GAMMA_DATA_PORT0                      ((0x16b5  << 2) + 0xff000000)
#define LCD2_GAMMA_ADDR_PORT0                      ((0x16b6  << 2) + 0xff000000)
//
// Closing file:  ./lcd2_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_mad_regs.h
//
//DEINTERLACE module start from 8'h90 end to 8'hff
// -----------------------------------------------
// REG_BASE:  MAD_VCBUS_BASE = 0x17
// -----------------------------------------------
#define DI_PRE_CTRL                                ((0x1700  << 2) + 0xff000000)
// bit 31,      cbus_pre_frame_rst
// bit 30,      cbus_pre_soft_rst
// bit 29,      pre_field_num
// bit 27:26,   mode_444c422
// bit 25,      di_cont_read_en
// bit 24:23,   mode_422c444
// bit 22,      mtn_after_nr
// bit 21:16,   pre_hold_fifo_lines
// bit 15,      nr_wr_by
// bit 14,      use_vdin_go_line
// bit 13,      di_prevdin_en
// bit 12,      di_pre_viu_link
// bit 11,      di_pre_repeat
// bit 10,      di_pre_drop_1st
// bit  9,      di_buf2_en
// bit  8,      di_chan2_en
// bit  7,      prenr_hist_en
// bit  6,      chan2_hist_en
// bit  5,      hist_check_en
// bit  4,      check_after_nr
// bit  3,      check222p_en
// bit  2,      check322p_en
// bit  1,      mtn_en
// bit  0,      nr_en
#define DI_POST_CTRL                               ((0x1701  << 2) + 0xff000000)
// bit 31,      cbus_post_frame_rst
// bit 30,      cbus_post_soft_rst
// bit 29,      post_field_num
// bit 21:16,   post_hold_fifo_lines
// bit 13,      prepost_link
// bit 12,      di_post_viu_link
// bit 11,      di_post_repeat
// bit 10,      di_post_drop_1st
// bit  9,      mif0_to_vpp_en
// bit  8,      di_vpp_out_en
// bit  7,      di_wr_bk_en
// bit  6,      di_mux_en
// bit  5,      di_blend_en
// bit  4,      di_mtnp_read_en
// bit  3,      di_mtn_buf_en
// bit  2,      di_ei_en
// bit  1,      di_buf1_en
// bit  0,      di_buf0_en
#define DI_POST_SIZE                               ((0x1702  << 2) + 0xff000000)
//bit 31:29,    diwr_field_mode     field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//bit 28:16,    vsize1post
//bit 12:0,     hsize1post
#define DI_PRE_SIZE                                ((0x1703  << 2) + 0xff000000)
//bit 31:29,    nrwr_field_mode     field mode,  0 frame mode, 4 for field mode botton field, 5 for field mode top field, , 6 for blank line mode
//bit 28:16,    vsize1pre
//bit 12:0,     hsize1pre
#define DI_EI_CTRL0                                ((0x1704  << 2) + 0xff000000)
//bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter && ...right>filter && ...top>filter && ...bot>filter -> filter
//bit 15:8,     ei0_threshold[2:+]
//bit 3,        ei0_vertical
//bit 2,        ei0_bpscf2
//bit 1,        ei0_bpsfar1
#define DI_EI_CTRL1                                ((0x1705  << 2) + 0xff000000)
//bit 31:24,    ei0_diff
//bit 23:16,    ei0_angle45
//bit 15:8,     ei0_peak
//bit 7:0,      ei0_cross
#define DI_EI_CTRL2                                ((0x1706  << 2) + 0xff000000)
//bit 31:24,    ei0_close2
//bit 23:16,    ei0_close1
//bit 15:8,     ei0_far2
//bit 7:0,      ei0_far1
//`define DI_NR_CTRL0               8'h07
//bit 26,       nr_cue_en
//bit 25,       nr2_en
#define DI_NR_CTRL1                                ((0x1708  << 2) + 0xff000000)
//bit 31:30,    mot_p1txtcore_mode
//bit 29:24,    mot_p1txtcore_clmt
//bit 21:16,    mot_p1txtcore_ylmt
//bit 15:8,     mot_p1txtcore_crate
//bit 7:0,      mot_p1txtcore_yrate
#define DI_NR_CTRL2                                ((0x1709  << 2) + 0xff000000)
//bit 29:24,    mot_curtxtcore_clmt
//bit 21:16,    mot_curtxtcore_ylmt
//bit 15:8,     mot_curtxtcore_crate
//bit 7:0,      mot_curtxtcore_yrate
//`define DI_NR_CTRL3               8'h0a
//no use
//`define DI_MTN_CTRL               8'h0b
//`define DI_CANVAS_URGENT0         8'h0a
//`define DI_CANVAS_URGENT1         8'h0b
#define DI_MTN_CTRL1                               ((0x170c  << 2) + 0xff000000)
//bit 11:8,		mtn_paramtnthd
//bit 7:0,      mtn_parafltthd
#define DI_BLEND_CTRL                              ((0x170d  << 2) + 0xff000000)
//bit 31,      blend_1_en
//bit 30,      blend_mtn_lpf
//bit 28,      post_mb_en
//bit 27,      blend_mtn3p_max
//bit 26,      blend_mtn3p_min
//bit 25,      blend_mtn3p_ave
//bit 24,      blend_mtn3p_maxtb
//bit 23,      blend_mtn_flt_en
//bit 22,      blend_data_flt_en
//bit 21:20,   blend_top_mode
//bit 19,      blend_reg3_enable
//bit 18,      blend_reg2_enable
//bit 17,      blend_reg1_enable
//bit 16,      blend_reg0_enable
//bit 15:14,   blend_reg3_mode
//bit 13:12,   blend_reg2_mode
//bit 11:10,   blend_reg1_mode
//bit 9:8,     blend_reg0_mode
//bit 7:0,     kdeint
//`define DI_BLEND_CTRL1            8'h0e
//no use
//`define DI_CANVAS_URGENT2         8'h0e
//`define DI_BLEND_CTRL2            8'h0f
//no use
#define DI_ARB_CTRL                                ((0x170f  << 2) + 0xff000000)
//bit 31:26,			di_arb_thd1
//bit 25:20,			di_arb_thd0
//bit 19,			di_arb_tid_mode
//bit 18,			di_arb_arb_mode
//bit 17,			di_arb_acq_en
//bit 16,			di_arb_disable_clk
//bit 15:0,			di_arb_req_en
#define DI_BLEND_REG0_X                            ((0x1710  << 2) + 0xff000000)
//bit 27:16,   blend_reg0_startx
//bit 11:0,    blend_reg0_endx
#define DI_BLEND_REG0_Y                            ((0x1711  << 2) + 0xff000000)
#define DI_BLEND_REG1_X                            ((0x1712  << 2) + 0xff000000)
#define DI_BLEND_REG1_Y                            ((0x1713  << 2) + 0xff000000)
#define DI_BLEND_REG2_X                            ((0x1714  << 2) + 0xff000000)
#define DI_BLEND_REG2_Y                            ((0x1715  << 2) + 0xff000000)
#define DI_BLEND_REG3_X                            ((0x1716  << 2) + 0xff000000)
#define DI_BLEND_REG3_Y                            ((0x1717  << 2) + 0xff000000)
#define DI_CLKG_CTRL                               ((0x1718  << 2) + 0xff000000)
//bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1, module clk is not gated (always on). [3] for pulldown,[2] for mtn_1,[1] for mtn_0,[0] for nr
//bit 23:16,   post_gclk_ctrl    no clk gate control. [4] for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0
//bit 1,       di_gate_all       clk shut down. if ==1 , all di clock shut down
//bit 0,       di_no_clk_gate    no clk gate control.     if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working.
#define DI_EI_CTRL3                                ((0x1719  << 2) + 0xff000000)
//bit 31,      reg_ei_1
//bit 30,      reg_demon_en
//bit 26:24,   reg_demon_mux
//bit 23:20,   reg_right_win
//bit 19:16,   reg_left_win
//bit 7:4,     reg_ei_sadm_quatize_margin
//bit 1:0,     reg_ei_sad_relative_mode
#define DI_EI_CTRL4                                ((0x171a  << 2) + 0xff000000)
//bit 29,      reg_ei_caldrt_ambliike2_biasvertical
//bit 28:24,   reg_ei_caldrt_addxla2list_drtmax
//bit 22:20,   reg_ei_caldrt_addxla2list_signm0th
//bit 19,      reg_ei_caldrt_addxla2list_mode
//bit 18:16,   reg_ei_signm_sad_cor_rate
//bit 15:12,   reg_ei_signm_sadi_cor_rate
//bit 11:6,    reg_ei_signm_sadi_cor_ofst
//bit 5:0,     reg_ei_signm_sad_ofst
#define DI_EI_CTRL5                                ((0x171b  << 2) + 0xff000000)
//bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd
//bit 26:24,   reg_ei_caldrt_cnflctchk_mg
//bit 23:22,   reg_ei_caldrt_cnflctchk_ws
//bit 21,      reg_ei_caldrt_cnflctchk_en
//bit 20,      reg_ei_caldrt_verfrc_final_en
//bit 19,      reg_ei_caldrt_verfrc_retimflt_en
//bit 18:16,   reg_ei_caldrt_verftc_eithratemth
//bit 15,      reg_ei_caldrt_verfrc_retiming_en
//bit 14:12,   reg_ei_caldrt_verfrc_bothratemth
//bit 11:9,    reg_ei_caldrt_ver_thrd
//bit 8:4,     reg_ei_caldrt_addxla2list_drtmin
//bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit
#define DI_EI_CTRL6                                ((0x171c  << 2) + 0xff000000)
//bit 31:24,   reg_ei_caldrt_abext_sad12thhig
//bit 23:16,   reg_ei_caldrt_abext_sad00thlow
//bit 15:8,    reg_ei_caldrt_abext_sad12thlow
//bit 6:4,     reg_ei_caldrt_abext_ratemth
//bit 2:0,     reg_ei_caldrt_abext_drtthrd
#define DI_EI_CTRL7                                ((0x171d  << 2) + 0xff000000)
//bit 29,      reg_ei_caldrt_xlanopeak_codien
//bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax
//bit 23,      reg_ei_caldrt_xlanopeak_en
//bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha
//bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd
//bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd
//bit 28:24,   reg_ei_caldrt_abext_sad00rate
//bit 28:24,   reg_ei_caldrt_abext_sad12rate
//bit 28:24,   reg_ei_caldrt_abext_sad00thhig
#define DI_EI_CTRL8                                ((0x171e  << 2) + 0xff000000)
//bit 30:28,   reg_ei_assign_headtail_magin
//bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode
//bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth
//bit 20,      reg_ei_caldrt_histchk_cnfid
//bit 19:16,   reg_ei_caldrt_histchk_thrd
//bit 15,      reg_ei_caldrt_histchk_abext
//bit 14,      reg_ei_caldrt_histchk_npen
//bit 13:11,   reg_ei_caldrt_amblike2_drtmg
//bit 10:8,    reg_ei_caldrt_amblike2_valmg
//bit 7:4,     reg_ei_caldrt_amblike2_alpha
//bit 3:0,     reg_ei_caldrt_amblike2_drtth
#define DI_EI_CTRL9                                ((0x171f  << 2) + 0xff000000)
//bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3
//bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en
//bit 26:24,   reg_ei_caldrt_conf_drtth
//bit 23:20,   reg_ei_caldrt_conf_absdrtth
//bit 19:18,   reg_ei_caldrt_abcheck_mode1
//bit 17:16,   reg_ei_caldrt_abcheck_mode0
//bit 15:12,   reg_ei_caldrt_abcheck_drth1
//bit 11:8,    reg_ei_caldrt_abcheck_drth0
//bit 6:4,     reg_ei_caldrt_abpnchk1_th
//bit 1,       reg_ei_caldrt_abpnchk1_en
//bit 0,       reg_ei_caldrt_abpnchk0_en
// DEINTERLACE mode check.
#define DI_MC_REG0_X                               ((0x1720  << 2) + 0xff000000)
//bit 27:16,   mc_reg0_start_x
//bit 11:0,    mc_reg0_end_x
#define DI_MC_REG0_Y                               ((0x1721  << 2) + 0xff000000)
#define DI_MC_REG1_X                               ((0x1722  << 2) + 0xff000000)
#define DI_MC_REG1_Y                               ((0x1723  << 2) + 0xff000000)
#define DI_MC_REG2_X                               ((0x1724  << 2) + 0xff000000)
#define DI_MC_REG2_Y                               ((0x1725  << 2) + 0xff000000)
#define DI_MC_REG3_X                               ((0x1726  << 2) + 0xff000000)
#define DI_MC_REG3_Y                               ((0x1727  << 2) + 0xff000000)
#define DI_MC_REG4_X                               ((0x1728  << 2) + 0xff000000)
#define DI_MC_REG4_Y                               ((0x1729  << 2) + 0xff000000)
#define DI_MC_32LVL0                               ((0x172a  << 2) + 0xff000000)
//bit 31:24,   mc_reg2_32lvl
//bit 23:16,   mc_reg1_32lvl
//bit 15:8,    mc_reg0_32lvl
//bit 7:0,     field_32lvl
#define DI_MC_32LVL1                               ((0x172b  << 2) + 0xff000000)
//bit 15:8,    mc_reg3_32lvl
//bit 7:0,     mc_reg4_32lvl
#define DI_MC_22LVL0                               ((0x172c  << 2) + 0xff000000)
//bit 31:16,   mc_reg0_22lvl
//bit 15:0,    field_22lvl
#define DI_MC_22LVL1                               ((0x172d  << 2) + 0xff000000)
//bit 31:16,   mc_reg2_22lvl
//bit 15:0,    mc_reg1_22lvl
#define DI_MC_22LVL2                               ((0x172e  << 2) + 0xff000000)
//bit 31:16,   mc_reg4_22lvl
//bit 15:0,    mc_reg3_22lvl
#define DI_MC_CTRL                                 ((0x172f  << 2) + 0xff000000)
//bit 4,       mc_reg4_en
//bit 3,       mc_reg3_en
//bit 2,       mc_reg2_en
//bit 1,       mc_reg1_en
//bit 0,       mc_reg0_en
#define DI_INTR_CTRL                               ((0x1730  << 2) + 0xff000000)
#define DI_INFO_ADDR                               ((0x1731  << 2) + 0xff000000)
#define DI_INFO_DATA                               ((0x1732  << 2) + 0xff000000)
#define DI_PRE_HOLD                                ((0x1733  << 2) + 0xff000000)
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
//     `define DET3D_MOTN_CFG                8'h34
//     //Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
//     //Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
//     //                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
//     //Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
//     //Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
//
//     `define DET3D_CB_CFG                  8'h35
//     //Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizontal or vertical combing detection.
//     //Bit 3:0,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizontal or vertical combing detection.
//
//     `define DET3D_SPLT_CFG                8'h36
//     //Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
//     //                                      The smaller of this value, the easier of the split line detected.
//     //Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
//     //                                      The smaller of this value, the more samples will be added to the estimation.
//
//     `define DET3D_HV_MUTE                 8'h37
//     //Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
//     //Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
//     //Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//     //Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//     //Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
//     //Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
//
//     `define DET3D_MAT_STA_P1M1            8'h38
//     //Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
//     //Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
//     //Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
//     //Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
//
//     `define DET3D_MAT_STA_P1TH            8'h39
//     //Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
//     //Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
//     //Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
//
//     `define DET3D_MAT_STA_M1TH            8'h3a
//     //Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
//     //Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
//     //Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
//
//     `define DET3D_MAT_STA_RSFT            8'h3b
//     //Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//     //Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//     //Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//     //                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//
//     `define DET3D_MAT_SYMTC_TH            8'h3c
//     //Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
//     //Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
//     //Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
//     //Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
//
//     `define DET3D_RO_DET_CB_HOR           8'h3d
//     //Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
//     //Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
//
//     `define DET3D_RO_DET_CB_VER           8'h3e
//     //Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
//     //Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
//
//     `define DET3D_RO_SPLT_HT              8'h3f
//     //Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
//     //Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
//     //Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//
//     //// DET 3D REG DEFINE END ////
#define DI_MTN_1_CTRL1                             ((0x1740  << 2) + 0xff000000)
//bit 31,      mtn_1_en
//bit 30,      mtn_init
//bit 29,      di2nr_txt_en
//bit 28,      reserved
//bit 27:24,   mtn_def
//bit 23:16,   mtn_adp_yc
//bit 15:8,    mtn_adp_2c
//bit 7:0,     mtn_adp_2y
#define DI_MTN_1_CTRL2                             ((0x1741  << 2) + 0xff000000)
//bit 31:24,   mtn_ykinter
//bit 23:16,   mtn_ckinter
//bit 15:8,    mtn_ykintra
//bit  7:0,    mtn_ckintra
#define DI_MTN_1_CTRL3                             ((0x1742  << 2) + 0xff000000)
//bit 31:24,   mtn_tyrate
//bit 23:16,   mtn_tcrate
//bit 15: 8,   mtn_mxcmby
//bit  7: 0,   mtn_mxcmbc
#define DI_MTN_1_CTRL4                             ((0x1743  << 2) + 0xff000000)
//bit 31:24,   mtn_tcorey
//bit 23:16,   mtn_tcorec
//bit 15: 8,   mtn_minth
//bit  7: 0,   mtn_maxth
#define DI_MTN_1_CTRL5                             ((0x1744  << 2) + 0xff000000)
//bit 31:28,   mtn_m1b_extnd
//bit 27:24,   mtn_m1b_errod
//bit 21:20,   mtn_mot_txt_mode
//bit 19:18,   mtn_replace_cbyy
//bit 17:16,   mtn_replace_ybyc
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
//// NR2 REG DEFINE BEGIN////
#define NR2_MET_NM_CTRL                            ((0x1745  << 2) + 0xff000000)
//Bit 28,	   reg_NM_reset	          Reset to the status of the Loop filter.
//Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise measurement sample number for statistics.
//                                    0:  256 samples;    1: 512 samples;    2: 1024 samples;   X: 2^(8+x) samples
//Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step.
//Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step.
//Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion for condition of pixels included in Luma Noise measurement.
//Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion for condition of pixels included in Chroma Noise measurement.
#define NR2_MET_NM_YCTRL                           ((0x1746  << 2) + 0xff000000)
//Bit 31:28,   reg_NM_YPLL_target	      Target rate of NM_Ynoise_thrd to mean of the Luma Noise
//Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP portion motion for condition of pixels included in Luma Noise measurement.
//Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
//Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma channel HP portion motion to decide whether the pixel will be included in Luma noise measurement.
//Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the Luma noise measurement is lock or not.
#define NR2_MET_NM_CCTRL                           ((0x1747  << 2) + 0xff000000)
//Bit 31:28,	reg_NM_CPLL_target	     Target rate of NM_Cnoise_thrd to mean of the Chroma Noise
//Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion for condition of pixels included in Chroma Noise measurement.
//Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
//Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma channel HP portion motion to decide whether the pixel will be included in Chroma noise measurement.
//Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma noise measurement is lock or not;
#define NR2_MET_NM_TNR                             ((0x1748  << 2) + 0xff000000)
//Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell ifLuma channel noise measurement is locked or not.
//Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell if Chroma channel noise measurement is locked or not.
//Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma channel noise level. It was 16x of pixel difference in 8 bits of YHPmot.
//Bit 11:0,	ro_NM_TNR_Clevel	         Read-only register to give Chroma channel noise level. It was 16x of pixel difference in 8 bits of CHPmot.
#define NR2_MET_NMFRM_TNR_YLEV                     ((0x1749  << 2) + 0xff000000)
//Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register to give Luma channel noise level within one frame/field.
#define NR2_MET_NMFRM_TNR_YCNT                     ((0x174a  << 2) + 0xff000000)
//Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels included in Frame/Field based noise level measurement.
#define NR2_MET_NMFRM_TNR_CLEV                     ((0x174b  << 2) + 0xff000000)
//Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register to give Chroma channel noise level within one frame/field.
#define NR2_MET_NMFRM_TNR_CCNT                     ((0x174c  << 2) + 0xff000000)
//Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels included in Frame/Field based noise level measurement.
#define NR2_3DEN_MODE                              ((0x174d  << 2) + 0xff000000)
//Bit 6:4,	Blend_3dnr_en_r
//Bit 2:0,	Blend_3dnr_en_l
//   `define NR2_IIR_CTRL                8'h4e
//   //Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//   //Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute,
//   //Bit 11:8,	 reg_LP_IIR_mute_thrd	Threshold of LP IIR mute to avoid ghost:
//   //Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be store in memory;1: 9bits will be store in memory;
//   //                                  2: 8bits will be store in memory;3: 7bits will be store in memory;
//   //Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute
//   //Bit 3:0,	reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost
//   //
#define NR2_SW_EN                                  ((0x174f  << 2) + 0xff000000)
//Bit 17:8,	Clk_gate_ctrl
//Bit 7,	Cfr_enable
//Bit 5,	Det3d_en
//Bit 4,	Nr2_proc_en
//Bit 0,	Nr2_sw_en
#define NR2_FRM_SIZE                               ((0x1750  << 2) + 0xff000000)
//Bit 27:16,  Frm_heigh	Frame/field height
//Bit 11: 0,  Frm_width	Frame/field width
//   `define NR2_SNR_SAD_CFG             8'h51
//   //Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel position SAD by SAD_min;1: do replacements
//   //Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);sum = (sum<0) ? 0: (sum>255)? 255: sum;
//   //Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
//   //Bit 4:0,	Sad_coef_num	            Sad coeffient
//
//   `define NR2_MATNR_SNR_OS            8'h52
//   //Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control margin for UV channel (X2 to u10 scale)
//   //Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control margin for luma channel (X2 to u10 scale)
//
//   `define NR2_MATNR_SNR_NRM_CFG       8'h53
//   //Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR boosting normalization offset to SAD_max ;
//   //Bit 15:8,	    reg_MATNR_SNR_NRM_max	Edge based SNR boosting normalization Max value
//   //Bit 7:0,	    reg_MATNR_SNR_NRM_min	Edge based SNR boosting normalization Min value
//
//   `define NR2_MATNR_SNR_NRM_GAIN      8'h54
//   //Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting normalization Gain for Chrm channel (norm 32 as 1)
//   //Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting normalization Gain for Luma channel (norm 32 as 1)
//
//   `define NR2_MATNR_SNR_LPF_CFG       8'h55
//   //Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH) SNRLPF_yuv[k] = TNRLPF_yuv[k];
//   //Bit 13:11,reg_MATNR_SNRLPF_Cmode	    LPF based SNR filtering mode on CHRM channel:
//   //                                      0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16;
//   //                                      4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[]
//   //Bit 10:8,	reg_MATNR_SNRLPF_Ymode	    LPF based SNR filtering mode on LUMA channel:
//   //                                      0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16;
//   //                                      4: TNRLPF;               5 : CurLPF3x3_yuv[];       6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[]
//   //Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
//   //Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale)
//
//   `define NR2_MATNR_SNR_USF_GAIN      8'h56
//   //Bit 15:8,	reg_MATNR_SNR_USF_Cgain	    Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1)
//   //Bit 7:0,	reg_MATNR_SNR_USF_Ygain	    Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1)
//
//   `define NR2_MATNR_SNR_EDGE2B        8'h57
//   //Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,  Offset for Beta based on Edge.
//   //Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.  Gain to SAD_min for Beta based on Edge. (norm 16 as 1)
//
//   `define NR2_MATNR_BETA_EGAIN        8'h58
//   //Bit 15:8,	reg_MATNR_CBeta_Egain	U8,  Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1)
//   //Bit 7:0,	reg_MATNR_YBeta_Egain	U8,  Gain to Edge based Beta for Luma channel. (normalized to 32 as 1)
//
//   `define NR2_MATNR_BETA_BRT          8'h59
//   //Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,  Beta adjustment based on Brightness high side Limit. (X16 to u8 scale)
//   //Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,  Beta adjustment based on Brightness high side slope. Normalized to 16 as 1
//   //Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,  Beta adjustment based on Brightness high threshold.(u8 scale)
//   //Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,  Beta adjustment based on Brightness low side Limit. (X16 to u8 scale)
//   //Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,  Beta adjustment based on Brightness low side slope. Normalized to 16 as 1
//   //Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,  Beta adjustment based on Brightness low threshold.(u8 scale)
//   `define NR2_MATNR_XBETA_CFG         8'h5a
//   //Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Chrm channel;
//   //Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,  Beta options (mux) from beta_motion and beta_edge for Luma channel;
//   //Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,  Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux)
//   //Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,  Offset to Beta for Luma channel.(after beta_edge and beta_motion mux)
//   `define NR2_MATNR_YBETA_SCL         8'h5b
//   //Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,  Final step Beta scale low limit for Luma channel;
//   //Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,  Final step Beta scale high limit for Luma channe;
//   //Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,  Final step Beta scale Gain for Luma channel (normalized 32 to 1);
//   //Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,  Final step Beta scale offset for Luma channel ;
//   `define NR2_MATNR_CBETA_SCL         8'h5c
//   //Bit 31:24,	reg_MATNR_CBeta_scale_min	Final step Beta scale low limit for Chrm channel.Similar to Y
//   //Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,  Final step Beta scale high limit for Chrm channel.Similar to Y
//   //Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,  Final step Beta scale Gain for Chrm channel Similar to Y
//   //Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,  Final step Beta scale offset for Chrm channel Similar to Y
//   `define NR2_SNR_MASK                8'h5d
//   //Bit 20:0, 	SAD_MSK	                    Valid signal in the 3x7 SAD surface
//   `define NR2_SAD2NORM_LUT0           8'h5e
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3	SAD convert normal LUT node 3
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2	SAD convert normal LUT node 2
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1	SAD convert normal LUT node 1
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0	SAD convert normal LUT node 0
//   `define NR2_SAD2NORM_LUT1           8'h5f
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7	SAD convert normal LUT node 7
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6	SAD convert normal LUT node 6
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5	SAD convert normal LUT node 5
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4	SAD convert normal LUT node 4
//   `define NR2_SAD2NORM_LUT2           8'h60
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11	SAD convert normal LUT node 11
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10	SAD convert normal LUT node 10
//   //Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9	SAD convert normal LUT node 9
//   //Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8	SAD convert normal LUT node 8
//   `define NR2_SAD2NORM_LUT3           8'h61
//   //Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15	SAD convert normal LUT node 15
//   //Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14	SAD convert normal LUT node 14
//   //Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13	SAD convert normal LUT node 13
//   //Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12	SAD convert normal LUT node 12
//   `define NR2_EDGE2BETA_LUT0          8'h62
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3	Edge convert beta LUT node 3
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2	Edge convert beta LUT node 2
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1	Edge convert beta LUT node 1
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0	Edge convert beta LUT node 0
//   `define NR2_EDGE2BETA_LUT1          8'h63
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7	Edge convert beta LUT node 7
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6	Edge convert beta LUT node 6
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5	Edge convert beta LUT node 5
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4	Edge convert beta LUT node 4
//   `define NR2_EDGE2BETA_LUT2          8'h64
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11	Edge convert beta LUT node 11
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10	Edge convert beta LUT node 10
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9	Edge convert beta LUT node 9
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8	Edge convert beta LUT node 8
//   `define NR2_EDGE2BETA_LUT3          8'h65
//   //Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15	Edge convert beta LUT node 15
//   //Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14	Edge convert beta LUT node 14
//   //Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13	Edge convert beta LUT node 13
//   //Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12	Edge convert beta LUT node 12
//   `define NR2_MOTION2BETA_LUT0        8'h66
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3	Motion convert beta LUT node 3
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2	Motion convert beta LUT node 2
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1	Motion convert beta LUT node 1
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0	Motion convert beta LUT node 0
//   `define NR2_MOTION2BETA_LUT1        8'h67
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7	Motion convert beta LUT node 7
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6	Motion convert beta LUT node 6
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5	Motion convert beta LUT node 5
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4	Motion convert beta LUT node 4
//   `define NR2_MOTION2BETA_LUT2        8'h68
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11	Motion convert beta LUT node 11
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10	Motion convert beta LUT node 10
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9	Motion convert beta LUT node 9
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8	Motion convert beta LUT node 8
//   `define NR2_MOTION2BETA_LUT3        8'h69
//   //Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15	Motion convert beta LUT node 15
//   //Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14	Motion convert beta LUT node 14
//   //Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13	Motion convert beta LUT node 13
//   //Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12	Motion convert beta LUT node 12
//    `define NR2_MATNR_MTN_CRTL          8'h6a
//    //Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
//    //Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4; 2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot)
//    //Bit 17:16,	reg_MATNR_Ymtn_use_mode	    Motion_yuvLuma channel motion selection mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4; 2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot)
//    //Bit 13:12,	reg_MATNR_mtn_txt_mode	    Texture detection mode for adaptive coring of HP motion
//    //Bit  9: 8,	reg_MATNR_mtn_cor_mode	    Coring selection mode based on texture detection;
//    //Bit  6: 4,	reg_MATNR_mtn_hpf_mode	    video mode of current and previous frame/field for MotHPF_yuv[k] calculation:
//    //Bit  2: 0,	reg_MATNR_mtn_lpf_mode	    LPF video mode of current and previous frame/field for MotLPF_yuv[k] calculation:
//    `define NR2_MATNR_MTN_CRTL2         8'h6b
//    //Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter mode for Luma LPF result generation (Cur and Prev);
//    //Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to motion_brtlp_uv, normalized to 32 as 1
//    //Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to motion_brtlp_y, normalized to 32 as 1
//    `define NR2_MATNR_MTN_COR           8'h6c
//    //Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion.
//    //Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for Chroma Motion. Normalized to 16 as 1
//    //Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion.
//    //Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for Luma Motion. Normalized to 16 as 1
//    `define NR2_MATNR_MTN_GAIN          8'h6d
//    //Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
//    //Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
//    //Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
//    //Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
//    `define NR2_MATNR_DEGHOST           8'h6e
//    //Bit 8,	reg_MATNR_DeGhost_En	Enable signal for DeGhost function:0: disable; 1: enable
//    //Bit 7:4,	reg_MATNR_DeGhost_COS	DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
//    //Bit 3:0,	reg_MATNR_DeGhost_YOS	DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
//
//    `define NR2_MATNR_ALPHALP_LUT0      8'h6f
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_3	    Matnr low-pass filter alpha LUT node 3
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_2	    Matnr low-pass filter alpha LUT node 2
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1	    Matnr low-pass filter alpha LUT node 1
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0	    Matnr low-pass filter alpha LUT node 0
//    `define NR2_MATNR_ALPHALP_LUT1      8'h70
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_7	    Matnr low-pass filter alpha LUT node 7
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_6	    Matnr low-pass filter alpha LUT node 6
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5	    Matnr low-pass filter alpha LUT node 5
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4	    Matnr low-pass filter alpha LUT node 4
//    `define NR2_MATNR_ALPHALP_LUT2      8'h71
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_11	Matnr low-pass filter alpha LUT node 11
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_10	Matnr low-pass filter alpha LUT node 10
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9	    Matnr low-pass filter alpha LUT node 9
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8	    Matnr low-pass filter alpha LUT node 8
//    `define NR2_MATNR_ALPHALP_LUT3      8'h72
//    //Bit 31:24,	reg_MATNR_AlphaLP_LUT_15	Matnr low-pass filter alpha LUT node 15
//    //Bit 23:16,	reg_MATNR_AlphaLP_LUT_14	Matnr low-pass filter alpha LUT node 14
//    //Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13	Matnr low-pass filter alpha LUT node 13
//    //Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12	Matnr low-pass filter alpha LUT node 12
//    `define NR2_MATNR_ALPHAHP_LUT0      8'h73
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_3	    Matnr high-pass filter alpha LUT node 3
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_2	    Matnr high-pass filter alpha LUT node 2
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1	    Matnr high-pass filter alpha LUT node 1
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0	    Matnr high-pass filter alpha LUT node 0
//    `define NR2_MATNR_ALPHAHP_LUT1      8'h74
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_7	    Matnr high-pass filter alpha LUT node 7
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_6	    Matnr high-pass filter alpha LUT node 6
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5	    Matnr high-pass filter alpha LUT node 5
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4	    Matnr high-pass filter alpha LUT node 4
//    `define NR2_MATNR_ALPHAHP_LUT2      8'h75
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_11	Matnr high-pass filter alpha LUT node 11
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_10	Matnr high-pass filter alpha LUT node 10
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9	    Matnr high-pass filter alpha LUT node 9
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8	    Matnr high-pass filter alpha LUT node 8
//    `define NR2_MATNR_ALPHAHP_LUT3      8'h76
//    //Bit 31:24,	reg_MATNR_AlphaHP_LUT_15	Matnr high-pass filter alpha LUT node 15
//    //Bit 23:16,	reg_MATNR_AlphaHP_LUT_14	Matnr high-pass filter alpha LUT node 14
//    //Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13	Matnr high-pass filter alpha LUT node 13
//    //Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12	Matnr high-pass filter alpha LUT node 12
//
//    `define NR2_MATNR_MTNB_BRT          8'h77
//    //Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on Brightness high side Limit. (X16 to u8 scale)
//    //Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on Brightness high side slope. Normalized to 16 as 1
//    //Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on Brightness high threshold.(u8 scale)
//    //Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on Brightness low side Limit. (X16 to u8 scale)
//    //Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on Brightness low side slope. Normalized to 16 as 1
//    //Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on Brightness low threshold.(u8 scale)
// 0x51 - 0x69 | 0x4e | 0x6a - 0x77
//
// Reading file:  ./vpu_nr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//========== nr2_snr_regs register begin ==========//
#define NR2_SNR_SAD_CFG                            ((0x1751  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12           reg_matnr_snr_sad_cenrpl       // unsigned , default = 1
//Bit 11: 8        reg_matnr_snr_sad_coring       // unsigned , default = 3
//Bit  7            reserved
//Bit  6: 5        reg_matnr_snr_sad_winmod       // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
//Bit  4: 0        sad_coef_num                      // unsigned , default = 1     0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1];
#define NR2_MATNR_SNR_OS                           ((0x1752  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_matnr_snr_cos              // unsigned , default = 8
//Bit  3: 0        reg_matnr_snr_yos              // unsigned , default = 13
#define NR2_MATNR_SNR_NRM_CFG                      ((0x1753  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_matnr_snr_nrm_ofst         // signed , default = 64
//Bit 15: 8        reg_matnr_snr_nrm_max          // unsigned , default = 255
//Bit  7: 0        reg_matnr_snr_nrm_min          // unsigned , default = 0
#define NR2_MATNR_SNR_NRM_GAIN                     ((0x1754  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_nrm_cgain        // unsigned , default = 0     norm 32
//Bit  7: 0        reg_matnr_snr_nrm_ygain        // unsigned , default = 32    norm 32
#define NR2_MATNR_SNR_LPF_CFG                      ((0x1755  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_matnr_snrlpf_sadmaxth      // unsigned , default = 12
//Bit 15:14        reserved
//Bit 13:11        reg_matnr_snrlpf_cmode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
//Bit 10: 8        reg_matnr_snrlpf_ymode         // unsigned , default = 2     0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4; 2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 5 4 3]/16;
//Bit  7: 4        reg_matnr_snrlpf_sadmin3th     // unsigned , default = 6     X8
//Bit  3: 0        reg_matnr_snrlpf_sadmin2th     // unsigned , default = 4     X8
#define NR2_MATNR_SNR_USF_GAIN                     ((0x1756  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_usf_cgain        // unsigned , default = 0     norm 64
//Bit  7: 0        reg_matnr_snr_usf_ygain        // unsigned , default = 0     norm 64
#define NR2_MATNR_SNR_EDGE2B                       ((0x1757  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_snr_edge2beta_ofst   // unsigned , default = 128
//Bit  7: 0        reg_matnr_snr_edge2beta_gain   // unsigned , default = 16
#define NR2_MATNR_BETA_EGAIN                       ((0x1758  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_matnr_cbeta_egain          // unsigned , default = 32    normalized to 32
//Bit  7: 0        reg_matnr_ybeta_egain          // unsigned , default = 32    normalized to 32
#define NR2_MATNR_BETA_BRT                         ((0x1759  << 2) + 0xff000000)
//Bit 31:28        reg_matnr_beta_brt_limt_hi     // unsigned , default = 0
//Bit 27:24        reg_matnr_beta_brt_slop_hi     // unsigned , default = 0
//Bit 23:16        reg_matnr_beta_brt_thrd_hi     // unsigned , default = 160
//Bit 15:12        reg_matnr_beta_brt_limt_lo     // unsigned , default = 6
//Bit 11: 8        reg_matnr_beta_brt_slop_lo     // unsigned , default = 6
//Bit  7: 0        reg_matnr_beta_brt_thrd_lo     // unsigned , default = 100
#define NR2_MATNR_XBETA_CFG                        ((0x175a  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:18        reg_matnr_cbeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2
//Bit 17:16        reg_matnr_ybeta_use_mode       // unsigned , default = 0     0: beta_motion; 1: beta_edge; 2: min(beta_mot,beta_edge); 3: (beta_mot + beta_edge)/2;
//Bit 15: 8        reg_matnr_cbeta_ofst           // unsigned , default = 0
//Bit  7: 0        reg_matnr_ybeta_ofst           // unsigned , default = 0
#define NR2_MATNR_YBETA_SCL                        ((0x175b  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_ybeta_scale_min      // unsigned , default = 60
//Bit 23:16        reg_matnr_ybeta_scale_max      // unsigned , default = 255
//Bit 15: 8        reg_matnr_ybeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
//Bit  7: 0        reg_matnr_ybeta_scale_ofst     // signed , default = 0
#define NR2_MATNR_CBETA_SCL                        ((0x175c  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_cbeta_scale_min      // unsigned , default = 0
//Bit 23:16        reg_matnr_cbeta_scale_max      // unsigned , default = 255
//Bit 15: 8        reg_matnr_cbeta_scale_gain     // unsigned , default = 32    normalized 32 to 1.0
//Bit  7: 0        reg_matnr_cbeta_scale_ofst     // signed , default = 0
#define NR2_SNR_MASK                               ((0x175d  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        sad_msk                        // unsigned , default = 0x0f9f3e
#define NR2_SAD2NORM_LUT0                          ((0x175e  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_sad2norm_lut3      // unsigned , default = 114
//Bit 23:16        reg_matnr_sad2norm_lut2      // unsigned , default = 146
//Bit 15: 8        reg_matnr_sad2norm_lut1      // unsigned , default = 171
//Bit  7: 0        reg_matnr_sad2norm_lut0      // unsigned , default = 205
#define NR2_SAD2NORM_LUT1                          ((0x175f  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_sad2norm_lut7      // unsigned , default = 28
//Bit 23:16        reg_matnr_sad2norm_lut6      // unsigned , default = 35
//Bit 15: 8        reg_matnr_sad2norm_lut5      // unsigned , default = 49
//Bit  7: 0        reg_matnr_sad2norm_lut4      // unsigned , default = 79
#define NR2_SAD2NORM_LUT2                          ((0x1760  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_sad2norm_lut11     // unsigned , default = 15
//Bit 23:16        reg_matnr_sad2norm_lut10     // unsigned , default = 17
//Bit 15: 8        reg_matnr_sad2norm_lut9      // unsigned , default = 19
//Bit  7: 0        reg_matnr_sad2norm_lut8      // unsigned , default = 23
#define NR2_SAD2NORM_LUT3                          ((0x1761  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_sad2norm_lut15     // unsigned , default = 8
//Bit 23:16        reg_matnr_sad2norm_lut14     // unsigned , default = 9
//Bit 15: 8        reg_matnr_sad2norm_lut13     // unsigned , default = 10
//Bit  7: 0        reg_matnr_sad2norm_lut12     // unsigned , default = 12
#define NR2_EDGE2BETA_LUT0                         ((0x1762  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_edge2beta_lut3    // unsigned , default = 128
//Bit 23:16        reg_matnr_edge2beta_lut2    // unsigned , default = 160
//Bit 15: 8        reg_matnr_edge2beta_lut1    // unsigned , default = 224
//Bit  7: 0        reg_matnr_edge2beta_lut0    // unsigned , default = 255
#define NR2_EDGE2BETA_LUT1                         ((0x1763  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_edge2beta_lut7    // unsigned , default = 4
//Bit 23:16        reg_matnr_edge2beta_lut6    // unsigned , default = 16
//Bit 15: 8        reg_matnr_edge2beta_lut5    // unsigned , default = 32
//Bit  7: 0        reg_matnr_edge2beta_lut4    // unsigned , default = 80
#define NR2_EDGE2BETA_LUT2                         ((0x1764  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_edge2beta_lut11    // unsigned , default = 0
//Bit 23:16        reg_matnr_edge2beta_lut10    // unsigned , default = 0
//Bit 15: 8        reg_matnr_edge2beta_lut9    // unsigned , default = 0
//Bit  7: 0        reg_matnr_edge2beta_lut8    // unsigned , default = 2
#define NR2_EDGE2BETA_LUT3                         ((0x1765  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_edge2beta_lut15    // unsigned , default = 0
//Bit 23:16        reg_matnr_edge2beta_lut14    // unsigned , default = 0
//Bit 15: 8        reg_matnr_edge2beta_lut13    // unsigned , default = 0
//Bit  7: 0        reg_matnr_edge2beta_lut12    // unsigned , default = 0
#define NR2_MOTION2BETA_LUT0                       ((0x1766  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_mot2beta_lut3     // unsigned , default = 32
//Bit 23:16        reg_matnr_mot2beta_lut2     // unsigned , default = 16
//Bit 15: 8        reg_matnr_mot2beta_lut1     // unsigned , default = 4
//Bit  7: 0        reg_matnr_mot2beta_lut0     // unsigned , default = 0
#define NR2_MOTION2BETA_LUT1                       ((0x1767  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_mot2beta_lut7     // unsigned , default = 196
//Bit 23:16        reg_matnr_mot2beta_lut6     // unsigned , default = 128
//Bit 15: 8        reg_matnr_mot2beta_lut5     // unsigned , default = 64
//Bit  7: 0        reg_matnr_mot2beta_lut4     // unsigned , default = 48
#define NR2_MOTION2BETA_LUT2                       ((0x1768  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_mot2beta_lut11     // unsigned , default = 255
//Bit 23:16        reg_matnr_mot2beta_lut10     // unsigned , default = 255
//Bit 15: 8        reg_matnr_mot2beta_lut9     // unsigned , default = 240
//Bit  7: 0        reg_matnr_mot2beta_lut8     // unsigned , default = 224
#define NR2_MOTION2BETA_LUT3                       ((0x1769  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_mot2beta_lut15     // unsigned , default = 255
//Bit 23:16        reg_matnr_mot2beta_lut14     // unsigned , default = 255
//Bit 15: 8        reg_matnr_mot2beta_lut13     // unsigned , default = 255
//Bit  7: 0        reg_matnr_mot2beta_lut12     // unsigned , default = 255
//========== nr2_snr_regs register end ==========//
//========== nr2_tnr_regs register begin ==========//
#define NR2_IIR_CTRL                               ((0x174e  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:14        reg_lp_iir_8bit_mode      // unsigned , default = 0  10bits; 1: 9bits; 2: 8bits 3: 7bits
//Bit 13:12        reg_hp_iir_mute_mode      // unsigned , default = 0
//Bit 11: 8        reg_hp_iir_mute_thrd      // unsigned , default = 0
//Bit  7: 6        reg_hp_iir_8bit_mode      // unsigned , default = 0
//Bit  5: 4        reg_lp_iir_mute_mode      // unsigned , default = 0
//Bit  3: 0        reg_lp_iir_mute_thrd      // unsigned , default = 0
#define NR2_MATNR_MTN_CRTL                         ((0x176a  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:18        reg_matnr_vmtn_use_mode   // unsigned , default = 0  0- Vmot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 17:16        reg_matnr_umtn_use_mode   // unsigned , default = 0  0- Umot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 15:14        reg_matnr_ymtn_use_mode   // unsigned , default = 0  0- Ymot, 1- Ymot/2 + (Umot+Vmot)/4; 2- Ymot/2 + max(Umot,Vmot)/2; 3- max(Ymot,Umot, Vmot)
//Bit 13:12        reg_matnr_mtn_txt_mode    // unsigned , default = 1
//Bit 11            reserved
//Bit 10: 8        reg_matnr_mtn_cor_mode    // unsigned , default = 1  changes)
//Bit  7: 4        reg_matnr_mtn_hpf_mode    // unsigned , default = 8  extend to u4 for nr4, 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6:3x3 SAD, 7: 5x3 SAD, 8-15: drt adaptive
//Bit  3            reserved
//Bit  2: 0        reg_matnr_mtn_lpf_mode    // unsigned , default = 6  0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5, 6,7: drt adaptive
#define NR2_MATNR_MTN_CRTL2                        ((0x176b  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:16        reg_matnr_iir_bs_ymode      // unsigned , default = 6  LPF~~ 0- 1x1; 1: 1x3; 2: 1x5; 3: 3x3; 4: 3o3; 5: 3x5; 6/7: 0
//Bit 15: 8        reg_matnr_mtnb_alplp_cgain  // unsigned , default = 64  to 32
//Bit  7: 0        reg_matnr_mtnb_alplp_ygain  // unsigned , default = 64  to 32
#define NR2_MATNR_MTN_COR                          ((0x176c  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_matnr_mtn_cor_cofst   // unsigned , default = 3  Offset for Chroma Motion.
//Bit 11: 8        reg_matnr_mtn_cor_cgain   // unsigned , default = 3  to texture based coring for Chroma Motion. Normalized to 16 as 1
//Bit  7: 4        reg_matnr_mtn_cor_yofst   // unsigned , default = 3  Offset for Luma Motion.
//Bit  3: 0        reg_matnr_mtn_cor_ygain   // unsigned , default = 3  to texture based coring for Luma Motion. Normalized to 16 as 1
#define NR2_MATNR_MTN_GAIN                         ((0x176d  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_mtn_hp_cgain    // unsigned , default = 64  to MotHPF_yuv[k] Chrm channel for motion calculation, normalized to 64 as 1
//Bit 23:16        reg_matnr_mtn_hp_ygain    // unsigned , default = 64  to MotHPF_yuv[k] Luma channel for motion calculation, normalized to 64 as 1
//Bit 15: 8        reg_matnr_mtn_lp_cgain    // unsigned , default = 64  to MotLPF_yuv[k] Chrm channel for motion calculation, normalized to 32 as 1
//Bit  7: 0        reg_matnr_mtn_lp_ygain    // unsigned , default = 64  to MotLPF_yuv[k] Luma channel for motion calculation, normalized to 32 as 1
#define NR2_MATNR_DEGHOST                          ((0x176e  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_matnr_deghost_mode    // unsigned , default = 0  0:old_deghost; 1:soft_denoise & strong_deghost; 2:strong_denoise & soft_deghost; 3:strong_denoise & strong_deghost
//Bit 27:25        reserved
//Bit 24:20        reg_matnr_deghost_ygain   // unsigned , default = 4
//Bit 19:17        reserved
//Bit 16:12        reg_matnr_deghost_cgain   // unsigned , default = 4
//Bit 11: 9        reserved
//Bit  8           reg_matnr_deghost_en      // unsigned , default = 1  0: disable; 1: enable Enable signal for DeGhost function:0: disable; 1: enable
//Bit  7: 4        reg_matnr_deghost_cos     // unsigned , default = 3  DeGhost Overshoot margin for UV channel, (X2 to u10 scale)
//Bit  3: 0        reg_matnr_deghost_yos     // unsigned , default = 3  DeGhost Overshoot margin for Luma channel, (X2 to u10 scale)
#define NR2_MATNR_ALPHALP_LUT0                     ((0x176f  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphalp_lut3    // unsigned , default = 64  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut2    // unsigned , default = 128  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut1    // unsigned , default = 128  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut0    // unsigned , default = 128  low-pass filter alpha LUT
#define NR2_MATNR_ALPHALP_LUT1                     ((0x1770  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphalp_lut7    // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut6    // unsigned , default = 128  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut5    // unsigned , default = 80  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut4    // unsigned , default = 64  low-pass filter alpha LUT
#define NR2_MATNR_ALPHALP_LUT2                     ((0x1771  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphalp_lut11   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut10   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut9    // unsigned , default = 255  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut8    // unsigned , default = 255  low-pass filter alpha LUT
#define NR2_MATNR_ALPHALP_LUT3                     ((0x1772  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphalp_lut15   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphalp_lut14   // unsigned , default = 255  low-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphalp_lut13   // unsigned , default = 255  low-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphalp_lut12   // unsigned , default = 255  low-pass filter alpha LUT
#define NR2_MATNR_ALPHAHP_LUT0                     ((0x1773  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphahp_lut3    // unsigned , default = 64  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut2    // unsigned , default = 128  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut1    // unsigned , default = 128  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut0    // unsigned , default = 128  high-pass filter alpha LUT
#define NR2_MATNR_ALPHAHP_LUT1                     ((0x1774  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphahp_lut7    // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut6    // unsigned , default = 128  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut5    // unsigned , default = 80  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut4    // unsigned , default = 64  high-pass filter alpha LUT
#define NR2_MATNR_ALPHAHP_LUT2                     ((0x1775  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphahp_lut11   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut10   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut9    // unsigned , default = 255  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut8    // unsigned , default = 255  high-pass filter alpha LUT
#define NR2_MATNR_ALPHAHP_LUT3                     ((0x1776  << 2) + 0xff000000)
//Bit 31:24        reg_matnr_alphahp_lut15   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 23:16        reg_matnr_alphahp_lut14   // unsigned , default = 255  high-pass filter alpha LUT
//Bit 15: 8        reg_matnr_alphahp_lut13   // unsigned , default = 255  high-pass filter alpha LUT
//Bit  7: 0        reg_matnr_alphahp_lut12   // unsigned , default = 255  high-pass filter alpha LUT
#define NR2_MATNR_MTNB_BRT                         ((0x1777  << 2) + 0xff000000)
//Bit 31:28        reg_matnr_mtnb_brt_limt_hi  // unsigned , default = 0
//Bit 27:24        reg_matnr_mtnb_brt_slop_hi  // unsigned , default = 0
//Bit 23:16        reg_matnr_mtnb_brt_thrd_hi  // unsigned , default = 160
//Bit 15:12        reg_matnr_mtnb_brt_limt_lo  // unsigned , default = 6
//Bit 11: 8        reg_matnr_mtnb_brt_slop_lo  // unsigned , default = 6
//Bit  7: 0        reg_matnr_mtnb_brt_thrd_lo  // unsigned , default = 100
//========== nr2_tnr_regs register end ==========//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_nr2_regs.h
//
//
// Reading file:  ./nr2_cue_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR2_CUE_MODE                               ((0x1778  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_cue2_isabv_org_invert1  // unsigned , default = 0
//Bit 18           reg_cue2_valid_condition    // unsigned , default = 1
//Bit 17:16        reg_cue2_orgline_flt_sel    // unsigned , default = 1
//Bit 15:12        reg_cue2_orgline_flt_alph   // unsigned , default = 4
//Bit 11           reg_cue2_isabv_org_invert   // unsigned , default = 0
//Bit 10           reg_cue2_iscur_org_invert   // unsigned , default = 0
//Bit  9           reg_cue_enable_r	          // unsigned , default = 1  right half frame enable
//Bit  8           reg_cue_enable_l            // unsigned , default = 1  left half frame enable
//Bit  7            reserved
//Bit  6: 4        reg_cue_con_rplc_mode       // unsigned , default = 7  pixel chroma replace mode;
//Bit  3: 0        reg_cue_chrm_flt_mode       // unsigned , default = 5  improvement filter mode,
#define NR2_CUE_CON_MOT_TH                         ((0x1779  << 2) + 0xff000000)
//Bit 31:24        reg_cue_con_cmot_thrd2	   // unsigned , default = 20  Detection threshold of up/down two rows,  Chroma channel in Chroma Up-sampling Error (CUE) Detection (tighter).
//Bit 23:16        reg_cue_con_ymot_thrd2	   // unsigned , default = 20  Detection threshold of up/mid/down three rows,  Luma channel in Chroma Up-sampling Error (CUE) Detection (tighter).
//Bit 15: 8        reg_cue_con_cmot_thrd	      // unsigned , default = 20  Detection threshold of up/down two rows, Chroma channel in Chroma Up-sampling Error (CUE) Detection.
//Bit  7: 0        reg_cue_con_ymot_thrd	      // unsigned , default = 20  Detection threshold of up/mid/down three rows, Luma channel in Chroma Up-sampling Error (CUE) Detection.
#define NR2_CUE_CON_DIF0                           ((0x177a  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cue_con_difp1_thrd	   // unsigned , default = 20  field Intra-Field top/below line chroma difference threshold,
//Bit  7: 0        reg_cue_con_difcur_thrd	  // unsigned , default = 0  Field/Frame Intra-Field up/down line chroma difference threshold,
#define NR2_CUE_CON_DIF1                           ((0x177b  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate0	         // unsigned , default = 8  Krate to decide CUE by relationship between CUE_diflG and CUE_difEG
//Bit 15: 8        reg_cue_con_difeg_thrd	   // unsigned , default = 0  to the difference between current Field/Frame middle line to down line color channel(CUE_difEG).
//Bit  7: 0        reg_cue_con_diflg_thrd	   // unsigned , default = 100  to the difference between P1 field top line to current Field/Frame down line color channel (CUE_diflG).
#define NR2_CUE_CON_DIF2                           ((0x177c  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate1	        // unsigned , default = 8  Krate to decide CUE by relationship between CUE_difnC and CUE_difEC
//Bit 15: 8        reg_cue_con_difec_thrd    // unsigned , default = 0  to the difference between current Field/Frame middle line to up line color channel(CUE_difEC).
//Bit  7: 0        reg_cue_con_difnc_thrd    // unsigned , default = 100  to the difference between P1 field bot line to current Field/Frame up line color channel (CUE_difnC).
#define NR2_CUE_CON_DIF3                           ((0x177d  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_cue_con_rate2	        // unsigned , default = 8  Krate to decide CUE by relationship between CUE_difP1 and CUE_difEP1
//Bit 15: 8        reg_cue_con_difep1_thrd   // unsigned , default = 10  top/below line to current field/frame middle line chroma difference (CUE_difEP1) threshold.
//Bit  7: 0        reg_cue_con_difp1_thrd2   // unsigned , default = 10  field Intra-Field top/below line chroma difference threshold (tighter),
#define NR2_CUE_PRG_DIF                            ((0x177e  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_cue_prg_enable	       // unsigned , default = 0  bit for progressive video CUE detection.If interlace input video,
//Bit 19:16        reg_cue_prg_rate	         // unsigned , default = 4  Krate to decide CUE by relationship between CUE_difCur and (CUE_difEC+CUE_difEG)
//Bit 15: 8        reg_cue_prg_difceg_thrd   // unsigned , default = 40  Frame Intra-Field up-mid and mid-down line chroma difference threshold for progressive video CUE detection,
//Bit  7: 0        reg_cue_prg_difcur_thrd   // unsigned , default = 30  Frame Intra-Field up/down line chroma difference threshold,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./nr2_cue_regs.h
//
#define NR2_CONV_MODE                              ((0x177f  << 2) + 0xff000000)
//Bit 3:2,	Conv_c444_mode	The format convert mode about 422 to 444 when data read out line buffer
//Bit 1:0,	Conv_c422_mode	the format convert mode about 444 to 422 when data write to line buffer
//// NR2 REG DEFINE END ////
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f | 8'h80~8'h8f | 0x9a-0x9b
//
// Reading file:  ./vpu_det3d_regs.h
//
//// DET 3D REG DEFINE BEGIN ////
//// 8'h34~8'h3f
//// DET 3D REG DEFINE END ////
#define DET3D_MOTN_CFG                             ((0x1734  << 2) + 0xff000000)
//Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable
//Bit 9:8,	reg_Det3D_Motion_Mode	    U2  Different mode for Motion Calculation of Luma and Chroma:
//                                      0: MotY, 1: (2*MotY + (MotU + MotV))/4; 2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2)
//Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details for coring of Motion Calculations, normalized to 32
//Bit 3:0,	reg_Det3D_Motion_Core_Thrd	U4  2X: static coring value for Motion Detection.
#define DET3D_CB_CFG                               ((0x1735  << 2) + 0xff000000)
//Bit 7:4,	reg_Det3D_ChessBd_HV_ofst	U4,  Noise immune offset for Horizontal or vertical combing detection.
//Bit 3:0,	reg_Det3D_ChessBd_NHV_ofst	U4,  Noise immune offset for NON-Horizontal or vertical combing detection.
#define DET3D_SPLT_CFG                             ((0x1736  << 2) + 0xff000000)
//Bit 7:4,	reg_Det3D_SplitValid_ratio	U4,  Ratio between max_value and the avg_value of the edge mapping for split line valid detection.
//                                      The smaller of this value, the easier of the split line detected.
//Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,  Ratio to the avg_value of the edge mapping for split line position estimation.
//                                      The smaller of this value, the more samples will be added to the estimation.
#define DET3D_HV_MUTE                              ((0x1737  << 2) + 0xff000000)
//Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Top and Bottom border part.
//Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute from H/V Edge calculation Left and right border part.
//Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to be mute from ChessBoard statistics calculation in middle part
//Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be mute from 8x8 statistics calculation in each block.
//Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to be mute from 8x8 statistics calculation in each block.
#define DET3D_MAT_STA_P1M1                         ((0x1738  << 2) + 0xff000000)
//Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1, normalized to 256 (0.8)
//Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1, normalized to 128 (0.5)
//Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6	U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1)
//Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6	U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8)
#define DET3D_MAT_STA_P1TH                         ((0x1739  << 2) + 0xff000000)
//Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (100)
//Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd offset to decide P1, X16         (48)
#define DET3D_MAT_STA_M1TH                         ((0x173a  << 2) + 0xff000000)
//Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (100)
//Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (80)
//Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4	U8  SAD to ENG Thrd offset to decide M1, X16         (64)
#define DET3D_MAT_STA_RSFT                         ((0x173b  << 2) + 0xff000000)
//Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge Statistics SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
//Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI calculation result right shift bits to accommodate the 12bits clipping:
//                                      0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly for images <=1920X1080: 2; 3: other higher resolutions
#define DET3D_MAT_SYMTC_TH                         ((0x173c  << 2) + 0xff000000)
//Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide if the Luma statistics is TB or LR symmetric.
//Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide if the Chroma (UV) statistics is TB or LR symmetric.
//Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric.
//Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to decide if the Motion statistics is TB or LR symmetric.
#define DET3D_RO_DET_CB_HOR                        ((0x173d  << 2) + 0xff000000)
//Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels of Horizontally Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of Pixels of Horizontally Surely matching Chessboard pattern.
#define DET3D_RO_DET_CB_VER                        ((0x173e  << 2) + 0xff000000)
//Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of Pixels of Vertically Surely NOT matching Chessboard pattern.
//Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number of Pixels of Vertically Surely matching Chessboard pattern.
#define DET3D_RO_SPLT_HT                           ((0x173f  << 2) + 0xff000000)
//Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border detected valid signal for top half picture
//Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the LR split position estimation for top half picture
//Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//// DET 3D REG DEFINE BEGIN ////
////  8'h80~8'h8f
#define DET3D_RO_SPLT_HB                           ((0x1780  << 2) + 0xff000000)
//Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_SPLT_VL                           ((0x1781  << 2) + 0xff000000)
//Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_SPLT_VR                           ((0x1782  << 2) + 0xff000000)
//Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
//Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
#define DET3D_RO_MAT_LUMA_LR                       ((0x1783  << 2) + 0xff000000)
//Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
//Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
//                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
//Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
//                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
#define DET3D_RO_MAT_LUMA_TB                       ((0x1784  << 2) + 0xff000000)
//Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
//Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
//Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
#define DET3D_RO_MAT_CHRU_LR                       ((0x1785  << 2) + 0xff000000)
//Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
//Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
#define DET3D_RO_MAT_CHRU_TB                       ((0x1786  << 2) + 0xff000000)
//Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
#define DET3D_RO_MAT_CHRV_LR                       ((0x1787  << 2) + 0xff000000)
//Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
#define DET3D_RO_MAT_CHRV_TB                       ((0x1788  << 2) + 0xff000000)
//Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
#define DET3D_RO_MAT_HEDG_LR                       ((0x1789  << 2) + 0xff000000)
//Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
#define DET3D_RO_MAT_HEDG_TB                       ((0x178a  << 2) + 0xff000000)
//Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
#define DET3D_RO_MAT_VEDG_LR                       ((0x178b  << 2) + 0xff000000)
//Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
#define DET3D_RO_MAT_VEDG_TB                       ((0x178c  << 2) + 0xff000000)
//Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
#define DET3D_RO_MAT_MOTN_LR                       ((0x178d  << 2) + 0xff000000)
//Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
//Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
//Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
#define DET3D_RO_MAT_MOTN_TB                       ((0x178e  << 2) + 0xff000000)
//Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
//Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
#define DET3D_RO_FRM_MOTN                          ((0x178f  << 2) + 0xff000000)
//Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
/// mat ram read enter addr
#define DET3D_RAMRD_ADDR_PORT                      ((0x179a  << 2) + 0xff000000)
#define DET3D_RAMRD_DATA_PORT                      ((0x179b  << 2) + 0xff000000)
//
// Closing file:  ./vpu_det3d_regs.h
//
//   `define DET3D_RO_SPLT_HB            8'h80
//   //Bit 24,	    RO_Det3D_Split_HB_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_SPLT_VL            8'h81
//   //Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_SPLT_VR            8'h82
//   //Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border detected valid signal for top half picture
//   //Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for the LR split position estimation for top half picture
//   //Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of LR split position to the (ColMax/2) for top half picture
//   `define DET3D_RO_MAT_LUMA_LR        8'h83
//   //Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//   //                               it can be -1/0/1:-1: most likely not LR symmetric 0: not sure 1: most likely LR symmetric
//   //Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left right pure symmetric for each band (8bands vertically),
//   //                               it can be 0/1: 0: not sure 1: most likely LR is pure symmetric
//   //Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma statistics for LR like decision,
//   //                               the larger this score, the more confidence that this is a LR 3D video. It is sum of  RO_Luma_LR_score[0~7]
//   `define DET3D_RO_MAT_LUMA_TB        8'h84
//   //Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom decision score for each band (8bands Horizontally),
//   //Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure symmetric for each band (8bands Horizontally),
//   //Bit 4:0,	RO_Luma_TB_sum	     Total score of 8x8 Luma statistics for TB like decision,
//   `define DET3D_RO_MAT_CHRU_LR        8'h85
//   //Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right decision score for each band (8bands vertically),
//   //Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure symmetric for each band (8bands vertically),
//   //Bit 4:0,	RO_ChrU_LR_sum	    Total score of 8x8 ChrU statistics for LR like decision,
//   `define DET3D_RO_MAT_CHRU_TB        8'h86
//   //Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_ChrU_TB_sum	    Total score of 8x8 ChrU statistics for TB like decision
//   `define DET3D_RO_MAT_CHRV_LR        8'h87
//   //Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_ChrV_LR_sum	    Total score of 8x8 ChrV statistics for LR like decision
//   `define DET3D_RO_MAT_CHRV_TB        8'h88
//   //Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics for TB like decision
//   `define DET3D_RO_MAT_HEDG_LR        8'h89
//   //Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for LR like decision
//   `define DET3D_RO_MAT_HEDG_TB        8'h8a
//   //Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Hedg_TB_sum	    Total score of 8x8 Hedg statistics for TB like decision
//   `define DET3D_RO_MAT_VEDG_LR        8'h8b
//   //Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Vedg_LR_sum	    Total score of 8x8 Vedg statistics for LR like decision
//   `define DET3D_RO_MAT_VEDG_TB        8'h8c
//   //Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Vedg_TB_sum	    Total score of 8x8 Vedg statistics for TB like decision
//   `define DET3D_RO_MAT_MOTN_LR        8'h8d
//   //Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision score for each band (8bands vertically)
//   //Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure symmetric for each band (8bands vertically)
//   //Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for LR like decision
//   `define DET3D_RO_MAT_MOTN_TB        8'h8e
//   //Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision score for each band (8bands Horizontally)
//   //Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure symmetric for each band (8bands Horizontally)
//   //Bit 4:0,	RO_Motn_TB_sum	    Total score of 8x8 Motion statistics for TB like decision
//   `define DET3D_RO_FRM_MOTN           8'h8f
//   //Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for still image decision in FW.
#define DI_EI_CTRL10                               ((0x1793  << 2) + 0xff000000)
//bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth
//bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd
//bit 23:20,   reg_ei_caldrt_hstrrgchk_mg
//bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul
//bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf
//bit 17:16,   reg_ei_caldrt_hstrrgchk_ws
//bit 15,      reg_ei_caldrt_hstrrgchk_en
//bit 14:13,   reg_ei_caldrt_hpncheck_mode
//bit 12,      reg_ei_caldrt_hpncheck_mute
//bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2
//bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1
//bit 5:4,     reg_ei_caldrt_hcnfcheck_mode
//bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2
#define DI_NR_1_CTRL0                              ((0x1794  << 2) + 0xff000000)
#define DI_NR_1_CTRL1                              ((0x1795  << 2) + 0xff000000)
#define DI_NR_1_CTRL2                              ((0x1796  << 2) + 0xff000000)
#define DI_NR_1_CTRL3                              ((0x1797  << 2) + 0xff000000)
#define DI_EI_XWIN0                                ((0x1798  << 2) + 0xff000000)
//bit 27:16,   ei_xend0
//bit 11:0,    ei_xstart0
#define DI_EI_XWIN1                                ((0x1799  << 2) + 0xff000000)
/// mat ram read enter addr
//   `define DET3D_RAMRD_ADDR_PORT       8'h9a
//   `define DET3D_RAMRD_DATA_PORT       8'h9b
#define NR2_CFR_PARA_CFG0                          ((0x179c  << 2) + 0xff000000)
//Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma difference calculation mode
//Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based phase register that need to be set by FW phase to phase:
//                                      this will be calculated based on dbdr_phase of the specific line of this frame.
//                                      u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center line is Dr in current line;
//Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line Luma/Chroma transition level calculation mode,
//Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2; 2: min(motAlp,curAlp); 3: max(motAlp,curAlp);
//Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion 2: top/bot + middle motion; 3: max(top/tot motion, middle motion)
#define NR2_CFR_PARA_CFG1                          ((0x179d  << 2) + 0xff000000)
//Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp to alpha that will be used for final blending.
//Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as the level of motion that we consider it at moving.
//Bit  7: 0,	reg_CFR_CurDif_gain	    gain to CurDif to map to alpha, normalized to 32;
//// DET 3D REG DEFINE END ////
#define DI_EI_CTRL11                               ((0x179e  << 2) + 0xff000000)
//bit 30:29,   reg_ei_amb_detect_mode
//bit 28:24,   reg_ei_amb_detect_winth
//bit 23:21,   reg_ei_amb_decide_rppth
//bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth
//bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode
//bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode
//bit 13:12,   reg_ei_retime_lastvertfrcchk_mode
//bit 11:8,    reg_ei_retime_lastpnchk_drtth
//bit 6,       reg_ei_retime_lastpnchk_en
//bit 5:4,     reg_ei_retime_mode
//bit 3,       reg_ei_retime_last_en
//bit 2,       reg_ei_retime_ab_en
//bit 1,       reg_ei_caldrt_hstrvertfrcchk_en
//bit 0,       reg_ei_caldrt_hstrrgchk_mode
#define DI_EI_CTRL12                               ((0x179f  << 2) + 0xff000000)
//bit 31:28,   reg_ei_drtdelay2_lmt
//bit 27:26,   reg_ei_drtdelay2_notver_lrwin
//bit 25:24,   reg_ei_drtdelay_mode
//bit 23,      reg_ei_drtdelay2_mode
//bit 22:20,   reg_ei_assign_xla_signm0th
//bit 19,      reg_ei_assign_pkbiasvert_en
//bit 18,      reg_ei_assign_xla_en
//bit 17:16,   reg_ei_assign_xla_mode
//bit 15:12,   reg_ei_assign_nlfilter_magin
//bit 11:8,    reg_ei_localsearch_maxrange
//bit 7:4,     reg_ei_xla_drtth
//bit 3:0,     reg_ei_flatmsad_thrd
//`define DI_DIWR_CANVAS      8'ha0
//`define DI_DIWR_URGENT      8'ha1
//`define DI_NRWR_CANVAS      8'ha2
//`define DI_NRWR_URGENT      8'ha7
//`define DI_CONTWR_X                8'ha0
//`define DI_CONTWR_Y                8'ha1
//`define DI_CONTWR_CTRL             8'ha2
//`define DI_CONTPRD_X               8'ha3
//`define DI_CONTPRD_Y               8'ha4
//`define DI_CONTP2RD_X              8'ha5
//`define DI_CONTP2RD_Y              8'ha6
#define DI_RO_PRE_FIELD_CNT0                       ((0x17a3  << 2) + 0xff000000)
#define DI_RO_PRE_FIELD_CNT1                       ((0x17a4  << 2) + 0xff000000)
#define DI_RO_POS_FRAME_CNT0                       ((0x17a5  << 2) + 0xff000000)
#define DI_RO_POS_FRAME_CNT1                       ((0x17a6  << 2) + 0xff000000)
//`define DI_CONTRD_CTRL             8'ha7
#define DI_EI_CTRL13                               ((0x17a8  << 2) + 0xff000000)
//bit 27:24,   reg_ei_int_drt2x_chrdrt_limit
//bit 23:20,   reg_ei_int_drt16x_core
//bit 19:16,   reg_ei_int_drtdelay2_notver_cancv
//bit 15:8,    reg_ei_int_drtdelay2_notver_sadth
//bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth
#define DI_MTN_1_CTRL6                             ((0x17a9  << 2) + 0xff000000)
//bit 31:24,   mtn_m1b_extnd
//bit 23:16,   mtn_m1b_errod
//bit 15: 8,   mtn_core_ykinter
//bit  7: 0,   mtn_core_ckinter
#define DI_MTN_1_CTRL7                             ((0x17aa  << 2) + 0xff000000)
//bit 31:24,   mtn_core_mxcmby
//bit 23:16,   mtn_core_mxcmbc
//bit 15: 8,   mtn_core_y
//bit  7: 0,   mtn_core_c
#define DI_MTN_1_CTRL8                             ((0x17ab  << 2) + 0xff000000)
//bit 31:24,   mtn_fcore_ykinter
//bit 23:16,   mtn_fcore_ckinter
//bit 15: 8,   mtn_fcore_ykintra
//bit  7: 0,   mtn_fcore_ckintra
#define DI_MTN_1_CTRL9                             ((0x17ac  << 2) + 0xff000000)
//bit 31:24,   mtn_fcore_2yrate
//bit 23:16,   mtn_fcore_2crate
//bit 15: 8,   mtn_fcore_y
//bit  7: 0,   mtn_fcore_c
#define DI_MTN_1_CTRL10                            ((0x17ad  << 2) + 0xff000000)
//bit 27:24,   mtn_motfld0
//bit 19:16,   mtn_stlfld0
//bit 11: 8,   mtn_motfld1
//bit  3: 0,   mtn_stlfld1
#define DI_MTN_1_CTRL11                            ((0x17ae  << 2) + 0xff000000)
//bit 27:24,   mtn_smotevn
//bit 20:16,   mtn_smotodd
//bit 11: 8,   mtn_sstlevn
//bit  4: 0,   mtn_sstlodd
#define DI_MTN_1_CTRL12                            ((0x17af  << 2) + 0xff000000)
//bit 31:24,   mtn_mgain
//bit 17:16,   mtn_mmode
//bit 15: 8,   mtn_sthrd
//bit  4: 0,   mtn_sgain
//`define DI_NRWR_X                 8'hc0
//`define DI_NRWR_Y                 8'hc1
//bit 31:30				nrwr_words_lim
//bit 29				nrwr_rev_y
//bit 28:16				nrwr_start_y
//bit 15				nrwr_ext_en
//bit 12:0				nrwr_end_y
//`define DI_NRWR_CTRL              8'hc2
//bit 31				pending_ddr_wrrsp_diwr
//bit 30				nrwr_reg_swap
//bit 29:26				nrwr_burst_lim
//bit 25				nrwr_canvas_syncen
//bit 24				nrwr_no_clk_gate
//bit 23:22				nrwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
					             //2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20				nrwr_hconv_mode
//bit 19:18				nrwr_vconv_mode
//bit 17				nrwr_swap_cbcr
//bit 16				nrwr_urgent
//bit 15:8				nrwr_canvas_index_chroma
//bit 7:0				nrwr_canvas_index_luma
//`define DI_MTNWR_X                8'hc3
//`define DI_MTNWR_Y                8'hc4
//`define DI_MTNWR_CTRL             8'hc5
#define DI_RO_CRC_NRWR                             ((0x17c0  << 2) + 0xff000000)
#define DI_RO_CRC_MTNWR                            ((0x17c1  << 2) + 0xff000000)
#define DI_RO_CRC_DEINT                            ((0x17c2  << 2) + 0xff000000)
#define DI_CRC_CHK0                                ((0x17c3  << 2) + 0xff000000)
#define DI_CRC_CHK1                                ((0x17c4  << 2) + 0xff000000)
//`define DI_DIWR_X                 8'hc6
//`define DI_DIWR_Y                 8'hc7
//bit 31:30				diwr_words_lim
//bit 29				diwr_rev_y
//bit 28:16				diwr_start_y
//bit 15				diwr_ext_en
//bit 12:0				diwr_end_y
//`define DI_DIWR_CTRL              8'hc8
//bit 31				pending_ddr_wrrsp_diwr
//bit 30				diwr_reg_swap
//bit 29:26				diwr_burst_lim
//bit 25				diwr_canvas_syncen
//bit 24				diwr_no_clk_gate
//bit 23:22				diwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas;
						     //2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20				diwr_hconv_mode
//bit 19:18				diwr_vconv_mode
//bit 17				diwr_swap_cbcr
//bit 16				diwr_urgent
//bit 15:8				diwr_canvas_index_chroma
//bit 7:0				diwr_canvas_index_luma
//`define DI_MTNCRD_X               8'hc9
//`define DI_MTNCRD_Y               8'hca
//`define DI_MTNPRD_X               8'hcb
//`define DI_MTNPRD_Y               8'hcc
//`define DI_MTNRD_CTRL             8'hcd
#define DI_TOP_PRE_CTRL                            ((0x17c5  << 2) + 0xff000000)
#define DI_TOP_POST_CTRL                           ((0x17c6  << 2) + 0xff000000)
#define DI_PRE_GL_CTRL                             ((0x17c7  << 2) + 0xff000000)
#define DI_PRE_GL_THD                              ((0x17c8  << 2) + 0xff000000)
#define DI_POST_GL_CTRL                            ((0x17c9  << 2) + 0xff000000)
#define DI_POST_GL_THD                             ((0x17ca  << 2) + 0xff000000)
#define DI_RO_PRE_DBG                              ((0x17cb  << 2) + 0xff000000)
#define DI_RO_POST_DBG                             ((0x17cc  << 2) + 0xff000000)
#define DI_TOP_CTRL                                ((0x17cd  << 2) + 0xff000000)
#define DI_AFBCD_GCLK0                             ((0x17ce  << 2) + 0xff000000)
#define DI_AFBCD_GCLK1                             ((0x17cf  << 2) + 0xff000000)
#define DI_RDMIF_DEPTH0                            ((0x17d0  << 2) + 0xff000000)
#define DI_RDMIF_DEPTH1                            ((0x17d1  << 2) + 0xff000000)
#define DI_RDMIF_DEPTH2                            ((0x17d2  << 2) + 0xff000000)
#define DI_TOP_CTRL1                               ((0x17d3  << 2) + 0xff000000)
#define DI_AFBCE0_HOLD_CTRL                        ((0x17d4  << 2) + 0xff000000)
#define DI_AFBCE1_HOLD_CTRL                        ((0x17d5  << 2) + 0xff000000)
// 0xe0 - 0xff
//
// Reading file:  ./di_pd_grad_reg.h
//
#define DI_PD_GRAD_CTRL                            ((0x17e0  << 2) + 0xff000000)
//Bit 31:12  reserved
//Bit 11:4   reg_fd_min_grad_th           // default 255 //u8, for cur/pre1 field. cur_min_grad_err > th, will be excluded of statistic
//Bit 3      reg_fd_min_grad_th_adjust_en // default 1   //u1, reg_fd_min_grad_err_th adjustment enable/disable
//Bit 2      reg_fd_err_grad_bf_flt_en    // default 1   //u1, 1:comput err_grad_sum before horizontal filtering; 0: ...after...; default=1;
//Bit 1      reg_fd_comb_field_sel        // default 0   //u1, comb consists of 2 field; 0: cur-pre; 1:pre-pre2;
//Bit 0      reg_fd_iscur_top_inver       // default 0   //u1, current field is top flag invert; 0 no invert, 1, invert
#define DI_PD_GRAD_TH_P                            ((0x17e1  << 2) + 0xff000000)
//Bit 31:24  reg_fd_min_grad_th_p0        //default 2     //u8,
//Bit 23:16  reg_fd_min_grad_th_p1        //default 4     //u8,
//Bit 15:8   reg_fd_min_grad_th_p2        //default 8     //u8,
//Bit 7:0    reg_fd_min_grad_th_p3        //default 12    //u8,
#define DI_PD_GRAD_TH_N                            ((0x17e2  << 2) + 0xff000000)
//Bit 31:24  reg_fd_min_grad_th_n0        //default 4     //u8,
//Bit 23:16  reg_fd_min_grad_th_n1        //default 8     //u8,
//Bit 15:8   reg_fd_min_grad_th_n2        //default 16    //u8,
//Bit 7:0    reg_fd_min_grad_th_n3        //default 32    //u8,
#define DI_PD_GRAD_GAIN_P                          ((0x17e3  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:24  reg_fd_min_grad_gain_p0      //default 16    //u5,
//Bit 23:21  reserved
//Bit 20:16  reg_fd_min_grad_gain_p1      //default 16    //u5,
//Bit 15:13  reserved
//Bit 12:8   reg_fd_min_grad_gain_p2      //default 16    //u5,
//Bit 7:5    reserved
//Bit 4:0    reg_fd_min_grad_gain_p3      //default 16    //u5,
#define DI_PD_GRAD_GAIN_N                          ((0x17e4  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:24  reg_fd_min_grad_gain_n0      //default 12    //u5,
//Bit 23:21  reserved
//Bit 20:16  reg_fd_min_grad_gain_n1      //default 12    //u5,
//Bit 15:13  reserved
//Bit 12:8   reg_fd_min_grad_gain_n2      //default 14    //u5,
//Bit 7:5    reserved
//Bit 4:0    reg_fd_min_grad_gain_n3      //default 15    //u5,
#define DI_PD_RO_SUM_P_WIN0                        ((0x17e5  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p0
#define DI_PD_RO_SUM_P_WIN1                        ((0x17e6  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p1
#define DI_PD_RO_SUM_P_WIN2                        ((0x17e7  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p2
#define DI_PD_RO_SUM_P_WIN3                        ((0x17e8  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p3
#define DI_PD_RO_SUM_P_WIN4                        ((0x17e9  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p4
#define DI_PD_RO_SUM_N_WIN0                        ((0x17ea  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n0
#define DI_PD_RO_SUM_N_WIN1                        ((0x17eb  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n1
#define DI_PD_RO_SUM_N_WIN2                        ((0x17ec  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n2
#define DI_PD_RO_SUM_N_WIN3                        ((0x17ed  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n3
#define DI_PD_RO_SUM_N_WIN4                        ((0x17ee  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n4
#define DI_PD_RO_CNT_P_WIN0                        ((0x17ef  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p0
#define DI_PD_RO_CNT_P_WIN1                        ((0x17f0  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p1
#define DI_PD_RO_CNT_P_WIN2                        ((0x17f1  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p2
#define DI_PD_RO_CNT_P_WIN3                        ((0x17f2  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p3
#define DI_PD_RO_CNT_P_WIN4                        ((0x17f3  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p4
#define DI_PD_RO_CNT_N_WIN0                        ((0x17f4  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n0
#define DI_PD_RO_CNT_N_WIN1                        ((0x17f5  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n1
#define DI_PD_RO_CNT_N_WIN2                        ((0x17f6  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n2
#define DI_PD_RO_CNT_N_WIN3                        ((0x17f7  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n3
#define DI_PD_RO_CNT_N_WIN4                        ((0x17f8  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n4
#define DI_PD_RO_SUM_P                             ((0x17f9  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_p_glb
#define DI_PD_RO_SUM_N                             ((0x17fa  << 2) + 0xff000000)
//Bit 31:0   ro_fd_err_grad_sum_n_glb
#define DI_PD_RO_CNT_P                             ((0x17fb  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_p_glb
#define DI_PD_RO_CNT_N                             ((0x17fc  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20:0   ro_fd_err_grad_cnt_n_glb
//
// Closing file:  ./di_pd_grad_reg.h
//
//`define DI_INP_GEN_REG            8'hce
//`define DI_INP_CANVAS0            8'hcf
//`define DI_INP_LUMA_X0            8'hd0
//`define DI_INP_LUMA_Y0            8'hd1
//`define DI_INP_CHROMA_X0          8'hd2
//`define DI_INP_CHROMA_Y0          8'hd3
//`define DI_INP_RPT_LOOP           8'hd4
//`define DI_INP_LUMA0_RPT_PAT      8'hd5
//`define DI_INP_CHROMA0_RPT_PAT    8'hd6
//`define DI_INP_DUMMY_PIXEL        8'hd7
//`define DI_INP_LUMA_FIFO_SIZE     8'hd8
//`define DI_INP_RANGE_MAP_Y        8'hba
//`define DI_INP_RANGE_MAP_CB       8'hbb
//`define DI_INP_RANGE_MAP_CR       8'hbc
//`define DI_INP_GEN_REG2           8'h91
//
//`define DI_INP_FMT_CTRL           8'hd9
//`define DI_INP_FMT_W              8'hda
////
//`define DI_MEM_GEN_REG            8'hdb
//`define DI_MEM_CANVAS0            8'hdc
//`define DI_MEM_LUMA_X0            8'hdd
//`define DI_MEM_LUMA_Y0            8'hde
//`define DI_MEM_CHROMA_X0          8'hdf
//`define DI_MEM_CHROMA_Y0          8'he0
//`define DI_MEM_RPT_LOOP           8'he1
//`define DI_MEM_LUMA0_RPT_PAT      8'he2
//`define DI_MEM_CHROMA0_RPT_PAT    8'he3
//`define DI_MEM_DUMMY_PIXEL        8'he4
//`define DI_MEM_LUMA_FIFO_SIZE     8'he5
//`define DI_MEM_RANGE_MAP_Y        8'hbd
//`define DI_MEM_RANGE_MAP_CB       8'hbe
//`define DI_MEM_RANGE_MAP_CR       8'hbf
//`define DI_MEM_GEN_REG2           8'h92
//
//`define DI_MEM_FMT_CTRL           8'he6
//`define DI_MEM_FMT_W              8'he7
//
//`define DI_IF1_GEN_REG            8'he8
//`define DI_IF1_CANVAS0            8'he9
//`define DI_IF1_LUMA_X0            8'hea
//`define DI_IF1_LUMA_Y0            8'heb
//`define DI_IF1_CHROMA_X0          8'hec
//`define DI_IF1_CHROMA_Y0          8'hed
//`define DI_IF1_RPT_LOOP           8'hee
//`define DI_IF1_LUMA0_RPT_PAT      8'hef
//`define DI_IF1_CHROMA0_RPT_PAT    8'hf0
//`define DI_IF1_DUMMY_PIXEL        8'hf1
//`define DI_IF1_LUMA_FIFO_SIZE     8'hf2
//`define DI_IF1_RANGE_MAP_Y        8'hfc
//`define DI_IF1_RANGE_MAP_CB       8'hfd
//`define DI_IF1_RANGE_MAP_CR       8'hfe
//`define DI_IF1_GEN_REG2           8'h90
//
//`define DI_IF1_FMT_CTRL           8'hf3
//`define DI_IF1_FMT_W              8'hf4
//
//
//`define DI_CHAN2_GEN_REG          8'hf5
//`define DI_CHAN2_CANVAS0          8'hf6
//`define DI_CHAN2_LUMA_X0          8'hf7
//`define DI_CHAN2_LUMA_Y0          8'hf8
//`define DI_CHAN2_CHROMA_X0        8'hf9
//`define DI_CHAN2_CHROMA_Y0        8'hfa
//`define DI_CHAN2_RPT_LOOP         8'hfb
//`define DI_CHAN2_LUMA0_RPT_PAT    8'hb0
//`define DI_CHAN2_CHROMA0_RPT_PAT  8'hb1
//`define DI_CHAN2_DUMMY_PIXEL      8'hb2
//`define DI_CHAN2_LUMA_FIFO_SIZE   8'hb3
//`define DI_CHAN2_RANGE_MAP_Y      8'hb4
//`define DI_CHAN2_RANGE_MAP_CB     8'hb5
//`define DI_CHAN2_RANGE_MAP_CR     8'hb6
//`define DI_CHAN2_GEN_REG2         8'hb7
//`define DI_CHAN2_FMT_CTRL         8'hb8
//`define DI_CHAN2_FMT_W            8'hb9
//
// Closing file:  ./vpu_mad_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  MADD_VCBUS_BASE = 0x18
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./di_dolby_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DI_DOLBY_CORE1C_REG_START                  ((0x1800  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_CLKGATE_CTRL               ((0x18f2  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL0                 ((0x18f3  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL1                 ((0x18f4  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL2                 ((0x18f5  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL3                 ((0x18f6  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL4                 ((0x18f7  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_SWAP_CTRL5                 ((0x18f8  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_DMA_CTRL                   ((0x18f9  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_DMA_STATUS                 ((0x18fa  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_STATUS0                    ((0x18fb  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_STATUS1                    ((0x18fc  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_STATUS2                    ((0x18fd  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_STATUS3                    ((0x18fe  << 2) + 0xff000000)
#define DI_DOLBY_CORE1C_DMA_PORT                   ((0x18ff  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_dolby_regs.h
//
//`include "di_inp_afbc_dec_regs.h"
//`include "di_mem_afbc_dec_regs.h"
//`include "fgrain_di_regs.h"
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DISP_IF0_VCBUS_BASE = 0x19
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./disp_if_regs.h
//
#define L_GAMMA_CNTL_PORT                          ((0x1900  << 2) + 0xff000000)
#define L_GAMMA_DATA_PORT                          ((0x1901  << 2) + 0xff000000)
#define L_GAMMA_ADDR_PORT                          ((0x1902  << 2) + 0xff000000)
#define L_GAMMA_VCOM_HSWITCH_ADDR                  ((0x1903  << 2) + 0xff000000)
#define L_RGB_BASE_ADDR                            ((0x1905  << 2) + 0xff000000)
#define L_RGB_COEFF_ADDR                           ((0x1906  << 2) + 0xff000000)
#define L_POL_CNTL_ADDR                            ((0x1907  << 2) + 0xff000000)
#define L_DITH_CNTL_ADDR                           ((0x1908  << 2) + 0xff000000)
#define L_GAMMA_PROBE_CTRL                         ((0x1909  << 2) + 0xff000000)
//read only
#define L_GAMMA_PROBE_COLOR_L                      ((0x190a  << 2) + 0xff000000)
#define L_GAMMA_PROBE_COLOR_H                      ((0x190b  << 2) + 0xff000000)
#define L_GAMMA_PROBE_HL_COLOR                     ((0x190c  << 2) + 0xff000000)
#define L_GAMMA_PROBE_POS_X                        ((0x190d  << 2) + 0xff000000)
#define L_GAMMA_PROBE_POS_Y                        ((0x190e  << 2) + 0xff000000)
#define L_STH1_HS_ADDR                             ((0x1910  << 2) + 0xff000000)
#define L_STH1_HE_ADDR                             ((0x1911  << 2) + 0xff000000)
#define L_STH1_VS_ADDR                             ((0x1912  << 2) + 0xff000000)
#define L_STH1_VE_ADDR                             ((0x1913  << 2) + 0xff000000)
#define L_STH2_HS_ADDR                             ((0x1914  << 2) + 0xff000000)
#define L_STH2_HE_ADDR                             ((0x1915  << 2) + 0xff000000)
#define L_STH2_VS_ADDR                             ((0x1916  << 2) + 0xff000000)
#define L_STH2_VE_ADDR                             ((0x1917  << 2) + 0xff000000)
#define L_OEH_HS_ADDR                              ((0x1918  << 2) + 0xff000000)
#define L_OEH_HE_ADDR                              ((0x1919  << 2) + 0xff000000)
#define L_OEH_VS_ADDR                              ((0x191a  << 2) + 0xff000000)
#define L_OEH_VE_ADDR                              ((0x191b  << 2) + 0xff000000)
#define L_VCOM_HSWITCH_ADDR                        ((0x191c  << 2) + 0xff000000)
#define L_VCOM_VS_ADDR                             ((0x191d  << 2) + 0xff000000)
#define L_VCOM_VE_ADDR                             ((0x191e  << 2) + 0xff000000)
#define L_CPV1_HS_ADDR                             ((0x191f  << 2) + 0xff000000)
#define L_CPV1_HE_ADDR                             ((0x1920  << 2) + 0xff000000)
#define L_CPV1_VS_ADDR                             ((0x1921  << 2) + 0xff000000)
#define L_CPV1_VE_ADDR                             ((0x1922  << 2) + 0xff000000)
#define L_CPV2_HS_ADDR                             ((0x1923  << 2) + 0xff000000)
#define L_CPV2_HE_ADDR                             ((0x1924  << 2) + 0xff000000)
#define L_CPV2_VS_ADDR                             ((0x1925  << 2) + 0xff000000)
#define L_CPV2_VE_ADDR                             ((0x1926  << 2) + 0xff000000)
#define L_STV1_HS_ADDR                             ((0x1927  << 2) + 0xff000000)
#define L_STV1_HE_ADDR                             ((0x1928  << 2) + 0xff000000)
#define L_STV1_VS_ADDR                             ((0x1929  << 2) + 0xff000000)
#define L_STV1_VE_ADDR                             ((0x192a  << 2) + 0xff000000)
#define L_STV2_HS_ADDR                             ((0x192b  << 2) + 0xff000000)
#define L_STV2_HE_ADDR                             ((0x192c  << 2) + 0xff000000)
#define L_STV2_VS_ADDR                             ((0x192d  << 2) + 0xff000000)
#define L_STV2_VE_ADDR                             ((0x192e  << 2) + 0xff000000)
#define L_OEV1_HS_ADDR                             ((0x192f  << 2) + 0xff000000)
#define L_OEV1_HE_ADDR                             ((0x1930  << 2) + 0xff000000)
#define L_OEV1_VS_ADDR                             ((0x1931  << 2) + 0xff000000)
#define L_OEV1_VE_ADDR                             ((0x1932  << 2) + 0xff000000)
#define L_OEV2_HS_ADDR                             ((0x1933  << 2) + 0xff000000)
#define L_OEV2_HE_ADDR                             ((0x1934  << 2) + 0xff000000)
#define L_OEV2_VS_ADDR                             ((0x1935  << 2) + 0xff000000)
#define L_OEV2_VE_ADDR                             ((0x1936  << 2) + 0xff000000)
#define L_OEV3_HS_ADDR                             ((0x1937  << 2) + 0xff000000)
#define L_OEV3_HE_ADDR                             ((0x1938  << 2) + 0xff000000)
#define L_OEV3_VS_ADDR                             ((0x1939  << 2) + 0xff000000)
#define L_OEV3_VE_ADDR                             ((0x193a  << 2) + 0xff000000)
#define L_LCD_PWR_ADDR                             ((0x193b  << 2) + 0xff000000)
#define L_LCD_PWM0_LO_ADDR                         ((0x193c  << 2) + 0xff000000)
#define L_LCD_PWM0_HI_ADDR                         ((0x193d  << 2) + 0xff000000)
#define L_LCD_PWM1_LO_ADDR                         ((0x193e  << 2) + 0xff000000)
#define L_LCD_PWM1_HI_ADDR                         ((0x193f  << 2) + 0xff000000)
#define L_INV_CNT_ADDR                             ((0x1940  << 2) + 0xff000000)
#define L_TCON_MISC_SEL_ADDR                       ((0x1941  << 2) + 0xff000000)
#define L_DUAL_PORT_CNTL_ADDR                      ((0x1942  << 2) + 0xff000000)
#define MLVDS_CLK_CTL1_HI                          ((0x1943  << 2) + 0xff000000)
#define MLVDS_CLK_CTL1_LO                          ((0x1944  << 2) + 0xff000000)
//  [31:30] enable mlvds clocks
//  [24]    mlvds_clk_half_delay       24 // Bit 0
//  [23:0]  mlvds_clk_pattern           0 // Bit 23:0
#define L_TCON_DOUBLE_CTL                          ((0x1949  << 2) + 0xff000000)
#define L_TCON_PATTERN_HI                          ((0x194a  << 2) + 0xff000000)
#define L_TCON_PATTERN_LO                          ((0x194b  << 2) + 0xff000000)
#define LDIM_BL_ADDR_PORT                          ((0x194e  << 2) + 0xff000000)
#define LDIM_BL_DATA_PORT                          ((0x194f  << 2) + 0xff000000)
#define L_DE_HS_ADDR                               ((0x1951  << 2) + 0xff000000)
#define L_DE_HE_ADDR                               ((0x1952  << 2) + 0xff000000)
#define L_DE_VS_ADDR                               ((0x1953  << 2) + 0xff000000)
#define L_DE_VE_ADDR                               ((0x1954  << 2) + 0xff000000)
#define L_HSYNC_HS_ADDR                            ((0x1955  << 2) + 0xff000000)
#define L_HSYNC_HE_ADDR                            ((0x1956  << 2) + 0xff000000)
#define L_HSYNC_VS_ADDR                            ((0x1957  << 2) + 0xff000000)
#define L_HSYNC_VE_ADDR                            ((0x1958  << 2) + 0xff000000)
#define L_VSYNC_HS_ADDR                            ((0x1959  << 2) + 0xff000000)
#define L_VSYNC_HE_ADDR                            ((0x195a  << 2) + 0xff000000)
#define L_VSYNC_VS_ADDR                            ((0x195b  << 2) + 0xff000000)
#define L_VSYNC_VE_ADDR                            ((0x195c  << 2) + 0xff000000)
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define L_LCD_MCU_CTL                              ((0x195d  << 2) + 0xff000000)
#define P2P_CH_SWAP0                               ((0x195e  << 2) + 0xff000000)
#define P2P_CH_SWAP1                               ((0x195f  << 2) + 0xff000000)
#define P2P_BIT_REV                                ((0x1950  << 2) + 0xff000000)
//**************************************************************************
//*  Dual port mLVDS registers
//**************************************************************************
// bit 3 - enable_u_dual_mlvds_dp_clk
// bit 2 - enable_u_map_mlvds_r_clk
// bit 1 - enable_u_map_mlvds_l_clk
// bit 0 - dual_mlvds_en
//`define DUAL_MLVDS_CTL                8'h60
// bit[12:0] - dual_mlvds_line_start
//`define DUAL_MLVDS_LINE_START         8'h61
// bit[12:0] - dual_mlvds_line_end
//`define DUAL_MLVDS_LINE_END           8'h62
// bit[12:0] - dual_mlvds_w_pixel_start_l
//`define DUAL_MLVDS_PIXEL_W_START_L    8'h63
// bit[12:0] - dual_mlvds_w_pixel_end_l
//`define DUAL_MLVDS_PIXEL_W_END_L      8'h64
// bit[12:0] - dual_mlvds_w_pixel_start_r
//`define DUAL_MLVDS_PIXEL_W_START_R    8'h65
// bit[12:0] - dual_mlvds_w_pixel_end_r
//`define DUAL_MLVDS_PIXEL_W_END_R      8'h66
// bit[12:0] - dual_mlvds_r_pixel_start_l
//`define DUAL_MLVDS_PIXEL_R_START_L    8'h67
// bit[12:0] - dual_mlvds_r_pixel_cnt_l
//`define DUAL_MLVDS_PIXEL_R_CNT_L      8'h68
// bit[12:0] - dual_mlvds_r_pixel_start_r
//`define DUAL_MLVDS_PIXEL_R_START_R    8'h69
// bit[12:0] - dual_mlvds_r_pixel_cnt_r
//`define DUAL_MLVDS_PIXEL_R_CNT_R      8'h6a
// bit[15]   - v_inversion_en
// bit[12:0] - v_inversion_pixel
//`define V_INVERSION_PIXEL             8'h70
// bit[15]   - v_inversion_sync_en
// bit[12:0] - v_inversion_line
//`define V_INVERSION_LINE              8'h71
// bit[15:12]  - v_loop_r
// bit[11:10]  - v_pattern_1_r
// bit[9:8]    - v_pattern_0_r
// bit[7:4]    - v_loop_l
// bit[3:2]    - v_pattern_1_l
// bit[1:0]    - v_pattern_0_l
//`define V_INVERSION_CONTROL           8'h72
//`define MLVDS2_CONTROL           8'h74
   #define     mLVDS2_RESERVED  15    // 15
   #define     mLVDS2_double_pattern  14    // 14
   #define     mLVDS2_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS2_dual_gate  7
   #define     mLVDS2_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS2_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS2_msb_first  4
   #define     mLVDS2_PORT_SWAP  3
   #define     mLVDS2_MLSB_SWAP  2
   #define     mLVDS2_PN_SWAP    1
   #define     mLVDS2_en         0
//`define MLVDS2_CONFIG_HI         8'h75
//`define MLVDS2_CONFIG_LO         8'h76
   #define     mLVDS2_reset_offset         29 // Bit 31:29
   #define     mLVDS2_reset_length         23 // Bit 28:23
   #define     mLVDS2_config_reserved      20 // Bit 22:20
   #define     mLVDS2_reset_start_bit12    19 // Bit 19
   #define     mLVDS2_data_write_toggle    18
   #define     mLVDS2_data_write_ini       17
   #define     mLVDS2_data_latch_1_toggle  16
   #define     mLVDS2_data_latch_1_ini     15
   #define     mLVDS2_data_latch_0_toggle  14
   #define     mLVDS2_data_latch_0_ini     13
   #define     mLVDS2_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS2_reset_start           0 // Bit 11:0
//`define MLVDS2_DUAL_GATE_WR_START        8'h77
//   `define     mlvds2_dual_gate_wr_start    0 // Bit 12:0
//`define MLVDS2_DUAL_GATE_WR_END          8'h78
//   `define     mlvds2_dual_gate_wr_end      0 // Bit 12:0
//
//`define MLVDS2_DUAL_GATE_RD_START        8'h79
//   `define     mlvds2_dual_gate_rd_start    0 // Bit 12:0
//`define MLVDS2_DUAL_GATE_RD_END          8'h7a
//   `define     mlvds2_dual_gate_rd_end      0 // Bit 12:0
//`define MLVDS2_SECOND_RESET_CTL          8'h7b
//   `define     mLVDS2_2nd_reset_start       0 // Bit 12:0
//
//`define MLVDS2_DUAL_GATE_CTL_HI        8'h7c
//`define MLVDS2_DUAL_GATE_CTL_LO        8'h7d
//   `define     mlvds2_tcon_field_en        24 // Bit 7:0
//   `define     mlvds2_dual_gate_reserved   21 // Bit 2:0
//   `define     mlvds2_scan_mode_start_line_bit12 20 // Bit 0
//   `define     mlvds2_scan_mode_odd        16 // Bit 3:0
//   `define     mlvds2_scan_mode_even       12 // Bit 3:0
//   `define     mlvds2_scan_mode_start_line  0 // Bit 11:0
//
//`define MLVDS2_RESET_CONFIG_HI         8'h7e
//`define MLVDS2_RESET_CONFIG_LO         8'h7f
//   `define     mLVDS2_reset_range_enable   31 // Bit 0
//   `define     mLVDS2_reset_range_inv      30 // Bit 0
//   `define     mLVDS2_reset_config_res1    29 // Bit 0
//   `define     mLVDS2_reset_range_line_0   16 // Bit 11:0
//   `define     mLVDS2_reset_config_res3    13 // Bit 2:0
//   `define     mLVDS2_reset_range_line_1    0 // Bit 11:0
//
//**************************************************************************
//*  Vbyone registers  (Note: no MinLVDS in G9tv, share the register)
//**************************************************************************
#define VBO_CTRL_L                                 ((0x1960  << 2) + 0xff000000)
#define VBO_CTRL_H                                 ((0x1961  << 2) + 0xff000000)
#define VBO_SOFT_RST                               ((0x1962  << 2) + 0xff000000)
#define VBO_LANES                                  ((0x1963  << 2) + 0xff000000)
#define VBO_VIN_CTRL                               ((0x1964  << 2) + 0xff000000)
#define VBO_ACT_VSIZE                              ((0x1965  << 2) + 0xff000000)
#define VBO_REGION_00                              ((0x1966  << 2) + 0xff000000)
#define VBO_REGION_01                              ((0x1967  << 2) + 0xff000000)
#define VBO_REGION_02                              ((0x1968  << 2) + 0xff000000)
#define VBO_REGION_03                              ((0x1969  << 2) + 0xff000000)
#define VBO_VBK_CTRL_0                             ((0x196a  << 2) + 0xff000000)
#define VBO_VBK_CTRL_1                             ((0x196b  << 2) + 0xff000000)
#define VBO_HBK_CTRL                               ((0x196c  << 2) + 0xff000000)
#define VBO_PXL_CTRL                               ((0x196d  << 2) + 0xff000000)
#define VBO_LANE_SKEW_L                            ((0x196e  << 2) + 0xff000000)
#define VBO_LANE_SKEW_H                            ((0x196f  << 2) + 0xff000000)
#define VBO_GCLK_LANE_L                            ((0x1970  << 2) + 0xff000000)
#define VBO_GCLK_LANE_H                            ((0x1971  << 2) + 0xff000000)
#define VBO_GCLK_MAIN                              ((0x1972  << 2) + 0xff000000)
#define VBO_STATUS_L                               ((0x1973  << 2) + 0xff000000)
#define VBO_STATUS_H                               ((0x1974  << 2) + 0xff000000)
#define VBO_LANE_OUTPUT                            ((0x1975  << 2) + 0xff000000)
#define LCD_PORT_SWAP                              ((0x1976  << 2) + 0xff000000)
#define VBO_TMCHK_THRD_L                           ((0x1978  << 2) + 0xff000000)
#define VBO_TMCHK_THRD_H                           ((0x1979  << 2) + 0xff000000)
#define VBO_FSM_HOLDER_L                           ((0x197a  << 2) + 0xff000000)
#define VBO_FSM_HOLDER_H                           ((0x197b  << 2) + 0xff000000)
#define VBO_INTR_STATE_CTRL                        ((0x197c  << 2) + 0xff000000)
#define VBO_INTR_UNMASK                            ((0x197d  << 2) + 0xff000000)
#define VBO_TMCHK_HSYNC_STATE_L                    ((0x197e  << 2) + 0xff000000)
#define VBO_TMCHK_HSYNC_STATE_H                    ((0x197f  << 2) + 0xff000000)
#define VBO_TMCHK_VSYNC_STATE_L                    ((0x19f4  << 2) + 0xff000000)
#define VBO_TMCHK_VSYNC_STATE_H                    ((0x19f5  << 2) + 0xff000000)
#define VBO_TMCHK_VDE_STATE_L                      ((0x19f6  << 2) + 0xff000000)
#define VBO_TMCHK_VDE_STATE_H                      ((0x19f7  << 2) + 0xff000000)
#define VBO_INTR_STATE                             ((0x19f8  << 2) + 0xff000000)
#define VBO_INFILTER_CTRL                          ((0x19f9  << 2) + 0xff000000)
#define VBO_INSGN_CTRL                             ((0x19fa  << 2) + 0xff000000)
#define VBO_INFILTER_CTRL_H                        ((0x1977  << 2) + 0xff000000)
//**************************************************************************
//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
//**************************************************************************
#define GAMMA_CNTL_PORT                            ((0x1980  << 2) + 0xff000000)
   #define  GAMMA_VCOM_POL    7     //RW
   #define  GAMMA_RVS_OUT     6     //RW
   #define  ADR_RDY           5     //Read Only
   #define  WR_RDY            4     //Read Only
   #define  RD_RDY            3     //Read Only
   #define  GAMMA_TR          2     //RW
   #define  GAMMA_SET         1     //RW
   #define  GAMMA_EN          0     //RW
#define GAMMA_DATA_PORT                            ((0x1981  << 2) + 0xff000000)
#define GAMMA_ADDR_PORT                            ((0x1982  << 2) + 0xff000000)
   #define  H_RD              12
   #define  H_AUTO_INC        11
   #define  H_SEL_R           10
   #define  H_SEL_G           9
   #define  H_SEL_B           8
   #define  HADR_MSB          7            //7:0
   #define  HADR              0            //7:0
#define GAMMA_VCOM_HSWITCH_ADDR                    ((0x1983  << 2) + 0xff000000)
#define RGB_BASE_ADDR                              ((0x1985  << 2) + 0xff000000)
#define RGB_COEFF_ADDR                             ((0x1986  << 2) + 0xff000000)
#define POL_CNTL_ADDR                              ((0x1987  << 2) + 0xff000000)
   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
   #define   CPH3_POL         8
   #define   CPH2_POL         7
   #define   CPH1_POL         6
   #define   TCON_DE_SEL      5
   #define   TCON_VS_SEL      4
   #define   TCON_HS_SEL      3
   #define   DE_POL           2
   #define   VS_POL           1
   #define   HS_POL           0
#define DITH_CNTL_ADDR                             ((0x1988  << 2) + 0xff000000)
   #define  DITH10_EN         10
   #define  DITH8_EN          9
   #define  DITH_MD           8
   #define  DITH10_CNTL_MSB   7          //7:4
   #define  DITH10_CNTL       4          //7:4
   #define  DITH8_CNTL_MSB    3          //3:0
   #define  DITH8_CNTL        0          //3:0
//Bit 1 highlight_en
//Bit 0 probe_en
#define GAMMA_PROBE_CTRL                           ((0x1989  << 2) + 0xff000000)
//read only
//Bit [15:0]  probe_color[15:0]
#define GAMMA_PROBE_COLOR_L                        ((0x198a  << 2) + 0xff000000)
//Read only
//Bit 15: if true valid probed color
//Bit [13:0]  probe_color[29:16]
#define GAMMA_PROBE_COLOR_H                        ((0x198b  << 2) + 0xff000000)
//bit 15:0, 5:6:5 color
#define GAMMA_PROBE_HL_COLOR                       ((0x198c  << 2) + 0xff000000)
//12:0 pos_x
#define GAMMA_PROBE_POS_X                          ((0x198d  << 2) + 0xff000000)
//12:0 pos_y
#define GAMMA_PROBE_POS_Y                          ((0x198e  << 2) + 0xff000000)
#define STH1_HS_ADDR                               ((0x1990  << 2) + 0xff000000)
#define STH1_HE_ADDR                               ((0x1991  << 2) + 0xff000000)
#define STH1_VS_ADDR                               ((0x1992  << 2) + 0xff000000)
#define STH1_VE_ADDR                               ((0x1993  << 2) + 0xff000000)
#define STH2_HS_ADDR                               ((0x1994  << 2) + 0xff000000)
#define STH2_HE_ADDR                               ((0x1995  << 2) + 0xff000000)
#define STH2_VS_ADDR                               ((0x1996  << 2) + 0xff000000)
#define STH2_VE_ADDR                               ((0x1997  << 2) + 0xff000000)
#define OEH_HS_ADDR                                ((0x1998  << 2) + 0xff000000)
#define OEH_HE_ADDR                                ((0x1999  << 2) + 0xff000000)
#define OEH_VS_ADDR                                ((0x199a  << 2) + 0xff000000)
#define OEH_VE_ADDR                                ((0x199b  << 2) + 0xff000000)
#define VCOM_HSWITCH_ADDR                          ((0x199c  << 2) + 0xff000000)
#define VCOM_VS_ADDR                               ((0x199d  << 2) + 0xff000000)
#define VCOM_VE_ADDR                               ((0x199e  << 2) + 0xff000000)
#define CPV1_HS_ADDR                               ((0x199f  << 2) + 0xff000000)
#define CPV1_HE_ADDR                               ((0x19a0  << 2) + 0xff000000)
#define CPV1_VS_ADDR                               ((0x19a1  << 2) + 0xff000000)
#define CPV1_VE_ADDR                               ((0x19a2  << 2) + 0xff000000)
#define CPV2_HS_ADDR                               ((0x19a3  << 2) + 0xff000000)
#define CPV2_HE_ADDR                               ((0x19a4  << 2) + 0xff000000)
#define CPV2_VS_ADDR                               ((0x19a5  << 2) + 0xff000000)
#define CPV2_VE_ADDR                               ((0x19a6  << 2) + 0xff000000)
#define STV1_HS_ADDR                               ((0x19a7  << 2) + 0xff000000)
#define STV1_HE_ADDR                               ((0x19a8  << 2) + 0xff000000)
#define STV1_VS_ADDR                               ((0x19a9  << 2) + 0xff000000)
#define STV1_VE_ADDR                               ((0x19aa  << 2) + 0xff000000)
#define STV2_HS_ADDR                               ((0x19ab  << 2) + 0xff000000)
#define STV2_HE_ADDR                               ((0x19ac  << 2) + 0xff000000)
#define STV2_VS_ADDR                               ((0x19ad  << 2) + 0xff000000)
#define STV2_VE_ADDR                               ((0x19ae  << 2) + 0xff000000)
#define OEV1_HS_ADDR                               ((0x19af  << 2) + 0xff000000)
#define OEV1_HE_ADDR                               ((0x19b0  << 2) + 0xff000000)
#define OEV1_VS_ADDR                               ((0x19b1  << 2) + 0xff000000)
#define OEV1_VE_ADDR                               ((0x19b2  << 2) + 0xff000000)
#define OEV2_HS_ADDR                               ((0x19b3  << 2) + 0xff000000)
#define OEV2_HE_ADDR                               ((0x19b4  << 2) + 0xff000000)
#define OEV2_VS_ADDR                               ((0x19b5  << 2) + 0xff000000)
#define OEV2_VE_ADDR                               ((0x19b6  << 2) + 0xff000000)
#define OEV3_HS_ADDR                               ((0x19b7  << 2) + 0xff000000)
#define OEV3_HE_ADDR                               ((0x19b8  << 2) + 0xff000000)
#define OEV3_VS_ADDR                               ((0x19b9  << 2) + 0xff000000)
#define OEV3_VE_ADDR                               ((0x19ba  << 2) + 0xff000000)
#define LCD_PWR_ADDR                               ((0x19bb  << 2) + 0xff000000)
   #define      LCD_VDD        5
   #define      LCD_VBL        4
   #define      LCD_GPI_MSB    3
   #define      LCD_GPIO       0
#define LCD_PWM0_LO_ADDR                           ((0x19bc  << 2) + 0xff000000)
#define LCD_PWM0_HI_ADDR                           ((0x19bd  << 2) + 0xff000000)
#define LCD_PWM1_LO_ADDR                           ((0x19be  << 2) + 0xff000000)
#define LCD_PWM1_HI_ADDR                           ((0x19bf  << 2) + 0xff000000)
#define INV_CNT_ADDR                               ((0x19c0  << 2) + 0xff000000)
   #define     INV_EN          4
   #define     INV_CNT_MSB     3
   #define     INV_CNT         0
#define TCON_MISC_SEL_ADDR                         ((0x19c1  << 2) + 0xff000000)
   #define     STH2_SEL        12
   #define     STH1_SEL        11
   #define     OEH_SEL         10
   #define     VCOM_SEL         9
   #define     DB_LINE_SW       8
   #define     CPV2_SEL         7
   #define     CPV1_SEL         6
   #define     STV2_SEL         5
   #define     STV1_SEL         4
   #define     OEV_UNITE        3
   #define     OEV3_SEL         2
   #define     OEV2_SEL         1
   #define     OEV1_SEL         0
#define DUAL_PORT_CNTL_ADDR                        ((0x19c2  << 2) + 0xff000000)
   #define     OUTPUT_YUV       15
   #define     DUAL_IDF         12   // 14:12
   #define     DUAL_ISF         9    // 11:9
   #define     LCD_ANALOG_SEL_CPH3   8
   #define     LCD_ANALOG_3PHI_CLK_SEL   7
   #define     LCD_LVDS_SEL54   6
   #define     LCD_LVDS_SEL27   5
   #define     LCD_TTL_SEL      4
   #define     DUAL_LVDC_EN     3
   #define     PORT_SWP         2
   #define     RGB_SWP          1
   #define     BIT_SWP          0
#define MLVDS_CONTROL                              ((0x19c3  << 2) + 0xff000000)
   #define     mLVDS_RESERVED  15    // 15
   #define     mLVDS_double_pattern  14    // 14
   #define     mLVDS_ins_reset  8    // 13:8  // each channel has one bit
   #define     mLVDS_dual_gate  7
   #define     mLVDS_bit_num    6    // 0-6Bits, 1-8Bits
   #define     mLVDS_pair_num   5    // 0-3Pairs, 1-6Pairs
   #define     mLVDS_msb_first  4
   #define     mLVDS_PORT_SWAP  3
   #define     mLVDS_MLSB_SWAP  2
   #define     mLVDS_PN_SWAP    1
   #define     mLVDS_en         0
#define MLVDS_RESET_PATTERN_HI                     ((0x19c4  << 2) + 0xff000000)
#define MLVDS_RESET_PATTERN_LO                     ((0x19c5  << 2) + 0xff000000)
   #define     mLVDS_reset_pattern  0 // Bit 47:16
#define MLVDS_RESET_PATTERN_EXT                    ((0x19c6  << 2) + 0xff000000)
   #define     mLVDS_reset_pattern_ext  0 // Bit 15:0
#define MLVDS_CONFIG_HI                            ((0x19c7  << 2) + 0xff000000)
#define MLVDS_CONFIG_LO                            ((0x19c8  << 2) + 0xff000000)
   #define     mLVDS_reset_offset         29 // Bit 31:29
   #define     mLVDS_reset_length         23 // Bit 28:23
   #define     mLVDS_config_reserved      20 // Bit 22:20
   #define     mLVDS_reset_start_bit12    19 // Bit 19
   #define     mLVDS_data_write_toggle    18
   #define     mLVDS_data_write_ini       17
   #define     mLVDS_data_latch_1_toggle  16
   #define     mLVDS_data_latch_1_ini     15
   #define     mLVDS_data_latch_0_toggle  14
   #define     mLVDS_data_latch_0_ini     13
   #define     mLVDS_reset_1_select       12 // 0 - same as reset_0, 1 - 1 clock delay of reset_0
   #define     mLVDS_reset_start           0 // Bit 11:0
#define TCON_DOUBLE_CTL                            ((0x19c9  << 2) + 0xff000000)
   #define     tcon_double_ini          8 // Bit 7:0
   #define     tcon_double_inv          0 // Bit 7:0
#define TCON_PATTERN_HI                            ((0x19ca  << 2) + 0xff000000)
#define TCON_PATTERN_LO                            ((0x19cb  << 2) + 0xff000000)
   #define     tcon_pattern_loop_data     16 // Bit 15:0
   #define     tcon_pattern_loop_start    12 // Bit 3:0
   #define     tcon_pattern_loop_end       8 // Bit 3:0
   #define     tcon_pattern_enable         0 // Bit 7:0
#define TCON_CONTROL_HI                            ((0x19cc  << 2) + 0xff000000)
#define TCON_CONTROL_LO                            ((0x19cd  << 2) + 0xff000000)
   #define     tcon_pclk_enable           26 // Bit 5:0 (enable pclk on TCON channel 7 to 2)
   #define     tcon_pclk_div              24 // Bit 1:0 (control phy clock divide 2,4,6,8)
   #define     tcon_delay                  0 // Bit 23:0 (3 bit for each channel)
#define LVDS_BLANK_DATA_HI                         ((0x19ce  << 2) + 0xff000000)
#define LVDS_BLANK_DATA_LO                         ((0x19cf  << 2) + 0xff000000)
   #define     LVDS_blank_data_reserved 30  // 31:30
   #define     LVDS_blank_data_r        20  // 29:20
   #define     LVDS_blank_data_g        10  // 19:10
   #define     LVDS_blank_data_b         0  //  9:0
#define LVDS_PACK_CNTL_ADDR                        ((0x19d0  << 2) + 0xff000000)
   #define     LVDS_USE_TCON    7
   #define     LVDS_DUAL        6
   #define     PN_SWP           5
   #define     LSB_FIRST        4
   #define     LVDS_RESV        3
   #define     ODD_EVEN_SWP     2
   #define     LVDS_REPACK      0
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN7-TCON4)
// Bit 11:0 -- de_hs(old tcon) second offset_hs (new tcon)
#define DE_HS_ADDR                                 ((0x19d1  << 2) + 0xff000000)
// New from M3 :
// Bit 15:12 -- Enable OFFSET Double Generate(TOCN3-TCON0)
#define DE_HE_ADDR                                 ((0x19d2  << 2) + 0xff000000)
#define DE_VS_ADDR                                 ((0x19d3  << 2) + 0xff000000)
#define DE_VE_ADDR                                 ((0x19d4  << 2) + 0xff000000)
#define HSYNC_HS_ADDR                              ((0x19d5  << 2) + 0xff000000)
#define HSYNC_HE_ADDR                              ((0x19d6  << 2) + 0xff000000)
#define HSYNC_VS_ADDR                              ((0x19d7  << 2) + 0xff000000)
#define HSYNC_VE_ADDR                              ((0x19d8  << 2) + 0xff000000)
#define VSYNC_HS_ADDR                              ((0x19d9  << 2) + 0xff000000)
#define VSYNC_HE_ADDR                              ((0x19da  << 2) + 0xff000000)
#define VSYNC_VS_ADDR                              ((0x19db  << 2) + 0xff000000)
#define VSYNC_VE_ADDR                              ((0x19dc  << 2) + 0xff000000)
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define LCD_MCU_CTL                                ((0x19dd  << 2) + 0xff000000)
// ReadOnly
//   R5G6B5 when R5G6B5_format
//   G8R8   when R8G8B8_format
//   G5R10  Other
#define LCD_MCU_DATA_0                             ((0x19de  << 2) + 0xff000000)
// ReadOnly
//   G8B8   when R8G8B8_format
//   G5B10  Other
#define LCD_MCU_DATA_1                             ((0x19df  << 2) + 0xff000000)
// LVDS
#define LVDS_GEN_CNTL                              ((0x19e0  << 2) + 0xff000000)
//`define LVDS_PHY_CNTL0          8'he1
//`define LVDS_PHY_CNTL1          8'he2
//`define LVDS_PHY_CNTL2          8'he3
//`define LVDS_PHY_CNTL3          8'he4
//`define LVDS_PHY_CNTL4          8'he5
//`define LVDS_PHY_CNTL5          8'he6
#define LVDS_SRG_TEST                              ((0x19e8  << 2) + 0xff000000)
#define LVDS_BIST_MUX0                             ((0x19e9  << 2) + 0xff000000)
#define LVDS_BIST_MUX1                             ((0x19ea  << 2) + 0xff000000)
#define LVDS_BIST_FIXED0                           ((0x19eb  << 2) + 0xff000000)
#define LVDS_BIST_FIXED1                           ((0x19ec  << 2) + 0xff000000)
#define LVDS_BIST_CNTL0                            ((0x19ed  << 2) + 0xff000000)
#define LVDS_CLKB_CLKA                             ((0x19ee  << 2) + 0xff000000)
#define LVDS_PHY_CLK_CNTL                          ((0x19ef  << 2) + 0xff000000)
#define LVDS_SER_EN                                ((0x19f0  << 2) + 0xff000000)
//`define LVDS_PHY_CNTL6        8'hf1
//`define LVDS_PHY_CNTL7        8'hf2
//`define LVDS_PHY_CNTL8        8'hf3
#define LVDS_CH_SWAP0                              ((0x19e1  << 2) + 0xff000000)
#define LVDS_CH_SWAP1                              ((0x19e2  << 2) + 0xff000000)
#define LVDS_CH_SWAP2                              ((0x19e3  << 2) + 0xff000000)
//`define MLVDS_CLK_CTL0_HI        8'hf4
//`define MLVDS_CLK_CTL0_LO        8'hf5
//   `define     mlvds_clk_pattern_reserved 31 // Bit 31
//   `define     mpclk_dly                  28 // Bit 2:0
//   `define     mpclk_div                  26 // Bit 1:0 (control phy clock divide 2,4,6,8)
//   `define     use_mpclk                  25 // Bit 0
//   `define     mlvds_clk_half_delay       24 // Bit 0
//   `define     mlvds_clk_pattern           0 // Bit 23:0
//`define MLVDS_DUAL_GATE_WR_START        8'hf6
//   `define     mlvds_dual_gate_wr_start    0 // Bit 12:0
//`define MLVDS_DUAL_GATE_WR_END          8'hf7
//   `define     mlvds_dual_gate_wr_end      0 // Bit 12:0
//
//`define MLVDS_DUAL_GATE_RD_START        8'hf8
//   `define     mlvds_dual_gate_rd_start    0 // Bit 12:0
//`define MLVDS_DUAL_GATE_RD_END          8'hf9
//   `define     mlvds_dual_gate_rd_end      0 // Bit 12:0
//`define MLVDS_SECOND_RESET_CTL          8'hfa
//   `define     mLVDS_2nd_reset_start       0 // Bit 12:0
//
#define MLVDS_DUAL_GATE_CTL_HI                     ((0x19fb  << 2) + 0xff000000)
#define MLVDS_DUAL_GATE_CTL_LO                     ((0x19fc  << 2) + 0xff000000)
//   `define     mlvds_tcon_field_en        24 // Bit 7:0
//   `define     mlvds_dual_gate_reserved   21 // Bit 2:0
//   `define     mlvds_scan_mode_start_line_bit12 20 // Bit 0
//   `define     mlvds_scan_mode_odd        16 // Bit 3:0
//   `define     mlvds_scan_mode_even       12 // Bit 3:0
//   `define     mlvds_scan_mode_start_line  0 // Bit 11:0
//
//`define MLVDS_RESET_CONFIG_HI         8'hfd
//`define MLVDS_RESET_CONFIG_LO         8'hfe
//   `define     mLVDS_reset_range_enable   31 // Bit 0
//   `define     mLVDS_reset_range_inv      30 // Bit 0
//   `define     mLVDS_reset_config_res1    29 // Bit 0
//   `define     mLVDS_reset_range_line_0   16 // Bit 11:0
//   `define     mLVDS_reset_config_res3    13 // Bit 2:0
//   `define     mLVDS_reset_range_line_1    0 // Bit 11:0
//===============================================================
//LCD DRIVER BASE   END
//===============================================================
//
// Closing file:  ./disp_if_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vregs_clk2.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VIU_VCBUS_BASE = 0x1a
// -----------------------------------------------
#define VIU_ADDR_START                             ((0x1a00  << 2) + 0xff000000)
#define VIU_ADDR_END                               ((0x1aff  << 2) + 0xff000000)
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers 0x00-0x0f
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define VIU_SW_RESET                               ((0x1a01  << 2) + 0xff000000)
#define VIU_SW_RESET0                              ((0x1a02  << 2) + 0xff000000)
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
#define VIU_SECURE_REG                             ((0x1a04  << 2) + 0xff000000)
// Bit 0 RW, dolby core1_tv secure w and r
// Bit 1 RW, dolby core2 secure w and r
// Bit 2 RW, dolby core3 secure w and r
// Bit 3 RW, for osd1 secure read
// Bit 4 RW, for osd2 secure read
#define DOLBY_INT_STAT                             ((0x1a05  << 2) + 0xff000000)
// todo
//bit 15:12 osdbld_gclk_ctrl 3:2 regclk ctrl 1:0 blending clk control
//bit 8 if true, vsync interrup is generate only field == 0
//bit 7:0 fix_disable
#define VIU_MISC_CTRL0                             ((0x1a06  << 2) + 0xff000000)
#define VIU_MISC_CTRL1                             ((0x1a07  << 2) + 0xff000000)
//Bit 31:7       Reserved
//Bit 6:4        reg_cfg_err_clr
//Bit 3          Reserved
//Bit 2:0        reg_cfg_done
#define VIU_SECURE_DUMMY                           ((0x1a08  << 2) + 0xff000000)
#define VIU_SECURE_ST_RO                           ((0x1a09  << 2) + 0xff000000)
// Bit 31:30 vdin0 dout splitter, bit 0 turns on vdin0 to old path, bit 1 turns on vdin0 to d2d3_intf vdin0 input path
// Bit 29:28 vdin1 dout splitter, bit 0 turns on vdin1 to old path, bit 1 turns on vdin1 to d2d3_intf vdin1 input path
// Bit 27:26 NR write dout splitter, bit 0 turns on NR write to old path, bit 1 turns on NR WR to d2d3_intf NR WR input path
// Bit 23 if true, turn on clk_d2d3_reg (register clock)
// Bit 22 if true, turn on clk_d2d3
// Bit 21 reg_v1_go_line
// Bit 20 reg_v1_go_field
// Bit 19 reg_v0_go_field
// Bit 18:16 v1_gofld_sel, 000: display go_field/go_line, 001: DI pre_frame_rst/go_line, 010: vdin0 go_field/go_line,
//011: vdin1 go_field/go_line, otherwise: force go_field by reg_v1_go_field(bit20), force go_line by reg_v1_go_line(bit21)
// Bit 15:13 v0_gofld_sel, 000: display go_field, 001: DI pre_frame_rst, 010: vdin0 go_field, 011: vdin1 go_field, otherwise: force go_field by
// reg_v0_go_field(bit19)
// Bit 12:6 hole_lines for d2d3 depth read interface
// Bit 5:4 d2d3_v1_sel, 2'b01: video display read interface(DI or vd1 fomart output), 2'b10: scale output, otherwise nothing as v1
// Bit 3 use_vdin_eol, if true, use vdin eol as the v0_eol, otherwise using length to get the v0_eol
// Bit 2:0  d2d3_v0_sel  001: vdin0, 010: vdin1, 011: NRW, 100: video display read interface(DI or vd1 fomart output), 101: vpp scale output
//
// `define D2D3_INTF_CTRL0                 8'h09
#define VD1_AFBCD0_MISC_CTRL                       ((0x1a0a  << 2) + 0xff000000)
#define VD2_AFBCD1_MISC_CTRL                       ((0x1a0b  << 2) + 0xff000000)
#define DOLBY_PATH_CTRL                            ((0x1a0c  << 2) + 0xff000000)
#define WR_BACK_MISC_CTRL                          ((0x1a0d  << 2) + 0xff000000)
#define OSD_PATH_MISC_CTRL                         ((0x1a0e  << 2) + 0xff000000)
#define MALI_AFBCD_TOP_CTRL                        ((0x1a0f  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// OSD1 registers 0x10-0x2f
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU_OSD1_CTRL_STAT                         ((0x1a10  << 2) + 0xff000000)
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15    RW, osd_dpath_sel   0-osd1 mif 1-vpu mali afbcd
// Bit 14    RW, replaced_alpha_en
// Bit 13: 6 RW, replaced_alpha
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU_OSD1_CTRL_STAT2                        ((0x1a2d  << 2) + 0xff000000)
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU_OSD1_COLOR_ADDR                        ((0x1a11  << 2) + 0xff000000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD1_COLOR                             ((0x1a12  << 2) + 0xff000000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD1_TCOLOR_AG0                        ((0x1a17  << 2) + 0xff000000)
#define VIU_OSD1_TCOLOR_AG1                        ((0x1a18  << 2) + 0xff000000)
#define VIU_OSD1_TCOLOR_AG2                        ((0x1a19  << 2) + 0xff000000)
#define VIU_OSD1_TCOLOR_AG3                        ((0x1a1a  << 2) + 0xff000000)
// Bit 31:30 Reserved
// Bit    29 RW, y_rev: 0=normal read, 1=reverse read in Y direction
// Bit    28 RW, x_rev: 0=normal read, 1=reverse read in X direction
// Bit 27:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU_OSD1_BLK0_CFG_W0                       ((0x1a1b  << 2) + 0xff000000)
#define VIU_OSD1_BLK1_CFG_W0                       ((0x1a1f  << 2) + 0xff000000)
#define VIU_OSD1_BLK2_CFG_W0                       ((0x1a23  << 2) + 0xff000000)
#define VIU_OSD1_BLK3_CFG_W0                       ((0x1a27  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU_OSD1_BLK0_CFG_W1                       ((0x1a1c  << 2) + 0xff000000)
#define VIU_OSD1_BLK1_CFG_W1                       ((0x1a20  << 2) + 0xff000000)
#define VIU_OSD1_BLK2_CFG_W1                       ((0x1a24  << 2) + 0xff000000)
#define VIU_OSD1_BLK3_CFG_W1                       ((0x1a28  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU_OSD1_BLK0_CFG_W2                       ((0x1a1d  << 2) + 0xff000000)
#define VIU_OSD1_BLK1_CFG_W2                       ((0x1a21  << 2) + 0xff000000)
#define VIU_OSD1_BLK2_CFG_W2                       ((0x1a25  << 2) + 0xff000000)
#define VIU_OSD1_BLK3_CFG_W2                       ((0x1a29  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU_OSD1_BLK0_CFG_W3                       ((0x1a1e  << 2) + 0xff000000)
#define VIU_OSD1_BLK1_CFG_W3                       ((0x1a22  << 2) + 0xff000000)
#define VIU_OSD1_BLK2_CFG_W3                       ((0x1a26  << 2) + 0xff000000)
#define VIU_OSD1_BLK3_CFG_W3                       ((0x1a2a  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU_OSD1_BLK0_CFG_W4                       ((0x1a13  << 2) + 0xff000000)
#define VIU_OSD1_BLK1_CFG_W4                       ((0x1a14  << 2) + 0xff000000)
#define VIU_OSD1_BLK2_CFG_W4                       ((0x1a15  << 2) + 0xff000000)
#define VIU_OSD1_BLK3_CFG_W4                       ((0x1a16  << 2) + 0xff000000)
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
// Bit    19 R,  fifo_overflow
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU_OSD1_FIFO_CTRL_STAT                    ((0x1a2b  << 2) + 0xff000000)
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU_OSD1_TEST_RDDATA                       ((0x1a2c  << 2) + 0xff000000)
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU_OSD1_PROT_CTRL                         ((0x1a2e  << 2) + 0xff000000)
////add for OSD1/2 mali_unpack
#define VIU_OSD1_MALI_UNPACK_CTRL                  ((0x1a2f  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// OSD2 registers 0x30-0x4f  0x64 -0x67
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define VIU_OSD2_CTRL_STAT                         ((0x1a30  << 2) + 0xff000000)
// Bit 31:26 Reserved
// Bit 25:16 R, fifo_count
// Bit 15    Reserved
// Bit 14    RW, replaced_alpha_en
// Bit 13: 6 RW, replaced_alpha
// Bit  5: 4 RW, hold_fifo_lines[6:5]
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, reserved
// Bit     0 RW, color_expand_mode
#define VIU_OSD2_CTRL_STAT2                        ((0x1a4d  << 2) + 0xff000000)
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define VIU_OSD2_COLOR_ADDR                        ((0x1a31  << 2) + 0xff000000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD2_COLOR                             ((0x1a32  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define VIU_OSD2_HL1_H_START_END                   ((0x1a33  << 2) + 0xff000000)
#define VIU_OSD2_HL1_V_START_END                   ((0x1a34  << 2) + 0xff000000)
#define VIU_OSD2_HL2_H_START_END                   ((0x1a35  << 2) + 0xff000000)
#define VIU_OSD2_HL2_V_START_END                   ((0x1a36  << 2) + 0xff000000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define VIU_OSD2_TCOLOR_AG0                        ((0x1a37  << 2) + 0xff000000)
#define VIU_OSD2_TCOLOR_AG1                        ((0x1a38  << 2) + 0xff000000)
#define VIU_OSD2_TCOLOR_AG2                        ((0x1a39  << 2) + 0xff000000)
#define VIU_OSD2_TCOLOR_AG3                        ((0x1a3a  << 2) + 0xff000000)
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define VIU_OSD2_BLK0_CFG_W0                       ((0x1a3b  << 2) + 0xff000000)
#define VIU_OSD2_BLK1_CFG_W0                       ((0x1a3f  << 2) + 0xff000000)
#define VIU_OSD2_BLK2_CFG_W0                       ((0x1a43  << 2) + 0xff000000)
#define VIU_OSD2_BLK3_CFG_W0                       ((0x1a47  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define VIU_OSD2_BLK0_CFG_W1                       ((0x1a3c  << 2) + 0xff000000)
#define VIU_OSD2_BLK1_CFG_W1                       ((0x1a40  << 2) + 0xff000000)
#define VIU_OSD2_BLK2_CFG_W1                       ((0x1a44  << 2) + 0xff000000)
#define VIU_OSD2_BLK3_CFG_W1                       ((0x1a48  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define VIU_OSD2_BLK0_CFG_W2                       ((0x1a3d  << 2) + 0xff000000)
#define VIU_OSD2_BLK1_CFG_W2                       ((0x1a41  << 2) + 0xff000000)
#define VIU_OSD2_BLK2_CFG_W2                       ((0x1a45  << 2) + 0xff000000)
#define VIU_OSD2_BLK3_CFG_W2                       ((0x1a49  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define VIU_OSD2_BLK0_CFG_W3                       ((0x1a3e  << 2) + 0xff000000)
#define VIU_OSD2_BLK1_CFG_W3                       ((0x1a42  << 2) + 0xff000000)
#define VIU_OSD2_BLK2_CFG_W3                       ((0x1a46  << 2) + 0xff000000)
#define VIU_OSD2_BLK3_CFG_W3                       ((0x1a4a  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define VIU_OSD2_BLK0_CFG_W4                       ((0x1a64  << 2) + 0xff000000)
#define VIU_OSD2_BLK1_CFG_W4                       ((0x1a65  << 2) + 0xff000000)
#define VIU_OSD2_BLK2_CFG_W4                       ((0x1a66  << 2) + 0xff000000)
#define VIU_OSD2_BLK3_CFG_W4                       ((0x1a67  << 2) + 0xff000000)
// Bit    31 RW, burst_len_sel[2] of [2:0]
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit    29 RW, div_swap : swap the 2 64bits words in 128 bit word
// Bit 28:24 RW, fifo_lim : when osd fifo is small than the fifo_lim*16, closed the rq port of osd_rd_mif
// Bit 23:22 RW, fifo_ctrl: 00 : for 1 word in 1 burst , 01 : for  2words in 1burst, 10: for 4words in 1burst, 11: reserved
// Bit 21:20 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT
// Bit    19 R,  fifo_overflow
//
// Bit 18:12 RW, fifo_depth_val, max value=64: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel[1:0] of [2:0]. 0=24(default), 1=32, 2=48, 3=64, 4=96, 5=128.
// Bit  9: 5 RW, hold_fifo_lines[4:0]
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define VIU_OSD2_FIFO_CTRL_STAT                    ((0x1a4b  << 2) + 0xff000000)
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define VIU_OSD2_TEST_RDDATA                       ((0x1a4c  << 2) + 0xff000000)
// Bit    15 RW, prot_en: 1=Borrow PROT's FIFO storage, either for rotate or non-rotate.
// Bit 12: 0 RW, effective FIFO size when prot_en=1.
#define VIU_OSD2_PROT_CTRL                         ((0x1a4e  << 2) + 0xff000000)
#define VIU_GCLK_CTRL                              ((0x1a4f  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// VIU registers 0x50 -0x5f
//------------------------------------------------------------------------------
#define VIU_DATA_SEC                               ((0x1a50  << 2) + 0xff000000)
#define VIU_FRM_CTRL                               ((0x1a51  << 2) + 0xff000000)
//Bit   31:30 reserved
//Bit   29    viu0_frm_start       unsigned,default = 0   //pulse
//Bit   28:27 reserved
//Bit   26    viu0_chk_dout_sec    unsigned,default = 0
//Bit   25    viu0_wrbak1_hsyn_en  unsigned,default = 0
//Bit   24    viu0_wrbak0_hsyn_en  unsigned,default = 0
//Bit   23:20 reserved
//Bit   19:17 viu0_frm_phs_mode    unsigned,default = 0
//Bit   16    viu0_frm_start_sel   unsigned,default = 0
//Bit   15:13 reserved
//Bit   12:0  viu0_hold_line_num   unsigned,default = 4
#define VIU_RDMIF_DEPTH                            ((0x1a52  << 2) + 0xff000000)
#define MALI_AFBCD1_TOP_CTRL                       ((0x1a55  << 2) + 0xff000000)
#define MALI_AFBCD2_TOP_CTRL                       ((0x1a56  << 2) + 0xff000000)
#define VD1_HDR_IN_SIZE                            ((0x1a57  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     vd1_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      vd1_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define VD2_HDR_IN_SIZE                            ((0x1a58  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     vd2_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      vd2_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define VD3_HDR_IN_SIZE                            ((0x1a59  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     vd3_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      vd3_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define OSD1_HDR_IN_SIZE                           ((0x1a5a  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     osd1_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      osd1_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define OSD2_HDR_IN_SIZE                           ((0x1a5b  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     osd2_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      osd2_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define OSD3_HDR_IN_SIZE                           ((0x1a5c  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     osd3_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      osd3_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define OSD4_HDR_IN_SIZE                           ((0x1a5d  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     osd4_hdr_in_vsize     unsigned,default = 1920 ,//vsize of hdr
//Bit   15:13     reserved
//Bit   12:0      osd4_hdr_in_hsize     unsigned,default = 1080 ,//hsize of hdr
#define OSD_BLEND_DIN_CTRL                         ((0x1a5e  << 2) + 0xff000000)
//Bit   31:4      reserved
//Bit   3 :0      osd_bld_din_sel     unsigned,default = 0xf
#define DOLBY_PATH_SWAP_CTRL1                      ((0x1a70  << 2) + 0xff000000)
//Bit   31:0      reserved
#define DOLBY_PATH_SWAP_CTRL2                      ((0x1a71  << 2) + 0xff000000)
//Bit   31:0      reserved
#define VPP_OSD1_SCALE_CTRL                        ((0x1a73  << 2) + 0xff000000)
//Bit   31:3   reserved
//Bit   2      osd1_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd1_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd1_sc_path_sel     unsigned,default = 0 ,//0:after HDR         1:before osd_blend
#define VPP_OSD2_SCALE_CTRL                        ((0x1a74  << 2) + 0xff000000)
//Bit   31:3   reserved
//Bit   2      osd2_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd2_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd2_sc_path_sel     unsigned,default = 0 ,//0:after HDR         1:before osd_blend
#define VPP_OSD3_SCALE_CTRL                        ((0x1a75  << 2) + 0xff000000)
//Bit   31:3   reserved
//Bit   2      osd3_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd3_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd3_sc_path_sel     unsigned,default = 0 ,//0:after HDR         1:before osd_blend
#define VPP_OSD4_SCALE_CTRL                        ((0x1a76  << 2) + 0xff000000)
//Bit   31:3   reserved
//Bit   2      osd4_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd4_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd4_sc_path_sel     unsigned,default = 0 ,//0:after HDR         1:before osd_blend
#define VIU_VD1_PATH_CTRL                          ((0x1ac0  << 2) + 0xff000000)
//Bit   31:30  reserved
//Bit   29     dolby_meta_sec       unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   28     vd1_sec              unsigned,default = 0 ,//0:vd  insecurity    1:vd  security
//Bit   27:18  reserved
//Bit   17     vd1_din_ext_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   16     vd1_dolby_byp        unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:0   reserved
#define VIU_VD2_PATH_CTRL                          ((0x1ac1  << 2) + 0xff000000)
//Bit   31:29  reserved
//Bit   28     vd2_sec              unsigned,default = 0 ,//0:vd  insecurity    1:vd  security
//Bit   27:18  reserved
//Bit   17     vd2_din_ext_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   16     vd2_dolby_byp        unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:0   reserved
#define VIU_VD3_PATH_CTRL                          ((0x1ac2  << 2) + 0xff000000)
//Bit   31:29  reserved
//Bit   28     vd3_sec              unsigned,default = 0 ,//0:vd  insecurity    1:vd  security
//Bit   27:18  reserved
//Bit   17     vd3_din_ext_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   16     vd3_dolby_byp        unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:0   reserved
#define VIU_OSD1_PATH_CTRL                         ((0x1ac3  << 2) + 0xff000000)
//Bit   31     reg_osd2_axi_sel     unsigned,default = 0 ,//0:mif               1:afbcd
//Bit   30     reserved
//Bit   29     mali_afbcd0_sec      unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   28     osd2_sec             unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   27:18  reserved
//Bit   17     osd1_din_ext_mode    unsigned,default = 1 ,//1:{2'd0,data}       0:{data,2'd0}
//Bit   16     osd1_dolby_byp       unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:5   reserved
//Bit   4      osd1_bld_din_sel     unsigned,default = 1 ,//0:osd_data to osd_bld 1:osd_data_byp osd_bld
//Bit   3      reserved
//Bit   2      osd1_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd1_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd1_sc_path_sel     unsigned,default = 0 ,//0:after HDR         1:before osd_blend
#define VIU_OSD2_PATH_CTRL                         ((0x1a77  << 2) + 0xff000000)
//Bit   31     reg_osd2_axi_sel     unsigned,default = 0 ,//0:mif               1:afbcd
//Bit   30:29  reserved
//Bit   28     osd2_sec             unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   27:18  reserved
//Bit   17     osd2_din_ext_mode    unsigned,default = 1 ,//1:{2'd0,data}       0:{data,2'd0}
//Bit   16     osd2_dolby_byp       unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:5   reserved
//Bit   4      osd2_bld_din_sel     unsigned,default = 1 ,//0:osd_data to osd_bld 1:osd_data_byp osd_bld
//Bit   3      reserved
//Bit   2      osd2_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd2_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd2_sc_path_sel     unsigned,default = 1 ,//0:after HDR         1:before osd_blend
#define VIU_OSD3_PATH_CTRL                         ((0x1a78  << 2) + 0xff000000)
//Bit   31     reg_osd3_axi_sel     unsigned,default = 0 ,//0:mif               1:afbcd
//Bit   30:29  reserved
//Bit   28     osd3_sec             unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   27:18  reserved
//Bit   17     osd3_din_ext_mode    unsigned,default = 1 ,//1:{2'd0,data}       0:{data,2'd0}
//Bit   16     osd3_dolby_byp       unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:5   reserved
//Bit   4      osd3_bld_din_sel     unsigned,default = 1 ,//0:osd_data to osd_bld 1:osd_data_byp osd_bld
//Bit   3      reserved
//Bit   2      osd3_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd3_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd3_sc_path_sel     unsigned,default = 1 ,//0:after HDR         1:before osd_blend
#define VIU_OSD4_PATH_CTRL                         ((0x1a79  << 2) + 0xff000000)
//Bit   31     reg_osd4_axi_sel     unsigned,default = 0 ,//0:mif               1:afbcd
//Bit   30:29  reserved
//Bit   28     osd4_sec             unsigned,default = 0 ,//0:osd insecurity    1:osd security
//Bit   27:18  reserved
//Bit   17     osd4_din_ext_mode    unsigned,default = 1 ,//1:{2'd0,data}       0:{data,2'd0}
//Bit   16     osd4_dolby_byp       unsigned,default = 1 ,//0:data into dolby   1:bypass dolby
//Bit   15:5   reserved
//Bit   4      osd4_bld_din_sel     unsigned,default = 1 ,//0:osd_data to osd_bld 1:osd_data_byp osd_bld
//Bit   3      reserved
//Bit   2      osd4_sc_cmp_byp      unsigned,default = 0 ,//0:open data_convert 1:bypass data_convert
//Bit   1      osd4_sc_cmp_mode     unsigned,default = 1 ,//0:{2'd0,data}       1:{data,2'd0}
//Bit   0      osd4_sc_path_sel     unsigned,default = 1 ,//0:after HDR         1:before osd_blend
#define VD_PATH_MISC_CTRL                          ((0x1a7a  << 2) + 0xff000000)
//Bit   31:0      reserved
#define VPP_PROBE_CTRL                             ((0x1a7b  << 2) + 0xff000000)
#define VPP_PROBE_POS                              ((0x1a7c  << 2) + 0xff000000)
#define VPP_HL_COLOR                               ((0x1a7d  << 2) + 0xff000000)
#define VPP_PROBE_COLOR                            ((0x1a7e  << 2) + 0xff000000)
#define VPP_PROBE_COLOR1                           ((0x1a7f  << 2) + 0xff000000)
#define VD1_PPS_DUMMY_DATA                         ((0x1a80  << 2) + 0xff000000)
//Bit   31:24     reserved
//Bit   23:0      vd_pps_dummy_data
#define VD2_PPS_DUMMY_DATA                         ((0x1a81  << 2) + 0xff000000)
//Bit   31:0      reserved
//Bit   23:0      vd_pps_dummy_data
#define VD3_PPS_DUMMY_DATA                         ((0x1a82  << 2) + 0xff000000)
//Bit   31:24     reserved
//Bit   23:0      vd_pps_dummy_data
#define VPP_VD1_DSC_CTRL                           ((0x1a83  << 2) + 0xff000000)
//Bit   31:0  vd1_in_dsc_ctrl  unsigned,default = 0
#define VPP_VD2_DSC_CTRL                           ((0x1a84  << 2) + 0xff000000)
//Bit   31:0  vd2_in_dsc_ctrl  unsigned,default = 0
#define VPP_VD3_DSC_CTRL                           ((0x1a85  << 2) + 0xff000000)
//Bit   31:0  vd3_in_dsc_ctrl  unsigned,default = 0
#define VPP_SC_HOLD_LINES                          ((0x1a88  << 2) + 0xff000000)
//Bit   31:28     reserved
//Bit   27:24     osd4_path_hold_lines unsigned,default = 0 ,//osd4 proc path hold lines
//Bit   23:20     osd3_path_hold_lines unsigned,default = 0 ,//osd3 proc path hold lines
//Bit   19:16     osd2_path_hold_lines unsigned,default = 0 ,//osd2 proc path hold lines
//Bit   15:12     osd1_path_hold_lines unsigned,default = 0 ,//osd1 proc path hold lines
//Bit   11:8      vd3_path_hold_lines  unsigned,default = 0 ,//vd3  proc path hold lines
//Bit   7 :4      vd2_path_hold_lines  unsigned,default = 0 ,//vd2  proc path hold lines
//Bit   3 :0      vd1_path_hold_lines  unsigned,default = 0 ,//vd1  proc path hold lines
#define PATH_START_SEL                             ((0x1a8a  << 2) + 0xff000000)
//Bit   31:14     reserved
//Bit   13:12     osd3_path_start_sel   unsigned,default = 2 ,//0:use vpp0_go_field 1:use vpp1_go_field 2:use vpp2_go_field
//Bit   11:10     reserved
//Bit   9 :8      osd2_path_start_sel   unsigned,default = 1 ,//0:use vpp0_go_field 1:use vpp1_go_field 2:use vpp2_go_field
//Bit   7 :6      reserved
//Bit   5 :4      vd3_path_start_sel    unsigned,default = 2 ,//0:use vpp0_go_field 1:use vpp1_go_field 2:use vpp2_go_field
//Bit   3 :2      reserved
//Bit   1 :0      vd2_path_start_sel    unsigned,default = 1 ,//0:use vpp0_go_field 1:use vpp1_go_field 2:use vpp2_go_field
#define VIU1_FRM_CTRL                              ((0x1a8d  << 2) + 0xff000000)
//Bit   31:30 reserved
//Bit   29    viu1_frm_start       unsigned,default = 0   //pulse
//Bit   28:27 reserved
//Bit   26    viu1_chk_dout_sec    unsigned,default = 0
//Bit   25    reserved
//Bit   24    viu1_wrbak0_hsyn_en  unsigned,default = 0
//Bit   23:20 reserved
//Bit   19:17 viu1_frm_phs_mode    unsigned,default = 0
//Bit   16    viu1_frm_start_sel   unsigned,default = 0
//Bit   15:13 reserved
//Bit   12:0  viu1_hold_line_num   unsigned,default = 4
#define VIU2_FRM_CTRL                              ((0x1a8e  << 2) + 0xff000000)
//Bit   31:30 reserved
//Bit   29    viu2_frm_start       unsigned,default = 0   //pulse
//Bit   28:27 reserved
//Bit   26    viu1_chk_dout_sec    unsigned,default = 0
//Bit   25    reserved
//Bit   24    viu1_wrbak0_hsyn_en  unsigned,default = 0
//Bit   23:20 reserved
//Bit   19:17 viu2_frm_phs_mode    unsigned,default = 0
//Bit   16    viu2_frm_start_sel   unsigned,default = 0
//Bit   15:13 reserved
//Bit   12:0  viu2_hold_line_num   unsigned,default = 4
#define VPU_SEC_INT_STAT                           ((0x1a8f  << 2) + 0xff000000)
//Bit   31:3  reserved
//Bit   2     vpp0_sec_int_stat  unsigned,default = 0 ,// vppx in sec error int status
//Bit   1     vpp1_sec_int_stat  unsigned,default = 0 ,// vppx in sec error int status
//Bit   0     vpp2_sec_int_stat  unsigned,default = 0 ,// vppx in sec error int status
//------------------------------------------------------------------------------
// OSD1_MATRIX registers 0x90 -0x9f
//------------------------------------------------------------------------------
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
#define VIU_OSD1_MATRIX_CTRL                       ((0x1a90  << 2) + 0xff000000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VIU_OSD1_MATRIX_COEF00_01                  ((0x1a91  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VIU_OSD1_MATRIX_COEF02_10                  ((0x1a92  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VIU_OSD1_MATRIX_COEF11_12                  ((0x1a93  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VIU_OSD1_MATRIX_COEF20_21                  ((0x1a94  << 2) + 0xff000000)
//Bit 31:30    mat_clmod
//Bit 18:16    mat_convrs
//Bit 12:0     mat_coef42
#define VIU_OSD1_MATRIX_COLMOD_COEF42              ((0x1a95  << 2) + 0xff000000)
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VIU_OSD1_MATRIX_OFFSET0_1                  ((0x1a96  << 2) + 0xff000000)
//Bit 10:0  offset2
#define VIU_OSD1_MATRIX_OFFSET2                    ((0x1a97  << 2) + 0xff000000)
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VIU_OSD1_MATRIX_PRE_OFFSET0_1              ((0x1a98  << 2) + 0xff000000)
//Bit 10:0  pre_offset2
#define VIU_OSD1_MATRIX_PRE_OFFSET2                ((0x1a99  << 2) + 0xff000000)
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VIU_OSD1_MATRIX_PROBE_COLOR                ((0x1a9a  << 2) + 0xff000000)
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VIU_OSD1_MATRIX_HL_COLOR                   ((0x1a9b  << 2) + 0xff000000)
//28:16 probe x, postion
//12:0  probe y, position
#define VIU_OSD1_MATRIX_PROBE_POS                  ((0x1a9c  << 2) + 0xff000000)
//Bit 28:16 coef22
//Bit 12:0  coef30
#define VIU_OSD1_MATRIX_COEF22_30                  ((0x1a9d  << 2) + 0xff000000)
//Bit 28:16 coef31
//Bit 12:0  coef32
#define VIU_OSD1_MATRIX_COEF31_32                  ((0x1a9e  << 2) + 0xff000000)
//Bit 28:16 coef40
//Bit 12:0  coef41
#define VIU_OSD1_MATRIX_COEF40_41                  ((0x1a9f  << 2) + 0xff000000)
#define VIU_OSD1_OETF_3X3_OFST_0                   ((0x1aa0  << 2) + 0xff000000)
#define VIU_OSD1_OETF_3X3_OFST_1                   ((0x1aa1  << 2) + 0xff000000)
//`define OSD_BLENDO_H_START_END          8'ha9       //'d1919
//OSD blending output horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
//`define OSD_BLENDO_V_START_END          8'haa      //'d1079
//OSD blending output vertical start and end
//Bit 28:16 start
//Bit 12:0 end
//`define OSD_BLEND_GEN_CTRL0                 8'hab  //'h2000
//Bit 31:23 const_out_alpha
//Bit 22:14 const_op_alpha
//Bit 13 if true, OSD2 foreground otherwise OSD1 foreground
//Bit 12  OSD BLENDing enable
//Bit 9:8 alpha_op_sel 00: output alpha use osd1_alpha, 01: use osd2_alpha, else use const_out_alpha
//Bit 5:4 color_op_sel 00: use osd1_alpha, 01: use osd2_alpha, else use const_op_alpha
//Bit 1  OSD2 enable
//Bit 0  OSD1 enable
//`define OSD_BLEND_GEN_CTRL1                 8'hac    //'h80000
//Bit 31    osd1_alpha_premult, if true, osd1 alpha is premultiply
//Bit 30    osd2_alpha_premult, if true, osd2 alpha is premultiply
//Bit 23:16 osd blending hold lines
//Bit 13:0  osd blending h_size
//`define OSD_BLEND_DUMMY_DATA                8'had   //0
//Bit 29:20   Y/R
//Bit 19:10   CB/G
//Bit 9:0     Cr/B
//`define OSD_BLEND_CURRENT_XY                8'hae    //read only
//Bit 28:16 current_x
//Bit 12:0 current_y
//Bit 7,  highlight_en
//Bit 6   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 5:4  probe_sel, 00: select matrix 0, 01: select matrix 1,  otherwise select nothing
//Bit 3:2, matrix coef idx selection, 00: select mat0, 01: select mat1, otherwise slect nothing
//Bit 1   mat1 conversion matrix enable
//Bit 0   mat0 conversion matrix enable
//`define VIU_OSD2_MATRIX_CTRL     8'hb0
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VIU_OSD2_MATRIX_COEF00_01                  ((0x1ab1  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VIU_OSD2_MATRIX_COEF02_10                  ((0x1ab2  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VIU_OSD2_MATRIX_COEF11_12                  ((0x1ab3  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VIU_OSD2_MATRIX_COEF20_21                  ((0x1ab4  << 2) + 0xff000000)
#define VIU_OSD2_MATRIX_COEF22                     ((0x1ab5  << 2) + 0xff000000)
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VIU_OSD2_MATRIX_OFFSET0_1                  ((0x1ab6  << 2) + 0xff000000)
//Bit 10:0  offset2
#define VIU_OSD2_MATRIX_OFFSET2                    ((0x1ab7  << 2) + 0xff000000)
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VIU_OSD2_MATRIX_PRE_OFFSET0_1              ((0x1ab8  << 2) + 0xff000000)
//Bit 10:0  pre_offset2
#define VIU_OSD2_MATRIX_PRE_OFFSET2                ((0x1ab9  << 2) + 0xff000000)
//Read only
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VIU_OSD2_MATRIX_PROBE_COLOR                ((0x1aba  << 2) + 0xff000000)
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VIU_OSD2_MATRIX_HL_COLOR                   ((0x1abb  << 2) + 0xff000000)
//28:16 probe x, postion
//12:0  probe y, position
#define VIU_OSD2_MATRIX_PROBE_POS                  ((0x1abc  << 2) + 0xff000000)
#define VIU_OSD2_MALI_UNPACK_CTRL                  ((0x1abd  << 2) + 0xff000000)
//`define VIU_OSD2_MATRIX_HL_COLOR          8'hbe
//`define VIU_OSD2_MATRIX_PROBE_POS         8'hbf
//     //todo add comment
//     `define LDIM_STTS_GCLK_CTRL0                    8'hc0
//     `define LDIM_STTS_CTRL0                         8'hc1
//     `define LDIM_STTS_WIDTHM1_HEIGHTM1              8'hc2
//     `define LDIM_STTS_MATRIX_COEF00_01              8'hc3
//     `define LDIM_STTS_MATRIX_COEF02_10              8'hc4
#define LDIM_STTS_MATRIX_COEF11_12                 ((0x1ac5  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_COEF20_21                 ((0x1ac6  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_COEF22                    ((0x1ac7  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_OFFSET0_1                 ((0x1ac8  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_OFFSET2                   ((0x1ac9  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_PRE_OFFSET0_1             ((0x1aca  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_PRE_OFFSET2               ((0x1acb  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_HL_COLOR                  ((0x1acc  << 2) + 0xff000000)
#define LDIM_STTS_MATRIX_PROBE_POS                 ((0x1acd  << 2) + 0xff000000)
//
//     //read only
#define LDIM_STTS_MATRIX_PROBE_COLOR               ((0x1ace  << 2) + 0xff000000)
//
//     //Bit 31, local dimming statistic enable
//     //Bit 29, 1: output region histogram 16bit 0:output region histogram 20bit
//     //Bit 28, eol enable
//     //Bit 27:25, vertical line overlap number for max finding
//     //Bit 24:22, horizontal pixel overlap number, 0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
//     //Bit 20, 1,2,1 low pass filter enable before max/hist statistic
//     //Bit 19:16, region H/V position index, refer to VDIN_LDIM_STTS_HIST_SET_REGION
//     //Bit 15:14, 1: region read index auto increase per block read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//     //			 2: region read index auto increase per read finished to VDIN_LDIM_STTS_HIST_READ_REGION
//     //			 0/3: disable read index self increase
//     //Bit 13:8, region read sub index, which mux the hist & max-finding result to cbus port, refer to LDIM_STTS_HIST_READ_REGION
//     //Bit 6:0, region read index
#define LDIM_STTS_HIST_REGION_IDX                  ((0x1ad0  << 2) + 0xff000000)
//Bit 28:0, if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h0: read/write hvstart0
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h1: read/write hend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h2: read/write vend01
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h3: read/write hend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h4: read/write vend23
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h5: read/write hend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h6: read/write vend45
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'd7: read/write hend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h8: read/write vend67
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'h9: read/write hend89
//			if VDIN_LDIM_STTS_HIST_REGION_IDX[19:16] == 5'ha: read/write vend89
//     //hvstart0, Bit 28:16 row0 vstart, Bit 12:0 col0 hstart
//     //hend01, Bit 28:16 col1 hend, Bit 12:0 col0 hend
//     //vend01, Bit 28:16 row1 vend, Bit 12:0 row0 vend
//     //hend23, Bit 28:16 col3 hend, Bit 12:0 col2 hend
//     //vend23, Bit 28:16 row3 vend, Bit 12:0 row2 vend
//     //hend45, Bit 28:16 col5 hend, Bit 12:0 col4 hend
//     //vend45, Bit 28:16 row5 vend, Bit 12:0 row4 vend
//     //hend67, Bit 28:16 col7 hend, Bit 12:0 col6 hend
//     //vend67, Bit 28:16 row7 vend, Bit 12:0 row6 vend
//     //hend89, Bit 28:16 col9 hend, Bit 12:0 col8 hend
//     //vend89, Bit 28:16 row9 vend, Bit 12:0 row8 vend
#define LDIM_STTS_HIST_SET_REGION                  ((0x1ad1  << 2) + 0xff000000)
//
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, comp0_hist0}, {max_comp1, comp0_hist1}, {max_comp0, comp0_hist2},
//     //										   comp0_hist3 ... comp2_hist16
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 1, that is output hist with 16bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 0, that is output 16hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//     //										   comp0_hist3 ... comp2_hist16
//     //if LDIM_STTS_HIST_REGION_IDX[29] == 0, that is output hist with 20bit data.
//     //if LDIM_STTS_HIST_REGION_IDX[21] == 1, that is output 32hist bins in comp 0.
//     //output sequence as rd_sub_idx from 0~47: {max_comp2, max_comp1, max_comp0}, comp0_hist0, comp0_hist1, comp0_hist2
//     //										   comp0_hist3 ...comp0_hist31 ... comp1_hist16
//
#define LDIM_STTS_HIST_READ_REGION                 ((0x1ad2  << 2) + 0xff000000)
#define LDIM_STTS_HIST_START_RD_REGION             ((0x1ad3  << 2) + 0xff000000)
#define LDIM_STTS_PCTL_TH                          ((0x1aaf  << 2) + 0xff000000)
//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
//Bit 17:6  for clock gating
//Bit 5:4   pscale_mode ch2
//Bit 3:2   pscale_mode ch1
//Bit 1:0   pscale_mode ch0
#define VIU_OSD1_EOTF_CTL                          ((0x1ad4  << 2) + 0xff000000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VIU_OSD1_EOTF_COEF00_01                    ((0x1ad5  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VIU_OSD1_EOTF_COEF02_10                    ((0x1ad6  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VIU_OSD1_EOTF_COEF11_12                    ((0x1ad7  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VIU_OSD1_EOTF_COEF20_21                    ((0x1ad8  << 2) + 0xff000000)
//Bit 28:16 coef22
//Bit   2:0 coef_rs
#define VIU_OSD1_EOTF_COEF22_RS                    ((0x1ad9  << 2) + 0xff000000)
#define VIU_OSD1_EOTF_LUT_ADDR_PORT                ((0x1ada  << 2) + 0xff000000)
#define VIU_OSD1_EOTF_LUT_DATA_PORT                ((0x1adb  << 2) + 0xff000000)
//Bit 31:29  for OETF ch0~ch2
//Bit 21:12  for clock gating
//Bit 11:8   for oetf_scl_ch2
//Bit  7:4   for oetf_scl_ch1
//Bit  3:0   for oetf_scl_ch0
#define VIU_OSD1_OETF_CTL                          ((0x1adc  << 2) + 0xff000000)
#define VIU_OSD1_OETF_LUT_ADDR_PORT                ((0x1add  << 2) + 0xff000000)
#define VIU_OSD1_OETF_LUT_DATA_PORT                ((0x1ade  << 2) + 0xff000000)
//can use 8'hdf 8'hcf
#define VIU_OSD1_DIMM_CTRL                         ((0x1adf  << 2) + 0xff000000)
#define VIU_OSD2_DIMM_CTRL                         ((0x1acf  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// OSD1_MATRIX registers 0xe0 -0xfe
//------------------------------------------------------------------------------
//the segment of afbc dec is 8'he0-8'hfe
//`define AFBC_DEC_OFFSET   8'he0
//
// Reading file:  ./afbc_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define AFBC_ENABLE                                ((0x1ae0  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:23,    reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22,       reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21,       reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20,       reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19,       reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16,    soft_rst          unsigned  , default = 4
//Bit   15:14,    reserved
//Bit   13:12,    ddr_blk_size      unsigned  , default = 1
//Bit   11:9,     cmd_blk_size      unsigned  , default = 3
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:2,      reserved
//Bit   1,        head_len_sel      unsigned  , default = 1
//Bit   0,        dec_frm_start     unsigned  , default = 0
#define AFBC_MODE                                  ((0x1ae1  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num     uns, default = 4 ,
//Bit   15:14,    burst_len         uns, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8,     compbits_yuv      uns, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define AFBC_SIZE_IN                               ((0x1ae2  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
#define AFBC_DEC_DEF_COLOR                         ((0x1ae3  << 2) + 0xff000000)
//Bit   31:30,   reserved
//Bit   29:20,   def_color_y        uns, default = 255, afbc dec y default setting value
//Bit   19:10,   def_color_u        uns, default = 128, afbc dec u default setting value
//Bit    9: 0,   def_color_v        uns, default = 128, afbc dec v default setting value
#define AFBC_CONV_CTRL                             ((0x1ae4  << 2) + 0xff000000)
//Bit   31:14,   reserved
//Bit   13:12,   fmt_mode            uns, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
#define AFBC_LBUF_DEPTH                            ((0x1ae5  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
//Bit   15:12,   reserved
//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
#define AFBC_HEAD_BADDR                            ((0x1ae6  << 2) + 0xff000000)
//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
#define AFBC_BODY_BADDR                            ((0x1ae7  << 2) + 0xff000000)
//Bit   31:0,   mif_data_baddr      uns, default = 32'h00010000;
#define AFBC_SIZE_OUT                              ((0x1ae8  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
#define AFBC_OUT_YSCOPE                            ((0x1ae9  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
#define AFBC_STAT                                  ((0x1aea  << 2) + 0xff000000)
//Bit   31:0,   ro_dbg_top_info      uns,
#define AFBC_VD_CFMT_CTRL                          ((0x1aeb  << 2) + 0xff000000)
//Bit 31    cfmt_gclk_bit_dis      uns, default = 0    ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      uns, default = 0    ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         uns, default = 0    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               uns, default = 0    ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en uns, default = 0    ; //if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     uns, default = 0    ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   uns, default = 0    ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     uns, default = 0    ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    uns, default = 0    ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        uns, default = 0    ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       uns, default = 0    ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               uns, default = 0    ; //vertical formatter enable
#define AFBC_VD_CFMT_W                             ((0x1aec  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                uns, default = 0    ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                uns, default = 0    ;vertical formatter width
#define AFBC_MIF_HOR_SCOPE                         ((0x1aed  << 2) + 0xff000000)
//Bit   31:26,   reserved
//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10,   reserved
//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
#define AFBC_MIF_VER_SCOPE                         ((0x1aee  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12,   reserved
//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
#define AFBC_PIXEL_HOR_SCOPE                       ((0x1aef  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
#define AFBC_PIXEL_VER_SCOPE                       ((0x1af0  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
#define AFBC_VD_CFMT_H                             ((0x1af1  << 2) + 0xff000000)
//Bit 31:13,    reserved
//Bit 12:0      cfmt_h  uns, default = 142  ; //vertical formatter height
#define AFBCDEC_IQUANT_ENABLE                      ((0x1af2  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1  //unsigned, RW, enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0  //unsigned, RW, enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst               //signed ,  RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define AFBCDEC_IQUANT_LUT_1                       ((0x1af3  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDEC_IQUANT_LUT_2                       ((0x1af4  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDEC_IQUANT_LUT_3                       ((0x1af5  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDEC_IQUANT_LUT_4                       ((0x1af6  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./afbc_dec_regs.h
//
//
// Closing file:  ./vregs_clk2.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC0A_VCBUS_BASE = 0x1b
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define ENCP_VFIFO2VD_CTL                          ((0x1b58  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCP_VFIFO2VD_PIXEL_START                  ((0x1b59  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCP_VFIFO2VD_PIXEL_END                    ((0x1b5a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCP_VFIFO2VD_LINE_TOP_START               ((0x1b5b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCP_VFIFO2VD_LINE_TOP_END                 ((0x1b5c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCP_VFIFO2VD_LINE_BOT_START               ((0x1b5d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCP_VFIFO2VD_LINE_BOT_END                 ((0x1b5e  << 2) + 0xff000000)
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define VENC_SYNC_ROUTE                            ((0x1b60  << 2) + 0xff000000)
		//			 encoder address space is assigned
		//			 to the video encoder interface status
		//			 register
#define VENC_VIDEO_EXSRC                           ((0x1b61  << 2) + 0xff000000)
#define VENC_DVI_SETTING                           ((0x1b62  << 2) + 0xff000000)
#define VENC_C656_CTRL                             ((0x1b63  << 2) + 0xff000000)
#define VENC_UPSAMPLE_CTRL0                        ((0x1b64  << 2) + 0xff000000)
#define VENC_UPSAMPLE_CTRL1                        ((0x1b65  << 2) + 0xff000000)
#define VENC_UPSAMPLE_CTRL2                        ((0x1b66  << 2) + 0xff000000)
// Invert control for tcon output
// bit[15:14] -- vsync, hsync,
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define TCON_INVERT_CTL                            ((0x1b67  << 2) + 0xff000000)
#define VENC_VIDEO_PROG_MODE                       ((0x1b68  << 2) + 0xff000000)
//---- Venc pixel/line info
#define VENC_ENCI_LINE                             ((0x1b69  << 2) + 0xff000000)
#define VENC_ENCI_PIXEL                            ((0x1b6a  << 2) + 0xff000000)
#define VENC_ENCP_LINE                             ((0x1b6b  << 2) + 0xff000000)
#define VENC_ENCP_PIXEL                            ((0x1b6c  << 2) + 0xff000000)
//---- Status
#define VENC_STATA                                 ((0x1b6d  << 2) + 0xff000000)
//---- Interrupt setting
#define VENC_INTCTRL                               ((0x1b6e  << 2) + 0xff000000)
#define VENC_INTFLAG                               ((0x1b6f  << 2) + 0xff000000)
//--------- Video test configuration
#define VENC_VIDEO_TST_EN                          ((0x1b70  << 2) + 0xff000000)
#define VENC_VIDEO_TST_MDSEL                       ((0x1b71  << 2) + 0xff000000)
#define VENC_VIDEO_TST_Y                           ((0x1b72  << 2) + 0xff000000)
#define VENC_VIDEO_TST_CB                          ((0x1b73  << 2) + 0xff000000)
#define VENC_VIDEO_TST_CR                          ((0x1b74  << 2) + 0xff000000)
#define VENC_VIDEO_TST_CLRBAR_STRT                 ((0x1b75  << 2) + 0xff000000)
#define VENC_VIDEO_TST_CLRBAR_WIDTH                ((0x1b76  << 2) + 0xff000000)
#define VENC_VIDEO_TST_VDCNT_STSET                 ((0x1b77  << 2) + 0xff000000)
//----- Video dac setting
#define VENC_VDAC_DACSEL0                          ((0x1b78  << 2) + 0xff000000)
#define VENC_VDAC_DACSEL1                          ((0x1b79  << 2) + 0xff000000)
#define VENC_VDAC_DACSEL2                          ((0x1b7a  << 2) + 0xff000000)
#define VENC_VDAC_DACSEL3                          ((0x1b7b  << 2) + 0xff000000)
#define VENC_VDAC_DACSEL4                          ((0x1b7c  << 2) + 0xff000000)
#define VENC_VDAC_DACSEL5                          ((0x1b7d  << 2) + 0xff000000)
#define VENC_VDAC_SETTING                          ((0x1b7e  << 2) + 0xff000000)
#define VENC_VDAC_TST_VAL                          ((0x1b7f  << 2) + 0xff000000)
#define VENC_VDAC_DAC0_GAINCTRL                    ((0x1bf0  << 2) + 0xff000000)
#define VENC_VDAC_DAC0_OFFSET                      ((0x1bf1  << 2) + 0xff000000)
#define VENC_VDAC_DAC1_GAINCTRL                    ((0x1bf2  << 2) + 0xff000000)
#define VENC_VDAC_DAC1_OFFSET                      ((0x1bf3  << 2) + 0xff000000)
#define VENC_VDAC_DAC2_GAINCTRL                    ((0x1bf4  << 2) + 0xff000000)
#define VENC_VDAC_DAC2_OFFSET                      ((0x1bf5  << 2) + 0xff000000)
#define VENC_VDAC_DAC3_GAINCTRL                    ((0x1bf6  << 2) + 0xff000000)
#define VENC_VDAC_DAC3_OFFSET                      ((0x1bf7  << 2) + 0xff000000)
#define VENC_VDAC_DAC4_GAINCTRL                    ((0x1bf8  << 2) + 0xff000000)
#define VENC_VDAC_DAC4_OFFSET                      ((0x1bf9  << 2) + 0xff000000)
#define VENC_VDAC_DAC5_GAINCTRL                    ((0x1bfa  << 2) + 0xff000000)
#define VENC_VDAC_DAC5_OFFSET                      ((0x1bfb  << 2) + 0xff000000)
#define VENC_VDAC_FIFO_CTRL                        ((0x1bfc  << 2) + 0xff000000)
#define ENCL_TCON_INVERT_CTL                       ((0x1bfd  << 2) + 0xff000000)
//
// Closing file:  ./venc_regs.h
//
//
// Reading file:  ./enc480p_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define ENCP_VIDEO_EN                              ((0x1b80  << 2) + 0xff000000)
#define ENCP_VIDEO_SYNC_MODE                       ((0x1b81  << 2) + 0xff000000)
#define ENCP_MACV_EN                               ((0x1b82  << 2) + 0xff000000)
#define ENCP_VIDEO_Y_SCL                           ((0x1b83  << 2) + 0xff000000)
#define ENCP_VIDEO_PB_SCL                          ((0x1b84  << 2) + 0xff000000)
#define ENCP_VIDEO_PR_SCL                          ((0x1b85  << 2) + 0xff000000)
#define ENCP_VIDEO_SYNC_SCL                        ((0x1b86  << 2) + 0xff000000)
#define ENCP_VIDEO_MACV_SCL                        ((0x1b87  << 2) + 0xff000000)
#define ENCP_VIDEO_Y_OFFST                         ((0x1b88  << 2) + 0xff000000)
#define ENCP_VIDEO_PB_OFFST                        ((0x1b89  << 2) + 0xff000000)
#define ENCP_VIDEO_PR_OFFST                        ((0x1b8a  << 2) + 0xff000000)
#define ENCP_VIDEO_SYNC_OFFST                      ((0x1b8b  << 2) + 0xff000000)
#define ENCP_VIDEO_MACV_OFFST                      ((0x1b8c  << 2) + 0xff000000)
//----- Video mode
#define ENCP_VIDEO_MODE                            ((0x1b8d  << 2) + 0xff000000)
#define ENCP_VIDEO_MODE_ADV                        ((0x1b8e  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCP_DBG_PX_RST                            ((0x1b90  << 2) + 0xff000000)
#define ENCP_DBG_LN_RST                            ((0x1b91  << 2) + 0xff000000)
#define ENCP_DBG_PX_INT                            ((0x1b92  << 2) + 0xff000000)
#define ENCP_DBG_LN_INT                            ((0x1b93  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCP_VIDEO_YFP1_HTIME                      ((0x1b94  << 2) + 0xff000000)
#define ENCP_VIDEO_YFP2_HTIME                      ((0x1b95  << 2) + 0xff000000)
#define ENCP_VIDEO_YC_DLY                          ((0x1b96  << 2) + 0xff000000)
#define ENCP_VIDEO_MAX_PXCNT                       ((0x1b97  << 2) + 0xff000000)
#define ENCP_VIDEO_HSPULS_BEGIN                    ((0x1b98  << 2) + 0xff000000)
#define ENCP_VIDEO_HSPULS_END                      ((0x1b99  << 2) + 0xff000000)
#define ENCP_VIDEO_HSPULS_SWITCH                   ((0x1b9a  << 2) + 0xff000000)
#define ENCP_VIDEO_VSPULS_BEGIN                    ((0x1b9b  << 2) + 0xff000000)
#define ENCP_VIDEO_VSPULS_END                      ((0x1b9c  << 2) + 0xff000000)
#define ENCP_VIDEO_VSPULS_BLINE                    ((0x1b9d  << 2) + 0xff000000)
#define ENCP_VIDEO_VSPULS_ELINE                    ((0x1b9e  << 2) + 0xff000000)
#define ENCP_VIDEO_EQPULS_BEGIN                    ((0x1b9f  << 2) + 0xff000000)
#define ENCP_VIDEO_EQPULS_END                      ((0x1ba0  << 2) + 0xff000000)
#define ENCP_VIDEO_EQPULS_BLINE                    ((0x1ba1  << 2) + 0xff000000)
#define ENCP_VIDEO_EQPULS_ELINE                    ((0x1ba2  << 2) + 0xff000000)
#define ENCP_VIDEO_HAVON_END                       ((0x1ba3  << 2) + 0xff000000)
#define ENCP_VIDEO_HAVON_BEGIN                     ((0x1ba4  << 2) + 0xff000000)
#define ENCP_VIDEO_VAVON_ELINE                     ((0x1baf  << 2) + 0xff000000)
#define ENCP_VIDEO_VAVON_BLINE                     ((0x1ba6  << 2) + 0xff000000)
#define ENCP_VIDEO_HSO_BEGIN                       ((0x1ba7  << 2) + 0xff000000)
#define ENCP_VIDEO_HSO_END                         ((0x1ba8  << 2) + 0xff000000)
#define ENCP_VIDEO_VSO_BEGIN                       ((0x1ba9  << 2) + 0xff000000)
#define ENCP_VIDEO_VSO_END                         ((0x1baa  << 2) + 0xff000000)
#define ENCP_VIDEO_VSO_BLINE                       ((0x1bab  << 2) + 0xff000000)
#define ENCP_VIDEO_VSO_ELINE                       ((0x1bac  << 2) + 0xff000000)
#define ENCP_VIDEO_SYNC_WAVE_CURVE                 ((0x1bad  << 2) + 0xff000000)
#define ENCP_VIDEO_MAX_LNCNT                       ((0x1bae  << 2) + 0xff000000)
#define ENCP_VIDEO_SY_VAL                          ((0x1bb0  << 2) + 0xff000000)
#define ENCP_VIDEO_SY2_VAL                         ((0x1bb1  << 2) + 0xff000000)
#define ENCP_VIDEO_BLANKY_VAL                      ((0x1bb2  << 2) + 0xff000000)
#define ENCP_VIDEO_BLANKPB_VAL                     ((0x1bb3  << 2) + 0xff000000)
#define ENCP_VIDEO_BLANKPR_VAL                     ((0x1bb4  << 2) + 0xff000000)
#define ENCP_VIDEO_HOFFST                          ((0x1bb5  << 2) + 0xff000000)
#define ENCP_VIDEO_VOFFST                          ((0x1bb6  << 2) + 0xff000000)
#define ENCP_VIDEO_RGB_CTRL                        ((0x1bb7  << 2) + 0xff000000)
#define ENCP_VIDEO_FILT_CTRL                       ((0x1bb8  << 2) + 0xff000000)
#define ENCP_VIDEO_OFLD_VPEQ_OFST                  ((0x1bb9  << 2) + 0xff000000)
#define ENCP_VIDEO_OFLD_VOAV_OFST                  ((0x1bba  << 2) + 0xff000000)
#define ENCP_VIDEO_MATRIX_CB                       ((0x1bbb  << 2) + 0xff000000)
#define ENCP_VIDEO_MATRIX_CR                       ((0x1bbc  << 2) + 0xff000000)
#define ENCP_VIDEO_RGBIN_CTRL                      ((0x1bbd  << 2) + 0xff000000)
//------------------Macrovision advanced setting
#define ENCP_MACV_BLANKY_VAL                       ((0x1bc0  << 2) + 0xff000000)
#define ENCP_MACV_MAXY_VAL                         ((0x1bc1  << 2) + 0xff000000)
#define ENCP_MACV_1ST_PSSYNC_STRT                  ((0x1bc2  << 2) + 0xff000000)
#define ENCP_MACV_PSSYNC_STRT                      ((0x1bc3  << 2) + 0xff000000)
#define ENCP_MACV_AGC_STRT                         ((0x1bc4  << 2) + 0xff000000)
#define ENCP_MACV_AGC_END                          ((0x1bc5  << 2) + 0xff000000)
#define ENCP_MACV_WAVE_END                         ((0x1bc6  << 2) + 0xff000000)
#define ENCP_MACV_STRTLINE                         ((0x1bc7  << 2) + 0xff000000)
#define ENCP_MACV_ENDLINE                          ((0x1bc8  << 2) + 0xff000000)
#define ENCP_MACV_TS_CNT_MAX_L                     ((0x1bc9  << 2) + 0xff000000)
#define ENCP_MACV_TS_CNT_MAX_H                     ((0x1bca  << 2) + 0xff000000)
#define ENCP_MACV_TIME_DOWN                        ((0x1bcb  << 2) + 0xff000000)
#define ENCP_MACV_TIME_LO                          ((0x1bcc  << 2) + 0xff000000)
#define ENCP_MACV_TIME_UP                          ((0x1bcd  << 2) + 0xff000000)
#define ENCP_MACV_TIME_RST                         ((0x1bce  << 2) + 0xff000000)
//---------------- VBI control -------------------
#define ENCP_VBI_CTRL                              ((0x1bd0  << 2) + 0xff000000)
#define ENCP_VBI_SETTING                           ((0x1bd1  << 2) + 0xff000000)
#define ENCP_VBI_BEGIN                             ((0x1bd2  << 2) + 0xff000000)
#define ENCP_VBI_WIDTH                             ((0x1bd3  << 2) + 0xff000000)
#define ENCP_VBI_HVAL                              ((0x1bd4  << 2) + 0xff000000)
#define ENCP_VBI_DATA0                             ((0x1bd5  << 2) + 0xff000000)
#define ENCP_VBI_DATA1                             ((0x1bd6  << 2) + 0xff000000)
//----------------C656 OUT Control------------- Grant
#define C656_HS_ST                                 ((0x1be0  << 2) + 0xff000000)
#define C656_HS_ED                                 ((0x1be1  << 2) + 0xff000000)
#define C656_VS_LNST_E                             ((0x1be2  << 2) + 0xff000000)
#define C656_VS_LNST_O                             ((0x1be3  << 2) + 0xff000000)
#define C656_VS_LNED_E                             ((0x1be4  << 2) + 0xff000000)
#define C656_VS_LNED_O                             ((0x1be5  << 2) + 0xff000000)
#define C656_FS_LNST                               ((0x1be6  << 2) + 0xff000000)
#define C656_FS_LNED                               ((0x1be7  << 2) + 0xff000000)
#define ENCP_VRR_CTRL                              ((0x1be8  << 2) + 0xff000000)
#define ENCP_VRR_ADJ_LMT                           ((0x1be9  << 2) + 0xff000000)
#define ENCP_VRR_CTRL1                             ((0x1bea  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./enc480p_regs.h
//
//
// Reading file:  ./enci_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define ENCI_VIDEO_MODE                            ((0x1b00  << 2) + 0xff000000)
#define ENCI_VIDEO_MODE_ADV                        ((0x1b01  << 2) + 0xff000000)
#define ENCI_VIDEO_FSC_ADJ                         ((0x1b02  << 2) + 0xff000000)
#define ENCI_VIDEO_BRIGHT                          ((0x1b03  << 2) + 0xff000000)
#define ENCI_VIDEO_CONT                            ((0x1b04  << 2) + 0xff000000)
#define ENCI_VIDEO_SAT                             ((0x1b05  << 2) + 0xff000000)
#define ENCI_VIDEO_HUE                             ((0x1b06  << 2) + 0xff000000)
#define ENCI_VIDEO_SCH                             ((0x1b07  << 2) + 0xff000000)
#define ENCI_SYNC_MODE                             ((0x1b08  << 2) + 0xff000000)
#define ENCI_SYNC_CTRL                             ((0x1b09  << 2) + 0xff000000)
#define ENCI_SYNC_HSO_BEGIN                        ((0x1b0a  << 2) + 0xff000000)
#define ENCI_SYNC_HSO_END                          ((0x1b0b  << 2) + 0xff000000)
#define ENCI_SYNC_VSO_EVN                          ((0x1b0c  << 2) + 0xff000000)
#define ENCI_SYNC_VSO_ODD                          ((0x1b0d  << 2) + 0xff000000)
#define ENCI_SYNC_VSO_EVNLN                        ((0x1b0e  << 2) + 0xff000000)
#define ENCI_SYNC_VSO_ODDLN                        ((0x1b0f  << 2) + 0xff000000)
#define ENCI_SYNC_HOFFST                           ((0x1b10  << 2) + 0xff000000)
#define ENCI_SYNC_VOFFST                           ((0x1b11  << 2) + 0xff000000)
#define ENCI_SYNC_ADJ                              ((0x1b12  << 2) + 0xff000000)
#define ENCI_RGB_SETTING                           ((0x1b13  << 2) + 0xff000000)
//`define	ENCI_CMPN_MATRIX_CB		8'h14
//`define	ENCI_CMPN_MATRIX_CR		8'h15
#define ENCI_DE_H_BEGIN                            ((0x1b16  << 2) + 0xff000000)
#define ENCI_DE_H_END                              ((0x1b17  << 2) + 0xff000000)
#define ENCI_DE_V_BEGIN_EVEN                       ((0x1b18  << 2) + 0xff000000)
#define ENCI_DE_V_END_EVEN                         ((0x1b19  << 2) + 0xff000000)
#define ENCI_DE_V_BEGIN_ODD                        ((0x1b1a  << 2) + 0xff000000)
#define ENCI_DE_V_END_ODD                          ((0x1b1b  << 2) + 0xff000000)
#define ENCI_VBI_SETTING                           ((0x1b20  << 2) + 0xff000000)
#define ENCI_VBI_CCDT_EVN                          ((0x1b21  << 2) + 0xff000000)
#define ENCI_VBI_CCDT_ODD                          ((0x1b22  << 2) + 0xff000000)
#define ENCI_VBI_CC525_LN                          ((0x1b23  << 2) + 0xff000000)
#define ENCI_VBI_CC625_LN                          ((0x1b24  << 2) + 0xff000000)
#define ENCI_VBI_WSSDT                             ((0x1b25  << 2) + 0xff000000)
#define ENCI_VBI_WSS_LN                            ((0x1b26  << 2) + 0xff000000)
#define ENCI_VBI_CGMSDT_L                          ((0x1b27  << 2) + 0xff000000)
#define ENCI_VBI_CGMSDT_H                          ((0x1b28  << 2) + 0xff000000)
#define ENCI_VBI_CGMS_LN                           ((0x1b29  << 2) + 0xff000000)
#define ENCI_VBI_TTX_HTIME                         ((0x1b2a  << 2) + 0xff000000)
#define ENCI_VBI_TTX_LN                            ((0x1b2b  << 2) + 0xff000000)
#define ENCI_VBI_TTXDT0                            ((0x1b2c  << 2) + 0xff000000)
#define ENCI_VBI_TTXDT1                            ((0x1b2d  << 2) + 0xff000000)
#define ENCI_VBI_TTXDT2                            ((0x1b2e  << 2) + 0xff000000)
#define ENCI_VBI_TTXDT3                            ((0x1b2f  << 2) + 0xff000000)
#define ENCI_MACV_N0                               ((0x1b30  << 2) + 0xff000000)
#define ENCI_MACV_N1                               ((0x1b31  << 2) + 0xff000000)
#define ENCI_MACV_N2                               ((0x1b32  << 2) + 0xff000000)
#define ENCI_MACV_N3                               ((0x1b33  << 2) + 0xff000000)
#define ENCI_MACV_N4                               ((0x1b34  << 2) + 0xff000000)
#define ENCI_MACV_N5                               ((0x1b35  << 2) + 0xff000000)
#define ENCI_MACV_N6                               ((0x1b36  << 2) + 0xff000000)
#define ENCI_MACV_N7                               ((0x1b37  << 2) + 0xff000000)
#define ENCI_MACV_N8                               ((0x1b38  << 2) + 0xff000000)
#define ENCI_MACV_N9                               ((0x1b39  << 2) + 0xff000000)
#define ENCI_MACV_N10                              ((0x1b3a  << 2) + 0xff000000)
#define ENCI_MACV_N11                              ((0x1b3b  << 2) + 0xff000000)
#define ENCI_MACV_N12                              ((0x1b3c  << 2) + 0xff000000)
#define ENCI_MACV_N13                              ((0x1b3d  << 2) + 0xff000000)
#define ENCI_MACV_N14                              ((0x1b3e  << 2) + 0xff000000)
#define ENCI_MACV_N15                              ((0x1b3f  << 2) + 0xff000000)
#define ENCI_MACV_N16                              ((0x1b40  << 2) + 0xff000000)
#define ENCI_MACV_N17                              ((0x1b41  << 2) + 0xff000000)
#define ENCI_MACV_N18                              ((0x1b42  << 2) + 0xff000000)
#define ENCI_MACV_N19                              ((0x1b43  << 2) + 0xff000000)
#define ENCI_MACV_N20                              ((0x1b44  << 2) + 0xff000000)
#define ENCI_MACV_N21                              ((0x1b45  << 2) + 0xff000000)
#define ENCI_MACV_N22                              ((0x1b46  << 2) + 0xff000000)
//`define	ENCI_MACV_P_AGC			8'h47
#define ENCI_DBG_PX_RST                            ((0x1b48  << 2) + 0xff000000)
#define ENCI_DBG_FLDLN_RST                         ((0x1b49  << 2) + 0xff000000)
#define ENCI_DBG_PX_INT                            ((0x1b4a  << 2) + 0xff000000)
#define ENCI_DBG_FLDLN_INT                         ((0x1b4b  << 2) + 0xff000000)
#define ENCI_DBG_MAXPX                             ((0x1b4c  << 2) + 0xff000000)
#define ENCI_DBG_MAXLN                             ((0x1b4d  << 2) + 0xff000000)
#define ENCI_MACV_MAX_AMP                          ((0x1b50  << 2) + 0xff000000)
#define ENCI_MACV_PULSE_LO                         ((0x1b51  << 2) + 0xff000000)
#define ENCI_MACV_PULSE_HI                         ((0x1b52  << 2) + 0xff000000)
#define ENCI_MACV_BKP_MAX                          ((0x1b53  << 2) + 0xff000000)
#define ENCI_CFILT_CTRL                            ((0x1b54  << 2) + 0xff000000)
#define ENCI_CFILT7                                ((0x1b55  << 2) + 0xff000000)
#define ENCI_YC_DELAY                              ((0x1b56  << 2) + 0xff000000)
#define ENCI_VIDEO_EN                              ((0x1b57  << 2) + 0xff000000)
//
// Closing file:  ./enci_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC0B_VCBUS_BASE = 0x1c
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef)
//===========================================================================
// Program video control signals from ENCI core to DVI/HDMI interface
#define ENCI_DVI_HSO_BEGIN                         ((0x1c00  << 2) + 0xff000000)
#define ENCI_DVI_HSO_END                           ((0x1c01  << 2) + 0xff000000)
#define ENCI_DVI_VSO_BLINE_EVN                     ((0x1c02  << 2) + 0xff000000)
#define ENCI_DVI_VSO_BLINE_ODD                     ((0x1c03  << 2) + 0xff000000)
#define ENCI_DVI_VSO_ELINE_EVN                     ((0x1c04  << 2) + 0xff000000)
#define ENCI_DVI_VSO_ELINE_ODD                     ((0x1c05  << 2) + 0xff000000)
#define ENCI_DVI_VSO_BEGIN_EVN                     ((0x1c06  << 2) + 0xff000000)
#define ENCI_DVI_VSO_BEGIN_ODD                     ((0x1c07  << 2) + 0xff000000)
#define ENCI_DVI_VSO_END_EVN                       ((0x1c08  << 2) + 0xff000000)
#define ENCI_DVI_VSO_END_ODD                       ((0x1c09  << 2) + 0xff000000)
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define ENCI_CFILT_CTRL2                           ((0x1c0a  << 2) + 0xff000000)
#define ENCI_DACSEL_0                              ((0x1c0b  << 2) + 0xff000000)
#define ENCI_DACSEL_1                              ((0x1c0c  << 2) + 0xff000000)
#define ENCP_DACSEL_0                              ((0x1c0d  << 2) + 0xff000000)
#define ENCP_DACSEL_1                              ((0x1c0e  << 2) + 0xff000000)
#define ENCP_MAX_LINE_SWITCH_POINT                 ((0x1c0f  << 2) + 0xff000000)
#define ENCI_TST_EN                                ((0x1c10  << 2) + 0xff000000)
#define ENCI_TST_MDSEL                             ((0x1c11  << 2) + 0xff000000)
#define ENCI_TST_Y                                 ((0x1c12  << 2) + 0xff000000)
#define ENCI_TST_CB                                ((0x1c13  << 2) + 0xff000000)
#define ENCI_TST_CR                                ((0x1c14  << 2) + 0xff000000)
#define ENCI_TST_CLRBAR_STRT                       ((0x1c15  << 2) + 0xff000000)
#define ENCI_TST_CLRBAR_WIDTH                      ((0x1c16  << 2) + 0xff000000)
#define ENCI_TST_VDCNT_STSET                       ((0x1c17  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCI_VFIFO2VD_CTL                          ((0x1c18  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCI_VFIFO2VD_PIXEL_START                  ((0x1c19  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCI_VFIFO2VD_PIXEL_END                    ((0x1c1a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCI_VFIFO2VD_LINE_TOP_START               ((0x1c1b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCI_VFIFO2VD_LINE_TOP_END                 ((0x1c1c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCI_VFIFO2VD_LINE_BOT_START               ((0x1c1d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCI_VFIFO2VD_LINE_BOT_END                 ((0x1c1e  << 2) + 0xff000000)
#define ENCI_VFIFO2VD_CTL2                         ((0x1c1f  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCT_VFIFO2VD_CTL                          ((0x1c20  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCT_VFIFO2VD_PIXEL_START                  ((0x1c21  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCT_VFIFO2VD_PIXEL_END                    ((0x1c22  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCT_VFIFO2VD_LINE_TOP_START               ((0x1c23  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCT_VFIFO2VD_LINE_TOP_END                 ((0x1c24  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCT_VFIFO2VD_LINE_BOT_START               ((0x1c25  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCT_VFIFO2VD_LINE_BOT_END                 ((0x1c26  << 2) + 0xff000000)
#define ENCT_VFIFO2VD_CTL2                         ((0x1c27  << 2) + 0xff000000)
#define ENCT_TST_EN                                ((0x1c28  << 2) + 0xff000000)
#define ENCT_TST_MDSEL                             ((0x1c29  << 2) + 0xff000000)
#define ENCT_TST_Y                                 ((0x1c2a  << 2) + 0xff000000)
#define ENCT_TST_CB                                ((0x1c2b  << 2) + 0xff000000)
#define ENCT_TST_CR                                ((0x1c2c  << 2) + 0xff000000)
#define ENCT_TST_CLRBAR_STRT                       ((0x1c2d  << 2) + 0xff000000)
#define ENCT_TST_CLRBAR_WIDTH                      ((0x1c2e  << 2) + 0xff000000)
#define ENCT_TST_VDCNT_STSET                       ((0x1c2f  << 2) + 0xff000000)
// Program video control signals from ENCP core to DVI/HDMI interface
#define ENCP_DVI_HSO_BEGIN                         ((0x1c30  << 2) + 0xff000000)
#define ENCP_DVI_HSO_END                           ((0x1c31  << 2) + 0xff000000)
#define ENCP_DVI_VSO_BLINE_EVN                     ((0x1c32  << 2) + 0xff000000)
#define ENCP_DVI_VSO_BLINE_ODD                     ((0x1c33  << 2) + 0xff000000)
#define ENCP_DVI_VSO_ELINE_EVN                     ((0x1c34  << 2) + 0xff000000)
#define ENCP_DVI_VSO_ELINE_ODD                     ((0x1c35  << 2) + 0xff000000)
#define ENCP_DVI_VSO_BEGIN_EVN                     ((0x1c36  << 2) + 0xff000000)
#define ENCP_DVI_VSO_BEGIN_ODD                     ((0x1c37  << 2) + 0xff000000)
#define ENCP_DVI_VSO_END_EVN                       ((0x1c38  << 2) + 0xff000000)
#define ENCP_DVI_VSO_END_ODD                       ((0x1c39  << 2) + 0xff000000)
#define ENCP_DE_H_BEGIN                            ((0x1c3a  << 2) + 0xff000000)
#define ENCP_DE_H_END                              ((0x1c3b  << 2) + 0xff000000)
#define ENCP_DE_V_BEGIN_EVEN                       ((0x1c3c  << 2) + 0xff000000)
#define ENCP_DE_V_END_EVEN                         ((0x1c3d  << 2) + 0xff000000)
#define ENCP_DE_V_BEGIN_ODD                        ((0x1c3e  << 2) + 0xff000000)
#define ENCP_DE_V_END_ODD                          ((0x1c3f  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCI_SYNC_LINE_LENGTH                      ((0x1c40  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCI_SYNC_PIXEL_EN                         ((0x1c41  << 2) + 0xff000000)
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCI_SYNC_TO_LINE_EN                       ((0x1c42  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCI_SYNC_TO_PIXEL                         ((0x1c43  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCP_SYNC_LINE_LENGTH                      ((0x1c44  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCP_SYNC_PIXEL_EN                         ((0x1c45  << 2) + 0xff000000)
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCP_SYNC_TO_LINE_EN                       ((0x1c46  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCP_SYNC_TO_PIXEL                         ((0x1c47  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCT_SYNC_LINE_LENGTH                      ((0x1c48  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCT_SYNC_PIXEL_EN                         ((0x1c49  << 2) + 0xff000000)
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCT_SYNC_TO_LINE_EN                       ((0x1c4a  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCT_SYNC_TO_PIXEL                         ((0x1c4b  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCL_SYNC_LINE_LENGTH                      ((0x1c4c  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCL_SYNC_PIXEL_EN                         ((0x1c4d  << 2) + 0xff000000)
// Bit 15 - enci_sync_enable
// Bit 14 - encp_sync_enable
// Bit 13 - enct_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCL_SYNC_TO_LINE_EN                       ((0x1c4e  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCL_SYNC_TO_PIXEL                         ((0x1c4f  << 2) + 0xff000000)
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define ENCP_VFIFO2VD_CTL2                         ((0x1c50  << 2) + 0xff000000)
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define VENC_DVI_SETTING_MORE                      ((0x1c51  << 2) + 0xff000000)
#define VENC_VDAC_DAC4_FILT_CTRL0                  ((0x1c54  << 2) + 0xff000000)
#define VENC_VDAC_DAC4_FILT_CTRL1                  ((0x1c55  << 2) + 0xff000000)
#define VENC_VDAC_DAC5_FILT_CTRL0                  ((0x1c56  << 2) + 0xff000000)
#define VENC_VDAC_DAC5_FILT_CTRL1                  ((0x1c57  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC_VDAC_DAC0_FILT_CTRL0                  ((0x1c58  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC_VDAC_DAC0_FILT_CTRL1                  ((0x1c59  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC_VDAC_DAC1_FILT_CTRL0                  ((0x1c5a  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC_VDAC_DAC1_FILT_CTRL1                  ((0x1c5b  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC_VDAC_DAC2_FILT_CTRL0                  ((0x1c5c  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC_VDAC_DAC2_FILT_CTRL1                  ((0x1c5d  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC_VDAC_DAC3_FILT_CTRL0                  ((0x1c5e  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC_VDAC_DAC3_FILT_CTRL1                  ((0x1c5f  << 2) + 0xff000000)
//===========================================================================
// ENCT registers
#define ENCT_VIDEO_EN                              ((0x1c60  << 2) + 0xff000000)
#define ENCT_VIDEO_Y_SCL                           ((0x1c61  << 2) + 0xff000000)
#define ENCT_VIDEO_PB_SCL                          ((0x1c62  << 2) + 0xff000000)
#define ENCT_VIDEO_PR_SCL                          ((0x1c63  << 2) + 0xff000000)
#define ENCT_VIDEO_Y_OFFST                         ((0x1c64  << 2) + 0xff000000)
#define ENCT_VIDEO_PB_OFFST                        ((0x1c65  << 2) + 0xff000000)
#define ENCT_VIDEO_PR_OFFST                        ((0x1c66  << 2) + 0xff000000)
//----- Video mode
#define ENCT_VIDEO_MODE                            ((0x1c67  << 2) + 0xff000000)
#define ENCT_VIDEO_MODE_ADV                        ((0x1c68  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCT_DBG_PX_RST                            ((0x1c69  << 2) + 0xff000000)
#define ENCT_DBG_LN_RST                            ((0x1c6a  << 2) + 0xff000000)
#define ENCT_DBG_PX_INT                            ((0x1c6b  << 2) + 0xff000000)
#define ENCT_DBG_LN_INT                            ((0x1c6c  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCT_VIDEO_YFP1_HTIME                      ((0x1c6d  << 2) + 0xff000000)
#define ENCT_VIDEO_YFP2_HTIME                      ((0x1c6e  << 2) + 0xff000000)
#define ENCT_VIDEO_YC_DLY                          ((0x1c6f  << 2) + 0xff000000)
#define ENCT_VIDEO_MAX_PXCNT                       ((0x1c70  << 2) + 0xff000000)
#define ENCT_VIDEO_HAVON_END                       ((0x1c71  << 2) + 0xff000000)
#define ENCT_VIDEO_HAVON_BEGIN                     ((0x1c72  << 2) + 0xff000000)
#define ENCT_VIDEO_VAVON_ELINE                     ((0x1c73  << 2) + 0xff000000)
#define ENCT_VIDEO_VAVON_BLINE                     ((0x1c74  << 2) + 0xff000000)
#define ENCT_VIDEO_HSO_BEGIN                       ((0x1c75  << 2) + 0xff000000)
#define ENCT_VIDEO_HSO_END                         ((0x1c76  << 2) + 0xff000000)
#define ENCT_VIDEO_VSO_BEGIN                       ((0x1c77  << 2) + 0xff000000)
#define ENCT_VIDEO_VSO_END                         ((0x1c78  << 2) + 0xff000000)
#define ENCT_VIDEO_VSO_BLINE                       ((0x1c79  << 2) + 0xff000000)
#define ENCT_VIDEO_VSO_ELINE                       ((0x1c7a  << 2) + 0xff000000)
#define ENCT_VIDEO_MAX_LNCNT                       ((0x1c7b  << 2) + 0xff000000)
#define ENCT_VIDEO_BLANKY_VAL                      ((0x1c7c  << 2) + 0xff000000)
#define ENCT_VIDEO_BLANKPB_VAL                     ((0x1c7d  << 2) + 0xff000000)
#define ENCT_VIDEO_BLANKPR_VAL                     ((0x1c7e  << 2) + 0xff000000)
#define ENCT_VIDEO_HOFFST                          ((0x1c7f  << 2) + 0xff000000)
#define ENCT_VIDEO_VOFFST                          ((0x1c80  << 2) + 0xff000000)
#define ENCT_VIDEO_RGB_CTRL                        ((0x1c81  << 2) + 0xff000000)
#define ENCT_VIDEO_FILT_CTRL                       ((0x1c82  << 2) + 0xff000000)
#define ENCT_VIDEO_OFLD_VPEQ_OFST                  ((0x1c83  << 2) + 0xff000000)
#define ENCT_VIDEO_OFLD_VOAV_OFST                  ((0x1c84  << 2) + 0xff000000)
#define ENCT_VIDEO_MATRIX_CB                       ((0x1c85  << 2) + 0xff000000)
#define ENCT_VIDEO_MATRIX_CR                       ((0x1c86  << 2) + 0xff000000)
#define ENCT_VIDEO_RGBIN_CTRL                      ((0x1c87  << 2) + 0xff000000)
#define ENCT_MAX_LINE_SWITCH_POINT                 ((0x1c88  << 2) + 0xff000000)
#define ENCT_DACSEL_0                              ((0x1c89  << 2) + 0xff000000)
#define ENCT_DACSEL_1                              ((0x1c8a  << 2) + 0xff000000)
#define ENCT_INBUF_CNTL0                           ((0x1c8b  << 2) + 0xff000000)
#define ENCT_INBUF_CNTL1                           ((0x1c8c  << 2) + 0xff000000)
#define ENCT_INBUF_CNT                             ((0x1c8d  << 2) + 0xff000000)
#define ENCT_INBUF_HOLD_CNT                        ((0x1c8e  << 2) + 0xff000000)
#define ENCT_INBUF_FIX_PIX_NUM                     ((0x1c8f  << 2) + 0xff000000)
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCL_VFIFO2VD_CTL                          ((0x1c90  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCL_VFIFO2VD_PIXEL_START                  ((0x1c91  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCL_VFIFO2VD_PIXEL_END                    ((0x1c92  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCL_VFIFO2VD_LINE_TOP_START               ((0x1c93  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCL_VFIFO2VD_LINE_TOP_END                 ((0x1c94  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCL_VFIFO2VD_LINE_BOT_START               ((0x1c95  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCL_VFIFO2VD_LINE_BOT_END                 ((0x1c96  << 2) + 0xff000000)
#define ENCL_VFIFO2VD_CTL2                         ((0x1c97  << 2) + 0xff000000)
#define ENCL_TST_EN                                ((0x1c98  << 2) + 0xff000000)
#define ENCL_TST_MDSEL                             ((0x1c99  << 2) + 0xff000000)
#define ENCL_TST_Y                                 ((0x1c9a  << 2) + 0xff000000)
#define ENCL_TST_CB                                ((0x1c9b  << 2) + 0xff000000)
#define ENCL_TST_CR                                ((0x1c9c  << 2) + 0xff000000)
#define ENCL_TST_CLRBAR_STRT                       ((0x1c9d  << 2) + 0xff000000)
#define ENCL_TST_CLRBAR_WIDTH                      ((0x1c9e  << 2) + 0xff000000)
#define ENCL_TST_VDCNT_STSET                       ((0x1c9f  << 2) + 0xff000000)
//===========================================================================
// ENCL registers
#define ENCL_VIDEO_EN                              ((0x1ca0  << 2) + 0xff000000)
#define ENCL_VIDEO_Y_SCL                           ((0x1ca1  << 2) + 0xff000000)
#define ENCL_VIDEO_PB_SCL                          ((0x1ca2  << 2) + 0xff000000)
#define ENCL_VIDEO_PR_SCL                          ((0x1ca3  << 2) + 0xff000000)
#define ENCL_VIDEO_Y_OFFST                         ((0x1ca4  << 2) + 0xff000000)
#define ENCL_VIDEO_PB_OFFST                        ((0x1ca5  << 2) + 0xff000000)
#define ENCL_VIDEO_PR_OFFST                        ((0x1ca6  << 2) + 0xff000000)
//----- Video mode
#define ENCL_VIDEO_MODE                            ((0x1ca7  << 2) + 0xff000000)
#define ENCL_VIDEO_MODE_ADV                        ((0x1ca8  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCL_DBG_PX_RST                            ((0x1ca9  << 2) + 0xff000000)
#define ENCL_DBG_LN_RST                            ((0x1caa  << 2) + 0xff000000)
#define ENCL_DBG_PX_INT                            ((0x1cab  << 2) + 0xff000000)
#define ENCL_DBG_LN_INT                            ((0x1cac  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCL_VIDEO_YFP1_HTIME                      ((0x1cad  << 2) + 0xff000000)
#define ENCL_VIDEO_YFP2_HTIME                      ((0x1cae  << 2) + 0xff000000)
#define ENCL_VIDEO_YC_DLY                          ((0x1caf  << 2) + 0xff000000)
#define ENCL_VIDEO_MAX_PXCNT                       ((0x1cb0  << 2) + 0xff000000)
#define ENCL_VIDEO_HAVON_END                       ((0x1cb1  << 2) + 0xff000000)
#define ENCL_VIDEO_HAVON_BEGIN                     ((0x1cb2  << 2) + 0xff000000)
#define ENCL_VIDEO_VAVON_ELINE                     ((0x1cb3  << 2) + 0xff000000)
#define ENCL_VIDEO_VAVON_BLINE                     ((0x1cb4  << 2) + 0xff000000)
#define ENCL_VIDEO_HSO_BEGIN                       ((0x1cb5  << 2) + 0xff000000)
#define ENCL_VIDEO_HSO_END                         ((0x1cb6  << 2) + 0xff000000)
#define ENCL_VIDEO_VSO_BEGIN                       ((0x1cb7  << 2) + 0xff000000)
#define ENCL_VIDEO_VSO_END                         ((0x1cb8  << 2) + 0xff000000)
#define ENCL_VIDEO_VSO_BLINE                       ((0x1cb9  << 2) + 0xff000000)
#define ENCL_VIDEO_VSO_ELINE                       ((0x1cba  << 2) + 0xff000000)
#define ENCL_VIDEO_MAX_LNCNT                       ((0x1cbb  << 2) + 0xff000000)
#define ENCL_VIDEO_BLANKY_VAL                      ((0x1cbc  << 2) + 0xff000000)
#define ENCL_VIDEO_BLANKPB_VAL                     ((0x1cbd  << 2) + 0xff000000)
#define ENCL_VIDEO_BLANKPR_VAL                     ((0x1cbe  << 2) + 0xff000000)
#define ENCL_VIDEO_HOFFST                          ((0x1cbf  << 2) + 0xff000000)
#define ENCL_VIDEO_VOFFST                          ((0x1cc0  << 2) + 0xff000000)
#define ENCL_VIDEO_RGB_CTRL                        ((0x1cc1  << 2) + 0xff000000)
#define ENCL_VIDEO_FILT_CTRL                       ((0x1cc2  << 2) + 0xff000000)
#define ENCL_VIDEO_OFLD_VPEQ_OFST                  ((0x1cc3  << 2) + 0xff000000)
#define ENCL_VIDEO_OFLD_VOAV_OFST                  ((0x1cc4  << 2) + 0xff000000)
#define ENCL_VIDEO_MATRIX_CB                       ((0x1cc5  << 2) + 0xff000000)
#define ENCL_VIDEO_MATRIX_CR                       ((0x1cc6  << 2) + 0xff000000)
#define ENCL_VIDEO_RGBIN_CTRL                      ((0x1cc7  << 2) + 0xff000000)
#define ENCL_MAX_LINE_SWITCH_POINT                 ((0x1cc8  << 2) + 0xff000000)
#define ENCL_DACSEL_0                              ((0x1cc9  << 2) + 0xff000000)
#define ENCL_DACSEL_1                              ((0x1cca  << 2) + 0xff000000)
#define ENCT_VIDEO_H_PRE_DE_END                    ((0x1ccb  << 2) + 0xff000000)
#define ENCT_VIDEO_H_PRE_DE_BEGIN                  ((0x1ccc  << 2) + 0xff000000)
#define ENCT_VIDEO_V_PRE_DE_ELINE                  ((0x1ccd  << 2) + 0xff000000)
#define ENCT_VIDEO_V_PRE_DE_BLINE                  ((0x1cce  << 2) + 0xff000000)
#define ENCL_VIDEO_H_PRE_DE_END                    ((0x1ccf  << 2) + 0xff000000)
#define ENCL_VIDEO_H_PRE_DE_BEGIN                  ((0x1cd0  << 2) + 0xff000000)
#define ENCL_VIDEO_V_PRE_DE_ELINE                  ((0x1cd1  << 2) + 0xff000000)
#define ENCL_VIDEO_V_PRE_DE_BLINE                  ((0x1cd2  << 2) + 0xff000000)
#define ENCL_INBUF_CNTL0                           ((0x1cd3  << 2) + 0xff000000)
#define ENCL_INBUF_CNTL1                           ((0x1cd4  << 2) + 0xff000000)
#define ENCL_INBUF_CNT                             ((0x1cd5  << 2) + 0xff000000)
#define ENCL_INBUF_HOLD_CNT                        ((0x1cd6  << 2) + 0xff000000)
#define ENCL_INBUF_FIX_PIX_NUM                     ((0x1cd7  << 2) + 0xff000000)
#define VENC_VRR_CTRL                              ((0x1cd8  << 2) + 0xff000000)
//Bit   31    cfg_vsp_din      // W, pulse
//Bit   30    cfg_vrr_clr      // W, pulse
//Bit 31:28   ro_vrr_vsp_cnt   // R,
//Bit 27:24   ro_vrr_max_err   // R,
//Bit 23:8    cfg_vsp_dly_num  // R/W, unsigned, default 0
//Bit  7:4    cfg_vrr_frm_ths  // R/W, unsigned, default 0
//Bit  3:2    cfg_vrr_vsp_en   // R/W, unsigned, default 0
//Bit    1    cfg_vrr_mode     // R/W, unsigned, default 0
//Bit    0    cfg_vrr_vsp_sel  // R/W, unsigned, default 0
#define VENC_VRR_ADJ_LMT                           ((0x1cd9  << 2) + 0xff000000)
//Bit 31:16  cfg_vrr_min_vnum  //R/W, unsigned,
//Bit 15:0   cfg_vrr_max_vnum  //R/W, unsigned,
#define VENC_VRR_CTRL1                             ((0x1cda  << 2) + 0xff000000)
//Bit 4:1    cfg_vsp_rst_num   //R/W, unsigned, default 1
//Bit   0    cfg_vsp_cnt_rst   //W,pulse
#define VPU_VPU_PWM_V0                             ((0x1ce0  << 2) + 0xff000000)
#define VPU_VPU_PWM_V1                             ((0x1ce1  << 2) + 0xff000000)
#define VPU_VPU_PWM_V2                             ((0x1ce2  << 2) + 0xff000000)
#define VPU_VPU_PWM_V3                             ((0x1ce3  << 2) + 0xff000000)
#define VPU_VPU_PWM_H0                             ((0x1ce4  << 2) + 0xff000000)
#define VPU_VPU_PWM_H1                             ((0x1ce5  << 2) + 0xff000000)
#define VPU_VPU_PWM_H2                             ((0x1ce6  << 2) + 0xff000000)
#define VPU_VPU_PWM_H3                             ((0x1ce7  << 2) + 0xff000000)
#define VPU_VPU_3D_SYNC1                           ((0x1ce8  << 2) + 0xff000000)
#define VPU_VPU_3D_SYNC2                           ((0x1ce9  << 2) + 0xff000000)
#define VPU_VENC_DUMMY                             ((0x1cdf  << 2) + 0xff000000)
#define VPU_VENC_ERROR                             ((0x1cea  << 2) + 0xff000000)
#define VPU_VENCI_STAT                             ((0x1ceb  << 2) + 0xff000000)
#define VPU_VENCP_STAT                             ((0x1cec  << 2) + 0xff000000)
#define VPU_VENCL_STAT                             ((0x1ced  << 2) + 0xff000000)
#define VPU_VENC_DITH                              ((0x1cee  << 2) + 0xff000000)
#define VPU_VENC_CTRL                              ((0x1cef  << 2) + 0xff000000)
#define VPU_VENCL_DITH_CTRL                        ((0x1cf0  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_1                       ((0x1cf1  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_2                       ((0x1cf2  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_3                       ((0x1cf3  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_4                       ((0x1cf4  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_5                       ((0x1cf5  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_6                       ((0x1cf6  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_7                       ((0x1cf7  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_8                       ((0x1cf8  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_9                       ((0x1cf9  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_10                      ((0x1cfa  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_11                      ((0x1cfb  << 2) + 0xff000000)
#define VPU_VENCL_DITH_LUT_12                      ((0x1cfc  << 2) + 0xff000000)
//
// Closing file:  ./venc2_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpp_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_VCBUS_BASE = 0x1d
// -----------------------------------------------
//===========================================================================
// Video postprocessing Registers
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define VPP_DUMMY_DATA                             ((0x1d00  << 2) + 0xff000000)
//input line length used in VPP
#define VPP_LINE_IN_LENGTH                         ((0x1d01  << 2) + 0xff000000)
//input Picture height used in VPP
#define VPP_PIC_IN_HEIGHT                          ((0x1d02  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
//Bit 6:0 	coef index
#define VPP_SCALE_COEF_IDX                         ((0x1d03  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
#define VPP_SCALE_COEF                             ((0x1d04  << 2) + 0xff000000)
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		.
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region
//		.
//  ---------------------------
//  ---------------------------  <------ region1_startp
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP_VSC_REGION12_STARTP                    ((0x1d05  << 2) + 0xff000000)
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP_VSC_REGION34_STARTP                    ((0x1d06  << 2) + 0xff000000)
#define VPP_VSC_REGION4_ENDP                       ((0x1d07  << 2) + 0xff000000)
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define VPP_VSC_START_PHASE_STEP                   ((0x1d08  << 2) + 0xff000000)
//vertical scaler region0 phase slope, Bit24 signed bit
#define VPP_VSC_REGION0_PHASE_SLOPE                ((0x1d09  << 2) + 0xff000000)
//vertical scaler region1 phase slope, Bit24 signed bit
#define VPP_VSC_REGION1_PHASE_SLOPE                ((0x1d0a  << 2) + 0xff000000)
//vertical scaler region3 phase slope, Bit24 signed bit
#define VPP_VSC_REGION3_PHASE_SLOPE                ((0x1d0b  << 2) + 0xff000000)
//vertical scaler region4 phase slope, Bit24 signed bit
#define VPP_VSC_REGION4_PHASE_SLOPE                ((0x1d0c  << 2) + 0xff000000)
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field
#define VPP_VSC_PHASE_CTRL                         ((0x1d0d  << 2) + 0xff000000)
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define VPP_VSC_INI_PHASE                          ((0x1d0e  << 2) + 0xff000000)
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define VPP_HSC_REGION12_STARTP                    ((0x1d10  << 2) + 0xff000000)
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define VPP_HSC_REGION34_STARTP                    ((0x1d11  << 2) + 0xff000000)
#define VPP_HSC_REGION4_ENDP                       ((0x1d12  << 2) + 0xff000000)
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define VPP_HSC_START_PHASE_STEP                   ((0x1d13  << 2) + 0xff000000)
//horizontal scaler region0 phase slope, Bit24 signed bit
#define VPP_HSC_REGION0_PHASE_SLOPE                ((0x1d14  << 2) + 0xff000000)
//horizontal scaler region1 phase slope, Bit24 signed bit
#define VPP_HSC_REGION1_PHASE_SLOPE                ((0x1d15  << 2) + 0xff000000)
//horizontal scaler region3 phase slope, Bit24 signed bit
#define VPP_HSC_REGION3_PHASE_SLOPE                ((0x1d16  << 2) + 0xff000000)
//horizontal scaler region4 phase slope, Bit24 signed bit
#define VPP_HSC_REGION4_PHASE_SLOPE                ((0x1d17  << 2) + 0xff000000)
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0
//Bit 15:0    horizontal scaler top field initial phase0
#define VPP_HSC_PHASE_CTRL                         ((0x1d18  << 2) + 0xff000000)
// Bit 22 if true, divide VSC line length 2 as the HSC input length, otherwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
// Bit 2:0 vertical scaler bank length
#define VPP_SC_MISC                                ((0x1d19  << 2) + 0xff000000)
// preblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_PREBLEND_VD1_H_START_END               ((0x1d1a  << 2) + 0xff000000)
// preblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_PREBLEND_VD1_V_START_END               ((0x1d1b  << 2) + 0xff000000)
// postblend video1 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_POSTBLEND_VD1_H_START_END              ((0x1d1c  << 2) + 0xff000000)
// postblend video1 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_POSTBLEND_VD1_V_START_END              ((0x1d1d  << 2) + 0xff000000)
// preblend/postblend video2 horizontal start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_BLEND_VD2_H_START_END                  ((0x1d1e  << 2) + 0xff000000)
// preblend/postblend video2 vertical start and end
//Bit 28:16 start
//Bit 12:0 end
#define VPP_BLEND_VD2_V_START_END                  ((0x1d1f  << 2) + 0xff000000)
// preblend horizontal size
#define VPP_PREBLEND_H_SIZE                        ((0x1d20  << 2) + 0xff000000)
// postblend horizontal size
#define VPP_POSTBLEND_H_SIZE                       ((0x1d21  << 2) + 0xff000000)
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 15:8     preblend hold lines
//Bit 7:0      postblend hold lines
#define VPP_HOLD_LINES                             ((0x1d22  << 2) + 0xff000000)
//Bit 26   if true, automatic change post blend output to one color if field ==1
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define VPP_BLEND_ONECOLOR_CTRL                    ((0x1d23  << 2) + 0xff000000)
//Read Only, VPP preblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP_PREBLEND_CURRENT_XY                    ((0x1d24  << 2) + 0xff000000)
//Read Only, VPP postblend current_x, current_y
//Bit 28:16 current_x
//Bit 12:0 current_y
#define VPP_POSTBLEND_CURRENT_XY                   ((0x1d25  << 2) + 0xff000000)
// Bit 31  vd1_bgosd_exchange_en for preblend
// Bit 30  vd1_bgosd_exchange_en for postblend
// Bit 28   color management enable
// Bit 27,  if true, vd2 use viu2 output as the input, otherwise use normal vd2 from memory
// Bit 26:18, vd2 alpha
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, vd2 enable for preblend
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, vd2 enable for postblend
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultiply
// Bit 8,  if true, osd2 is alpha premultiply
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//			 the aync fifo will be reseted.
// Bit 1,
// Bit 0	if true, the output result of VPP is saturated
#define VPP_MISC                                   ((0x1d26  << 2) + 0xff000000)
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 12:0 ofifo size (actually only bit 10:1 is valid), always even number
#define VPP_OFIFO_SIZE                             ((0x1d27  << 2) + 0xff000000)
//Read only
//Bit 28:18 current scale out fifo counter
//Bit 17:13 current afifo counter
//Bit 12:0 current ofifo counter
#define VPP_FIFO_STATUS                            ((0x1d28  << 2) + 0xff000000)
// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable
// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable
#define VPP_SMOKE_CTRL                             ((0x1d29  << 2) + 0xff000000)
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//smoke3 for VD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define VPP_SMOKE1_VAL                             ((0x1d2a  << 2) + 0xff000000)
#define VPP_SMOKE2_VAL                             ((0x1d2b  << 2) + 0xff000000)
#define VPP_SMOKE3_VAL                             ((0x1d2c  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE1_H_START_END                     ((0x1d2d  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE1_V_START_END                     ((0x1d2e  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE2_H_START_END                     ((0x1d2f  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE2_V_START_END                     ((0x1d30  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE3_H_START_END                     ((0x1d31  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0 end
#define VPP_SMOKE3_V_START_END                     ((0x1d32  << 2) + 0xff000000)
//Bit 27:16 scale out fifo line length minus 1
//Bit 12:0 scale out fifo size (actually only bit 11:1 is valid, 11:1, max 1024), always even number
#define VPP_SCO_FIFO_CTRL                          ((0x1d33  << 2) + 0xff000000)
//for 3D quincunx sub-sampling and horizontal pixel by pixel 3D interleaving
//Bit 27:24, prehsc_mode, bit 3:2, prehsc odd line interp mode, bit 1:0, prehsc even line interp mode,
//           each 2bit, 00: pix0+pix1/2, average, 01: pix1, 10: pix0
//Bit 23 horizontal scaler double pixel mode
//Bit 22:21   horizontal scaler initial repeat pixel0 number1
//Bit 19:16   horizontal scaler initial receiving number1
//Bit 15:0    horizontal scaler top field initial phase1
#define VPP_HSC_PHASE_CTRL1                        ((0x1d34  << 2) + 0xff000000)
//for 3D quincunx sub-sampling
//31:24  prehsc pattern, each patten 1 bit, from lsb -> msb
//22:20  prehsc pattern start
//18:16 prehsc pattern end
//15:8 hsc pattern, each patten 1 bit, from lsb -> msb
//6:4  hsc pattern start
//2:0  hsc pattern end
#define VPP_HSC_INI_PAT_CTRL                       ((0x1d35  << 2) + 0xff000000)
#define VPP_SC_GCLK_CTRL                           ((0x1d36  << 2) + 0xff000000)
#define VPP_PREHSC_COEF                            ((0x1d37  << 2) + 0xff000000)
#define VPP_PRE_SCALE_CTRL                         ((0x1d38  << 2) + 0xff000000)
#define VPP_PREVSC_COEF                            ((0x1d39  << 2) + 0xff000000)
#define VPP_PREHSC_COEF1                           ((0x1d3a  << 2) + 0xff000000)
// 0x3b-0x3e
//
// Reading file:  ./vpp_pst_sta_regs.h
//
#define VPP_PST_STA_CTRL                           ((0x1d3b  << 2) + 0xff000000)
//Bit  31:5      reserved
//Bit  21:16     reg_pst_hist_rd_idx              .unsigned , default = 0, used for histgram read out
//Bit  15:12     reserved
//Bit  11:8      reg_gclk_ctrl                    .unsigned , default = 0,
//Bit  7:5       reserved
//Bit  4         reg_pst_hist_win_en              .unsigned , default = 0, enable for post histogram sta window mode
//Bit  3:2       reg_pst_hist_mode_sel            .unsigned , default = 0, component selection for hist sta: 0~2 for data[cmp]; 3: max(dat[0],dat[1], dat[2])
//Bit  1         reg_pst_hist_after_csc           .unsigned , default = 0, hist_sta after CSC or NOT. 0: before CSC (YUV); 1: after CSC (R/G/B)
//Bit  0         reg_pst_hist_sta_en              .unsigned , default = 0, enable for post histogram sta
#define VPP_PST_STA_WIN_X                          ((0x1d3c  << 2) + 0xff000000)
//Bit  31:30     reserved
//Bit  29:16     reg_pst_hist_win_xed      .unsigned , default = 1919
//Bit  15:14     reserved
//Bit  13: 0     reg_pst_hist_win_xst      .unsigned , default = 0
#define VPP_PST_STA_WIN_Y                          ((0x1d3d  << 2) + 0xff000000)
//Bit  31:30     reserved
//Bit  29:16     reg_pst_hist_win_yed      .unsigned , default = 1079
//Bit  15:14     reserved
//Bit  13: 0     reg_pst_hist_win_yst      .unsigned , default = 0
#define VPP_PST_STA_RO_HIST                        ((0x1d3e  << 2) + 0xff000000)
//Bit  23:0      ro_pst_hist_out           .unsigned ,RO,default = 0  ;
//
// Closing file:  ./vpp_pst_sta_regs.h
//
//Bit 3			minus black level enable for vadj2
//Bit 2			Video adjustment enable for vadj2
//Bit 1			minus black level enable for vadj1
//Bit 0			Video adjustment enable for vadj1
#define VPP_VADJ_CTRL                              ((0x1d40  << 2) + 0xff000000)
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
//`define VPP_VADJ1_Y                    8'h41      //'h00080
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
//`define VPP_VADJ1_MA_MB                8'h42   //26'h100_0000
//`define VPP_VADJ1_MC_MD                8'h43   //26'h000_0100
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
//`define VPP_VADJ2_Y                    8'h44      //'h00080
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
//`define VPP_VADJ2_MA_MB                8'h45   //26'h100_0000
//`define VPP_VADJ2_MC_MD                8'h46   //26'h000_0100
//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur
//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur
//Bit 0 horizontal sharpness enable
#define VPP_HSHARP_CTRL                            ((0x1d50  << 2) + 0xff000000)
//{1'b0,threshold} < diff
//Bit 26:16  luma threshold0
//Bit 10:0   luma threshold1
#define VPP_HSHARP_LUMA_THRESH01                   ((0x1d51  << 2) + 0xff000000)
//
//Bit 26:16  luma threshold2
//Bit 10:0   luma threshold3
#define VPP_HSHARP_LUMA_THRESH23                   ((0x1d52  << 2) + 0xff000000)
//Bit 26:16  chroma threshold0
//Bit 10:0   chroma threshold1
#define VPP_HSHARP_CHROMA_THRESH01                 ((0x1d53  << 2) + 0xff000000)
//Bit 26:16  chroma threshold2
//Bit 10:0   chroma threshold3
#define VPP_HSHARP_CHROMA_THRESH23                 ((0x1d54  << 2) + 0xff000000)
//Bit 23:16 luma gain2
//Bit 15:8  luma gain1
//Bit 7:0   luma gain0
#define VPP_HSHARP_LUMA_GAIN                       ((0x1d55  << 2) + 0xff000000)
//
//Bit 23:16 chroma gain2
//Bit 15:8  chroma gain1
//Bit 7:0   chroma gain0
#define VPP_HSHARP_CHROMA_GAIN                     ((0x1d56  << 2) + 0xff000000)
//Read only
//Bit 31, if it is true, it means this probe is valid in the last field/frame
//Bit 29:20 component 0
//Bit 19:10 component 1
//Bit 9:0 component 2
#define VPP_MATRIX_PROBE_COLOR                     ((0x1d5c  << 2) + 0xff000000)
#define VPP_MATRIX_PROBE_COLOR1                    ((0x1dd7  << 2) + 0xff000000)
//Bit 23:16 component 0
//Bit 15:8  component 1
//Bit 7:0 component 2
#define VPP_MATRIX_HL_COLOR                        ((0x1d5d  << 2) + 0xff000000)
//28:16 probe x, postion
//12:0  probe y, position
#define VPP_MATRIX_PROBE_POS                       ((0x1d5e  << 2) + 0xff000000)
//Bit 16,  highlight_en
//Bit 15   probe_post, if true, probe pixel data after matrix, otherwise probe pixel data before matrix
//Bit 14:12 probe_sel, 000: select post matrix, 001: select vd1 matrix, 010: select vd2 matrix
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    vd2 conversion matrix enable
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define VPP_MATRIX_CTRL                            ((0x1d5f  << 2) + 0xff000000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VPP_MATRIX_COEF00_01                       ((0x1d60  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VPP_MATRIX_COEF02_10                       ((0x1d61  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VPP_MATRIX_COEF11_12                       ((0x1d62  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VPP_MATRIX_COEF20_21                       ((0x1d63  << 2) + 0xff000000)
#define VPP_MATRIX_COEF22                          ((0x1d64  << 2) + 0xff000000)
//Bit 26:16 offset0
//Bit 10:0  offset1
#define VPP_MATRIX_OFFSET0_1                       ((0x1d65  << 2) + 0xff000000)
//Bit 10:0  offset2
#define VPP_MATRIX_OFFSET2                         ((0x1d66  << 2) + 0xff000000)
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define VPP_MATRIX_PRE_OFFSET0_1                   ((0x1d67  << 2) + 0xff000000)
//Bit 10:0  pre_offset2
#define VPP_MATRIX_PRE_OFFSET2                     ((0x1d68  << 2) + 0xff000000)
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define VPP_DUMMY_DATA1                            ((0x1d69  << 2) + 0xff000000)
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define VPP_GAINOFF_CTRL0                          ((0x1d6a  << 2) + 0xff000000)
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define VPP_GAINOFF_CTRL1                          ((0x1d6b  << 2) + 0xff000000)
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define VPP_GAINOFF_CTRL2                          ((0x1d6c  << 2) + 0xff000000)
//Bit 26:16, pre_offset0, signed data
//Bit 10:0, pre_offset1, signed data
#define VPP_GAINOFF_CTRL3                          ((0x1d6d  << 2) + 0xff000000)
//Bit 10:0, pre_offset2, signed data
#define VPP_GAINOFF_CTRL4                          ((0x1d6e  << 2) + 0xff000000)
#define VPP_GAINOFF_GCLK_CTRL                      ((0x1d6f  << 2) + 0xff000000)
//only two registers used in the color management, which are defined in the chroma_reg.h
//`define VPP_CHROMA_ADDR_PORT    8'h70
//`define VPP_CHROMA_DATA_PORT    8'h71
//
// Reading file:  ./chroma_reg.h
//
//**********************************************************************************
//* Copyright (c) 2008, AMLOGIC Inc.
//* All rights reserved
//**********************************************************************************
//* File :  chroma_reg.v
//* Author : Terrence Wang
//* Date : Dec 2008
//* Description :
//*
//**********************************************************************************
//* Modification History:
//* Date    Modified By         Reason
//**********************************************************************************
// synopsys translate_off
// synopsys translate_on
#define VPP_CHROMA_ADDR_PORT                       ((0x1d70  << 2) + 0xff000000)
#define VPP_CHROMA_DATA_PORT                       ((0x1d71  << 2) + 0xff000000)
//`define CHROMA_ADDR_PORT        8'h67
//`define CHROMA_DATA_PORT        8'h68

//  CHROMA_GAIN_REG_XX(00-07)
//  hue gain, sat gain function control
//  Bit 31      reg_sat_en                  enable sat adjustment in current region
//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
//                                          1'b1: increase  1'b0: decrease
//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
//                                          2'b01 central biggest   2'b00 one side biggest
//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
//                                          1'b1: left side biggest 1'b0 right side biggest
//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
//                                          0x00-0xff
//  Bit 15      reg_hue_en                  enable hue adjustment in current region
//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
//                                          1'b1: clockwise 1'b0: anti-clockwise
//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
//                                          1'b1: parabola curve    1'b0: non-symmetry curve
//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
//                                          1'b1: right side change more    1'b0: left side change more
//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
//                                          0x00-0x80, note: should be no bigger than 0x80

    #define CHROMA_GAIN_REG00       0x00


//  HUE_HUE_RANGE_REG_XX(00-07)
//  hue range select
//  Bit 31:24   no use now
//  Bit 23:16   reg_hue_shift_range         define the angle of target region
//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
//                                          must be greater or equal than 8'd8
//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
//                                          the symmetry region hue_shift_range = reg_hue_shift_range
//                                          in symmetry region, all the sat and hue setting will be same with original region,
//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
//                                          0x6000 means 360 degree
//                                          only region 0 and 1 can exceed 360 degrees.

    #define HUE_HUE_RANGE_REG00     0x01


//  HUE_RANGE_INV_REG_XX
//  Calculation should be follow
//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
//  HUE_RANGE_INV_REG_XX is to used to save divider

    #define HUE_RANGE_INV_REG00     0x02



//  for belowing each low, high, low_slope, high_slope group:
//            a_____________b
//            /             \               a = low  + 2^low_slope
//           /               \              b = high - 2^high_slope
//          /                 \             low_slope <= 7; high_slope <= 7
//         /                   \            b >= a
//  ______/_____________________\________
//       low                    high
//
//
//  HUE_LUM_RANGE_REG_XX(00-07)
//  luma range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
//                                          0x00-0xff

    #define HUE_LUM_RANGE_REG00     0x03

//  HUE_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
//                                          0x00-0xff

    #define HUE_SAT_RANGE_REG00     0x04

//  SAT_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
//                                          0x00-0xff

    #define SAT_SAT_RANGE_REG00     0x05


    #define CHROMA_GAIN_REG01       0x06
    #define HUE_HUE_RANGE_REG01     0x07
    #define HUE_RANGE_INV_REG01     0x08
    #define HUE_LUM_RANGE_REG01     0x09
    #define HUE_SAT_RANGE_REG01     0x0a
    #define SAT_SAT_RANGE_REG01     0x0b

    #define CHROMA_GAIN_REG02       0x0c
    #define HUE_HUE_RANGE_REG02     0x0d
    #define HUE_RANGE_INV_REG02     0x0e
    #define HUE_LUM_RANGE_REG02     0x0f
    #define HUE_SAT_RANGE_REG02     0x10
    #define SAT_SAT_RANGE_REG02     0x11


    #define CHROMA_GAIN_REG03       0x12
    #define HUE_HUE_RANGE_REG03     0x13
    #define HUE_RANGE_INV_REG03     0x14
    #define HUE_LUM_RANGE_REG03     0x15
    #define HUE_SAT_RANGE_REG03     0x16
    #define SAT_SAT_RANGE_REG03     0x17

    #define CHROMA_GAIN_REG04       0x18
    #define HUE_HUE_RANGE_REG04     0x19
    #define HUE_RANGE_INV_REG04     0x1a
    #define HUE_LUM_RANGE_REG04     0x1b
    #define HUE_SAT_RANGE_REG04     0x1c
    #define SAT_SAT_RANGE_REG04     0x1d

    #define CHROMA_GAIN_REG05       0x1e
    #define HUE_HUE_RANGE_REG05     0x1f
    #define HUE_RANGE_INV_REG05     0x20
    #define HUE_LUM_RANGE_REG05     0x21
    #define HUE_SAT_RANGE_REG05     0x22
    #define SAT_SAT_RANGE_REG05     0x23

    #define CHROMA_GAIN_REG06       0x24
    #define HUE_HUE_RANGE_REG06     0x25
    #define HUE_RANGE_INV_REG06     0x26
    #define HUE_LUM_RANGE_REG06     0x27
    #define HUE_SAT_RANGE_REG06     0x28
    #define SAT_SAT_RANGE_REG06     0x29

    #define CHROMA_GAIN_REG07       0x2a
    #define HUE_HUE_RANGE_REG07     0x2b
    #define HUE_RANGE_INV_REG07     0x2c
    #define HUE_LUM_RANGE_REG07     0x2d
    #define HUE_SAT_RANGE_REG07     0x2e
    #define SAT_SAT_RANGE_REG07     0x2f

//  REG_CHROMA_CONTROL
//  Bit 31      reg_chroma_en               enable color manage function
//                                          1'b1: enable    1'b0: bypass
//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
//  Bit 5       uv_adj_en                   final uv_adjust enable
//                                          1'b1: enable    1'b0: bypass
//  Bit 2       hue_en                      rgb to hue enable
//                                          1'b1: enable(default)   1'b0: bypass
//  Bit 1:0     csc_sel                     define input YUV with different color type
//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024
    #define REG_DEMO_CENTER_BAR     0x31   // default 32h'0
    #define REG_DEMO_HLIGHT_MODE    0x32   // default 32h'0
    #define REG_DEMO_OWR_DATA       0x33   // default 32h'0


////===========================================////
//// CM2 ADDR
////===========================================////

    #define SAT_BYYB_NODE_REG0          0x200   // default 32'h0
//Bit 31:24, sat_byyb_node3    the 4th node
//Bit 23:16, sat_byyb_node2    the 3th node
//Bit 15: 8, sat_byyb_node1    signed, the 2th node about saturation
//Bit  7: 0, sat_byyb_node0    signed, the 1th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"

	#define SAT_BYYB_NODE_REG1          0x201   // default 32'h0
//Bit 31:24, sat_byyb_node7     the 8th node
//Bit 23:16, sat_byyb_node6     the 7th node
//Bit 15: 8, sat_byyb_node5     signed, the 6th node about saturation
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation
//gain offset along y coordinate,the gain normalized to 128 as "1"

    #define SAT_BYYB_NODE_REG2          0x202   // default 32'h0
//Bit 31: 8, reserved
//Bit  7: 0, sat_byyb_node4     signed, the 5th node about saturation


    #define SAT_SRC_NODE_REG            0x203   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, sat_src_node1
//Bit 15:12, reserved
//Bit 11: 0, sat_src_node0     usigned, threshold of input saturation for  first and second piece

    #define CM_ENH_SFT_MODE_REG         0x204   // default 32'h0
//Bit 31: 9, reserved
//Bit  8: 6, hue_lsft_mode        hue offset adjustments scale
//Bit  5: 4, luma_lsft_mode       luma offset adjustments scale for reg_cm2_adj_luma_via_hue
//Bit  3: 2, sat_byy_rsft_mode    saturation gain adjustments scale for reg_cm2_adj_sat_via_y
//Bit  1: 0, sat_byhs_rsft_mode   saturation gain adjustments scale for reg_cm2_adj_sat_via_hs[:][:] 0:no scale up/down 1:dnscale by 2(-128,127)/2

    #define FRM_SIZE_REG                0x205   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, reg_frm_height       the frame height size
//Bit 15:13, reserved
//Bit 12: 0, reg_frm_width        the frame width size

    #define FITLER_CFG_REG              0x206   // default 32'h0
//Bit 31: 5, reserved
//Bit  4: 4, interleave_mod         horizontal interleave filter(zero-padding) for 3D considerations 0:using non-zero padding lpf 1:using zero-padding lpf
//Bit  3: 2, lpf_slt_uv           apply cm on lp portion or original video pixels options
//Bit  1: 0, lpf_slt_y            apply cm on lp portion or original video pixels options

    #define CM_GLOBAL_GAIN_REG          0x207   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, cm2_global_sat     global saturation gain for general color adjustments(0~4095 <=> 0~8),512 normalized to "1"
//Bit 15:12, reserved
//Bit 11: 0, cm2_global_hue     global hue offsets for general color adjustments(0~4095 <=> 0~360 degree)

    #define CM_ENH_CTL_REG              0x208   // default 32'h0
//Bit  31:7, reserved
//Bit     6, hue_adj_en        cm2 hue adjustments
//Bit     5, sat_adj_en        cm2 saturation adjustments
//Bit     4, luma_adj_en       enable signal for cm2 luma adjustments
//Bit     3, reserved
//Bit     2, cm2_filt_en       apply cm on lp portion enable
//Bit     1, cm2_en            cm2 enable signal
//Bit     0, cm1_en

    #define ROI_X_SCOPE_REG             0x209   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, roi_x_end      ending col index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, roi_x_beg      start col index of the region of interest

   #define ROI_Y_SCOPE_REG             0x20a   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, roi_y_end      ending row index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, roi_y_beg      start row index of the region of interest

    #define POI_XY_DIR_REG              0x20b   // default 32'h0
//Bit 31:29, reserved
//Bit 28:16, poi_y_dir      ending row index of the region of interest
//Bit 15:13, reserved
//Bit 12: 0, poi_x_dir      start row index of the region of interest

    #define COI_Y_SCOPE_REG             0x20c   // default 32'h0
//Bit 31:16, reserved
//Bit 15: 8, coi_y_end
//Bit  7: 0, coi_y_beg

    #define COI_H_SCOPE_REG             0x20d   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, coi_h_end
//Bit 15:12, reserved
//Bit 11: 0, coi_h_beg        lower bound of hue value for color of interest ,12 bits precision

    #define COI_S_SCOPE_REG             0x20e   // default 32'h0
//Bit 31:28, reserved
//Bit 27:16, coi_s_end
//Bit 15:12, reserved
//Bit 11: 0, coi_s_beg        lower bound of sat value for color of interest ,12 bits precision
    #define IFO_MODE_REG                0x20f   // default 32'h0
//Bit 31:8, reserved
//Bit  7:6, ifo_mode3
//Bit  5:4, ifo_mode2
//Bit  3:2, ifo_mode1
//Bit  1:0, ifo_mode0
    #define POI_RPL_MODE_REG            0x210   // default 32'h0
//Bit 31:4, reserved
//Bit  3:0, poi_rpl_mode          enhance mode control of pixels inside and outside region of interest bit[3:2]control roi
    #define DEMO_OWR_YHS_REG            0x211   // default 32'h0
//Bit 31: 0, demo_owr_yhs

    #define DEMO_POI_Y_REG              0x212   // default 32'h0
//Bit 31: 8, reserved
//Bit  7: 0, luma_data_poi_r       only get locked higher 8bits
    #define DEMO_POI_H_REG              0x213   // default 32'h0
//Bit 31: 12, reserved
//Bit 11: 0, hue_data_poi_r        only get locked higher 12bits
    #define DEMO_POI_S_REG              0x214   // default 32'h0
//Bit 31: 12, reserved
//Bit 11: 0, sat_data_poi_r         only get locked higher 12bits
    //`define LUMA_BYH_LIMT_REG           10'h215   // default 32'h0
    #define LUMA_ADJ_LIMT_REG           0x215   // default 32'h0
//Bit 31:24, reserved
//Bit 23:16, luma_lmt_satslp         slope to do the luma adjustment degrade
//Bit 15:12, reserved
//Bit 11:0, luma_lmt_satth           threshold to saturation
    #define SAT_ADJ_LIMT_REG            0x216   // default 32'h0
//Bit 31:24, reserved
//Bit 23:16, sat_lmt_satslp        slope to do the adjustment degrade
//Bit 15:12, reserved
//Bit 11:0, sat_lmt_satth          threshold to saturation
    #define HUE_ADJ_LIMT_REG            0x217   // default 32'h0
//Bit 31: 24, reserved
//Bit 23: 16, hue_lmt_satslp        slope to do the adjustment degrade
//Bit 15: 12, reserved
//Bit 11: 0,  hue_lmt_satth          threshold to saturation
    #define UVHS_OFST_REG               0x218   // default 32'h0
//Bit 31: 24, hs2uv_v_ofst
//Bit 23: 16, hs2uv_u_ofst
//Bit 15: 8,  uv2hs_v_ofst
//Bit  7: 0,  uv2hs_u_ofst
    #define HUE_CFG_PARA_REG            0x219   // default 32'h0
//Bit 31: 17, reserved
//Bit     16, hue_protect_en
//Bit 15: 13, cm2_hue_byhs_mode
//Bit     12, cm2_hue_div_mode
//Bit 11: 0, cm2_before_hue_ofst
    #define DEMO_SPLT_CFG_REG           0x21a   // default 32'h0
//Bit 31: 22, reserved
//Bit 21: 20, demo_split_mode
//Bit 19: 16, demo_split_width        slope to do the adjustment degrade
//Bit 15: 13, reserved
//Bit 12: 0,  demo_split_post           threshold to saturation
    #define DEMO_SPLT_YHS_REG           0x21b   // default 32'h0
//Bit 31: 0,  demo_splt_yhs             threshold to saturation

    #define XVYCC_YSCP_REG              0x21c   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_y_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_y_min
    #define XVYCC_USCP_REG              0x21d   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_u_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_u_min
    #define XVYCC_VSCP_REG              0x21e   // default 32'h0
//Bit 31: 28, reserved
//Bit 27: 16, xvycc_v_max
//Bit 15: 12, reserved
//Bit 11: 0, xvycc_v_min
    #define LUMA_ADJ0_REG               0x21f   // default 32'h0
//Bit 21: 12, reg_cm_luma_blacklevel
//Bit 11: 0,  reg_cm_luma_contrast
    #define LUMA_ADJ1_REG               0x220   // default 32'h0

    #define STA_WIN_XYXY0_REG           0x221   // default 32'h0
    #define STA_WIN_XYXY1_REG           0x222   // default 32'h0
    #define STA_CFG_REG                 0x223   // default 32'h0
    #define STA_SAT_HIST0_REG           0x224   // default 32'h0
    #define STA_SAT_HIST1_REG           0x225   // default 32'h0
    #define RO_CM_HUE_HIST_BIN0         0x226   // default 32'h0
    #define RO_CM_HUE_HIST_BIN1         0x227   // default 32'h0
    #define RO_CM_HUE_HIST_BIN2         0x228   // default 32'h0
    #define RO_CM_HUE_HIST_BIN3         0x229   // default 32'h0
    #define RO_CM_HUE_HIST_BIN4         0x22a   // default 32'h0
    #define RO_CM_HUE_HIST_BIN5         0x22b   // default 32'h0
    #define RO_CM_HUE_HIST_BIN6         0x22c   // default 32'h0
    #define RO_CM_HUE_HIST_BIN7         0x22d   // default 32'h0
    #define RO_CM_HUE_HIST_BIN8         0x22e   // default 32'h0
    #define RO_CM_HUE_HIST_BIN9         0x22f   // default 32'h0
    #define RO_CM_HUE_HIST_BIN10        0x230   // default 32'h0
    #define RO_CM_HUE_HIST_BIN11        0x231   // default 32'h0
    #define RO_CM_HUE_HIST_BIN12        0x232   // default 32'h0
    #define RO_CM_HUE_HIST_BIN13        0x233   // default 32'h0
    #define RO_CM_HUE_HIST_BIN14        0x234   // default 32'h0
    #define RO_CM_HUE_HIST_BIN15        0x235   // default 32'h0
    #define RO_CM_HUE_HIST_BIN16        0x236   // default 32'h0
    #define RO_CM_HUE_HIST_BIN17        0x237   // default 32'h0
    #define RO_CM_HUE_HIST_BIN18        0x238   // default 32'h0
    #define RO_CM_HUE_HIST_BIN19        0x239   // default 32'h0
    #define RO_CM_HUE_HIST_BIN20        0x23a   // default 32'h0
    #define RO_CM_HUE_HIST_BIN21        0x23b   // default 32'h0
    #define RO_CM_HUE_HIST_BIN22        0x23c   // default 32'h0
    #define RO_CM_HUE_HIST_BIN23        0x23d   // default 32'h0
    #define RO_CM_HUE_HIST_BIN24        0x23e   // default 32'h0
    #define RO_CM_HUE_HIST_BIN25        0x23f   // default 32'h0
    #define RO_CM_HUE_HIST_BIN26        0x240   // default 32'h0
    #define RO_CM_HUE_HIST_BIN27        0x241   // default 32'h0
    #define RO_CM_HUE_HIST_BIN28        0x242   // default 32'h0
    #define RO_CM_HUE_HIST_BIN29        0x243   // default 32'h0
    #define RO_CM_HUE_HIST_BIN30        0x244   // default 32'h0
    #define RO_CM_HUE_HIST_BIN31        0x245   // default 32'h0
    #define RO_CM_SAT_HIST_BIN0         0x246   // default 32'h0
    #define RO_CM_SAT_HIST_BIN1         0x247   // default 32'h0
    #define RO_CM_SAT_HIST_BIN2         0x248   // default 32'h0
    #define RO_CM_SAT_HIST_BIN3         0x249   // default 32'h0
    #define RO_CM_SAT_HIST_BIN4         0x24a   // default 32'h0
    #define RO_CM_SAT_HIST_BIN5         0x24b   // default 32'h0
    #define RO_CM_SAT_HIST_BIN6         0x24c   // default 32'h0
    #define RO_CM_SAT_HIST_BIN7         0x24d   // default 32'h0
    #define RO_CM_SAT_HIST_BIN8         0x24e   // default 32'h0
    #define RO_CM_SAT_HIST_BIN9         0x24f   // default 32'h0
    #define RO_CM_SAT_HIST_BIN10        0x250   // default 32'h0
    #define RO_CM_SAT_HIST_BIN11        0x251   // default 32'h0
    #define RO_CM_SAT_HIST_BIN12        0x252   // default 32'h0
    #define RO_CM_SAT_HIST_BIN13        0x253   // default 32'h0
    #define RO_CM_SAT_HIST_BIN14        0x254   // default 32'h0
    #define RO_CM_SAT_HIST_BIN15        0x255   // default 32'h0
    #define RO_CM_SAT_HIST_BIN16        0x256   // default 32'h0
    #define RO_CM_SAT_HIST_BIN17        0x257   // default 32'h0
    #define RO_CM_SAT_HIST_BIN18        0x258   // default 32'h0
    #define RO_CM_SAT_HIST_BIN19        0x259   // default 32'h0
    #define RO_CM_SAT_HIST_BIN20        0x25a   // default 32'h0
    #define RO_CM_SAT_HIST_BIN21        0x25b   // default 32'h0
    #define RO_CM_SAT_HIST_BIN22        0x25c   // default 32'h0
    #define RO_CM_SAT_HIST_BIN23        0x25d   // default 32'h0
    #define RO_CM_SAT_HIST_BIN24        0x25e   // default 32'h0
    #define RO_CM_SAT_HIST_BIN25        0x25f   // default 32'h0
    #define RO_CM_SAT_HIST_BIN26        0x260   // default 32'h0
    #define RO_CM_SAT_HIST_BIN27        0x261   // default 32'h0
    #define RO_CM_SAT_HIST_BIN28        0x262   // default 32'h0
    #define RO_CM_SAT_HIST_BIN29        0x263   // default 32'h0
    #define RO_CM_SAT_HIST_BIN30        0x264   // default 32'h0
    #define RO_CM_SAT_HIST_BIN31        0x265   // default 32'h0
    #define RO_CM_BLK_BIN               0x266   // default 32'h0
    #define RO_CM_BRT_BIN               0x267   // default 32'h0

////========= NODE 0 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H00      0x100   // default 32'H0
//Bit 31: 24, reg_cm2_adj_sat_via_hs_2
//Bit 23: 16, reg_cm2_adj_sat_via_hs_1
//Bit 15: 8,  reg_cm2_adj_sat_via_hs_0
//Bit  7: 0, reg_cm2_adj_luma_via_h
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H00      0x101   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H00      0x102   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H00      0x103   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H00      0x104   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 1 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H01      0x108   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H01      0x109   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H01      0x10a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H01      0x10b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H01      0x10c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 2 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H02      0x110   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H02      0x111   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H02      0x112   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H02      0x113   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H02      0x114   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 3 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H03      0x118   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H03      0x119   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H03      0x11a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H03      0x11b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H03      0x11c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 4 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H04      0x120   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H04      0x121   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H04      0x122   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H04      0x123   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H04      0x124   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 5 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H05      0x128   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H05      0x129   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H05      0x12a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H05      0x12b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H05      0x12c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 6 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H06      0x130   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H06      0x131   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H06      0x132   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H06      0x133   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H06      0x134   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 7 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H07      0x138   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H07      0x139   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H07      0x13a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H07      0x13b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H07      0x13c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 8 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H08      0x140   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H08      0x141   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H08      0x142   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H08      0x143   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H08      0x144   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 9 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H09      0x148   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H09      0x149   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H09      0x14a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H09      0x14b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H09      0x14c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 10 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H10      0x150   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H10      0x151   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H10      0x152   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H10      0x153   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H10      0x154   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 11 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H11      0x158   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H11      0x159   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H11      0x15a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H11      0x15b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H11      0x15c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 12 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H12      0x160   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H12      0x161   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H12      0x162   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H12      0x163   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H12      0x164   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx

////========= NODE 13 COEFFICIENT ==============////

    #define REG_CM2_ENH_COEFF0_H13      0x168   // default 32'H0
                                                  // [ 7: 0] : luma_byh_hx   / [15: 8] : sat_byhs_s0hx
                                                  // [23:16] : sat_byhs_s0hx / [31:24] : sat_byhs_s2hx
    #define REG_CM2_ENH_COEFF1_H13      0x169   // default 32'H0
                                                  // [ 7: 0] : hue_byh_hx   / [15: 8] : hue_byy_y0hx
                                                  // [23:16] : hue_byy_y1hx / [31:24] : hue_byy_y2hx
    #define REG_CM2_ENH_COEFF2_H13      0x16a   // default 32'H0
                                                  // [ 7: 0] : hue_byy_y3hx / [15: 8] : hue_byy_y4hx
                                                  // [23:16] : hue_bys_s0hx / [31:24] : hue_bys_s1hx
    #define REG_CM2_ENH_COEFF3_H13      0x16b   // default 32'H0
                                                  // [ 7: 0] : hue_bys_s2hx / [15: 8] : hue_bys_s3hx
                                                  // [23:16] : hue_bys_s4hx / [31:24] : hue_byya_y0hx
    #define REG_CM2_ENH_COEFF4_H13      0x16c   // default 32'H0
                                                  // [ 7: 0] : hue_byya_y1hx / [15: 8] : hue_byya_y2hx
                                                  // [23:16] : hue_byya_y3hx / [31:24] : hue_byya_y4hx


/* Constraints
0)
  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
  the 8 regions for hue adjustment are defined by: (example are for region 0)
    a) hue:
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_hue_sat_low_00
        end:   reg_hue_sat_high_00

  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
  the 8 regions for sat adjustment are defined by: (example are for region 0)
    a) hue: same as that for hue adjustment.
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_sat_sat_low_00
        end:   reg_sat_sat_high_00

1)
  reg_hue_hue_shift_range_00[7:0]:
  reg_hue_hue_shift_range_01[7:0]:
  reg_hue_hue_shift_range_02[7:0]:
  reg_hue_hue_shift_range_03[7:0]:
  reg_hue_hue_shift_range_04[7:0]:
  reg_hue_hue_shift_range_05[7:0]:
  reg_hue_hue_shift_range_06[7:0]:
  reg_hue_hue_shift_range_07[7:0]:
  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx

2)
  all regions of 0-7 should meet below requirement. below is just an example for region 7.
  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >=
        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)

  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)

  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)

  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)

3)
  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
  only region 0 and 1 can exceed 360 degrees. ie:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
  but below should be met:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1

  others could not exceed 360 degrees. ie:
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.

4)
  reg_hue_gain_00[7:0] <= 0x80.
  reg_hue_gain_01[7:0] <= 0x80.
  reg_hue_gain_02[7:0] <= 0x80.
  reg_hue_gain_03[7:0] <= 0x80.
  reg_hue_gain_04[7:0] <= 0x80.
  reg_hue_gain_05[7:0] <= 0x80.
  reg_hue_gain_06[7:0] <= 0x80.
  reg_hue_gain_07[7:0] <= 0x80.

5)
  below registers can only have two setting: 00 and 01.
    reg_hue_central_en_00[1:0]  .. _07[1:0]
    reg_sat_central_en_00[1:0]  .. _07[1:0]

6)
  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
   for example: below is for region 0:
   reg_hue_lum_low_slope_00[3:0]  <= 7
   reg_hue_lum_high_slope_00[3:0] <= 7
   reg_hue_sat_low_slope_00[3:0]  <= 7
   reg_hue_sat_high_slope_00[3:0] <= 7
   reg_sat_lum_low_slope_00[3:0]  <= 7
   reg_sat_lum_high_slope_00[3:0] <= 7
   reg_sat_sat_low_slope_00[3:0]  <= 7
   reg_sat_sat_high_slope_00[3:0] <= 7
*/

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./chroma_reg.h
//
//(hsvsharp), (blue), gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,(hsharp),sco_ff, vadj1, vadj2, ofifo, (chroma1), clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again
//because the register itself canot be set again without clk
//Bit 31:0
#define VPP_GCLK_CTRL0                             ((0x1d72  << 2) + 0xff000000)
//(front_lti), (front_cti), Chroma2_filter, Chroma2, (Ccoring), (blackext), dnlp
//Bit 13:0
#define VPP_GCLK_CTRL1                             ((0x1d73  << 2) + 0xff000000)
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
//`define VPP_SC_GCLK_CTRL        8'h74
//Bit 17:9 VD1 alpha for preblend
//Bit 8:0 VD1 alpha for postblend
#define VPP_MISC1                                  ((0x1d76  << 2) + 0xff000000)
//Bit 31:0 super scalar clock control
#define VPP_SRSCL_GCLK_CTRL                        ((0x1d77  << 2) + 0xff000000)
//Bit 31:0 OSD super scalar clock control
#define VPP_OSDSR_GCLK_CTRL                        ((0x1d78  << 2) + 0xff000000)
//Bit 31:0 vvycc clock control
#define VPP_XVYCC_GCLK_CTRL                        ((0x1d79  << 2) + 0xff000000)
//Bit 8:0 VD3 alpha for postblend
#define VPP_MISC2                                  ((0x1d7a  << 2) + 0xff000000)
//Bit 31:24     blackext_start
//Bit 23:16     blackext_slope1
//Bit 15:8      blackext_midpt
//Bit 7:0       blackext_slope2
#define VPP_BLACKEXT_CTRL                          ((0x1d80  << 2) + 0xff000000)
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define VPP_DNLP_CTRL_00                           ((0x1d81  << 2) + 0xff000000)
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define VPP_DNLP_CTRL_01                           ((0x1d82  << 2) + 0xff000000)
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define VPP_DNLP_CTRL_02                           ((0x1d83  << 2) + 0xff000000)
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define VPP_DNLP_CTRL_03                           ((0x1d84  << 2) + 0xff000000)
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define VPP_DNLP_CTRL_04                           ((0x1d85  << 2) + 0xff000000)
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define VPP_DNLP_CTRL_05                           ((0x1d86  << 2) + 0xff000000)
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define VPP_DNLP_CTRL_06                           ((0x1d87  << 2) + 0xff000000)
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define VPP_DNLP_CTRL_07                           ((0x1d88  << 2) + 0xff000000)
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define VPP_DNLP_CTRL_08                           ((0x1d89  << 2) + 0xff000000)
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define VPP_DNLP_CTRL_09                           ((0x1d8a  << 2) + 0xff000000)
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define VPP_DNLP_CTRL_10                           ((0x1d8b  << 2) + 0xff000000)
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define VPP_DNLP_CTRL_11                           ((0x1d8c  << 2) + 0xff000000)
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define VPP_DNLP_CTRL_12                           ((0x1d8d  << 2) + 0xff000000)
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define VPP_DNLP_CTRL_13                           ((0x1d8e  << 2) + 0xff000000)
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define VPP_DNLP_CTRL_14                           ((0x1d8f  << 2) + 0xff000000)
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define VPP_DNLP_CTRL_15                           ((0x1d90  << 2) + 0xff000000)
// `define VPP_PEAKING_HGAIN       8'h91   //32'h0
// `define VPP_PEAKING_VGAIN       8'h92   //32'h0
// `define VPP_PEAKING_NLP_1       8'h93   //32'h0
// `define VPP_PEAKING_NLP_2       8'h94   //32'h0
// `define VPP_PEAKING_NLP_3       8'h95   //32'h0
// `define VPP_PEAKING_NLP_4       8'h96   //32'h0
// `define VPP_PEAKING_NLP_5       8'h97   //32'h0
// `define VPP_SHARP_LIMIT         8'h98   //32'h0
// `define VPP_VLTI_CTRL           8'h99   //32'h0
// `define VPP_HLTI_CTRL           8'h9a   //32'h0
// `define VPP_CTI_CTRL            8'h9b   //32'h0
#define VPP_SRSHARP0_CTRL                          ((0x1d91  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
//Bit 15:6   reserved
//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
//Bit 3      srsharp_demo_en         srsharp demo enable
//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
//Bit 1,     srsharp_buf_en          srsharp buffer enable
//Bit 0,     srsharp_en              srsharp enable
#define VPP_SRSHARP1_CTRL                          ((0x1d92  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  srsharp_demo_split_sz   srsharp demo top/bot left/right width
//Bit 15:6   reserved
//Bit 5:4    srsharp_demo_disp_post  srsharp demo display postion
//Bit 3      srsharp_demo_en         srsharp demo enable
//Bit 2      srsharp_c444to422_en    srsharp format444 convert 422 enable
//Bit 1,     srsharp_buf_en          srsharp buffer enable
//Bit 0,     srsharp_en              srsharp enable
#define VPP_DOLBY_CTRL                             ((0x1d93  << 2) + 0xff000000)
//todo
#define VPP_DAT_CONV_PARA0                         ((0x1d94  << 2) + 0xff000000)
#define VPP_DAT_CONV_PARA1                         ((0x1d95  << 2) + 0xff000000)
//todo
#define VPP_SYNC_SEL0                              ((0x1d96  << 2) + 0xff000000)
//`define VPP_VADJ1_BLACK_VAL         8'h97   //32'h0
//`define VPP_VADJ2_BLACK_VAL         8'h98   //32'h0
//Bit 29        blue_stretch_cb_inc
//Bit 28        blue_stretch_cr_inc
//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
//Bit 23:16     blue_stretch_gain
//Bit 15:8      blue_stretch_gain_cb4cr
//Bit 7:0       blue_stretch_luma_high
#define VPP_BLUE_STRETCH_1                         ((0x1d9c  << 2) + 0xff000000)
//Bit 31:27     blue_stretch_error_crp
//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
//Bit 15:11     blue_stretch_error_crn
//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
#define VPP_BLUE_STRETCH_2                         ((0x1d9d  << 2) + 0xff000000)
//Bit 31:27     blue_stretch_error_cbp
//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
//Bit 15:11     blue_stretch_error_cbn
//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
#define VPP_BLUE_STRETCH_3                         ((0x1d9e  << 2) + 0xff000000)
#define VPP_CCORING_CTRL                           ((0x1da0  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:16 reg_bypass_ccoring_ythd    // unsigned , default = 0   bypass_ccoring_ythd
//Bit 15:8  ccoring_th                 // unsigned , default = 0   Chroma coring threshold
//Bit 7:0   reserved
//Bit 3:0   ccoring_slope              // unsigned , default = 0   Chroma coring slope
#define VPP_VE_ENABLE_CTRL                         ((0x1da1  << 2) + 0xff000000)
//Bit 31:21  reserved
//Bit 20     demo_ccoring_enable     // unsigned  , default = 0 demo chroma coring enable
//Bit 19     demo_blackext_enable    // unsigned  , default = 0 demo black extension enable
//Bit 18     demo_dnlp_enable        // unsigned  , default = 0 demo dynamic nonlinear luma processing enable
//Bit 17     demo_hsvsharp_enable    // unsigned  , default = 0 demo hsvsharp enable
//Bit 16     demo_bluestretch_enable // unsigned  , default = 0 demo bluestretch enable
//Bit 15:14  demo_disp_position      // unsigned  , default = 0 2'b00: demo adjust on top, 2'b01: demo adjust on bottom, 2'b10: demo adjust on left, 2'b11: demo adjust on right
//Bit 13:7   reserved
//Bit 6      sr4c0_path_sel          // unsigned  , default = 0
//Bit 5      srscl_path_sel          // unsigned  , default = 0
//Bit 4      ccoring_en              // unsigned  , default = 0  chroma coring enable
//Bit 3      blackext_en             // unsigned  , default = 0  black extension enable
//Bit 2      dnlp_en                 // unsigned  , default = 0  dynamic nonlinear luma processing enable
//Bit 1      hsvsharp_en             // unsigned  , default = 0  hsvsharp enable
//Bit 0      blue_stretch_en         // unsigned  , default = 0  bluestretch enable
#define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH          ((0x1da2  << 2) + 0xff000000)
//Bit 31:13  reserved
//Bit 12:0   ve_demo_left_top_screen_width // unsigned  , default = 0 demo left or top screen width
#define VPP_VE_DEMO_CENTER_BAR                     ((0x1da3  << 2) + 0xff000000)
 //Bit 31      ve_demo_center_bar // unsigned  , default = 0 center bar enable
 //Bit 27:24   ve_demo_center_bar // unsigned  , default = 0 center bar width    (*2)
 //Bit 23:16   ve_demo_center_bar // unsigned  , default = 0 center bar Cr       (*4)
 //Bit 15:8    ve_demo_center_bar // unsigned  , default = 0 center bar Cb       (*4)
 //Bit 7:0     ve_demo_center_bar // unsigned  , default = 0 center bar y        (*4)
#define VPP_VE_H_V_SIZE                            ((0x1da4  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  ve_line_length  // unsigned  , default = 780  ve_line_length
//Bit 15:13  reserved
//Bit 12:0   ve_pic_height   // unsigned  , default = 438  ve_pic_height
#define VPP_OUT_H_V_SIZE                           ((0x1da5  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  vppout_line_length  / unsigned  , default = 780   vppout_line_length
//Bit 15:13  reserved
//Bit 12:0   vppout_pic_height   // unsigned  , default = 438  vppout_pic_height
#define VPP_IN_H_V_SIZE                            ((0x1da6  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  vppin_line_length  / unsigned  , default = 780   vppout_line_length
//Bit 15:13  reserved
//Bit 12:0   vppin_pic_height   // unsigned  , default = 438  vppout_pic_height
#define VPP_VDO_MEAS_CTRL                          ((0x1da8  << 2) + 0xff000000)
//Bit 31:11  reserved
//Bit 10:0   vdo_meas_ctrl    // unsigned  , default = 0  vdo_meas_ctrl
//Read only
//19:16  ind_meas_count_n, every number of sync_span vsyncs, this counter add 1
//15:0, high bit portion of counter
#define VPP_VDO_MEAS_VS_COUNT_HI                   ((0x1da9  << 2) + 0xff000000)
//Read only
//31:0, low bit portion of counter
#define VPP_VDO_MEAS_VS_COUNT_LO                   ((0x1daa  << 2) + 0xff000000)
//bit 11:9 vd2_sel,  001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 8:6 vd1_l_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//bit 5:3 vd1_r_sel, 001: select vd1_din, 010: select vd2_din, 011: select d2d3_l_din, 100: d2d3_r_din, otherwise no selection
//note: the source vd1_l_sel selected cannot be used as the source of vd1_r_sel or vd2_sel
// vd1_r_sel is useful only vd1_interleave_mode is not 00. And the source vd1_r_sel used can not used for the vd2_sel any more.
//bit 2:0 vd1_interleave_mode, 000: no interleave, 001: pixel interleaving, 010: line interleaving, 011: 2 pixel interleaving,
// 100: 2 line interleaving
#define VPP_INPUT_CTRL                             ((0x1dab  << 2) + 0xff000000)
//bit 25:24 cti_bpf_sel
//bit 20:16 cti_blend_factor_gama
//bit 12:8 cti_blend_factor_beta
//bit 4:0 cti_blend_factor_alpha
#define VPP_CTI_CTRL2                              ((0x1dac  << 2) + 0xff000000)
// `define VPP_PEAKING_SAT_THD1 8'had
// `define VPP_PEAKING_SAT_THD2 8'hae
// `define VPP_PEAKING_SAT_THD3 8'haf
// `define VPP_PEAKING_SAT_THD4 8'hb0
// `define VPP_PEAKING_SAT_THD5 8'hb1
// `define VPP_PEAKING_SAT_THD6 8'hb2
// `define VPP_PEAKING_SAT_THD7 8'hb3
// `define VPP_PEAKING_SAT_THD8 8'hb4
// `define VPP_PEAKING_SAT_THD9 8'hb5
// `define VPP_PEAKING_GAIN_ADD1 8'hb6
// `define VPP_PEAKING_GAIN_ADD2 8'hb7
#define VPP_WRBAK_CTRL_SEC                         ((0x1dad  << 2) + 0xff000000)
#define VD1_BLEND_SRC_CTRL_SEC                     ((0x1dae  << 2) + 0xff000000)
#define VD2_BLEND_SRC_CTRL_SEC                     ((0x1daf  << 2) + 0xff000000)
#define OSD1_BLEND_SRC_CTRL_SEC                    ((0x1db0  << 2) + 0xff000000)
#define OSD2_BLEND_SRC_CTRL_SEC                    ((0x1db1  << 2) + 0xff000000)
//crc check , new add
#define VPP_RO_CRCSUM                              ((0x1db2  << 2) + 0xff000000)
#define VPP_CRC_CHK                                ((0x1db3  << 2) + 0xff000000)
//bit 23:16 peaking_dnlp_gain, u5.3, DNLP effect
//bit 15:8  peaking_factor
//bit 5     peaking_dnlp_demo_en
//bit 4     peaking_dnlp_en
//bit 3:0   peaking_filter_sel
#define VPP_PEAKING_DNLP                           ((0x1db8  << 2) + 0xff000000)
//bit 24    sharp_demo_win_en
//bit 23:12 sharp_demo_win_vend
//bit 11:0  sharp_demo_win_vstart
#define VPP_SHARP_DEMO_WIN_CTRL1                   ((0x1db9  << 2) + 0xff000000)
//bit 23:12 sharp_demo_win_hend
//bit 11:0  sharp_demo_win_hstart
#define VPP_SHARP_DEMO_WIN_CTRL2                   ((0x1dba  << 2) + 0xff000000)
//Bit 31:24     front_hlti_neg_gain
//Bit 23:16     front_hlti_pos_gain
//Bit 15:8      front_hlti_threshold
//Bit 7:0       front_hlti_blend_factor
#define VPP_FRONT_HLTI_CTRL                        ((0x1dbb  << 2) + 0xff000000)
//Bit 31        front_enable, enable the front LTI&CTI before scaler
//Bit 26:24     front_cti_step2
//Bit 23:21     front_cti_step
//Bit 20:16     front_cti_blend_factor
//Bit 15        front_cti_median_mode
//Bit 14:8      front_cti_threshold
//Bit 7:0       front_cti_gain
#define VPP_FRONT_CTI_CTRL                         ((0x1dbc  << 2) + 0xff000000)
//bit 29:28 front_hlti_step
//bit 25:24 front_cti_bpf_sel
//bit 20:16 front_cti_blend_factor_gama
//bit 12:8  front_cti_blend_factor_beta
//bit 4:0   front_cti_blend_factor_alpha
#define VPP_FRONT_CTI_CTRL2                        ((0x1dbd  << 2) + 0xff000000)
//Bit 12:0 line number use to generate interrupt when line == this number
#define VPP_INT_LINE_NUM                           ((0x1dce  << 2) + 0xff000000)
#define VPP_XVYCC_MISC                             ((0x1dcf  << 2) + 0xff000000)
// new add lti/cti in 120924
//Bit  3: 0        //default== 0  reg_hlti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hlti_dn_flt_coe[1]
//Bit 11: 8        //default== 0  reg_hlti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hlti_dn_flt_coe[3]
//Bit 19:16        //default== 4  reg_hlti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hlti_dn_flt_nrm  u3: 3~7
#define VPP_HLTI_DN_FLT                            ((0x1dd0  << 2) + 0xff000000)
//Bit  7: 0        //default== 8  reg_hlti_bst_gain  u8, norm 16 as "1"
//Bit 15: 8        //default== 20 reg_hlti_bst_core  u8, norm 32 as "1"
//Bit 23:16        //default== 32 reg_hlti_oob_gain  u8, norm 32 as "1"
//Bit 28:24        //default== 0  reg_hlti_oob_core  u5
#define VPP_HLTI_GAIN                              ((0x1dd1  << 2) + 0xff000000)
//Bit  7: 0        //default== 2  reg_hlti_clp_ofst  u8,
//Bit     8        //default== 0  reg_hlti_clp_mode  u1,
//Bit 11: 9        //default== 1  reg_hlti_clp_wind  u3,
//Bit 14:12        //default== 1  reg_hlti_bst_fltr  u3,
//Bit    15        //default== 1  reg_hlti_enable    u1,
#define VPP_HLTI_PARA                              ((0x1dd2  << 2) + 0xff000000)
//Bit  3: 0        //default== 0  reg_hcti_dn_flt_coe[0]
//Bit  7: 4        //default== 0  reg_hcti_dn_flt_coe[1]
//Bit 11: 8        //default== 1  reg_hcti_dn_flt_coe[2]
//Bit 15:12        //default== 2  reg_hcti_dn_flt_coe[3]
//Bit 19:16        //default== 2  reg_hcti_dn_flt_coe[4]
//Bit 22:20        //default== 3  reg_hcti_dn_flt_nrm   u3: 3~7
#define VPP_HCTI_DN_FLT                            ((0x1dd3  << 2) + 0xff000000)
//Bit 7: 0        //default== 48 reg_hcti_bst_gain  u8, norm 16 as "1"
//Bit15: 8        //default== 17 reg_hcti_bst_core  u8, norm 32 as "1"
//Bit23:16        //default== 16 reg_hcti_oob_gain  u8, norm 32 as "1"
//Bit28:24        //default==  0 reg_hcti_oob_core  u5
#define VPP_HCTI_GAIN                              ((0x1dd4  << 2) + 0xff000000)
//Bit  7: 0        //default==  0 reg_hcti_clp_ofst  u8,
//Bit     8        //default==  1 reg_hcti_clp_mode  u1,
//Bit 11: 9        //default==  3 reg_hcti_clp_wind  u3,
//Bit 14:12        //default==  6 reg_hcti_bst_fltr  u3,
//Bit    15        //default==  1 reg_hcti_enable    u1,
#define VPP_HCTI_PARA                              ((0x1dd5  << 2) + 0xff000000)
//Bit  7: 0        //default== 48 reg_vcti_bst_gain  u8, normalize 16 as "1"
//Bit 15: 8        //default== 10 reg_vcti_bst_core  u8
//Bit 19:16        //default== 10 reg_vcti_clp_ofst  u4
//Bit    20        //default==  1 reg_vcti_clp_wind  u1, 0: wind 3, 1: wind5
#define VPP_VCTI_PARA                              ((0x1dd6  << 2) + 0xff000000)
//`define VPP_MATRIX_PROBE_COLOR1 8'hd7  //defined before
//Bit 31          //default== 0, urgent fifo hold enable
//Bit 28:12       //default== 0, urgent fifo hold line threshold
//Bit 15          //default== 0, urgent_ctrl_en
//Bit 14          //default== 0, urgent_wr, if true for write buffer
//Bit 13          //default== 0, out_inv_en
//Bit 12          //default == 0, urgent_ini_value
//Bit 11:6        //default == 0, up_th  up threshold
//Bit 5:0         //default == 0, dn_th  dn threshold
#define VPP_OFIFO_URG_CTRL                         ((0x1dd8  << 2) + 0xff000000)
#define VPP_CLIP_MISC0                             ((0x1dd9  << 2) + 0xff000000)
//Bit 29:20       // default == 1023, final clip r channel top
//Bit 19:10       // default == 1023, final clip g channel top
//Bit  9: 0       // default == 1023, final clip b channel top
#define VPP_CLIP_MISC1                             ((0x1dda  << 2) + 0xff000000)
//Bit 29:20       // default ==    0, final clip r channel bottom
//Bit 19:10       // default ==    0, final clip g channel bottom
//Bit  9: 0       // default ==    0, final clip b channel bottom
#define VPP_MATRIX_COEF13_14                       ((0x1ddb  << 2) + 0xff000000)
//Bit 28:16       // default == 0, matrix coef13
//Bit 12:0        // default == 0, matrix coef14
#define VPP_MATRIX_COEF23_24                       ((0x1ddc  << 2) + 0xff000000)
//Bit 28:16       // default == 0, matrix coef23
//Bit 12:0        // default == 0, matrix coef24
#define VPP_MATRIX_COEF15_25                       ((0x1ddd  << 2) + 0xff000000)
//Bit 28:16       // default == 0, matrix coef15
//Bit 12:0        // default == 0, matrix coef25
#define VPP_MATRIX_CLIP                            ((0x1dde  << 2) + 0xff000000)
//Bit 7:5         //  default == 0,   mat rs
//Bit 4:3         //  default == 0,   mat clmod
//Bit 2:0         //  default == 0,   mat clip enable
#define VPP_XVYCC_MISC0                            ((0x1ddf  << 2) + 0xff000000)
//Bit 29:20       // default == 1023, xvycc clip r channel top
//Bit 19:10       // default == 1023, xvycc clip g channel top
//Bit  9: 0       // default == 1023, xvycc clip b channel top
#define VPP_XVYCC_MISC1                            ((0x1de0  << 2) + 0xff000000)
//Bit 29:20       // default ==    0, xvycc clip r channel bottom
//Bit 19:10       // default ==    0, xvycc clip g channel bottom
//Bit  9: 0       // default ==    0, xvycc clip b channel bottom
#define VPP_VD1_CLIP_MISC0                         ((0x1de1  << 2) + 0xff000000)
//Bit 29:20       // default == 1023, vd1 clip r channel top
//Bit 19:10       // default == 1023, vd1 clip g channel top
//Bit  9: 0       // default == 1023, vd1 clip b channel top
#define VPP_VD1_CLIP_MISC1                         ((0x1de2  << 2) + 0xff000000)
//Bit 29:20       // default ==    0, vd1 clip r channel bottom
//Bit 19:10       // default ==    0, vd1 clip g channel bottom
//Bit  9: 0       // default ==    0, vd1 clip b channel bottom
#define VPP_VD2_CLIP_MISC0                         ((0x1de3  << 2) + 0xff000000)
//Bit 29:20       // default == 1023, vd2 clip r channel top
//Bit 19:10       // default == 1023, vd2 clip g channel top
//Bit  9: 0       // default == 1023, vd2 clip b channel top
#define VPP_VD2_CLIP_MISC1                         ((0x1de4  << 2) + 0xff000000)
//Bit 29:20       // default ==    0, vd2 clip r channel bottom
//Bit 19:10       // default ==    0, vd2 clip g channel bottom
//Bit  9: 0       // default ==    0, vd2 clip b channel bottom
#define VPP_VD3_CLIP_MISC0                         ((0x1de5  << 2) + 0xff000000)
//Bit 29:20       // default == 1023, vd2 clip r channel top
//Bit 19:10       // default == 1023, vd2 clip g channel top
//Bit  9: 0       // default == 1023, vd2 clip b channel top
#define VPP_VD3_CLIP_MISC1                         ((0x1de6  << 2) + 0xff000000)
//Bit 29:20       // default ==    0, vd2 clip r channel bottom
//Bit 19:10       // default ==    0, vd2 clip g channel bottom
//Bit  9: 0       // default ==    0, vd2 clip b channel bottom
#define VPP_BLEND_VD3_H_START_END                  ((0x1deb  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0  end
#define VPP_BLEND_VD3_V_START_END                  ((0x1dec  << 2) + 0xff000000)
//Bit 28:16 start
//Bit 12:0  end
#define VD3_BLEND_SRC_CTRL                         ((0x1def  << 2) + 0xff000000)
#define VPP_VD2_HDR_IN_SIZE                        ((0x1df0  << 2) + 0xff000000)
//Bit 31:16       // default ==    0
//Bit 15:0        // default ==    0
#define VPP_OSD1_IN_SIZE                           ((0x1df1  << 2) + 0xff000000)
//Bit 31:16       // default ==    0
//Bit 15:0        // default ==    0
#define VPP_GCLK_CTRL2                             ((0x1df2  << 2) + 0xff000000)
//`define VPP_BLEND_SRC_SEL               8'hf3
//`define VD2_PPS_DUMMY_DATA              8'hf4
#define VPP_OSD1_BLD_H_SCOPE                       ((0x1df5  << 2) + 0xff000000)
#define VPP_OSD1_BLD_V_SCOPE                       ((0x1df6  << 2) + 0xff000000)
#define VPP_OSD2_BLD_H_SCOPE                       ((0x1df7  << 2) + 0xff000000)
#define VPP_OSD2_BLD_V_SCOPE                       ((0x1df8  << 2) + 0xff000000)
#define VPP_WRBAK_CTRL                             ((0x1df9  << 2) + 0xff000000)
#define VPP_SLEEP_CTRL                             ((0x1dfa  << 2) + 0xff000000)
#define VD1_BLEND_SRC_CTRL                         ((0x1dfb  << 2) + 0xff000000)
#define VD2_BLEND_SRC_CTRL                         ((0x1dfc  << 2) + 0xff000000)
#define OSD1_BLEND_SRC_CTRL                        ((0x1dfd  << 2) + 0xff000000)
#define OSD2_BLEND_SRC_CTRL                        ((0x1dfe  << 2) + 0xff000000)
//`define VPP_OSD_SCALE_CTRL              8'hff
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DISP_IF1_VCBUS_BASE = 0x1e
// -----------------------------------------------
//===========================================================================
//`include "disp_if_regs.h"
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DISP_IF2_VCBUS_BASE = 0x1f
// -----------------------------------------------
//===========================================================================
//`include "disp_if_regs.h"
//===========================================================================
//===========================================================================
//
// Reading file:  ./vregs_clk1.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VIUB_VCBUS_BASE = 0x20
// -----------------------------------------------
#define VIUB_ADDR_START                            ((0x2000  << 2) + 0xff000000)
#define VIUB_ADDR_END                              ((0x20ff  << 2) + 0xff000000)
//`define TRACE_REG 8'ff
//------------------------------------------------------------------------------
// VIU top-level registers
//------------------------------------------------------------------------------
// Bit  0 RW, osd1_reset
// Bit  1 RW, osd2_reset
// Bit  2 RW, vd1_reset
// Bit  3 RW, vd1_fmt_reset
// Bit  4 RW, vd2_reset
// Bit  5 RW, vd2_fmt_reset
// Bit  6 RW, di_dsr1to2_reset
// Bit  7 RW, vpp_reset
// Bit  8 RW, di_if1_reset
// Bit  9 RW, di_if1_fmt_reset
// Bit 10 RW, di_inp_reset
// Bit 11 RW, di_inp_fmt_reset
// Bit 12 RW, di_mem_reset
// Bit 13 RW, di_mem_fmt_reset
// Bit 14 RW, di_nr_wr_mif_reset
// Bit 15 RW, dein_wr_mif_reset
// Bit 16 RW, di_chan2_mif_reset
// Bit 17 RW, di_mtn_wr_mif_reset
// Bit 18 RW, di_mtn_rd_mif_reset
// Bit 19 RW, di_mad_reset
// Bit 20 RW, vdin0_reset
// Bit 21 RW, vdin1_reset
// Bit 22 RW, nrin_mux_reset
// Bit 23 RW, vdin0_wr_reset
// Bit 24 RW, vdin1_wr_reset
// Bit 25 RW, reserved
// Bit 26 RW, d2d3_reset
// Bit 27 RW, di_cont_wr_mif_reset
// Bit 28 RW, di_cont_rd_mif_reset
#define VIUB_SW_RESET                              ((0x2001  << 2) + 0xff000000)
#define VIUB_SW_RESET0                             ((0x2002  << 2) + 0xff000000)
// Bit 0 RW, software reset for mcvecrd_mif
// Bit 1 RW, software reset for mcinfowr_mif
// Bit 2 RW, software reset for mcinford_mif
#define DI_AFBCE_CTRL                              ((0x2003  << 2) + 0xff000000)
#define VIUB_SECURE_ST_RO                          ((0x2004  << 2) + 0xff000000)
//bit 8 if true, vsync interrup is generate only field == 0
//bit 7:0 fix_disable
#define VIUB_MISC_CTRL0                            ((0x2006  << 2) + 0xff000000)
#define VIUB_GCLK_CTRL0                            ((0x2007  << 2) + 0xff000000)
//// gclk_ctrl0_gl[ 0] : def=1 di_top_wrap clk enable
////
//// gclk_ctrl0_gl[ 8] : def=0 mad pre clock enable, from mad clock
//// gclk_ctrl0_gl[ 9] : def=0 mad post clock enable, from mad clock
//// gclk_ctrl0_gl[10] : def=0 div clock enable, di slow clock including di&mcdi
//// gclk_ctrl0_gl[11] : def=0 mcdi clock enable, from div clock
//// gclk_ctrl0_gl[12] : def=0 di post clock enable, from div clock
//// gclk_ctrl0_gl[13] : def=0 reserved
//// gclk_ctrl0_gl[14] : def=1 di_no_clk_gate, for old di
//// gclk_ctrl0_gl[15] : def=0 di_gate_all, for old di
#define VIUB_GCLK_CTRL1                            ((0x2008  << 2) + 0xff000000)
//// gclk_ctrl1_gl[ 1: 0] : def=2'b00 mif-sub-arb clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 3: 2] : def=2'b00 if1 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 5: 4] : def=2'b00 if2 rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 7: 6] : def=2'b00 de wrmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[ 9: 8] : def=2'b00 mtnrd post mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[11:10] : def=2'b00 mcdi post mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[17:16] : def=2'b00 inp rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[19:18] : def=2'b00 mem rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[21:20] : def=2'b00 chan rdmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[23:22] : def=2'b00 nr wrmif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[25:24] : def=2'b00 mtn mif clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl1_gl[27:26] : def=2'b00 mcdi pre mif clock gate ctrl [1]: clock valid, [0]: clock close
////
#define VIUB_GCLK_CTRL2                            ((0x2009  << 2) + 0xff000000)
//// gclk_ctrl_pre[ 1: 0] : def=2'b00 nr clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 3: 2] : def=2'b00 pd clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 5: 4] : def=2'b00 mtn det clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 7: 6] : def=2'b00 debanding clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[ 9: 8] : def=2'b00 dnr clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[11:10] : def=2'b00 nr&dnr blend clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_pre[13:12] : def=2'b00 mcdi clock gate ctrl [1]: clock valid, [0]: clock close
#define VIUB_GCLK_CTRL3                            ((0x200a  << 2) + 0xff000000)
//// gclk_ctrl_post[ 1: 0] : def=2'b00 di blend clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_post[ 3: 2] : def=2'b00 ei clock gate ctrl [1]: clock valid, [0]: clock close
//// gclk_ctrl_post[ 5: 4] : def=2'b00 ei_0 clock gate ctrl [1]: clock valid, [0]: clock close
#define DI_DBG_CTRL                                ((0x200b  << 2) + 0xff000000)
#define DI_DBG_CTRL1                               ((0x200c  << 2) + 0xff000000)
#define DI_DBG_SRDY_INF                            ((0x200d  << 2) + 0xff000000)
#define DI_DBG_RRDY_INF                            ((0x200e  << 2) + 0xff000000)
#define VIUB_SECURE_REG                            ((0x200f  << 2) + 0xff000000)
#define DI_PRE_SEC_IN                              ((0x2010  << 2) + 0xff000000)
#define DI_POST_SEC_IN                             ((0x2011  << 2) + 0xff000000)
//`define DI_IF2_GEN_REG            8'h10
//`define DI_IF2_CANVAS0            8'h11
//`define DI_IF2_LUMA_X0            8'h12
//`define DI_IF2_LUMA_Y0            8'h13
//`define DI_IF2_CHROMA_X0          8'h14
//`define DI_IF2_CHROMA_Y0          8'h15
//`define DI_IF2_RPT_LOOP           8'h16
//`define DI_IF2_LUMA0_RPT_PAT      8'h17
//`define DI_IF2_CHROMA0_RPT_PAT    8'h18
//`define DI_IF2_DUMMY_PIXEL        8'h19
//`define DI_IF2_LUMA_FIFO_SIZE     8'h1a
//`define DI_IF2_RANGE_MAP_Y        8'h1b
//`define DI_IF2_RANGE_MAP_CB       8'h1c
//`define DI_IF2_RANGE_MAP_CR       8'h1d
//`define DI_IF2_GEN_REG2           8'h1e
//`define DI_IF2_FMT_CTRL           8'h1f
//`define DI_IF2_FMT_W              8'h20
//
//`define DI_IF2_URGENT_CTRL		  8'h21
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//`define DI_IF2_GEN_REG3           8'h22
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
//==================================
#define DI_EI_DRT_CTRL                             ((0x2028  << 2) + 0xff000000)
//Bit 31,     reg_rectg_en      ;u1
//Bit 30,     reg_recbld_en     ;u1
//Bit 29:28,  reg_rectg_ws      ;u2
//Bit 27,     reserved
//Bit 26:24,  reg_abq_margin    ;u3
//Bit 23,     reserved
//Bit 22:20,  reg_trend_mg      ;u3
//Bit 19:16,  reg_int_d16xc1    ;u4
//Bit 15:14,  reserved
//Bit 13: 8,  reg_int_chlmt1    ;u6
//Bit  7,     reserved
//Bit  6: 4,  reg_nscheck_thrd  ;u3
//Bit  3,     reserved
//Bit  2: 0,  reg_horsl_ws      ;u3
#define DI_EI_DRT_PIXTH                            ((0x2029  << 2) + 0xff000000)
//Bit 31:24,  reg_min_pix        ;u8
//Bit 23:16,  reg_max_pix        ;u8
//Bit 15: 8,  reg_dmaxmin_thrdma ;u8
//Bit  7: 0,  reg_dmaxmin_thrdmi ;u8
#define DI_EI_DRT_CORRPIXTH                        ((0x202a  << 2) + 0xff000000)
//Bit 31:24,  reg_newcorrpix_maxthrd ;u8
//Bit 23:16,  reg_corrpix_diffthrd   ;u8
//Bit 15: 8,  reg_corrpix_minthrd    ;u8
//Bit  7: 0,  reg_corrpix_maxthrd    ;u8
#define DI_EI_DRT_RECTG_WAVE                       ((0x202b  << 2) + 0xff000000)
//Bit 31:29,  reserved
//Bit 28:24,  reg_max_pixwave  ;u5
//Bit 23:21,  reserved
//Bit 20:16,  reg_pix_wave     ;u5
//Bit 15:14,  reserved
//Bit 13: 8,  reg_maxdrt_thrd  ;u6
//Bit  7: 0,  reg_wave_thrd    ;u8
#define DI_EI_DRT_PIX_DIFFTH                       ((0x202c  << 2) + 0xff000000)
//Bit 31:24,  reg_newraw_thrd    ;u8
//Bit 23:16,  reg_tb_max_thrd    ;u8
//Bit 15: 8,  reg_diffpix_thrd   ;u8
//Bit  7: 6,  reserved
//Bit  5: 0,  reg_bilt_trendnumt ;u8
#define DI_EI_DRT_UNBITREND_TH                     ((0x202d  << 2) + 0xff000000)
//Bit 31:29,  reserved
//Bit 28:24,  reg_trend_numb     ;u5
//Bit 23:21,  reserved
//Bit 20:16,  reg_bilt_trendnum  ;u5
//Bit 15:13,  reserved
//Bit 12: 8,  reg_unil_trendnumt ;u5
//Bit  7: 5,  reserved
//Bit  4: 0,  reg_trend_num      ;u5
//`define DI_IF0_GEN_REG            8'h30
//`define DI_IF0_CANVAS0            8'h31
//`define DI_IF0_LUMA_X0            8'h32
//`define DI_IF0_LUMA_Y0            8'h33
//`define DI_IF0_CHROMA_X0          8'h34
//`define DI_IF0_CHROMA_Y0          8'h35
//`define DI_IF0_RPT_LOOP           8'h36
//`define DI_IF0_LUMA0_RPT_PAT      8'h37
//`define DI_IF0_CHROMA0_RPT_PAT    8'h38
//`define DI_IF0_DUMMY_PIXEL        8'h39
//`define DI_IF0_LUMA_FIFO_SIZE     8'h3a
//`define DI_IF0_RANGE_MAP_Y        8'h3b
//`define DI_IF0_RANGE_MAP_CB       8'h3c
//`define DI_IF0_RANGE_MAP_CR       8'h3d
//`define DI_IF0_GEN_REG2           8'h3e
//`define DI_IF0_FMT_CTRL           8'h3f
//`define DI_IF0_FMT_W              8'h40
//
//`define DI_IF0_URGENT_CTRL		  8'h41
//bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 , low threshold  for di inp chroma path
//bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 , low threshold  for di inp luma path
//`define DI_IF0_GEN_REG3           8'h42
//bit 31:1,  reversed
//bit 0,     cntl_64bit_rev
// di arbtration :
// the segment is 8'h50-8'h5f
//
// Reading file:  ./di_arb_axi_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define DI_RDARB_MODE_L1C1                         ((0x2050  << 2) + 0xff000000)
//Bit   31:22,    reserved
//Bit   21:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define DI_RDARB_REQEN_SLV_L1C1                    ((0x2051  << 2) + 0xff000000)
//Bit   31:12,     reserved
//Bit   11:0,     rdarb_dc_req_en     unsigned  , default = 12'hfff
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[6]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[10]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[11]: the slv5 req to mst port1 enable,
#define DI_RDARB_WEIGH0_SLV_L1C1                   ((0x2052  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define DI_RDARB_WEIGH1_SLV_L1C1                   ((0x2053  << 2) + 0xff000000)
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define DI_WRARB_MODE_L1C1                         ((0x2054  << 2) + 0xff000000)
//Bit   31:22,    reserved
//Bit   21:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//                                    wrarb_sel[4]==0 slave dc4 connect master port0 wrarb_sel[4]==1 slave dc4 connect master port1
//                                    wrarb_sel[5]==0 slave dc5 connect master port0 wrarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define DI_WRARB_REQEN_SLV_L1C1                    ((0x2055  << 2) + 0xff000000)
//Bit   31:12,     reserved
//Bit   11:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define DI_WRARB_WEIGH0_SLV_L1C1                   ((0x2056  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define DI_WRARB_WEIGH1_SLV_L1C1                   ((0x2057  << 2) + 0xff000000)
//Bit   31:6,    reserved
//Bit   5:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define DI_RDWR_ARB_STATUS_L1C1                    ((0x2058  << 2) + 0xff000000)
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define DI_ARB_DBG_CTRL_L1C1                       ((0x2059  << 2) + 0xff000000)
#define DI_ARB_DBG_STAT_L1C1                       ((0x205a  << 2) + 0xff000000)
#define DI_RDARB_UGT_L1C1                          ((0x205b  << 2) + 0xff000000)
#define DI_RDARB_LIMT0_L1C1                        ((0x205c  << 2) + 0xff000000)
#define DI_WRARB_UGT_L1C1                          ((0x205d  << 2) + 0xff000000)
#define DI_ARB_AXIWR_PROT                          ((0x205e  << 2) + 0xff000000)
#define DI_ARB_AXIRD0_PROT                         ((0x205f  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_arb_axi_regs.h
//
// di afbc_enc
// the segment is 8'h60-8'h8f
//
// Reading file:  ./di_afbc_enc0_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DI_AFBCE_ENABLE                            ((0x2060  << 2) + 0xff000000)
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    di_afbce_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define DI_AFBCE_MODE                              ((0x2061  << 2) + 0xff000000)
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define DI_AFBCE_SIZE_IN                           ((0x2062  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vert size in  unit: pixel
#define DI_AFBCE_BLK_SIZE_IN                       ((0x2063  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vert size in  unit: pixel
#define DI_AFBCE_HEAD_BADDR                        ((0x2064  << 2) + 0xff000000)
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define DI_AFBCE_MIF_SIZE                          ((0x2065  << 2) + 0xff000000)
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define DI_AFBCE_PIXEL_IN_HOR_SCOPE                ((0x2066  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define DI_AFBCE_PIXEL_IN_VER_SCOPE                ((0x2067  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define DI_AFBCE_CONV_CTRL                         ((0x2068  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define DI_AFBCE_MIF_HOR_SCOPE                     ((0x2069  << 2) + 0xff000000)
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define DI_AFBCE_MIF_VER_SCOPE                     ((0x206a  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define DI_AFBCE_STAT1                             ((0x206b  << 2) + 0xff000000)
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define DI_AFBCE_STAT2                             ((0x206c  << 2) + 0xff000000)
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define DI_AFBCE_FORMAT                            ((0x206d  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define DI_AFBCE_MODE_EN                           ((0x206e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define DI_AFBCE_DWSCALAR                          ((0x206f  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define DI_AFBCE_DEFCOLOR_1                        ((0x2070  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define DI_AFBCE_DEFCOLOR_2                        ((0x2071  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define DI_AFBCE_QUANT_ENABLE                      ((0x2072  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define DI_AFBCE_IQUANT_LUT_1                      ((0x2073  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE_IQUANT_LUT_2                      ((0x2074  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE_IQUANT_LUT_3                      ((0x2075  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE_IQUANT_LUT_4                      ((0x2076  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE_RQUANT_LUT_1                      ((0x2077  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define DI_AFBCE_RQUANT_LUT_2                      ((0x2078  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define DI_AFBCE_RQUANT_LUT_3                      ((0x2079  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define DI_AFBCE_RQUANT_LUT_4                      ((0x207a  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define DI_AFBCE_YUV_FORMAT_CONV_MODE              ((0x207b  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define DI_AFBCE_DUMMY_DATA                        ((0x207c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define DI_AFBCE_CLR_FLAG                          ((0x207d  << 2) + 0xff000000)
//Bit 31:0         reg_di_afbce_clr_flag           // unsigned, default = 0  ;
#define DI_AFBCE_STA_FLAGT                         ((0x207e  << 2) + 0xff000000)
//Bit 31:0         ro_di_afbce__sta_flag        // unsigned, RO,default = 0  ;
#define DI_AFBCE_MMU_NUM                           ((0x207f  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define DI_AFBCE_MMU_RMIF_CTRL1                    ((0x2080  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define DI_AFBCE_MMU_RMIF_CTRL2                    ((0x2081  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define DI_AFBCE_MMU_RMIF_CTRL3                    ((0x2082  << 2) + 0xff000000)
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define DI_AFBCE_MMU_RMIF_CTRL4                    ((0x2083  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define DI_AFBCE_MMU_RMIF_SCOPE_X                  ((0x2084  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define DI_AFBCE_MMU_RMIF_SCOPE_Y                  ((0x2085  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define DI_AFBCE_MMU_RMIF_RO_STAT                  ((0x2086  << 2) + 0xff000000)
//Bit 15:0  reg_status        // unsigned ,
#define DI_AFBCE_PIP_CTRL                          ((0x208a  << 2) + 0xff000000)
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define DI_AFBCE_ROT_CTRL                          ((0x208b  << 2) + 0xff000000)
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define DI_AFBCE_DIMM_CTRL                         ((0x208c  << 2) + 0xff000000)
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define DI_AFBCE_BND_DEC_MISC                      ((0x208d  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define DI_AFBCE_RD_ARB_MISC                       ((0x208e  << 2) + 0xff000000)
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_afbc_enc0_regs.h
//
// the segment is 8'h90-8'ha3
//
// Reading file:  ./di_wrmif0_regs.h
//
#define NRWR_DBG_AXI_CMD_CNT                       ((0x2090  << 2) + 0xff000000)
#define NRWR_DBG_AXI_DAT_CNT                       ((0x2091  << 2) + 0xff000000)
#define DI_NRWR_CANVAS                             ((0x2092  << 2) + 0xff000000)
#define DI_NRWR_URGENT                             ((0x2093  << 2) + 0xff000000)
#define DI_NRWR_X                                  ((0x2094  << 2) + 0xff000000)
#define DI_NRWR_Y                                  ((0x2095  << 2) + 0xff000000)
//bit 31:30		  NRWR_words_lim
//bit 29		  NRWR_rev_y
//bit 28:16		  NRWR_start_y
//bit 15		  NRWR_ext_en
//bit 12:0		  NRWR_end_y
#define DI_NRWR_CTRL                               ((0x2096  << 2) + 0xff000000)
//bit 31		  pending_ddr_wrrsp_NRWR
//bit 30		  NRWR_reg_swap
//bit 29:26		  NRWR_burst_lim
//bit 25		  NRWR_canvas_syncen
//bit 24		  NRWR_no_clk_gate
//bit 23:22		  NRWR_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas 2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20		  NRWR_hconv_mode
//bit 19:18		  NRWR_vconv_mode
//bit 17		  NRWR_swap_cbcr
//bit 16		  NRWR_urgent
//bit 15:8		  NRWR_canvas_index_chroma
//bit 7:0		  NRWR_canvas_index_luma
#define DI_NRWR_SHRK_CTRL                          ((0x2097  << 2) + 0xff000000)
//bit   31:10     reserved
//bit   9:8       reg_vshrk_mode        unsigned, default = 0, 0:1/2 horizontal shrink 1:1/4 horizontal shrink 2:1/8 horizontal shrink
//bit   7:6       reg_hshrk_mode        unsigned, default = 0, 0:1/2 vertical shrink 1:1/4 vertical shrink 2:1/8 vertical shrink
//bit   5:2       reg_gclk_ctrl         unsigned, default = 0
//bit   1         reg_frm_rst           unsigned, default = 0
//bit   0         reg_shrk_en           unsigned, default = 0
#define DI_NRWR_SHRK_SIZE                          ((0x2098  << 2) + 0xff000000)
//bit   31:26     reserved
//bit   25:13     reg_frm_hsize         unsigned, default = 1920, hsize in
//bit   12:0      reg_frm_vsize         unsigned, default = 1080, vsize in
#define DI_NRWR_CROP_CTRL                          ((0x209a  << 2) + 0xff000000)
//Bit   31        reg_crop_en           unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30:4      reserved
//Bit   3:0       reg_hold_line         unsigned  , RW,default = 4,dimm_layer data
#define DI_NRWR_CROP_DIMM_CTRL                     ((0x209b  << 2) + 0xff000000)
//Bit   31        reg_dimm_layer_en     unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data         unsigned  , RW,default = 29'h00080200,dimm_layer data
#define DI_NRWR_CROP_SIZE_IN                       ((0x209c  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     reg_crop_hsize         unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     reg_crop_vsize         unsigned, default = 1080 , pic vert size in  unit: pixel
#define DI_NRWR_CROP_HSCOPE                        ((0x209d  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_h      unsigned, default = 1919 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_h      unsigned, default = 0    ;
#define DI_NRWR_CROP_VSCOPE                        ((0x209e  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_v      unsigned, default = 1079 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_v      unsigned, default = 0    ;
#define DI_NRWR_BADDR0                             ((0x20a0  << 2) + 0xff000000)
//Bit   31:0      wmif_baddr_luma        unsigned, default = 0x20000
#define DI_NRWR_STRIDE0                            ((0x20a1  << 2) + 0xff000000)
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_luma       unsigned, default = 0x1000;
#define DI_NRWR_BADDR1                             ((0x20a2  << 2) + 0xff000000)
//Bit   31:0      wmif_baddr_chroma      unsigned, default = 0x20000
#define DI_NRWR_STRIDE1                            ((0x20a3  << 2) + 0xff000000)
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_chroma     unsigned, default = 0x1000;
//
// Closing file:  ./di_wrmif0_regs.h
//
// di afbc_enc
// the segment is 8'hc0-8'hef
//
// Reading file:  ./di_afbc_enc1_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DI_AFBCE1_ENABLE                           ((0x20c0  << 2) + 0xff000000)
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    di_AFBCE1_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define DI_AFBCE1_MODE                             ((0x20c1  << 2) + 0xff000000)
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved         unsigned, default = 0 , enable singal of crop
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define DI_AFBCE1_SIZE_IN                          ((0x20c2  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vert size in  unit: pixel
#define DI_AFBCE1_BLK_SIZE_IN                      ((0x20c3  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vert size in  unit: pixel
#define DI_AFBCE1_HEAD_BADDR                       ((0x20c4  << 2) + 0xff000000)
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define DI_AFBCE1_MIF_SIZE                         ((0x20c5  << 2) + 0xff000000)
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define DI_AFBCE1_PIXEL_IN_HOR_SCOPE               ((0x20c6  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define DI_AFBCE1_PIXEL_IN_VER_SCOPE               ((0x20c7  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define DI_AFBCE1_CONV_CTRL                        ((0x20c8  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define DI_AFBCE1_MIF_HOR_SCOPE                    ((0x20c9  << 2) + 0xff000000)
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define DI_AFBCE1_MIF_VER_SCOPE                    ((0x20ca  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define DI_AFBCE1_STAT1                            ((0x20cb  << 2) + 0xff000000)
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define DI_AFBCE1_STAT2                            ((0x20cc  << 2) + 0xff000000)
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define DI_AFBCE1_FORMAT                           ((0x20cd  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define DI_AFBCE1_MODE_EN                          ((0x20ce  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define DI_AFBCE1_DWSCALAR                         ((0x20cf  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define DI_AFBCE1_DEFCOLOR_1                       ((0x20d0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define DI_AFBCE1_DEFCOLOR_2                       ((0x20d1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define DI_AFBCE1_QUANT_ENABLE                     ((0x20d2  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define DI_AFBCE1_IQUANT_LUT_1                     ((0x20d3  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE1_IQUANT_LUT_2                     ((0x20d4  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE1_IQUANT_LUT_3                     ((0x20d5  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE1_IQUANT_LUT_4                     ((0x20d6  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define DI_AFBCE1_RQUANT_LUT_1                     ((0x20d7  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define DI_AFBCE1_RQUANT_LUT_2                     ((0x20d8  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define DI_AFBCE1_RQUANT_LUT_3                     ((0x20d9  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define DI_AFBCE1_RQUANT_LUT_4                     ((0x20da  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define DI_AFBCE1_YUV_FORMAT_CONV_MODE             ((0x20db  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define DI_AFBCE1_DUMMY_DATA                       ((0x20dc  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define DI_AFBCE1_CLR_FLAG                         ((0x20dd  << 2) + 0xff000000)
//Bit 31:0         reg_di_AFBCE1_clr_flag           // unsigned, default = 0  ;
#define DI_AFBCE1_STA_FLAGT                        ((0x20de  << 2) + 0xff000000)
//Bit 31:0         ro_di_AFBCE1__sta_flag        // unsigned, RO,default = 0  ;
#define DI_AFBCE1_MMU_NUM                          ((0x20df  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define DI_AFBCE1_MMU_RMIF_CTRL1                   ((0x20e0  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define DI_AFBCE1_MMU_RMIF_CTRL2                   ((0x20e1  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define DI_AFBCE1_MMU_RMIF_CTRL3                   ((0x20e2  << 2) + 0xff000000)
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define DI_AFBCE1_MMU_RMIF_CTRL4                   ((0x20e3  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define DI_AFBCE1_MMU_RMIF_SCOPE_X                 ((0x20e4  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define DI_AFBCE1_MMU_RMIF_SCOPE_Y                 ((0x20e5  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define DI_AFBCE1_MMU_RMIF_RO_STAT                 ((0x20e6  << 2) + 0xff000000)
//Bit 15:0  reg_status        // unsigned ,
#define DI_AFBCE1_PIP_CTRL                         ((0x20ea  << 2) + 0xff000000)
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define DI_AFBCE1_ROT_CTRL                         ((0x20eb  << 2) + 0xff000000)
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define DI_AFBCE1_DIMM_CTRL                        ((0x20ec  << 2) + 0xff000000)
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define DI_AFBCE1_BND_DEC_MISC                     ((0x20ed  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define DI_AFBCE1_RD_ARB_MISC                      ((0x20ee  << 2) + 0xff000000)
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_afbc_enc1_regs.h
//
// the segment is 8'hf0-8'hff, 8'ha8-8'hab
//
// Reading file:  ./di_wrmif1_regs.h
//
#define DIWR_DBG_AXI_CMD_CNT                       ((0x20f0  << 2) + 0xff000000)
#define DIWR_DBG_AXI_DAT_CNT                       ((0x20f1  << 2) + 0xff000000)
#define DI_DIWR_CANVAS                             ((0x20f2  << 2) + 0xff000000)
#define DI_DIWR_URGENT                             ((0x20f3  << 2) + 0xff000000)
#define DI_DIWR_X                                  ((0x20f4  << 2) + 0xff000000)
#define DI_DIWR_Y                                  ((0x20f5  << 2) + 0xff000000)
//bit 31:30		  diwr_words_lim
//bit 29		  diwr_rev_y
//bit 28:16		  diwr_start_y
//bit 15		  diwr_ext_en
//bit 12:0		  diwr_end_y
#define DI_DIWR_CTRL                               ((0x20f6  << 2) + 0xff000000)
//bit 31		  pending_ddr_wrrsp_diwr
//bit 30		  diwr_reg_swap
//bit 29:26		  diwr_burst_lim
//bit 25		  diwr_canvas_syncen
//bit 24		  diwr_no_clk_gate
//bit 23:22		  diwr_rgb_mode  0:422 to one canvas;1:4:4:4 to one canvas 2:Y to luma , CBCR to chroma canvas ,for nv12/21; 3 : reserved
//bit 21:20		  diwr_hconv_mode
//bit 19:18		  diwr_vconv_mode
//bit 17		  diwr_swap_cbcr
//bit 16		  diwr_urgent
//bit 15:8		  diwr_canvas_index_chroma
//bit 7:0		  diwr_canvas_index_luma
#define DI_DIWR_SHRK_CTRL                          ((0x20f7  << 2) + 0xff000000)
//bit   31:10     reserved
//bit   9:8       reg_vshrk_mode        unsigned, default = 0, 0:1/2 horizontal shrink 1:1/4 horizontal shrink 2:1/8 horizontal shrink
//bit   7:6       reg_hshrk_mode        unsigned, default = 0, 0:1/2 vertical shrink 1:1/4 vertical shrink 2:1/8 vertical shrink
//bit   5:2       reg_gclk_ctrl         unsigned, default = 0
//bit   1         reg_frm_rst           unsigned, default = 0
//bit   0         reg_shrk_en           unsigned, default = 0
#define DI_DIWR_SHRK_SIZE                          ((0x20f8  << 2) + 0xff000000)
//bit   31:26     reserved
//bit   25:13     reg_frm_hsize         unsigned, default = 1920, hsize in
//bit   12:0      reg_frm_vsize         unsigned, default = 1080, vsize in
#define DI_DIWR_CROP_CTRL                          ((0x20fa  << 2) + 0xff000000)
//Bit   31        reg_crop_en           unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30:4      reserved
//Bit   3:0       reg_hold_line         unsigned  , RW,default = 4,dimm_layer data
#define DI_DIWR_CROP_DIMM_CTRL                     ((0x20fb  << 2) + 0xff000000)
//Bit   31        reg_dimm_layer_en     unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data         unsigned  , RW,default = 29'h00080200,dimm_layer data
#define DI_DIWR_CROP_SIZE_IN                       ((0x20fc  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     reg_crop_hsize         unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     reg_crop_vsize         unsigned, default = 1080 , pic vert size in  unit: pixel
#define DI_DIWR_CROP_HSCOPE                        ((0x20fd  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_h      unsigned, default = 1919 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_h      unsigned, default = 0    ;
#define DI_DIWR_CROP_VSCOPE                        ((0x20fe  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16,    reg_cropwin_end_v      unsigned, default = 1079 ;
//Bit   15:13,    reserved
//Bit   12:0,     reg_cropwin_bgn_v      unsigned, default = 0    ;
#define DI_DIWR_BADDR0                             ((0x20a8  << 2) + 0xff000000)
//Bit   31:0      wmif_baddr_luma        unsigned, default = 0x20000
#define DI_DIWR_STRIDE0                            ((0x20a9  << 2) + 0xff000000)
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_luma       unsigned, default = 0x1000;
#define DI_DIWR_BADDR1                             ((0x20aa  << 2) + 0xff000000)
//Bit   31:0      wmif_baddr_chroma      unsigned, default = 0x20000
#define DI_DIWR_STRIDE1                            ((0x20ab  << 2) + 0xff000000)
//Bit   31        canvas_mode_en         unsigned, default = 0    ;
//Bit   30:14     reserved
//Bit   13:0      wmif_stride_chroma     unsigned, default = 0x1000;
//
// Closing file:  ./di_wrmif1_regs.h
//
//
// Closing file:  ./vregs_clk1.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC1A_VCBUS_BASE = 0x21
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc_1_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define ENCP1_VFIFO2VD_CTL                         ((0x2158  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCP1_VFIFO2VD_PIXEL_START                 ((0x2159  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCP1_VFIFO2VD_PIXEL_END                   ((0x215a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCP1_VFIFO2VD_LINE_TOP_START              ((0x215b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCP1_VFIFO2VD_LINE_TOP_END                ((0x215c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCP1_VFIFO2VD_LINE_BOT_START              ((0x215d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCP1_VFIFO2VD_LINE_BOT_END                ((0x215e  << 2) + 0xff000000)
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define VENC1_SYNC_ROUTE                           ((0x2160  << 2) + 0xff000000)
        //             encoder address space is assigned
        //             to the video encoder interface status
        //             register
#define VENC1_VIDEO_EXSRC                          ((0x2161  << 2) + 0xff000000)
#define VENC1_DVI_SETTING                          ((0x2162  << 2) + 0xff000000)
#define VENC1_C656_CTRL                            ((0x2163  << 2) + 0xff000000)
#define VENC1_UPSAMPLE_CTRL0                       ((0x2164  << 2) + 0xff000000)
#define VENC1_UPSAMPLE_CTRL1                       ((0x2165  << 2) + 0xff000000)
#define VENC1_UPSAMPLE_CTRL2                       ((0x2166  << 2) + 0xff000000)
// Invert control for tcon output
// bit[15:14] -- vsync, hsync,
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define TCON1_INVERT_CTL                           ((0x2167  << 2) + 0xff000000)
#define VENC1_VIDEO_PROG_MODE                      ((0x2168  << 2) + 0xff000000)
//---- Venc pixel/line info
#define VENC1_ENCI_LINE                            ((0x2169  << 2) + 0xff000000)
#define VENC1_ENCI_PIXEL                           ((0x216a  << 2) + 0xff000000)
#define VENC1_ENCP_LINE                            ((0x216b  << 2) + 0xff000000)
#define VENC1_ENCP_PIXEL                           ((0x216c  << 2) + 0xff000000)
//---- Status
#define VENC1_STATA                                ((0x216d  << 2) + 0xff000000)
//---- Interrupt setting
#define VENC1_INTCTRL                              ((0x216e  << 2) + 0xff000000)
#define VENC1_INTFLAG                              ((0x216f  << 2) + 0xff000000)
//--------- Video test configuration
#define VENC1_VIDEO_TST_EN                         ((0x2170  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_MDSEL                      ((0x2171  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_Y                          ((0x2172  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_CB                         ((0x2173  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_CR                         ((0x2174  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_CLRBAR_STRT                ((0x2175  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_CLRBAR_WIDTH               ((0x2176  << 2) + 0xff000000)
#define VENC1_VIDEO_TST_VDCNT_STSET                ((0x2177  << 2) + 0xff000000)
//----- Video dac setting
#define VENC1_VDAC_DACSEL0                         ((0x2178  << 2) + 0xff000000)
#define VENC1_VDAC_DACSEL1                         ((0x2179  << 2) + 0xff000000)
#define VENC1_VDAC_DACSEL2                         ((0x217a  << 2) + 0xff000000)
#define VENC1_VDAC_DACSEL3                         ((0x217b  << 2) + 0xff000000)
#define VENC1_VDAC_DACSEL4                         ((0x217c  << 2) + 0xff000000)
#define VENC1_VDAC_DACSEL5                         ((0x217d  << 2) + 0xff000000)
#define VENC1_VDAC_SETTING                         ((0x217e  << 2) + 0xff000000)
#define VENC1_VDAC_TST_VAL                         ((0x217f  << 2) + 0xff000000)
#define VENC1_VDAC_DAC0_GAINCTRL                   ((0x21f0  << 2) + 0xff000000)
#define VENC1_VDAC_DAC0_OFFSET                     ((0x21f1  << 2) + 0xff000000)
#define VENC1_VDAC_DAC1_GAINCTRL                   ((0x21f2  << 2) + 0xff000000)
#define VENC1_VDAC_DAC1_OFFSET                     ((0x21f3  << 2) + 0xff000000)
#define VENC1_VDAC_DAC2_GAINCTRL                   ((0x21f4  << 2) + 0xff000000)
#define VENC1_VDAC_DAC2_OFFSET                     ((0x21f5  << 2) + 0xff000000)
#define VENC1_VDAC_DAC3_GAINCTRL                   ((0x21f6  << 2) + 0xff000000)
#define VENC1_VDAC_DAC3_OFFSET                     ((0x21f7  << 2) + 0xff000000)
#define VENC1_VDAC_DAC4_GAINCTRL                   ((0x21f8  << 2) + 0xff000000)
#define VENC1_VDAC_DAC4_OFFSET                     ((0x21f9  << 2) + 0xff000000)
#define VENC1_VDAC_DAC5_GAINCTRL                   ((0x21fa  << 2) + 0xff000000)
#define VENC1_VDAC_DAC5_OFFSET                     ((0x21fb  << 2) + 0xff000000)
#define VENC1_VDAC_FIFO_CTRL                       ((0x21fc  << 2) + 0xff000000)
#define ENCL1_TCON_INVERT_CTL                      ((0x21fd  << 2) + 0xff000000)
//
// Closing file:  ./venc_1_regs.h
//
//
// Reading file:  ./enc480p_1_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define ENCP1_VIDEO_EN                             ((0x2180  << 2) + 0xff000000)
#define ENCP1_VIDEO_SYNC_MODE                      ((0x2181  << 2) + 0xff000000)
#define ENCP1_MACV_EN                              ((0x2182  << 2) + 0xff000000)
#define ENCP1_VIDEO_Y_SCL                          ((0x2183  << 2) + 0xff000000)
#define ENCP1_VIDEO_PB_SCL                         ((0x2184  << 2) + 0xff000000)
#define ENCP1_VIDEO_PR_SCL                         ((0x2185  << 2) + 0xff000000)
#define ENCP1_VIDEO_SYNC_SCL                       ((0x2186  << 2) + 0xff000000)
#define ENCP1_VIDEO_MACV_SCL                       ((0x2187  << 2) + 0xff000000)
#define ENCP1_VIDEO_Y_OFFST                        ((0x2188  << 2) + 0xff000000)
#define ENCP1_VIDEO_PB_OFFST                       ((0x2189  << 2) + 0xff000000)
#define ENCP1_VIDEO_PR_OFFST                       ((0x218a  << 2) + 0xff000000)
#define ENCP1_VIDEO_SYNC_OFFST                     ((0x218b  << 2) + 0xff000000)
#define ENCP1_VIDEO_MACV_OFFST                     ((0x218c  << 2) + 0xff000000)
//----- Video mode
#define ENCP1_VIDEO_MODE                           ((0x218d  << 2) + 0xff000000)
#define ENCP1_VIDEO_MODE_ADV                       ((0x218e  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCP1_DBG_PX_RST                           ((0x2190  << 2) + 0xff000000)
#define ENCP1_DBG_LN_RST                           ((0x2191  << 2) + 0xff000000)
#define ENCP1_DBG_PX_INT                           ((0x2192  << 2) + 0xff000000)
#define ENCP1_DBG_LN_INT                           ((0x2193  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCP1_VIDEO_YFP1_HTIME                     ((0x2194  << 2) + 0xff000000)
#define ENCP1_VIDEO_YFP2_HTIME                     ((0x2195  << 2) + 0xff000000)
#define ENCP1_VIDEO_YC_DLY                         ((0x2196  << 2) + 0xff000000)
#define ENCP1_VIDEO_MAX_PXCNT                      ((0x2197  << 2) + 0xff000000)
#define ENCP1_VIDEO_HSPULS_BEGIN                   ((0x2198  << 2) + 0xff000000)
#define ENCP1_VIDEO_HSPULS_END                     ((0x2199  << 2) + 0xff000000)
#define ENCP1_VIDEO_HSPULS_SWITCH                  ((0x219a  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSPULS_BEGIN                   ((0x219b  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSPULS_END                     ((0x219c  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSPULS_BLINE                   ((0x219d  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSPULS_ELINE                   ((0x219e  << 2) + 0xff000000)
#define ENCP1_VIDEO_EQPULS_BEGIN                   ((0x219f  << 2) + 0xff000000)
#define ENCP1_VIDEO_EQPULS_END                     ((0x21a0  << 2) + 0xff000000)
#define ENCP1_VIDEO_EQPULS_BLINE                   ((0x21a1  << 2) + 0xff000000)
#define ENCP1_VIDEO_EQPULS_ELINE                   ((0x21a2  << 2) + 0xff000000)
#define ENCP1_VIDEO_HAVON_END                      ((0x21a3  << 2) + 0xff000000)
#define ENCP1_VIDEO_HAVON_BEGIN                    ((0x21a4  << 2) + 0xff000000)
#define ENCP1_VIDEO_VAVON_ELINE                    ((0x21af  << 2) + 0xff000000)
#define ENCP1_VIDEO_VAVON_BLINE                    ((0x21a6  << 2) + 0xff000000)
#define ENCP1_VIDEO_HSO_BEGIN                      ((0x21a7  << 2) + 0xff000000)
#define ENCP1_VIDEO_HSO_END                        ((0x21a8  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSO_BEGIN                      ((0x21a9  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSO_END                        ((0x21aa  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSO_BLINE                      ((0x21ab  << 2) + 0xff000000)
#define ENCP1_VIDEO_VSO_ELINE                      ((0x21ac  << 2) + 0xff000000)
#define ENCP1_VIDEO_SYNC_WAVE_CURVE                ((0x21ad  << 2) + 0xff000000)
#define ENCP1_VIDEO_MAX_LNCNT                      ((0x21ae  << 2) + 0xff000000)
#define ENCP1_VIDEO_SY_VAL                         ((0x21b0  << 2) + 0xff000000)
#define ENCP1_VIDEO_SY2_VAL                        ((0x21b1  << 2) + 0xff000000)
#define ENCP1_VIDEO_BLANKY_VAL                     ((0x21b2  << 2) + 0xff000000)
#define ENCP1_VIDEO_BLANKPB_VAL                    ((0x21b3  << 2) + 0xff000000)
#define ENCP1_VIDEO_BLANKPR_VAL                    ((0x21b4  << 2) + 0xff000000)
#define ENCP1_VIDEO_HOFFST                         ((0x21b5  << 2) + 0xff000000)
#define ENCP1_VIDEO_VOFFST                         ((0x21b6  << 2) + 0xff000000)
#define ENCP1_VIDEO_RGB_CTRL                       ((0x21b7  << 2) + 0xff000000)
#define ENCP1_VIDEO_FILT_CTRL                      ((0x21b8  << 2) + 0xff000000)
#define ENCP1_VIDEO_OFLD_VPEQ_OFST                 ((0x21b9  << 2) + 0xff000000)
#define ENCP1_VIDEO_OFLD_VOAV_OFST                 ((0x21ba  << 2) + 0xff000000)
#define ENCP1_VIDEO_MATRIX_CB                      ((0x21bb  << 2) + 0xff000000)
#define ENCP1_VIDEO_MATRIX_CR                      ((0x21bc  << 2) + 0xff000000)
#define ENCP1_VIDEO_RGBIN_CTRL                     ((0x21bd  << 2) + 0xff000000)
//------------------Macrovision advanced setting
#define ENCP1_MACV_BLANKY_VAL                      ((0x21c0  << 2) + 0xff000000)
#define ENCP1_MACV_MAXY_VAL                        ((0x21c1  << 2) + 0xff000000)
#define ENCP1_MACV_1ST_PSSYNC_STRT                 ((0x21c2  << 2) + 0xff000000)
#define ENCP1_MACV_PSSYNC_STRT                     ((0x21c3  << 2) + 0xff000000)
#define ENCP1_MACV_AGC_STRT                        ((0x21c4  << 2) + 0xff000000)
#define ENCP1_MACV_AGC_END                         ((0x21c5  << 2) + 0xff000000)
#define ENCP1_MACV_WAVE_END                        ((0x21c6  << 2) + 0xff000000)
#define ENCP1_MACV_STRTLINE                        ((0x21c7  << 2) + 0xff000000)
#define ENCP1_MACV_ENDLINE                         ((0x21c8  << 2) + 0xff000000)
#define ENCP1_MACV_TS_CNT_MAX_L                    ((0x21c9  << 2) + 0xff000000)
#define ENCP1_MACV_TS_CNT_MAX_H                    ((0x21ca  << 2) + 0xff000000)
#define ENCP1_MACV_TIME_DOWN                       ((0x21cb  << 2) + 0xff000000)
#define ENCP1_MACV_TIME_LO                         ((0x21cc  << 2) + 0xff000000)
#define ENCP1_MACV_TIME_UP                         ((0x21cd  << 2) + 0xff000000)
#define ENCP1_MACV_TIME_RST                        ((0x21ce  << 2) + 0xff000000)
//---------------- VBI control -------------------
#define ENCP1_VBI_CTRL                             ((0x21d0  << 2) + 0xff000000)
#define ENCP1_VBI_SETTING                          ((0x21d1  << 2) + 0xff000000)
#define ENCP1_VBI_BEGIN                            ((0x21d2  << 2) + 0xff000000)
#define ENCP1_VBI_WIDTH                            ((0x21d3  << 2) + 0xff000000)
#define ENCP1_VBI_HVAL                             ((0x21d4  << 2) + 0xff000000)
#define ENCP1_VBI_DATA0                            ((0x21d5  << 2) + 0xff000000)
#define ENCP1_VBI_DATA1                            ((0x21d6  << 2) + 0xff000000)
//----------------C656 OUT Control------------- Grant
#define C656_HS_ST_1                               ((0x21e0  << 2) + 0xff000000)
#define C656_HS_ED_1                               ((0x21e1  << 2) + 0xff000000)
#define C656_VS_LNST_E_1                           ((0x21e2  << 2) + 0xff000000)
#define C656_VS_LNST_O_1                           ((0x21e3  << 2) + 0xff000000)
#define C656_VS_LNED_E_1                           ((0x21e4  << 2) + 0xff000000)
#define C656_VS_LNED_O_1                           ((0x21e5  << 2) + 0xff000000)
#define C656_FS_LNST_1                             ((0x21e6  << 2) + 0xff000000)
#define C656_FS_LNED_1                             ((0x21e7  << 2) + 0xff000000)
#define ENCP1_VRR_CTRL                             ((0x21e8  << 2) + 0xff000000)
#define ENCP1_VRR_ADJ_LMT                          ((0x21e9  << 2) + 0xff000000)
#define ENCP1_VRR_CTRL1                            ((0x21ea  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./enc480p_1_regs.h
//
//
// Reading file:  ./enci_1_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define ENCI1_VIDEO_MODE                           ((0x2100  << 2) + 0xff000000)
#define ENCI1_VIDEO_MODE_ADV                       ((0x2101  << 2) + 0xff000000)
#define ENCI1_VIDEO_FSC_ADJ                        ((0x2102  << 2) + 0xff000000)
#define ENCI1_VIDEO_BRIGHT                         ((0x2103  << 2) + 0xff000000)
#define ENCI1_VIDEO_CONT                           ((0x2104  << 2) + 0xff000000)
#define ENCI1_VIDEO_SAT                            ((0x2105  << 2) + 0xff000000)
#define ENCI1_VIDEO_HUE                            ((0x2106  << 2) + 0xff000000)
#define ENCI1_VIDEO_SCH                            ((0x2107  << 2) + 0xff000000)
#define ENCI1_SYNC_MODE                            ((0x2108  << 2) + 0xff000000)
#define ENCI1_SYNC_CTRL                            ((0x2109  << 2) + 0xff000000)
#define ENCI1_SYNC_HSO_BEGIN                       ((0x210a  << 2) + 0xff000000)
#define ENCI1_SYNC_HSO_END                         ((0x210b  << 2) + 0xff000000)
#define ENCI1_SYNC_VSO_EVN                         ((0x210c  << 2) + 0xff000000)
#define ENCI1_SYNC_VSO_ODD                         ((0x210d  << 2) + 0xff000000)
#define ENCI1_SYNC_VSO_EVNLN                       ((0x210e  << 2) + 0xff000000)
#define ENCI1_SYNC_VSO_ODDLN                       ((0x210f  << 2) + 0xff000000)
#define ENCI1_SYNC_HOFFST                          ((0x2110  << 2) + 0xff000000)
#define ENCI1_SYNC_VOFFST                          ((0x2111  << 2) + 0xff000000)
#define ENCI1_SYNC_ADJ                             ((0x2112  << 2) + 0xff000000)
#define ENCI1_RGB_SETTING                          ((0x2113  << 2) + 0xff000000)
//`define    ENCI1_CMPN_MATRIX_CB        8'h14
//`define    ENCI1_CMPN_MATRIX_CR        8'h15
#define ENCI1_DE_H_BEGIN                           ((0x2116  << 2) + 0xff000000)
#define ENCI1_DE_H_END                             ((0x2117  << 2) + 0xff000000)
#define ENCI1_DE_V_BEGIN_EVEN                      ((0x2118  << 2) + 0xff000000)
#define ENCI1_DE_V_END_EVEN                        ((0x2119  << 2) + 0xff000000)
#define ENCI1_DE_V_BEGIN_ODD                       ((0x211a  << 2) + 0xff000000)
#define ENCI1_DE_V_END_ODD                         ((0x211b  << 2) + 0xff000000)
#define ENCI1_VBI_SETTING                          ((0x2120  << 2) + 0xff000000)
#define ENCI1_VBI_CCDT_EVN                         ((0x2121  << 2) + 0xff000000)
#define ENCI1_VBI_CCDT_ODD                         ((0x2122  << 2) + 0xff000000)
#define ENCI1_VBI_CC525_LN                         ((0x2123  << 2) + 0xff000000)
#define ENCI1_VBI_CC625_LN                         ((0x2124  << 2) + 0xff000000)
#define ENCI1_VBI_WSSDT                            ((0x2125  << 2) + 0xff000000)
#define ENCI1_VBI_WSS_LN                           ((0x2126  << 2) + 0xff000000)
#define ENCI1_VBI_CGMSDT_L                         ((0x2127  << 2) + 0xff000000)
#define ENCI1_VBI_CGMSDT_H                         ((0x2128  << 2) + 0xff000000)
#define ENCI1_VBI_CGMS_LN                          ((0x2129  << 2) + 0xff000000)
#define ENCI1_VBI_TTX_HTIME                        ((0x212a  << 2) + 0xff000000)
#define ENCI1_VBI_TTX_LN                           ((0x212b  << 2) + 0xff000000)
#define ENCI1_VBI_TTXDT0                           ((0x212c  << 2) + 0xff000000)
#define ENCI1_VBI_TTXDT1                           ((0x212d  << 2) + 0xff000000)
#define ENCI1_VBI_TTXDT2                           ((0x212e  << 2) + 0xff000000)
#define ENCI1_VBI_TTXDT3                           ((0x212f  << 2) + 0xff000000)
#define ENCI1_MACV_N0                              ((0x2130  << 2) + 0xff000000)
#define ENCI1_MACV_N1                              ((0x2131  << 2) + 0xff000000)
#define ENCI1_MACV_N2                              ((0x2132  << 2) + 0xff000000)
#define ENCI1_MACV_N3                              ((0x2133  << 2) + 0xff000000)
#define ENCI1_MACV_N4                              ((0x2134  << 2) + 0xff000000)
#define ENCI1_MACV_N5                              ((0x2135  << 2) + 0xff000000)
#define ENCI1_MACV_N6                              ((0x2136  << 2) + 0xff000000)
#define ENCI1_MACV_N7                              ((0x2137  << 2) + 0xff000000)
#define ENCI1_MACV_N8                              ((0x2138  << 2) + 0xff000000)
#define ENCI1_MACV_N9                              ((0x2139  << 2) + 0xff000000)
#define ENCI1_MACV_N10                             ((0x213a  << 2) + 0xff000000)
#define ENCI1_MACV_N11                             ((0x213b  << 2) + 0xff000000)
#define ENCI1_MACV_N12                             ((0x213c  << 2) + 0xff000000)
#define ENCI1_MACV_N13                             ((0x213d  << 2) + 0xff000000)
#define ENCI1_MACV_N14                             ((0x213e  << 2) + 0xff000000)
#define ENCI1_MACV_N15                             ((0x213f  << 2) + 0xff000000)
#define ENCI1_MACV_N16                             ((0x2140  << 2) + 0xff000000)
#define ENCI1_MACV_N17                             ((0x2141  << 2) + 0xff000000)
#define ENCI1_MACV_N18                             ((0x2142  << 2) + 0xff000000)
#define ENCI1_MACV_N19                             ((0x2143  << 2) + 0xff000000)
#define ENCI1_MACV_N20                             ((0x2144  << 2) + 0xff000000)
#define ENCI1_MACV_N21                             ((0x2145  << 2) + 0xff000000)
#define ENCI1_MACV_N22                             ((0x2146  << 2) + 0xff000000)
//`define    ENCI1_MACV_P_AGC            8'h47
#define ENCI1_DBG_PX_RST                           ((0x2148  << 2) + 0xff000000)
#define ENCI1_DBG_FLDLN_RST                        ((0x2149  << 2) + 0xff000000)
#define ENCI1_DBG_PX_INT                           ((0x214a  << 2) + 0xff000000)
#define ENCI1_DBG_FLDLN_INT                        ((0x214b  << 2) + 0xff000000)
#define ENCI1_DBG_MAXPX                            ((0x214c  << 2) + 0xff000000)
#define ENCI1_DBG_MAXLN                            ((0x214d  << 2) + 0xff000000)
#define ENCI1_MACV_MAX_AMP                         ((0x2150  << 2) + 0xff000000)
#define ENCI1_MACV_PULSE_LO                        ((0x2151  << 2) + 0xff000000)
#define ENCI1_MACV_PULSE_HI                        ((0x2152  << 2) + 0xff000000)
#define ENCI1_MACV_BKP_MAX                         ((0x2153  << 2) + 0xff000000)
#define ENCI1_CFILT_CTRL                           ((0x2154  << 2) + 0xff000000)
#define ENCI1_CFILT7                               ((0x2155  << 2) + 0xff000000)
#define ENCI1_YC_DELAY                             ((0x2156  << 2) + 0xff000000)
#define ENCI1_VIDEO_EN                             ((0x2157  << 2) + 0xff000000)
//
// Closing file:  ./enci_1_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC1B_VCBUS_BASE = 0x22
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc2_1_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef)
//===========================================================================
// Program video control signals from ENCI core to DVI/HDMI interface
#define ENCI1_DVI_HSO_BEGIN                        ((0x2200  << 2) + 0xff000000)
#define ENCI1_DVI_HSO_END                          ((0x2201  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_BLINE_EVN                    ((0x2202  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_BLINE_ODD                    ((0x2203  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_ELINE_EVN                    ((0x2204  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_ELINE_ODD                    ((0x2205  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_BEGIN_EVN                    ((0x2206  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_BEGIN_ODD                    ((0x2207  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_END_EVN                      ((0x2208  << 2) + 0xff000000)
#define ENCI1_DVI_VSO_END_ODD                      ((0x2209  << 2) + 0xff000000)
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define ENCI1_CFILT_CTRL2                          ((0x220a  << 2) + 0xff000000)
#define ENCI1_DACSEL_0                             ((0x220b  << 2) + 0xff000000)
#define ENCI1_DACSEL_1                             ((0x220c  << 2) + 0xff000000)
#define ENCP1_DACSEL_0                             ((0x220d  << 2) + 0xff000000)
#define ENCP1_DACSEL_1                             ((0x220e  << 2) + 0xff000000)
#define ENCP1_MAX_LINE_SWITCH_POINT                ((0x220f  << 2) + 0xff000000)
#define ENCI1_TST_EN                               ((0x2210  << 2) + 0xff000000)
#define ENCI1_TST_MDSEL                            ((0x2211  << 2) + 0xff000000)
#define ENCI1_TST_Y                                ((0x2212  << 2) + 0xff000000)
#define ENCI1_TST_CB                               ((0x2213  << 2) + 0xff000000)
#define ENCI1_TST_CR                               ((0x2214  << 2) + 0xff000000)
#define ENCI1_TST_CLRBAR_STRT                      ((0x2215  << 2) + 0xff000000)
#define ENCI1_TST_CLRBAR_WIDTH                     ((0x2216  << 2) + 0xff000000)
#define ENCI1_TST_VDCNT_STSET                      ((0x2217  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCI1_VFIFO2VD_CTL                         ((0x2218  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCI1_VFIFO2VD_PIXEL_START                 ((0x2219  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCI1_VFIFO2VD_PIXEL_END                   ((0x221a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCI1_VFIFO2VD_LINE_TOP_START              ((0x221b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCI1_VFIFO2VD_LINE_TOP_END                ((0x221c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCI1_VFIFO2VD_LINE_BOT_START              ((0x221d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCI1_VFIFO2VD_LINE_BOT_END                ((0x221e  << 2) + 0xff000000)
#define ENCI1_VFIFO2VD_CTL2                        ((0x221f  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCT1_VFIFO2VD_CTL                         ((0x2220  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCT1_VFIFO2VD_PIXEL_START                 ((0x2221  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCT1_VFIFO2VD_PIXEL_END                   ((0x2222  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCT1_VFIFO2VD_LINE_TOP_START              ((0x2223  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCT1_VFIFO2VD_LINE_TOP_END                ((0x2224  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCT1_VFIFO2VD_LINE_BOT_START              ((0x2225  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCT1_VFIFO2VD_LINE_BOT_END                ((0x2226  << 2) + 0xff000000)
#define ENCT1_VFIFO2VD_CTL2                        ((0x2227  << 2) + 0xff000000)
#define ENCT1_TST_EN                               ((0x2228  << 2) + 0xff000000)
#define ENCT1_TST_MDSEL                            ((0x2229  << 2) + 0xff000000)
#define ENCT1_TST_Y                                ((0x222a  << 2) + 0xff000000)
#define ENCT1_TST_CB                               ((0x222b  << 2) + 0xff000000)
#define ENCT1_TST_CR                               ((0x222c  << 2) + 0xff000000)
#define ENCT1_TST_CLRBAR_STRT                      ((0x222d  << 2) + 0xff000000)
#define ENCT1_TST_CLRBAR_WIDTH                     ((0x222e  << 2) + 0xff000000)
#define ENCT1_TST_VDCNT_STSET                      ((0x222f  << 2) + 0xff000000)
// Program video control signals from ENCP core to DVI/HDMI interface
#define ENCP1_DVI_HSO_BEGIN                        ((0x2230  << 2) + 0xff000000)
#define ENCP1_DVI_HSO_END                          ((0x2231  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_BLINE_EVN                    ((0x2232  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_BLINE_ODD                    ((0x2233  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_ELINE_EVN                    ((0x2234  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_ELINE_ODD                    ((0x2235  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_BEGIN_EVN                    ((0x2236  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_BEGIN_ODD                    ((0x2237  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_END_EVN                      ((0x2238  << 2) + 0xff000000)
#define ENCP1_DVI_VSO_END_ODD                      ((0x2239  << 2) + 0xff000000)
#define ENCP1_DE_H_BEGIN                           ((0x223a  << 2) + 0xff000000)
#define ENCP1_DE_H_END                             ((0x223b  << 2) + 0xff000000)
#define ENCP1_DE_V_BEGIN_EVEN                      ((0x223c  << 2) + 0xff000000)
#define ENCP1_DE_V_END_EVEN                        ((0x223d  << 2) + 0xff000000)
#define ENCP1_DE_V_BEGIN_ODD                       ((0x223e  << 2) + 0xff000000)
#define ENCP1_DE_V_END_ODD                         ((0x223f  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCI1_SYNC_LINE_LENGTH                     ((0x2240  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCI1_SYNC_PIXEL_EN                        ((0x2241  << 2) + 0xff000000)
// Bit 15 - ENCI1_sync_enable
// Bit 14 - ENCP1_sync_enable
// Bit 13 - ENCT1_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCI1_SYNC_TO_LINE_EN                      ((0x2242  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCI1_SYNC_TO_PIXEL                        ((0x2243  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCP1_SYNC_LINE_LENGTH                     ((0x2244  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCP1_SYNC_PIXEL_EN                        ((0x2245  << 2) + 0xff000000)
// Bit 15 - ENCI1_sync_enable
// Bit 14 - ENCP1_sync_enable
// Bit 13 - ENCT1_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCP1_SYNC_TO_LINE_EN                      ((0x2246  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCP1_SYNC_TO_PIXEL                        ((0x2247  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCT1_SYNC_LINE_LENGTH                     ((0x2248  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCT1_SYNC_PIXEL_EN                        ((0x2249  << 2) + 0xff000000)
// Bit 15 - ENCI1_sync_enable
// Bit 14 - ENCP1_sync_enable
// Bit 13 - ENCT1_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCT1_SYNC_TO_LINE_EN                      ((0x224a  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCT1_SYNC_TO_PIXEL                        ((0x224b  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCL1_SYNC_LINE_LENGTH                     ((0x224c  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCL1_SYNC_PIXEL_EN                        ((0x224d  << 2) + 0xff000000)
// Bit 15 - ENCI1_sync_enable
// Bit 14 - ENCP1_sync_enable
// Bit 13 - ENCT1_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCL1_SYNC_TO_LINE_EN                      ((0x224e  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCL1_SYNC_TO_PIXEL                        ((0x224f  << 2) + 0xff000000)
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define ENCP1_VFIFO2VD_CTL2                        ((0x2250  << 2) + 0xff000000)
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define VENC1_DVI_SETTING_MORE                     ((0x2251  << 2) + 0xff000000)
#define VENC1_VDAC_DAC4_FILT_CTRL0                 ((0x2254  << 2) + 0xff000000)
#define VENC1_VDAC_DAC4_FILT_CTRL1                 ((0x2255  << 2) + 0xff000000)
#define VENC1_VDAC_DAC5_FILT_CTRL0                 ((0x2256  << 2) + 0xff000000)
#define VENC1_VDAC_DAC5_FILT_CTRL1                 ((0x2257  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC1_VDAC_DAC0_FILT_CTRL0                 ((0x2258  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC1_VDAC_DAC0_FILT_CTRL1                 ((0x2259  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC1_VDAC_DAC1_FILT_CTRL0                 ((0x225a  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC1_VDAC_DAC1_FILT_CTRL1                 ((0x225b  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC1_VDAC_DAC2_FILT_CTRL0                 ((0x225c  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC1_VDAC_DAC2_FILT_CTRL1                 ((0x225d  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC1_VDAC_DAC3_FILT_CTRL0                 ((0x225e  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC1_VDAC_DAC3_FILT_CTRL1                 ((0x225f  << 2) + 0xff000000)
//===========================================================================
// ENCT registers
#define ENCT1_VIDEO_EN                             ((0x2260  << 2) + 0xff000000)
#define ENCT1_VIDEO_Y_SCL                          ((0x2261  << 2) + 0xff000000)
#define ENCT1_VIDEO_PB_SCL                         ((0x2262  << 2) + 0xff000000)
#define ENCT1_VIDEO_PR_SCL                         ((0x2263  << 2) + 0xff000000)
#define ENCT1_VIDEO_Y_OFFST                        ((0x2264  << 2) + 0xff000000)
#define ENCT1_VIDEO_PB_OFFST                       ((0x2265  << 2) + 0xff000000)
#define ENCT1_VIDEO_PR_OFFST                       ((0x2266  << 2) + 0xff000000)
//----- Video mode
#define ENCT1_VIDEO_MODE                           ((0x2267  << 2) + 0xff000000)
#define ENCT1_VIDEO_MODE_ADV                       ((0x2268  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCT1_DBG_PX_RST                           ((0x2269  << 2) + 0xff000000)
#define ENCT1_DBG_LN_RST                           ((0x226a  << 2) + 0xff000000)
#define ENCT1_DBG_PX_INT                           ((0x226b  << 2) + 0xff000000)
#define ENCT1_DBG_LN_INT                           ((0x226c  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCT1_VIDEO_YFP1_HTIME                     ((0x226d  << 2) + 0xff000000)
#define ENCT1_VIDEO_YFP2_HTIME                     ((0x226e  << 2) + 0xff000000)
#define ENCT1_VIDEO_YC_DLY                         ((0x226f  << 2) + 0xff000000)
#define ENCT1_VIDEO_MAX_PXCNT                      ((0x2270  << 2) + 0xff000000)
#define ENCT1_VIDEO_HAVON_END                      ((0x2271  << 2) + 0xff000000)
#define ENCT1_VIDEO_HAVON_BEGIN                    ((0x2272  << 2) + 0xff000000)
#define ENCT1_VIDEO_VAVON_ELINE                    ((0x2273  << 2) + 0xff000000)
#define ENCT1_VIDEO_VAVON_BLINE                    ((0x2274  << 2) + 0xff000000)
#define ENCT1_VIDEO_HSO_BEGIN                      ((0x2275  << 2) + 0xff000000)
#define ENCT1_VIDEO_HSO_END                        ((0x2276  << 2) + 0xff000000)
#define ENCT1_VIDEO_VSO_BEGIN                      ((0x2277  << 2) + 0xff000000)
#define ENCT1_VIDEO_VSO_END                        ((0x2278  << 2) + 0xff000000)
#define ENCT1_VIDEO_VSO_BLINE                      ((0x2279  << 2) + 0xff000000)
#define ENCT1_VIDEO_VSO_ELINE                      ((0x227a  << 2) + 0xff000000)
#define ENCT1_VIDEO_MAX_LNCNT                      ((0x227b  << 2) + 0xff000000)
#define ENCT1_VIDEO_BLANKY_VAL                     ((0x227c  << 2) + 0xff000000)
#define ENCT1_VIDEO_BLANKPB_VAL                    ((0x227d  << 2) + 0xff000000)
#define ENCT1_VIDEO_BLANKPR_VAL                    ((0x227e  << 2) + 0xff000000)
#define ENCT1_VIDEO_HOFFST                         ((0x227f  << 2) + 0xff000000)
#define ENCT1_VIDEO_VOFFST                         ((0x2280  << 2) + 0xff000000)
#define ENCT1_VIDEO_RGB_CTRL                       ((0x2281  << 2) + 0xff000000)
#define ENCT1_VIDEO_FILT_CTRL                      ((0x2282  << 2) + 0xff000000)
#define ENCT1_VIDEO_OFLD_VPEQ_OFST                 ((0x2283  << 2) + 0xff000000)
#define ENCT1_VIDEO_OFLD_VOAV_OFST                 ((0x2284  << 2) + 0xff000000)
#define ENCT1_VIDEO_MATRIX_CB                      ((0x2285  << 2) + 0xff000000)
#define ENCT1_VIDEO_MATRIX_CR                      ((0x2286  << 2) + 0xff000000)
#define ENCT1_VIDEO_RGBIN_CTRL                     ((0x2287  << 2) + 0xff000000)
#define ENCT1_MAX_LINE_SWITCH_POINT                ((0x2288  << 2) + 0xff000000)
#define ENCT1_DACSEL_0                             ((0x2289  << 2) + 0xff000000)
#define ENCT1_DACSEL_1                             ((0x228a  << 2) + 0xff000000)
#define ENCT1_INBUF_CNTL0                          ((0x228b  << 2) + 0xff000000)
#define ENCT1_INBUF_CNTL1                          ((0x228c  << 2) + 0xff000000)
#define ENCT1_INBUF_CNT                            ((0x228d  << 2) + 0xff000000)
#define ENCT1_INBUF_HOLD_CNT                       ((0x228e  << 2) + 0xff000000)
#define ENCT1_INBUF_FIX_PIX_NUM                    ((0x228f  << 2) + 0xff000000)
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCL1_VFIFO2VD_CTL                         ((0x2290  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCL1_VFIFO2VD_PIXEL_START                 ((0x2291  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCL1_VFIFO2VD_PIXEL_END                   ((0x2292  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCL1_VFIFO2VD_LINE_TOP_START              ((0x2293  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCL1_VFIFO2VD_LINE_TOP_END                ((0x2294  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCL1_VFIFO2VD_LINE_BOT_START              ((0x2295  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCL1_VFIFO2VD_LINE_BOT_END                ((0x2296  << 2) + 0xff000000)
#define ENCL1_VFIFO2VD_CTL2                        ((0x2297  << 2) + 0xff000000)
#define ENCL1_TST_EN                               ((0x2298  << 2) + 0xff000000)
#define ENCL1_TST_MDSEL                            ((0x2299  << 2) + 0xff000000)
#define ENCL1_TST_Y                                ((0x229a  << 2) + 0xff000000)
#define ENCL1_TST_CB                               ((0x229b  << 2) + 0xff000000)
#define ENCL1_TST_CR                               ((0x229c  << 2) + 0xff000000)
#define ENCL1_TST_CLRBAR_STRT                      ((0x229d  << 2) + 0xff000000)
#define ENCL1_TST_CLRBAR_WIDTH                     ((0x229e  << 2) + 0xff000000)
#define ENCL1_TST_VDCNT_STSET                      ((0x229f  << 2) + 0xff000000)
//===========================================================================
// ENCL1 registers
#define ENCL1_VIDEO_EN                             ((0x22a0  << 2) + 0xff000000)
#define ENCL1_VIDEO_Y_SCL                          ((0x22a1  << 2) + 0xff000000)
#define ENCL1_VIDEO_PB_SCL                         ((0x22a2  << 2) + 0xff000000)
#define ENCL1_VIDEO_PR_SCL                         ((0x22a3  << 2) + 0xff000000)
#define ENCL1_VIDEO_Y_OFFST                        ((0x22a4  << 2) + 0xff000000)
#define ENCL1_VIDEO_PB_OFFST                       ((0x22a5  << 2) + 0xff000000)
#define ENCL1_VIDEO_PR_OFFST                       ((0x22a6  << 2) + 0xff000000)
//----- Video mode
#define ENCL1_VIDEO_MODE                           ((0x22a7  << 2) + 0xff000000)
#define ENCL1_VIDEO_MODE_ADV                       ((0x22a8  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCL1_DBG_PX_RST                           ((0x22a9  << 2) + 0xff000000)
#define ENCL1_DBG_LN_RST                           ((0x22aa  << 2) + 0xff000000)
#define ENCL1_DBG_PX_INT                           ((0x22ab  << 2) + 0xff000000)
#define ENCL1_DBG_LN_INT                           ((0x22ac  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCL1_VIDEO_YFP1_HTIME                     ((0x22ad  << 2) + 0xff000000)
#define ENCL1_VIDEO_YFP2_HTIME                     ((0x22ae  << 2) + 0xff000000)
#define ENCL1_VIDEO_YC_DLY                         ((0x22af  << 2) + 0xff000000)
#define ENCL1_VIDEO_MAX_PXCNT                      ((0x22b0  << 2) + 0xff000000)
#define ENCL1_VIDEO_HAVON_END                      ((0x22b1  << 2) + 0xff000000)
#define ENCL1_VIDEO_HAVON_BEGIN                    ((0x22b2  << 2) + 0xff000000)
#define ENCL1_VIDEO_VAVON_ELINE                    ((0x22b3  << 2) + 0xff000000)
#define ENCL1_VIDEO_VAVON_BLINE                    ((0x22b4  << 2) + 0xff000000)
#define ENCL1_VIDEO_HSO_BEGIN                      ((0x22b5  << 2) + 0xff000000)
#define ENCL1_VIDEO_HSO_END                        ((0x22b6  << 2) + 0xff000000)
#define ENCL1_VIDEO_VSO_BEGIN                      ((0x22b7  << 2) + 0xff000000)
#define ENCL1_VIDEO_VSO_END                        ((0x22b8  << 2) + 0xff000000)
#define ENCL1_VIDEO_VSO_BLINE                      ((0x22b9  << 2) + 0xff000000)
#define ENCL1_VIDEO_VSO_ELINE                      ((0x22ba  << 2) + 0xff000000)
#define ENCL1_VIDEO_MAX_LNCNT                      ((0x22bb  << 2) + 0xff000000)
#define ENCL1_VIDEO_BLANKY_VAL                     ((0x22bc  << 2) + 0xff000000)
#define ENCL1_VIDEO_BLANKPB_VAL                    ((0x22bd  << 2) + 0xff000000)
#define ENCL1_VIDEO_BLANKPR_VAL                    ((0x22be  << 2) + 0xff000000)
#define ENCL1_VIDEO_HOFFST                         ((0x22bf  << 2) + 0xff000000)
#define ENCL1_VIDEO_VOFFST                         ((0x22c0  << 2) + 0xff000000)
#define ENCL1_VIDEO_RGB_CTRL                       ((0x22c1  << 2) + 0xff000000)
#define ENCL1_VIDEO_FILT_CTRL                      ((0x22c2  << 2) + 0xff000000)
#define ENCL1_VIDEO_OFLD_VPEQ_OFST                 ((0x22c3  << 2) + 0xff000000)
#define ENCL1_VIDEO_OFLD_VOAV_OFST                 ((0x22c4  << 2) + 0xff000000)
#define ENCL1_VIDEO_MATRIX_CB                      ((0x22c5  << 2) + 0xff000000)
#define ENCL1_VIDEO_MATRIX_CR                      ((0x22c6  << 2) + 0xff000000)
#define ENCL1_VIDEO_RGBIN_CTRL                     ((0x22c7  << 2) + 0xff000000)
#define ENCL1_MAX_LINE_SWITCH_POINT                ((0x22c8  << 2) + 0xff000000)
#define ENCL1_DACSEL_0                             ((0x22c9  << 2) + 0xff000000)
#define ENCL1_DACSEL_1                             ((0x22ca  << 2) + 0xff000000)
#define ENCT1_VIDEO_H_PRE_DE_END                   ((0x22cb  << 2) + 0xff000000)
#define ENCT1_VIDEO_H_PRE_DE_BEGIN                 ((0x22cc  << 2) + 0xff000000)
#define ENCT1_VIDEO_V_PRE_DE_ELINE                 ((0x22cd  << 2) + 0xff000000)
#define ENCT1_VIDEO_V_PRE_DE_BLINE                 ((0x22ce  << 2) + 0xff000000)
#define ENCL1_VIDEO_H_PRE_DE_END                   ((0x22cf  << 2) + 0xff000000)
#define ENCL1_VIDEO_H_PRE_DE_BEGIN                 ((0x22d0  << 2) + 0xff000000)
#define ENCL1_VIDEO_V_PRE_DE_ELINE                 ((0x22d1  << 2) + 0xff000000)
#define ENCL1_VIDEO_V_PRE_DE_BLINE                 ((0x22d2  << 2) + 0xff000000)
#define ENCL1_INBUF_CNTL0                          ((0x22d3  << 2) + 0xff000000)
#define ENCL1_INBUF_CNTL1                          ((0x22d4  << 2) + 0xff000000)
#define ENCL1_INBUF_CNT                            ((0x22d5  << 2) + 0xff000000)
#define ENCL1_INBUF_HOLD_CNT                       ((0x22d6  << 2) + 0xff000000)
#define ENCL1_INBUF_FIX_PIX_NUM                    ((0x22d7  << 2) + 0xff000000)
#define VENC1_VRR_CTRL                             ((0x22d8  << 2) + 0xff000000)
//Bit   31    cfg_vsp_din      // W, pulse
//Bit   30    cfg_vrr_clr      // W, pulse
//Bit 31:28   ro_vrr_vsp_cnt   // R,
//Bit 27:24   ro_vrr_max_err   // R,
//Bit 23:8    cfg_vsp_dly_num  // R/W, unsigned, default 0
//Bit  7:4    cfg_vrr_frm_ths  // R/W, unsigned, default 0
//Bit  3:2    cfg_vrr_vsp_en   // R/W, unsigned, default 0
//Bit    1    cfg_vrr_mode     // R/W, unsigned, default 0
//Bit    0    cfg_vrr_vsp_sel  // R/W, unsigned, default 0
#define VENC1_VRR_ADJ_LMT                          ((0x22d9  << 2) + 0xff000000)
//Bit 31:16  cfg_vrr_min_vnum  //R/W, unsigned,
//Bit 15:0   cfg_vrr_max_vnum  //R/W, unsigned,
#define VENC1_VRR_CTRL1                            ((0x22da  << 2) + 0xff000000)
//Bit 4:1    cfg_vsp_rst_num   //R/W, unsigned, default 1
//Bit   0    cfg_vsp_cnt_rst   //W,pulse
#define VPU1_VPU_PWM_V0                            ((0x22e0  << 2) + 0xff000000)
#define VPU1_VPU_PWM_V1                            ((0x22e1  << 2) + 0xff000000)
#define VPU1_VPU_PWM_V2                            ((0x22e2  << 2) + 0xff000000)
#define VPU1_VPU_PWM_V3                            ((0x22e3  << 2) + 0xff000000)
#define VPU1_VPU_PWM_H0                            ((0x22e4  << 2) + 0xff000000)
#define VPU1_VPU_PWM_H1                            ((0x22e5  << 2) + 0xff000000)
#define VPU1_VPU_PWM_H2                            ((0x22e6  << 2) + 0xff000000)
#define VPU1_VPU_PWM_H3                            ((0x22e7  << 2) + 0xff000000)
#define VPU1_VPU_3D_SYNC1                          ((0x22e8  << 2) + 0xff000000)
#define VPU1_VPU_3D_SYNC2                          ((0x22e9  << 2) + 0xff000000)
#define VPU1_VENC_DUMMY                            ((0x22df  << 2) + 0xff000000)
#define VPU1_VENC_ERROR                            ((0x22ea  << 2) + 0xff000000)
#define VPU1_VENCI_STAT                            ((0x22eb  << 2) + 0xff000000)
#define VPU1_VENCP_STAT                            ((0x22ec  << 2) + 0xff000000)
#define VPU1_VENCL_STAT                            ((0x22ed  << 2) + 0xff000000)
#define VPU1_VENC_DITH                             ((0x22ee  << 2) + 0xff000000)
#define VPU1_VENC_CTRL                             ((0x22ef  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_CTRL                       ((0x22f0  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_1                      ((0x22f1  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_2                      ((0x22f2  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_3                      ((0x22f3  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_4                      ((0x22f4  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_5                      ((0x22f5  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_6                      ((0x22f6  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_7                      ((0x22f7  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_8                      ((0x22f8  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_9                      ((0x22f9  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_10                     ((0x22fa  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_11                     ((0x22fb  << 2) + 0xff000000)
#define VPU1_VENCL_DITH_LUT_12                     ((0x22fc  << 2) + 0xff000000)
//
// Closing file:  ./venc2_1_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC2A_VCBUS_BASE = 0x23
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc_2_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define ENCP2_VFIFO2VD_CTL                         ((0x2358  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCP2_VFIFO2VD_PIXEL_START                 ((0x2359  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCP2_VFIFO2VD_PIXEL_END                   ((0x235a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCP2_VFIFO2VD_LINE_TOP_START              ((0x235b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCP2_VFIFO2VD_LINE_TOP_END                ((0x235c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCP2_VFIFO2VD_LINE_BOT_START              ((0x235d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCP2_VFIFO2VD_LINE_BOT_END                ((0x235e  << 2) + 0xff000000)
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define VENC2_SYNC_ROUTE                           ((0x2360  << 2) + 0xff000000)
        //             encoder address space is assigned
        //             to the video encoder interface status
        //             register
#define VENC2_VIDEO_EXSRC                          ((0x2361  << 2) + 0xff000000)
#define VENC2_DVI_SETTING                          ((0x2362  << 2) + 0xff000000)
#define VENC2_C656_CTRL                            ((0x2363  << 2) + 0xff000000)
#define VENC2_UPSAMPLE_CTRL0                       ((0x2364  << 2) + 0xff000000)
#define VENC2_UPSAMPLE_CTRL1                       ((0x2365  << 2) + 0xff000000)
#define VENC2_UPSAMPLE_CTRL2                       ((0x2366  << 2) + 0xff000000)
// Invert control for tcon output
// bit[15:14] -- vsync, hsync,
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define TCON2_INVERT_CTL                           ((0x2367  << 2) + 0xff000000)
#define VENC2_VIDEO_PROG_MODE                      ((0x2368  << 2) + 0xff000000)
//---- Venc pixel/line info
#define VENC2_ENCI_LINE                            ((0x2369  << 2) + 0xff000000)
#define VENC2_ENCI_PIXEL                           ((0x236a  << 2) + 0xff000000)
#define VENC2_ENCP_LINE                            ((0x236b  << 2) + 0xff000000)
#define VENC2_ENCP_PIXEL                           ((0x236c  << 2) + 0xff000000)
//---- Status
#define VENC2_STATA                                ((0x236d  << 2) + 0xff000000)
//---- Interrupt setting
#define VENC2_INTCTRL                              ((0x236e  << 2) + 0xff000000)
#define VENC2_INTFLAG                              ((0x236f  << 2) + 0xff000000)
//--------- Video test configuration
#define VENC2_VIDEO_TST_EN                         ((0x2370  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_MDSEL                      ((0x2371  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_Y                          ((0x2372  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_CB                         ((0x2373  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_CR                         ((0x2374  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_CLRBAR_STRT                ((0x2375  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_CLRBAR_WIDTH               ((0x2376  << 2) + 0xff000000)
#define VENC2_VIDEO_TST_VDCNT_STSET                ((0x2377  << 2) + 0xff000000)
//----- Video dac setting
#define VENC2_VDAC_DACSEL0                         ((0x2378  << 2) + 0xff000000)
#define VENC2_VDAC_DACSEL1                         ((0x2379  << 2) + 0xff000000)
#define VENC2_VDAC_DACSEL2                         ((0x237a  << 2) + 0xff000000)
#define VENC2_VDAC_DACSEL3                         ((0x237b  << 2) + 0xff000000)
#define VENC2_VDAC_DACSEL4                         ((0x237c  << 2) + 0xff000000)
#define VENC2_VDAC_DACSEL5                         ((0x237d  << 2) + 0xff000000)
#define VENC2_VDAC_SETTING                         ((0x237e  << 2) + 0xff000000)
#define VENC2_VDAC_TST_VAL                         ((0x237f  << 2) + 0xff000000)
#define VENC2_VDAC_DAC0_GAINCTRL                   ((0x23f0  << 2) + 0xff000000)
#define VENC2_VDAC_DAC0_OFFSET                     ((0x23f1  << 2) + 0xff000000)
#define VENC2_VDAC_DAC1_GAINCTRL                   ((0x23f2  << 2) + 0xff000000)
#define VENC2_VDAC_DAC1_OFFSET                     ((0x23f3  << 2) + 0xff000000)
#define VENC2_VDAC_DAC2_GAINCTRL                   ((0x23f4  << 2) + 0xff000000)
#define VENC2_VDAC_DAC2_OFFSET                     ((0x23f5  << 2) + 0xff000000)
#define VENC2_VDAC_DAC3_GAINCTRL                   ((0x23f6  << 2) + 0xff000000)
#define VENC2_VDAC_DAC3_OFFSET                     ((0x23f7  << 2) + 0xff000000)
#define VENC2_VDAC_DAC4_GAINCTRL                   ((0x23f8  << 2) + 0xff000000)
#define VENC2_VDAC_DAC4_OFFSET                     ((0x23f9  << 2) + 0xff000000)
#define VENC2_VDAC_DAC5_GAINCTRL                   ((0x23fa  << 2) + 0xff000000)
#define VENC2_VDAC_DAC5_OFFSET                     ((0x23fb  << 2) + 0xff000000)
#define VENC2_VDAC_FIFO_CTRL                       ((0x23fc  << 2) + 0xff000000)
#define ENCL2_TCON_INVERT_CTL                      ((0x23fd  << 2) + 0xff000000)
//
// Closing file:  ./venc_2_regs.h
//
//
// Reading file:  ./enc480p_2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define ENCP2_VIDEO_EN                             ((0x2380  << 2) + 0xff000000)
#define ENCP2_VIDEO_SYNC_MODE                      ((0x2381  << 2) + 0xff000000)
#define ENCP2_MACV_EN                              ((0x2382  << 2) + 0xff000000)
#define ENCP2_VIDEO_Y_SCL                          ((0x2383  << 2) + 0xff000000)
#define ENCP2_VIDEO_PB_SCL                         ((0x2384  << 2) + 0xff000000)
#define ENCP2_VIDEO_PR_SCL                         ((0x2385  << 2) + 0xff000000)
#define ENCP2_VIDEO_SYNC_SCL                       ((0x2386  << 2) + 0xff000000)
#define ENCP2_VIDEO_MACV_SCL                       ((0x2387  << 2) + 0xff000000)
#define ENCP2_VIDEO_Y_OFFST                        ((0x2388  << 2) + 0xff000000)
#define ENCP2_VIDEO_PB_OFFST                       ((0x2389  << 2) + 0xff000000)
#define ENCP2_VIDEO_PR_OFFST                       ((0x238a  << 2) + 0xff000000)
#define ENCP2_VIDEO_SYNC_OFFST                     ((0x238b  << 2) + 0xff000000)
#define ENCP2_VIDEO_MACV_OFFST                     ((0x238c  << 2) + 0xff000000)
//----- Video mode
#define ENCP2_VIDEO_MODE                           ((0x238d  << 2) + 0xff000000)
#define ENCP2_VIDEO_MODE_ADV                       ((0x238e  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCP2_DBG_PX_RST                           ((0x2390  << 2) + 0xff000000)
#define ENCP2_DBG_LN_RST                           ((0x2391  << 2) + 0xff000000)
#define ENCP2_DBG_PX_INT                           ((0x2392  << 2) + 0xff000000)
#define ENCP2_DBG_LN_INT                           ((0x2393  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCP2_VIDEO_YFP1_HTIME                     ((0x2394  << 2) + 0xff000000)
#define ENCP2_VIDEO_YFP2_HTIME                     ((0x2395  << 2) + 0xff000000)
#define ENCP2_VIDEO_YC_DLY                         ((0x2396  << 2) + 0xff000000)
#define ENCP2_VIDEO_MAX_PXCNT                      ((0x2397  << 2) + 0xff000000)
#define ENCP2_VIDEO_HSPULS_BEGIN                   ((0x2398  << 2) + 0xff000000)
#define ENCP2_VIDEO_HSPULS_END                     ((0x2399  << 2) + 0xff000000)
#define ENCP2_VIDEO_HSPULS_SWITCH                  ((0x239a  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSPULS_BEGIN                   ((0x239b  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSPULS_END                     ((0x239c  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSPULS_BLINE                   ((0x239d  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSPULS_ELINE                   ((0x239e  << 2) + 0xff000000)
#define ENCP2_VIDEO_EQPULS_BEGIN                   ((0x239f  << 2) + 0xff000000)
#define ENCP2_VIDEO_EQPULS_END                     ((0x23a0  << 2) + 0xff000000)
#define ENCP2_VIDEO_EQPULS_BLINE                   ((0x23a1  << 2) + 0xff000000)
#define ENCP2_VIDEO_EQPULS_ELINE                   ((0x23a2  << 2) + 0xff000000)
#define ENCP2_VIDEO_HAVON_END                      ((0x23a3  << 2) + 0xff000000)
#define ENCP2_VIDEO_HAVON_BEGIN                    ((0x23a4  << 2) + 0xff000000)
#define ENCP2_VIDEO_VAVON_ELINE                    ((0x23af  << 2) + 0xff000000)
#define ENCP2_VIDEO_VAVON_BLINE                    ((0x23a6  << 2) + 0xff000000)
#define ENCP2_VIDEO_HSO_BEGIN                      ((0x23a7  << 2) + 0xff000000)
#define ENCP2_VIDEO_HSO_END                        ((0x23a8  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSO_BEGIN                      ((0x23a9  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSO_END                        ((0x23aa  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSO_BLINE                      ((0x23ab  << 2) + 0xff000000)
#define ENCP2_VIDEO_VSO_ELINE                      ((0x23ac  << 2) + 0xff000000)
#define ENCP2_VIDEO_SYNC_WAVE_CURVE                ((0x23ad  << 2) + 0xff000000)
#define ENCP2_VIDEO_MAX_LNCNT                      ((0x23ae  << 2) + 0xff000000)
#define ENCP2_VIDEO_SY_VAL                         ((0x23b0  << 2) + 0xff000000)
#define ENCP2_VIDEO_SY2_VAL                        ((0x23b1  << 2) + 0xff000000)
#define ENCP2_VIDEO_BLANKY_VAL                     ((0x23b2  << 2) + 0xff000000)
#define ENCP2_VIDEO_BLANKPB_VAL                    ((0x23b3  << 2) + 0xff000000)
#define ENCP2_VIDEO_BLANKPR_VAL                    ((0x23b4  << 2) + 0xff000000)
#define ENCP2_VIDEO_HOFFST                         ((0x23b5  << 2) + 0xff000000)
#define ENCP2_VIDEO_VOFFST                         ((0x23b6  << 2) + 0xff000000)
#define ENCP2_VIDEO_RGB_CTRL                       ((0x23b7  << 2) + 0xff000000)
#define ENCP2_VIDEO_FILT_CTRL                      ((0x23b8  << 2) + 0xff000000)
#define ENCP2_VIDEO_OFLD_VPEQ_OFST                 ((0x23b9  << 2) + 0xff000000)
#define ENCP2_VIDEO_OFLD_VOAV_OFST                 ((0x23ba  << 2) + 0xff000000)
#define ENCP2_VIDEO_MATRIX_CB                      ((0x23bb  << 2) + 0xff000000)
#define ENCP2_VIDEO_MATRIX_CR                      ((0x23bc  << 2) + 0xff000000)
#define ENCP2_VIDEO_RGBIN_CTRL                     ((0x23bd  << 2) + 0xff000000)
//------------------Macrovision advanced setting
#define ENCP2_MACV_BLANKY_VAL                      ((0x23c0  << 2) + 0xff000000)
#define ENCP2_MACV_MAXY_VAL                        ((0x23c1  << 2) + 0xff000000)
#define ENCP2_MACV_1ST_PSSYNC_STRT                 ((0x23c2  << 2) + 0xff000000)
#define ENCP2_MACV_PSSYNC_STRT                     ((0x23c3  << 2) + 0xff000000)
#define ENCP2_MACV_AGC_STRT                        ((0x23c4  << 2) + 0xff000000)
#define ENCP2_MACV_AGC_END                         ((0x23c5  << 2) + 0xff000000)
#define ENCP2_MACV_WAVE_END                        ((0x23c6  << 2) + 0xff000000)
#define ENCP2_MACV_STRTLINE                        ((0x23c7  << 2) + 0xff000000)
#define ENCP2_MACV_ENDLINE                         ((0x23c8  << 2) + 0xff000000)
#define ENCP2_MACV_TS_CNT_MAX_L                    ((0x23c9  << 2) + 0xff000000)
#define ENCP2_MACV_TS_CNT_MAX_H                    ((0x23ca  << 2) + 0xff000000)
#define ENCP2_MACV_TIME_DOWN                       ((0x23cb  << 2) + 0xff000000)
#define ENCP2_MACV_TIME_LO                         ((0x23cc  << 2) + 0xff000000)
#define ENCP2_MACV_TIME_UP                         ((0x23cd  << 2) + 0xff000000)
#define ENCP2_MACV_TIME_RST                        ((0x23ce  << 2) + 0xff000000)
//---------------- VBI control -------------------
#define ENCP2_VBI_CTRL                             ((0x23d0  << 2) + 0xff000000)
#define ENCP2_VBI_SETTING                          ((0x23d1  << 2) + 0xff000000)
#define ENCP2_VBI_BEGIN                            ((0x23d2  << 2) + 0xff000000)
#define ENCP2_VBI_WIDTH                            ((0x23d3  << 2) + 0xff000000)
#define ENCP2_VBI_HVAL                             ((0x23d4  << 2) + 0xff000000)
#define ENCP2_VBI_DATA0                            ((0x23d5  << 2) + 0xff000000)
#define ENCP2_VBI_DATA1                            ((0x23d6  << 2) + 0xff000000)
//----------------C656 OUT Control------------- Grant
#define C656_HS_ST_2                               ((0x23e0  << 2) + 0xff000000)
#define C656_HS_ED_2                               ((0x23e1  << 2) + 0xff000000)
#define C656_VS_LNST_E_2                           ((0x23e2  << 2) + 0xff000000)
#define C656_VS_LNST_O_2                           ((0x23e3  << 2) + 0xff000000)
#define C656_VS_LNED_E_2                           ((0x23e4  << 2) + 0xff000000)
#define C656_VS_LNED_O_2                           ((0x23e5  << 2) + 0xff000000)
#define C656_FS_LNST_2                             ((0x23e6  << 2) + 0xff000000)
#define C656_FS_LNED_2                             ((0x23e7  << 2) + 0xff000000)
#define ENCP2_VRR_CTRL                             ((0x23e8  << 2) + 0xff000000)
#define ENCP2_VRR_ADJ_LMT                          ((0x23e9  << 2) + 0xff000000)
#define ENCP2_VRR_CTRL1                            ((0x23ea  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./enc480p_2_regs.h
//
//
// Reading file:  ./enci_2_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define ENCI2_VIDEO_MODE                           ((0x2300  << 2) + 0xff000000)
#define ENCI2_VIDEO_MODE_ADV                       ((0x2301  << 2) + 0xff000000)
#define ENCI2_VIDEO_FSC_ADJ                        ((0x2302  << 2) + 0xff000000)
#define ENCI2_VIDEO_BRIGHT                         ((0x2303  << 2) + 0xff000000)
#define ENCI2_VIDEO_CONT                           ((0x2304  << 2) + 0xff000000)
#define ENCI2_VIDEO_SAT                            ((0x2305  << 2) + 0xff000000)
#define ENCI2_VIDEO_HUE                            ((0x2306  << 2) + 0xff000000)
#define ENCI2_VIDEO_SCH                            ((0x2307  << 2) + 0xff000000)
#define ENCI2_SYNC_MODE                            ((0x2308  << 2) + 0xff000000)
#define ENCI2_SYNC_CTRL                            ((0x2309  << 2) + 0xff000000)
#define ENCI2_SYNC_HSO_BEGIN                       ((0x230a  << 2) + 0xff000000)
#define ENCI2_SYNC_HSO_END                         ((0x230b  << 2) + 0xff000000)
#define ENCI2_SYNC_VSO_EVN                         ((0x230c  << 2) + 0xff000000)
#define ENCI2_SYNC_VSO_ODD                         ((0x230d  << 2) + 0xff000000)
#define ENCI2_SYNC_VSO_EVNLN                       ((0x230e  << 2) + 0xff000000)
#define ENCI2_SYNC_VSO_ODDLN                       ((0x230f  << 2) + 0xff000000)
#define ENCI2_SYNC_HOFFST                          ((0x2310  << 2) + 0xff000000)
#define ENCI2_SYNC_VOFFST                          ((0x2311  << 2) + 0xff000000)
#define ENCI2_SYNC_ADJ                             ((0x2312  << 2) + 0xff000000)
#define ENCI2_RGB_SETTING                          ((0x2313  << 2) + 0xff000000)
//`define    ENCI2_CMPN_MATRIX_CB        8'h14
//`define    ENCI2_CMPN_MATRIX_CR        8'h15
#define ENCI2_DE_H_BEGIN                           ((0x2316  << 2) + 0xff000000)
#define ENCI2_DE_H_END                             ((0x2317  << 2) + 0xff000000)
#define ENCI2_DE_V_BEGIN_EVEN                      ((0x2318  << 2) + 0xff000000)
#define ENCI2_DE_V_END_EVEN                        ((0x2319  << 2) + 0xff000000)
#define ENCI2_DE_V_BEGIN_ODD                       ((0x231a  << 2) + 0xff000000)
#define ENCI2_DE_V_END_ODD                         ((0x231b  << 2) + 0xff000000)
#define ENCI2_VBI_SETTING                          ((0x2320  << 2) + 0xff000000)
#define ENCI2_VBI_CCDT_EVN                         ((0x2321  << 2) + 0xff000000)
#define ENCI2_VBI_CCDT_ODD                         ((0x2322  << 2) + 0xff000000)
#define ENCI2_VBI_CC525_LN                         ((0x2323  << 2) + 0xff000000)
#define ENCI2_VBI_CC625_LN                         ((0x2324  << 2) + 0xff000000)
#define ENCI2_VBI_WSSDT                            ((0x2325  << 2) + 0xff000000)
#define ENCI2_VBI_WSS_LN                           ((0x2326  << 2) + 0xff000000)
#define ENCI2_VBI_CGMSDT_L                         ((0x2327  << 2) + 0xff000000)
#define ENCI2_VBI_CGMSDT_H                         ((0x2328  << 2) + 0xff000000)
#define ENCI2_VBI_CGMS_LN                          ((0x2329  << 2) + 0xff000000)
#define ENCI2_VBI_TTX_HTIME                        ((0x232a  << 2) + 0xff000000)
#define ENCI2_VBI_TTX_LN                           ((0x232b  << 2) + 0xff000000)
#define ENCI2_VBI_TTXDT0                           ((0x232c  << 2) + 0xff000000)
#define ENCI2_VBI_TTXDT1                           ((0x232d  << 2) + 0xff000000)
#define ENCI2_VBI_TTXDT2                           ((0x232e  << 2) + 0xff000000)
#define ENCI2_VBI_TTXDT3                           ((0x232f  << 2) + 0xff000000)
#define ENCI2_MACV_N0                              ((0x2330  << 2) + 0xff000000)
#define ENCI2_MACV_N1                              ((0x2331  << 2) + 0xff000000)
#define ENCI2_MACV_N2                              ((0x2332  << 2) + 0xff000000)
#define ENCI2_MACV_N3                              ((0x2333  << 2) + 0xff000000)
#define ENCI2_MACV_N4                              ((0x2334  << 2) + 0xff000000)
#define ENCI2_MACV_N5                              ((0x2335  << 2) + 0xff000000)
#define ENCI2_MACV_N6                              ((0x2336  << 2) + 0xff000000)
#define ENCI2_MACV_N7                              ((0x2337  << 2) + 0xff000000)
#define ENCI2_MACV_N8                              ((0x2338  << 2) + 0xff000000)
#define ENCI2_MACV_N9                              ((0x2339  << 2) + 0xff000000)
#define ENCI2_MACV_N10                             ((0x233a  << 2) + 0xff000000)
#define ENCI2_MACV_N11                             ((0x233b  << 2) + 0xff000000)
#define ENCI2_MACV_N12                             ((0x233c  << 2) + 0xff000000)
#define ENCI2_MACV_N13                             ((0x233d  << 2) + 0xff000000)
#define ENCI2_MACV_N14                             ((0x233e  << 2) + 0xff000000)
#define ENCI2_MACV_N15                             ((0x233f  << 2) + 0xff000000)
#define ENCI2_MACV_N16                             ((0x2340  << 2) + 0xff000000)
#define ENCI2_MACV_N17                             ((0x2341  << 2) + 0xff000000)
#define ENCI2_MACV_N18                             ((0x2342  << 2) + 0xff000000)
#define ENCI2_MACV_N19                             ((0x2343  << 2) + 0xff000000)
#define ENCI2_MACV_N20                             ((0x2344  << 2) + 0xff000000)
#define ENCI2_MACV_N21                             ((0x2345  << 2) + 0xff000000)
#define ENCI2_MACV_N22                             ((0x2346  << 2) + 0xff000000)
//`define    ENCI2_MACV_P_AGC            8'h47
#define ENCI2_DBG_PX_RST                           ((0x2348  << 2) + 0xff000000)
#define ENCI2_DBG_FLDLN_RST                        ((0x2349  << 2) + 0xff000000)
#define ENCI2_DBG_PX_INT                           ((0x234a  << 2) + 0xff000000)
#define ENCI2_DBG_FLDLN_INT                        ((0x234b  << 2) + 0xff000000)
#define ENCI2_DBG_MAXPX                            ((0x234c  << 2) + 0xff000000)
#define ENCI2_DBG_MAXLN                            ((0x234d  << 2) + 0xff000000)
#define ENCI2_MACV_MAX_AMP                         ((0x2350  << 2) + 0xff000000)
#define ENCI2_MACV_PULSE_LO                        ((0x2351  << 2) + 0xff000000)
#define ENCI2_MACV_PULSE_HI                        ((0x2352  << 2) + 0xff000000)
#define ENCI2_MACV_BKP_MAX                         ((0x2353  << 2) + 0xff000000)
#define ENCI2_CFILT_CTRL                           ((0x2354  << 2) + 0xff000000)
#define ENCI2_CFILT7                               ((0x2355  << 2) + 0xff000000)
#define ENCI2_YC_DELAY                             ((0x2356  << 2) + 0xff000000)
#define ENCI2_VIDEO_EN                             ((0x2357  << 2) + 0xff000000)
//
// Closing file:  ./enci_2_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VENC2B_VCBUS_BASE = 0x24
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./venc2_2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff (VENC registers 0xc00 - 0xcef)
//===========================================================================
// Program video control signals from ENCI core to DVI/HDMI interface
#define ENCI2_DVI_HSO_BEGIN                        ((0x2400  << 2) + 0xff000000)
#define ENCI2_DVI_HSO_END                          ((0x2401  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_BLINE_EVN                    ((0x2402  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_BLINE_ODD                    ((0x2403  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_ELINE_EVN                    ((0x2404  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_ELINE_ODD                    ((0x2405  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_BEGIN_EVN                    ((0x2406  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_BEGIN_ODD                    ((0x2407  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_END_EVN                      ((0x2408  << 2) + 0xff000000)
#define ENCI2_DVI_VSO_END_ODD                      ((0x2409  << 2) + 0xff000000)
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define ENCI2_CFILT_CTRL2                          ((0x240a  << 2) + 0xff000000)
#define ENCI2_DACSEL_0                             ((0x240b  << 2) + 0xff000000)
#define ENCI2_DACSEL_1                             ((0x240c  << 2) + 0xff000000)
#define ENCP2_DACSEL_0                             ((0x240d  << 2) + 0xff000000)
#define ENCP2_DACSEL_1                             ((0x240e  << 2) + 0xff000000)
#define ENCP2_MAX_LINE_SWITCH_POINT                ((0x240f  << 2) + 0xff000000)
#define ENCI2_TST_EN                               ((0x2410  << 2) + 0xff000000)
#define ENCI2_TST_MDSEL                            ((0x2411  << 2) + 0xff000000)
#define ENCI2_TST_Y                                ((0x2412  << 2) + 0xff000000)
#define ENCI2_TST_CB                               ((0x2413  << 2) + 0xff000000)
#define ENCI2_TST_CR                               ((0x2414  << 2) + 0xff000000)
#define ENCI2_TST_CLRBAR_STRT                      ((0x2415  << 2) + 0xff000000)
#define ENCI2_TST_CLRBAR_WIDTH                     ((0x2416  << 2) + 0xff000000)
#define ENCI2_TST_VDCNT_STSET                      ((0x2417  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCI2_VFIFO2VD_CTL                         ((0x2418  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCI2_VFIFO2VD_PIXEL_START                 ((0x2419  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCI2_VFIFO2VD_PIXEL_END                   ((0x241a  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCI2_VFIFO2VD_LINE_TOP_START              ((0x241b  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCI2_VFIFO2VD_LINE_TOP_END                ((0x241c  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCI2_VFIFO2VD_LINE_BOT_START              ((0x241d  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCI2_VFIFO2VD_LINE_BOT_END                ((0x241e  << 2) + 0xff000000)
#define ENCI2_VFIFO2VD_CTL2                        ((0x241f  << 2) + 0xff000000)
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCT2_VFIFO2VD_CTL                         ((0x2420  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCT2_VFIFO2VD_PIXEL_START                 ((0x2421  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCT2_VFIFO2VD_PIXEL_END                   ((0x2422  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCT2_VFIFO2VD_LINE_TOP_START              ((0x2423  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCT2_VFIFO2VD_LINE_TOP_END                ((0x2424  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCT2_VFIFO2VD_LINE_BOT_START              ((0x2425  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCT2_VFIFO2VD_LINE_BOT_END                ((0x2426  << 2) + 0xff000000)
#define ENCT2_VFIFO2VD_CTL2                        ((0x2427  << 2) + 0xff000000)
#define ENCT2_TST_EN                               ((0x2428  << 2) + 0xff000000)
#define ENCT2_TST_MDSEL                            ((0x2429  << 2) + 0xff000000)
#define ENCT2_TST_Y                                ((0x242a  << 2) + 0xff000000)
#define ENCT2_TST_CB                               ((0x242b  << 2) + 0xff000000)
#define ENCT2_TST_CR                               ((0x242c  << 2) + 0xff000000)
#define ENCT2_TST_CLRBAR_STRT                      ((0x242d  << 2) + 0xff000000)
#define ENCT2_TST_CLRBAR_WIDTH                     ((0x242e  << 2) + 0xff000000)
#define ENCT2_TST_VDCNT_STSET                      ((0x242f  << 2) + 0xff000000)
// Program video control signals from ENCP core to DVI/HDMI interface
#define ENCP2_DVI_HSO_BEGIN                        ((0x2430  << 2) + 0xff000000)
#define ENCP2_DVI_HSO_END                          ((0x2431  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_BLINE_EVN                    ((0x2432  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_BLINE_ODD                    ((0x2433  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_ELINE_EVN                    ((0x2434  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_ELINE_ODD                    ((0x2435  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_BEGIN_EVN                    ((0x2436  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_BEGIN_ODD                    ((0x2437  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_END_EVN                      ((0x2438  << 2) + 0xff000000)
#define ENCP2_DVI_VSO_END_ODD                      ((0x2439  << 2) + 0xff000000)
#define ENCP2_DE_H_BEGIN                           ((0x243a  << 2) + 0xff000000)
#define ENCP2_DE_H_END                             ((0x243b  << 2) + 0xff000000)
#define ENCP2_DE_V_BEGIN_EVEN                      ((0x243c  << 2) + 0xff000000)
#define ENCP2_DE_V_END_EVEN                        ((0x243d  << 2) + 0xff000000)
#define ENCP2_DE_V_BEGIN_ODD                       ((0x243e  << 2) + 0xff000000)
#define ENCP2_DE_V_END_ODD                         ((0x243f  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCI2_SYNC_LINE_LENGTH                     ((0x2440  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCI2_SYNC_PIXEL_EN                        ((0x2441  << 2) + 0xff000000)
// Bit 15 - ENCI2_sync_enable
// Bit 14 - ENCP2_sync_enable
// Bit 13 - ENCT2_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCI2_SYNC_TO_LINE_EN                      ((0x2442  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCI2_SYNC_TO_PIXEL                        ((0x2443  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCP2_SYNC_LINE_LENGTH                     ((0x2444  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCP2_SYNC_PIXEL_EN                        ((0x2445  << 2) + 0xff000000)
// Bit 15 - ENCI2_sync_enable
// Bit 14 - ENCP2_sync_enable
// Bit 13 - ENCT2_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCP2_SYNC_TO_LINE_EN                      ((0x2446  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCP2_SYNC_TO_PIXEL                        ((0x2447  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCT2_SYNC_LINE_LENGTH                     ((0x2448  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCT2_SYNC_PIXEL_EN                        ((0x2449  << 2) + 0xff000000)
// Bit 15 - ENCI2_sync_enable
// Bit 14 - ENCP2_sync_enable
// Bit 13 - ENCT2_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCT2_SYNC_TO_LINE_EN                      ((0x244a  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCT2_SYNC_TO_PIXEL                        ((0x244b  << 2) + 0xff000000)
// Bit 15:11 - sync length
// Bit 10:0 - sync start line
#define ENCL2_SYNC_LINE_LENGTH                     ((0x244c  << 2) + 0xff000000)
// Bit 15 - sync_pulse_enable
// Bit 12:0 - sync start pixel
#define ENCL2_SYNC_PIXEL_EN                        ((0x244d  << 2) + 0xff000000)
// Bit 15 - ENCI2_sync_enable
// Bit 14 - ENCP2_sync_enable
// Bit 13 - ENCT2_sync_enable
// Bit 12 - short_fussy_sync
// Bit 11 - fussy_sync_enable
// Bit 10:0 - sync target line
#define ENCL2_SYNC_TO_LINE_EN                      ((0x244e  << 2) + 0xff000000)
// Bit 12:0 - sync target pixel
#define ENCL2_SYNC_TO_PIXEL                        ((0x244f  << 2) + 0xff000000)
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define ENCP2_VFIFO2VD_CTL2                        ((0x2450  << 2) + 0xff000000)
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define VENC2_DVI_SETTING_MORE                     ((0x2451  << 2) + 0xff000000)
#define VENC2_VDAC_DAC4_FILT_CTRL0                 ((0x2454  << 2) + 0xff000000)
#define VENC2_VDAC_DAC4_FILT_CTRL1                 ((0x2455  << 2) + 0xff000000)
#define VENC2_VDAC_DAC5_FILT_CTRL0                 ((0x2456  << 2) + 0xff000000)
#define VENC2_VDAC_DAC5_FILT_CTRL1                 ((0x2457  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC2_VDAC_DAC0_FILT_CTRL0                 ((0x2458  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC2_VDAC_DAC0_FILT_CTRL1                 ((0x2459  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC2_VDAC_DAC1_FILT_CTRL0                 ((0x245a  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC2_VDAC_DAC1_FILT_CTRL1                 ((0x245b  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC2_VDAC_DAC2_FILT_CTRL0                 ((0x245c  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC2_VDAC_DAC2_FILT_CTRL1                 ((0x245d  << 2) + 0xff000000)
//Bit 0   filter_en
#define VENC2_VDAC_DAC3_FILT_CTRL0                 ((0x245e  << 2) + 0xff000000)
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0,
#define VENC2_VDAC_DAC3_FILT_CTRL1                 ((0x245f  << 2) + 0xff000000)
//===========================================================================
// ENCT registers
#define ENCT2_VIDEO_EN                             ((0x2460  << 2) + 0xff000000)
#define ENCT2_VIDEO_Y_SCL                          ((0x2461  << 2) + 0xff000000)
#define ENCT2_VIDEO_PB_SCL                         ((0x2462  << 2) + 0xff000000)
#define ENCT2_VIDEO_PR_SCL                         ((0x2463  << 2) + 0xff000000)
#define ENCT2_VIDEO_Y_OFFST                        ((0x2464  << 2) + 0xff000000)
#define ENCT2_VIDEO_PB_OFFST                       ((0x2465  << 2) + 0xff000000)
#define ENCT2_VIDEO_PR_OFFST                       ((0x2466  << 2) + 0xff000000)
//----- Video mode
#define ENCT2_VIDEO_MODE                           ((0x2467  << 2) + 0xff000000)
#define ENCT2_VIDEO_MODE_ADV                       ((0x2468  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCT2_DBG_PX_RST                           ((0x2469  << 2) + 0xff000000)
#define ENCT2_DBG_LN_RST                           ((0x246a  << 2) + 0xff000000)
#define ENCT2_DBG_PX_INT                           ((0x246b  << 2) + 0xff000000)
#define ENCT2_DBG_LN_INT                           ((0x246c  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCT2_VIDEO_YFP1_HTIME                     ((0x246d  << 2) + 0xff000000)
#define ENCT2_VIDEO_YFP2_HTIME                     ((0x246e  << 2) + 0xff000000)
#define ENCT2_VIDEO_YC_DLY                         ((0x246f  << 2) + 0xff000000)
#define ENCT2_VIDEO_MAX_PXCNT                      ((0x2470  << 2) + 0xff000000)
#define ENCT2_VIDEO_HAVON_END                      ((0x2471  << 2) + 0xff000000)
#define ENCT2_VIDEO_HAVON_BEGIN                    ((0x2472  << 2) + 0xff000000)
#define ENCT2_VIDEO_VAVON_ELINE                    ((0x2473  << 2) + 0xff000000)
#define ENCT2_VIDEO_VAVON_BLINE                    ((0x2474  << 2) + 0xff000000)
#define ENCT2_VIDEO_HSO_BEGIN                      ((0x2475  << 2) + 0xff000000)
#define ENCT2_VIDEO_HSO_END                        ((0x2476  << 2) + 0xff000000)
#define ENCT2_VIDEO_VSO_BEGIN                      ((0x2477  << 2) + 0xff000000)
#define ENCT2_VIDEO_VSO_END                        ((0x2478  << 2) + 0xff000000)
#define ENCT2_VIDEO_VSO_BLINE                      ((0x2479  << 2) + 0xff000000)
#define ENCT2_VIDEO_VSO_ELINE                      ((0x247a  << 2) + 0xff000000)
#define ENCT2_VIDEO_MAX_LNCNT                      ((0x247b  << 2) + 0xff000000)
#define ENCT2_VIDEO_BLANKY_VAL                     ((0x247c  << 2) + 0xff000000)
#define ENCT2_VIDEO_BLANKPB_VAL                    ((0x247d  << 2) + 0xff000000)
#define ENCT2_VIDEO_BLANKPR_VAL                    ((0x247e  << 2) + 0xff000000)
#define ENCT2_VIDEO_HOFFST                         ((0x247f  << 2) + 0xff000000)
#define ENCT2_VIDEO_VOFFST                         ((0x2480  << 2) + 0xff000000)
#define ENCT2_VIDEO_RGB_CTRL                       ((0x2481  << 2) + 0xff000000)
#define ENCT2_VIDEO_FILT_CTRL                      ((0x2482  << 2) + 0xff000000)
#define ENCT2_VIDEO_OFLD_VPEQ_OFST                 ((0x2483  << 2) + 0xff000000)
#define ENCT2_VIDEO_OFLD_VOAV_OFST                 ((0x2484  << 2) + 0xff000000)
#define ENCT2_VIDEO_MATRIX_CB                      ((0x2485  << 2) + 0xff000000)
#define ENCT2_VIDEO_MATRIX_CR                      ((0x2486  << 2) + 0xff000000)
#define ENCT2_VIDEO_RGBIN_CTRL                     ((0x2487  << 2) + 0xff000000)
#define ENCT2_MAX_LINE_SWITCH_POINT                ((0x2488  << 2) + 0xff000000)
#define ENCT2_DACSEL_0                             ((0x2489  << 2) + 0xff000000)
#define ENCT2_DACSEL_1                             ((0x248a  << 2) + 0xff000000)
#define ENCT2_INBUF_CNTL0                          ((0x248b  << 2) + 0xff000000)
#define ENCT2_INBUF_CNTL1                          ((0x248c  << 2) + 0xff000000)
#define ENCT2_INBUF_CNT                            ((0x248d  << 2) + 0xff000000)
#define ENCT2_INBUF_HOLD_CNT                       ((0x248e  << 2) + 0xff000000)
#define ENCT2_INBUF_FIX_PIX_NUM                    ((0x248f  << 2) + 0xff000000)
//===========================================================================
// For ENCL
//===========================================================================
// bit 15:8 -- vfifo2vd_vd_sel
// bit 7 -- vfifo2vd_drop
// bit 6:1 -- vfifo2vd_delay
// bit 0 -- vfifo2vd_en
#define ENCL2_VFIFO2VD_CTL                         ((0x2490  << 2) + 0xff000000)
// bit 12:0 -- vfifo2vd_pixel_start
#define ENCL2_VFIFO2VD_PIXEL_START                 ((0x2491  << 2) + 0xff000000)
// bit 12:00 -- vfifo2vd_pixel_end
#define ENCL2_VFIFO2VD_PIXEL_END                   ((0x2492  << 2) + 0xff000000)
// bit 10:0 -- vfifo2vd_line_top_start
#define ENCL2_VFIFO2VD_LINE_TOP_START              ((0x2493  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_top_end
#define ENCL2_VFIFO2VD_LINE_TOP_END                ((0x2494  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_start
#define ENCL2_VFIFO2VD_LINE_BOT_START              ((0x2495  << 2) + 0xff000000)
// bit 10:00 -- vfifo2vd_line_bot_end
#define ENCL2_VFIFO2VD_LINE_BOT_END                ((0x2496  << 2) + 0xff000000)
#define ENCL2_VFIFO2VD_CTL2                        ((0x2497  << 2) + 0xff000000)
#define ENCL2_TST_EN                               ((0x2498  << 2) + 0xff000000)
#define ENCL2_TST_MDSEL                            ((0x2499  << 2) + 0xff000000)
#define ENCL2_TST_Y                                ((0x249a  << 2) + 0xff000000)
#define ENCL2_TST_CB                               ((0x249b  << 2) + 0xff000000)
#define ENCL2_TST_CR                               ((0x249c  << 2) + 0xff000000)
#define ENCL2_TST_CLRBAR_STRT                      ((0x249d  << 2) + 0xff000000)
#define ENCL2_TST_CLRBAR_WIDTH                     ((0x249e  << 2) + 0xff000000)
#define ENCL2_TST_VDCNT_STSET                      ((0x249f  << 2) + 0xff000000)
//===========================================================================
// ENCL2 registers
#define ENCL2_VIDEO_EN                             ((0x24a0  << 2) + 0xff000000)
#define ENCL2_VIDEO_Y_SCL                          ((0x24a1  << 2) + 0xff000000)
#define ENCL2_VIDEO_PB_SCL                         ((0x24a2  << 2) + 0xff000000)
#define ENCL2_VIDEO_PR_SCL                         ((0x24a3  << 2) + 0xff000000)
#define ENCL2_VIDEO_Y_OFFST                        ((0x24a4  << 2) + 0xff000000)
#define ENCL2_VIDEO_PB_OFFST                       ((0x24a5  << 2) + 0xff000000)
#define ENCL2_VIDEO_PR_OFFST                       ((0x24a6  << 2) + 0xff000000)
//----- Video mode
#define ENCL2_VIDEO_MODE                           ((0x24a7  << 2) + 0xff000000)
#define ENCL2_VIDEO_MODE_ADV                       ((0x24a8  << 2) + 0xff000000)
//--------------- Debug pins
#define ENCL2_DBG_PX_RST                           ((0x24a9  << 2) + 0xff000000)
#define ENCL2_DBG_LN_RST                           ((0x24aa  << 2) + 0xff000000)
#define ENCL2_DBG_PX_INT                           ((0x24ab  << 2) + 0xff000000)
#define ENCL2_DBG_LN_INT                           ((0x24ac  << 2) + 0xff000000)
//----------- Video Advanced setting
#define ENCL2_VIDEO_YFP1_HTIME                     ((0x24ad  << 2) + 0xff000000)
#define ENCL2_VIDEO_YFP2_HTIME                     ((0x24ae  << 2) + 0xff000000)
#define ENCL2_VIDEO_YC_DLY                         ((0x24af  << 2) + 0xff000000)
#define ENCL2_VIDEO_MAX_PXCNT                      ((0x24b0  << 2) + 0xff000000)
#define ENCL2_VIDEO_HAVON_END                      ((0x24b1  << 2) + 0xff000000)
#define ENCL2_VIDEO_HAVON_BEGIN                    ((0x24b2  << 2) + 0xff000000)
#define ENCL2_VIDEO_VAVON_ELINE                    ((0x24b3  << 2) + 0xff000000)
#define ENCL2_VIDEO_VAVON_BLINE                    ((0x24b4  << 2) + 0xff000000)
#define ENCL2_VIDEO_HSO_BEGIN                      ((0x24b5  << 2) + 0xff000000)
#define ENCL2_VIDEO_HSO_END                        ((0x24b6  << 2) + 0xff000000)
#define ENCL2_VIDEO_VSO_BEGIN                      ((0x24b7  << 2) + 0xff000000)
#define ENCL2_VIDEO_VSO_END                        ((0x24b8  << 2) + 0xff000000)
#define ENCL2_VIDEO_VSO_BLINE                      ((0x24b9  << 2) + 0xff000000)
#define ENCL2_VIDEO_VSO_ELINE                      ((0x24ba  << 2) + 0xff000000)
#define ENCL2_VIDEO_MAX_LNCNT                      ((0x24bb  << 2) + 0xff000000)
#define ENCL2_VIDEO_BLANKY_VAL                     ((0x24bc  << 2) + 0xff000000)
#define ENCL2_VIDEO_BLANKPB_VAL                    ((0x24bd  << 2) + 0xff000000)
#define ENCL2_VIDEO_BLANKPR_VAL                    ((0x24be  << 2) + 0xff000000)
#define ENCL2_VIDEO_HOFFST                         ((0x24bf  << 2) + 0xff000000)
#define ENCL2_VIDEO_VOFFST                         ((0x24c0  << 2) + 0xff000000)
#define ENCL2_VIDEO_RGB_CTRL                       ((0x24c1  << 2) + 0xff000000)
#define ENCL2_VIDEO_FILT_CTRL                      ((0x24c2  << 2) + 0xff000000)
#define ENCL2_VIDEO_OFLD_VPEQ_OFST                 ((0x24c3  << 2) + 0xff000000)
#define ENCL2_VIDEO_OFLD_VOAV_OFST                 ((0x24c4  << 2) + 0xff000000)
#define ENCL2_VIDEO_MATRIX_CB                      ((0x24c5  << 2) + 0xff000000)
#define ENCL2_VIDEO_MATRIX_CR                      ((0x24c6  << 2) + 0xff000000)
#define ENCL2_VIDEO_RGBIN_CTRL                     ((0x24c7  << 2) + 0xff000000)
#define ENCL2_MAX_LINE_SWITCH_POINT                ((0x24c8  << 2) + 0xff000000)
#define ENCL2_DACSEL_0                             ((0x24c9  << 2) + 0xff000000)
#define ENCL2_DACSEL_1                             ((0x24ca  << 2) + 0xff000000)
#define ENCT2_VIDEO_H_PRE_DE_END                   ((0x24cb  << 2) + 0xff000000)
#define ENCT2_VIDEO_H_PRE_DE_BEGIN                 ((0x24cc  << 2) + 0xff000000)
#define ENCT2_VIDEO_V_PRE_DE_ELINE                 ((0x24cd  << 2) + 0xff000000)
#define ENCT2_VIDEO_V_PRE_DE_BLINE                 ((0x24ce  << 2) + 0xff000000)
#define ENCL2_VIDEO_H_PRE_DE_END                   ((0x24cf  << 2) + 0xff000000)
#define ENCL2_VIDEO_H_PRE_DE_BEGIN                 ((0x24d0  << 2) + 0xff000000)
#define ENCL2_VIDEO_V_PRE_DE_ELINE                 ((0x24d1  << 2) + 0xff000000)
#define ENCL2_VIDEO_V_PRE_DE_BLINE                 ((0x24d2  << 2) + 0xff000000)
#define ENCL2_INBUF_CNTL0                          ((0x24d3  << 2) + 0xff000000)
#define ENCL2_INBUF_CNTL1                          ((0x24d4  << 2) + 0xff000000)
#define ENCL2_INBUF_CNT                            ((0x24d5  << 2) + 0xff000000)
#define ENCL2_INBUF_HOLD_CNT                       ((0x24d6  << 2) + 0xff000000)
#define ENCL2_INBUF_FIX_PIX_NUM                    ((0x24d7  << 2) + 0xff000000)
#define VENC2_VRR_CTRL                             ((0x24d8  << 2) + 0xff000000)
//Bit   31    cfg_vsp_din      // W, pulse
//Bit   30    cfg_vrr_clr      // W, pulse
//Bit 31:28   ro_vrr_vsp_cnt   // R,
//Bit 27:24   ro_vrr_max_err   // R,
//Bit 23:8    cfg_vsp_dly_num  // R/W, unsigned, default 0
//Bit  7:4    cfg_vrr_frm_ths  // R/W, unsigned, default 0
//Bit  3:2    cfg_vrr_vsp_en   // R/W, unsigned, default 0
//Bit    1    cfg_vrr_mode     // R/W, unsigned, default 0
//Bit    0    cfg_vrr_vsp_sel  // R/W, unsigned, default 0
#define VENC2_VRR_ADJ_LMT                          ((0x24d9  << 2) + 0xff000000)
//Bit 31:16  cfg_vrr_min_vnum  //R/W, unsigned,
//Bit 15:0   cfg_vrr_max_vnum  //R/W, unsigned,
#define VENC2_VRR_CTRL1                            ((0x24da  << 2) + 0xff000000)
//Bit 4:1    cfg_vsp_rst_num   //R/W, unsigned, default 1
//Bit   0    cfg_vsp_cnt_rst   //W,pulse
#define VPU2_VPU_PWM_V0                            ((0x24e0  << 2) + 0xff000000)
#define VPU2_VPU_PWM_V1                            ((0x24e1  << 2) + 0xff000000)
#define VPU2_VPU_PWM_V2                            ((0x24e2  << 2) + 0xff000000)
#define VPU2_VPU_PWM_V3                            ((0x24e3  << 2) + 0xff000000)
#define VPU2_VPU_PWM_H0                            ((0x24e4  << 2) + 0xff000000)
#define VPU2_VPU_PWM_H1                            ((0x24e5  << 2) + 0xff000000)
#define VPU2_VPU_PWM_H2                            ((0x24e6  << 2) + 0xff000000)
#define VPU2_VPU_PWM_H3                            ((0x24e7  << 2) + 0xff000000)
#define VPU2_VPU_3D_SYNC1                          ((0x24e8  << 2) + 0xff000000)
#define VPU2_VPU_3D_SYNC2                          ((0x24e9  << 2) + 0xff000000)
#define VPU2_VENC_DUMMY                            ((0x24df  << 2) + 0xff000000)
#define VPU2_VENC_ERROR                            ((0x24ea  << 2) + 0xff000000)
#define VPU2_VENCI_STAT                            ((0x24eb  << 2) + 0xff000000)
#define VPU2_VENCP_STAT                            ((0x24ec  << 2) + 0xff000000)
#define VPU2_VENCL_STAT                            ((0x24ed  << 2) + 0xff000000)
#define VPU2_VENC_DITH                             ((0x24ee  << 2) + 0xff000000)
#define VPU2_VENC_CTRL                             ((0x24ef  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_CTRL                       ((0x24f0  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_1                      ((0x24f1  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_2                      ((0x24f2  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_3                      ((0x24f3  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_4                      ((0x24f4  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_5                      ((0x24f5  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_6                      ((0x24f6  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_7                      ((0x24f7  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_8                      ((0x24f8  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_9                      ((0x24f9  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_10                     ((0x24fa  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_11                     ((0x24fb  << 2) + 0xff000000)
#define VPU2_VENCL_DITH_LUT_12                     ((0x24fc  << 2) + 0xff000000)
//
// Closing file:  ./venc2_2_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_top_regs.h
//
// synopsys translate_off
// synopsys translate_on
//======================================================================
//   vpu  register.
//======================================================================
// -----------------------------------------------
// REG_BASE:  VPU_VCBUS_BASE = 0x27
// -----------------------------------------------
#define VPU_CRC_CTRL                               ((0x2701  << 2) + 0xff000000)
#define VPU_RO_CRC0                                ((0x2702  << 2) + 0xff000000)
#define VPU_RO_CRC1                                ((0x2703  << 2) + 0xff000000)
#define VPU_RO_CRC2                                ((0x2704  << 2) + 0xff000000)
#define VPU_RO_CRC3                                ((0x2705  << 2) + 0xff000000)
#define VPU_RO_CRC4                                ((0x2706  << 2) + 0xff000000)
#define VPU_RO_CRC5                                ((0x2707  << 2) + 0xff000000)
#define VPU_RO_CRC6                                ((0x2708  << 2) + 0xff000000)
#define VPU_INTF_CTRL                              ((0x270a  << 2) + 0xff000000)
#define VPU_APB_PROT_CTRL                          ((0x270b  << 2) + 0xff000000)
#define VPU_ENC_ERROR                              ((0x270c  << 2) + 0xff000000)
#define VPU_SECURE_REG                             ((0x270d  << 2) + 0xff000000)
#define VPU_SECURE_ST_RO                           ((0x270e  << 2) + 0xff000000)
#define VPU_VDIN_SEC_IN                            ((0x270f  << 2) + 0xff000000)
//Read only
//`define     VPU_TVDVBI_VSLATCH_ADDR   8'h12
//Read only
//`define     VPU_TVDVBI_WRRSP_ADDR 8'h13
#define VPU_VDIN_PRE_ARB_CTRL                      ((0x2714  << 2) + 0xff000000)
#define VPU_VDISP_PRE_ARB_CTRL                     ((0x2715  << 2) + 0xff000000)
#define VPU_VPUARB2_PRE_ARB_CTRL                   ((0x2716  << 2) + 0xff000000)
// [31:21] Reserved.
// [20:18] cntl_encx_clk_sel
// [17:16] cntl_vencl_dpi_sel_clk
// [15: 8] Reserved
// [ 6: 4] Reserved
// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
#define VPU_VIU_VENC_MUX_CTRL                      ((0x271a  << 2) + 0xff000000)
// [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
// [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
// [ 7: 5] data_comp_map. Input data is CrYCb(BRG), map the output data to desired format:
//                          0=output CrYCb(BRG);
//                          1=output YCbCr(RGB);
//                          2=output YCrCb(RBG);
//                          3=output CbCrY(GBR);
//                          4=output CbYCr(GRB);
//                          5=output CrCbY(BGR);
//                          6,7=Rsrv.
// [    4] inv_dvi_clk. 1=Invert clock to external DVI, (clock invertion exists at internal HDMI).
// [    3] inv_vsync. 1=Invert Vsync polarity.
// [    2] inv_hsync. 1=Invert Hsync polarity.
// [ 1: 0] src_sel. 0=Disable output to HDMI; 1=Select VENC_I output to HDMI; 2=Select VENC_P output.
#define VPU_HDMI_SETTING                           ((0x271b  << 2) + 0xff000000)
#define ENCI_INFO_READ                             ((0x271c  << 2) + 0xff000000)
#define ENCP_INFO_READ                             ((0x271d  << 2) + 0xff000000)
#define ENCT_INFO_READ                             ((0x271e  << 2) + 0xff000000)
#define ENCL_INFO_READ                             ((0x271f  << 2) + 0xff000000)
// Bit  0 RW, viu_rst_n
// Bit  1 RW, vdin_mmc_arb_rst_n
// Bit  2 RW, vdisp_mmc_arb_rst_n
// Bit  3 RW, vpuarb2_mmc_arb_rst_n
#define VPU_SW_RESET                               ((0x2720  << 2) + 0xff000000)
// Bit  6 RW, gclk_mpeg_vpu_misc
// Bit  5 RW, gclk_mpeg_venc_l_top
// Bit  4 RW, gclk_mpeg_vencl_int
// Bit  3 RW, gclk_mpeg_vencp_int
// Bit  2 RW, gclk_mpeg_vi2_top
// Bit  1 RW, gclk_mpeg_vi_top
// Bit  0 RW, gclk_mpeg_venc_p_top
#define VPU_CLK_GATE                               ((0x2723  << 2) + 0xff000000)
#define VPU_MEM_PD_REG0                            ((0x2725  << 2) + 0xff000000)
#define VPU_MEM_PD_REG1                            ((0x2726  << 2) + 0xff000000)
// [   31] hdmi_data_ovr_en: 1=Enable overriding data input to HDMI TX with hdmi_data_ovr[29:0]. 0=No override. Default 0.
// [   30] Reserved.                                                                                            Default 0
// [29: 0] hdmi_data_ovr.                                                                                       Default 0.
#define VPU_HDMI_DATA_OVR                          ((0x2727  << 2) + 0xff000000)
#define VPU_AXI_QOS_RD0                            ((0x2730  << 2) + 0xff000000)
#define VPU_AXI_QOS_RD1                            ((0x2731  << 2) + 0xff000000)
#define VPU_AXI_QOS_WR0                            ((0x2732  << 2) + 0xff000000)
#define VPU_AXI_CACHE                              ((0x2733  << 2) + 0xff000000)
//Bit 0,   if true, force vencl clk enable, otherwise, it might auto turn off by mipi DSI
#define VPU_MISC_CTRL                              ((0x2740  << 2) + 0xff000000)
#define VPU_ISP_GCLK_CTRL0                         ((0x2741  << 2) + 0xff000000)
#define VPU_ISP_GCLK_CTRL1                         ((0x2742  << 2) + 0xff000000)
#define VPU_HDMI_FMT_CTRL                          ((0x2743  << 2) + 0xff000000)
#define VPU_VDIN_ASYNC_HOLD_CTRL                   ((0x2744  << 2) + 0xff000000)
#define VPU_VDISP_ASYNC_HOLD_CTRL                  ((0x2745  << 2) + 0xff000000)
#define VPU_VPUARB2_ASYNC_HOLD_CTRL                ((0x2746  << 2) + 0xff000000)
#define VPU_ARB_URG_CTRL                           ((0x2747  << 2) + 0xff000000)
#define VPU_SECURE_DUMMY                           ((0x2748  << 2) + 0xff000000)
#define VPU_VENCL_DITH_EN                          ((0x2749  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_RST                           ((0x274a  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_CTRL0                         ((0x274b  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_CTRL1                         ((0x274c  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_CTRL2                         ((0x274d  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_CTRL3                         ((0x274e  << 2) + 0xff000000)
// todo :
#define VPU_422TO444_CTRL4                         ((0x274f  << 2) + 0xff000000)
//Bit 20    reg_viu2vdin0_sw_reset:   software reset
//Bit 19:18 reg_viu2vdin0_dn_ratio:   down-scale ratio; 0: no scale; 1: 1/2;  2:1/4; 3: reserved
//Bit 17:16 reg_viu2vdin0_flt_mode:   filter mode; 0: no filter; 1:[0 2 2 0]/4; 2:[1 1 1 1]/4; 3:[1 3 3 1]/8
//Bit 15:14 reversed
//Bit 13:0  reg_viu2vdin0_hsize:      source horizontal size
#define VPU_VIU2VDIN0_HDN_CTRL                     ((0x2780  << 2) + 0xff000000)
#define VPU_VIU_ASYNC_MASK                         ((0x2781  << 2) + 0xff000000)
#define VPU_VDIN_MISC_CTRL                         ((0x2782  << 2) + 0xff000000)
// [31:29] Reserved.
// [28:24] cntl_viu2vdin1_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          5'b00000=Disable VIU to VDIN path;
//          5'b00001=Enable VIU of ENC_I domain to VDIN;
//          5'b00010=Enable VIU of ENC_P domain to VDIN;
//          5'b00100=Enable VIU of ENC_T domain to VDIN;
//          5'b01000=Enable VIU WriteBack 1 domain to VDIN;
//          5'b10000=Enable VIU WriteBack 2 domain to VDIN;
// [23:21] Reserved.
// [20:16] cntl_viu2vdin1_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          5'b00000=Disable VIU to VDIN clock;
//          5'b00001=Select encI clock to VDIN;
//          5'b00010=Select encP clock to VDIN;
//          5'b00100=Select encT clock to VDIN;
//          5'b01000=Select VIU WriteBack 1 clock to VDIN;
//          5'b10000=Select VIU WriteBack 2 clock to VDIN;
// [15:13] Reserved.
// [12: 8] cntl_viu2vdin0_sel_data. Select VIU to VDIN data path, must clear it first before changing the path selection:
//          5'b00000=Disable VIU to VDIN path;
//          5'b00001=Enable VIU of ENC_I domain to VDIN;
//          5'b00010=Enable VIU of ENC_P domain to VDIN;
//          5'b00100=Enable VIU of ENC_T domain to VDIN;
//          5'b01000=Enable VIU WriteBack 1 domain to VDIN;
//          5'b10000=Enable VIU WriteBack 2 domain to VDIN;
// [ 7:5]  Reserved.
// [ 4: 0] cntl_viu2vdin0_sel_clk. Select which clock to VDIN path, must clear it first before changing the clock:
//          5'b00000=Disable VIU to VDIN clock;
//          5'b00001=Select encI clock to VDIN;
//          5'b00010=Select encP clock to VDIN;
//          5'b00100=Select encT clock to VDIN;
//          5'b01000=Select VIU WriteBack 1 clock to VDIN;
//          5'b10000=Select VIU WriteBack 2 clock to VDIN;
#define VPU_VIU_VDIN_IF_MUX_CTRL                   ((0x2783  << 2) + 0xff000000)
//Bit 20    reg_viu2vdin1_sw_reset:   software reset
//Bit 19:18 reg_viu2vdin1_dn_ratio:   down-scale ratio; 0: no scale; 1: 1/2;  2:1/4; 3: reserved
//Bit 17:16 reg_viu2vdin1_flt_mode:   filter mode; 0: no filter; 1:[0 2 2 0]/4; 2:[1 1 1 1]/4; 3:[1 3 3 1]/8
//Bit 15:14 reversed
//Bit 13:0  reg_viu2vdin1_hsize:      source horizontal size
#define VPU_VIU2VDIN1_HDN_CTRL                     ((0x2784  << 2) + 0xff000000)
#define VPU_VENCX_CLK_CTRL                         ((0x2785  << 2) + 0xff000000)
//Bit 0  encp_afifo_clk
//Bit 1  encl_afifo_clk
//Bit 2  enci_afifo_clk
#define VPU_DISP_VIU0_CTRL                         ((0x2786  << 2) + 0xff000000)
//Bit 31    lvds_out_enable[0]
//Bit 30    vbo_out_enable[0]
//Bit 29    hdmi_tx_enable[0]
//Bit 28    dsi_edp_enable[0]
//Bit 27:7  reversed
//Bit 6     viu0_disable_rst_afifo
//Bit 5:4   viu0_vs_hs_ctrl
//Bit 3:2   viu0_force_field_ctrl
//Bit 1     viu0_force_go_line
//Bit 0     viu0_force_go_field
#define VPU_DISP_VIU1_CTRL                         ((0x2787  << 2) + 0xff000000)
//Bit 31    lvds_out_enable[1]
//Bit 30    vbo_out_enable[1]
//Bit 29    hdmi_tx_enable[1]
//Bit 28    dsi_edp_enable[1]
//Bit 27:7  reversed
//Bit 6     viu1_disable_rst_afifo
//Bit 5:4   viu1_vs_hs_ctrl
//Bit 3:2   viu1_force_field_ctrl
//Bit 1     viu1_force_go_line
//Bit 0     viu1_force_go_field
#define VPU_DISP_VIU2_CTRL                         ((0x2788  << 2) + 0xff000000)
//Bit 31    lvds_out_enable[2]
//Bit 30    vbo_out_enable[2]
//Bit 29    hdmi_tx_enable[2]
//Bit 28    dsi_edp_enable[2]
//Bit 27:7  reversed
//Bit 6     viu2_disable_rst_afifo
//Bit 5:4   viu2_vs_hs_ctrl
//Bit 3:2   viu2_force_field_ctrl
//Bit 1     viu2_force_go_line
//Bit 0     viu2_force_go_field
#define VPU_VENC_RGN_CTRL                          ((0x2789  << 2) + 0xff000000)
#define VPU_VENC_RGN_RSIZE                         ((0x278a  << 2) + 0xff000000)
#define VPU_DISP_WRAP_CTRL                         ((0x278b  << 2) + 0xff000000)
// vpu arbtration :
// the segment is 8'h90-8'hc8
//
// Reading file:  ./vpu_arb_axi_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define VPU_RDARB_MODE_L1C1                        ((0x2790  << 2) + 0xff000000)
//Bit   31:22,    reserved
//Bit   21:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define VPU_RDARB_REQEN_SLV_L1C1                   ((0x2791  << 2) + 0xff000000)
//Bit   31:12,     reserved
//Bit   11:0,     rdarb_dc_req_en     unsigned  , default = 12'hfff
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[6]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[10]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[11]: the slv5 req to mst port1 enable,
#define VPU_RDARB_WEIGH0_SLV_L1C1                  ((0x2792  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define VPU_RDARB_WEIGH1_SLV_L1C1                  ((0x2793  << 2) + 0xff000000)
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define VPU_WRARB_MODE_L1C1                        ((0x2794  << 2) + 0xff000000)
//Bit   31:22,    reserved
//Bit   21:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//                                    wrarb_sel[4]==0 slave dc4 connect master port0 wrarb_sel[4]==1 slave dc4 connect master port1
//                                    wrarb_sel[5]==0 slave dc5 connect master port0 wrarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port1 clk gate control
#define VPU_WRARB_REQEN_SLV_L1C1                   ((0x2795  << 2) + 0xff000000)
//Bit   31:12,     reserved
//Bit   11:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    wrarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    wrarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define VPU_WRARB_WEIGH0_SLV_L1C1                  ((0x2796  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define VPU_WRARB_WEIGH1_SLV_L1C1                  ((0x2797  << 2) + 0xff000000)
//Bit   31:6,    reserved
//Bit   5:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define VPU_RDWR_ARB_STATUS_L1C1                   ((0x2798  << 2) + 0xff000000)
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define VPU_RDARB_MODE_L1C2                        ((0x2799  << 2) + 0xff000000)
//Bit   31:21,    reserved
//Bit   20:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port0 clk gate control
#define VPU_RDARB_REQEN_SLV_L1C2                   ((0x279a  << 2) + 0xff000000)
//Bit   31:10,     reserved
//Bit    9:0,     rdarb_dc_req_en     unsigned  , default = 0
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[6]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[7]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[8]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[9]: the slv4 req to mst port1 enable,
#define VPU_RDARB_WEIGH0_SLV_L1C2                  ((0x279b  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define VPU_RDWR_ARB_STATUS_L1C2                   ((0x279c  << 2) + 0xff000000)
//Bit   31:3,    reserved
//Bit      2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define VPU_RDARB_MODE_L2C1                        ((0x279d  << 2) + 0xff000000)
//Bit   31:28,    reserved
//Bit   27:16,    rdarb_sel           uns, default = 0 ,
//                                    rdarb_sel[0]==0 slave dc0 connect master port0 rdarb_sel[0]==1 slave dc0 connect master port1
//                                    rdarb_sel[1]==0 slave dc1 connect master port0 rdarb_sel[1]==1 slave dc1 connect master port1
//                                    rdarb_sel[2]==0 slave dc2 connect master port0 rdarb_sel[2]==1 slave dc2 connect master port1
//                                    rdarb_sel[3]==0 slave dc3 connect master port0 rdarb_sel[3]==1 slave dc3 connect master port1
//                                    rdarb_sel[4]==0 slave dc4 connect master port0 rdarb_sel[4]==1 slave dc4 connect master port1
//                                    rdarb_sel[5]==0 slave dc5 connect master port0 rdarb_sel[5]==1 slave dc5 connect master port1
//Bit   15:11,    reserved
//Bit   10:8,      rdarb_arb_mode      uns, default = 0 ,
//                                    rdarb_arb_mode[0] master port0 arb way,
//                                    rdarb_arb_mode[1] master port1 arb way,
//Bit   7:6,      reserved
//Bit   5:0,      rdarb_gate_clk_ctrl uns, default = 0 ,
//                                    rdarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    rdarb_gate_clk_ctrl[3:2] master port1 clk gate control
//                                    rdarb_gate_clk_ctrl[5:4] master port2 clk gate control
#define VPU_RDARB_REQEN_SLV_L2C1                   ((0x279e  << 2) + 0xff000000)
//Bit   31:18,     reserved
//Bit   17:0,     rdarb_dc_req_en     unsigned  , default = 0
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port0 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port0 enable,
//                                    rdarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    rdarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    rdarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    rdarb_dc_req_en[3]: the slv3 req to mst port1 enable,
//                                    rdarb_dc_req_en[4]: the slv4 req to mst port1 enable,
//                                    rdarb_dc_req_en[5]: the slv5 req to mst port1 enable,
#define VPU_RDARB_WEIGH0_SLV_L2C1                  ((0x279f  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    rddc_weigh_sxn[3*6+:6]: the slv3 req weigh number
//                                    rddc_weigh_sxn[4*6+:6]: the slv4 req weigh number
#define VPU_RDARB_WEIGH1_SLV_L2C1                  ((0x27a0  << 2) + 0xff000000)
//Bit   31:6,    reserved
//Bit   5:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv5 req weigh number
#define VPU_RDWR_ARB_STATUS_L2C1                   ((0x27a1  << 2) + 0xff000000)
//Bit   31:4,    reserved
//Bit    3:2,    wrarb_arb_busy     unsigned  , default = 0
//Bit    1:0,    rdarb_arb_busy     unsigned  , default = 0
#define VPU_WRARB_MODE_L2C1                        ((0x27a2  << 2) + 0xff000000)
//Bit   31:20,    reserved
//Bit   19:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//                                    wrarb_sel[2]==0 slave dc2 connect master port0 wrarb_sel[2]==1 slave dc2 connect master port1
//                                    wrarb_sel[3]==0 slave dc3 connect master port0 wrarb_sel[3]==1 slave dc3 connect master port1
//Bit   15:10,    reserved
//Bit   9:8,      wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//                                    wrarb_arb_mode[1] master port1 arb way,
//Bit   7:4,      reserved
//Bit   3:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
//                                    wrarb_gate_clk_ctrl[3:2] master port0 clk gate control
#define VPU_WRARB_REQEN_SLV_L2C1                   ((0x27a3  << 2) + 0xff000000)
//Bit   31:8,     reserved
//Bit    7:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port0 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port0 enable,
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port1 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port1 enable,
//                                    wrarb_dc_req_en[2]: the slv2 req to mst port1 enable,
//                                    wrarb_dc_req_en[3]: the slv3 req to mst port1 enable,
#define VPU_WRARB_WEIGH0_SLV_L2C1                  ((0x27a4  << 2) + 0xff000000)
//Bit   31:24,    reserved
//Bit   23:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv2 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv3 req weigh number
#define VPU_ASYNC_RD_MODE0                         ((0x27a5  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define VPU_ASYNC_RD_MODE1                         ((0x27a6  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define VPU_ASYNC_RD_MODE2                         ((0x27a7  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define VPU_ASYNC_RD_MODE3                         ((0x27a8  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define VPU_ASYNC_RD_MODE4                         ((0x27a9  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      rd_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      rd_rel_num        unsigned  , default = 0  release the read command threshold
#define VPU_ASYNC_WR_MODE0                         ((0x27aa  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define VPU_ASYNC_WR_MODE1                         ((0x27ab  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define VPU_ASYNC_WR_MODE2                         ((0x27ac  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       req_en            unsigned  , default = 0  async enable
//Bit   17:16,    clk_gate_ctrl     unsigned  , default = 0  async clock gate control
//Bit   15:12,    auto_arugt_weight unsigned  , default = 4
//Bit   11,       reserved
//Bit   10:9,     arugt_sel         unsigned  , default = 0
//                                  00 : use auto fifo arugt generate the output arugt.
//                                  01 : use the register bit control
//                                  00 : use the input arguent
//Bit   8,        arguent_cfg       unsigned  , default = 0  register arguent control bit
//Bit   7:4,      wr_hold_num       unsigned  , default = 4  hold the read command threshold
//Bit   3:0,      wr_rel_num        unsigned  , default = 0  release the write command threshold
#define VPU_ASYNC_STAT                             ((0x27ad  << 2) + 0xff000000)
//Bit   31:19,    reserved
//Bit   18,       axiwr2_chan_idle  unsigned  , RO, axi write channel2 idle state
//Bit   17,       axiwr1_chan_idle  unsigned  , RO, axi write channel1 idle state
//Bit   16,       axiwr0_chan_idle  unsigned  , RO, axi write channel0 idle state
//Bit   15:5,     reserved
//Bit   4,        axird4_chan_idle  unsigned  , RO, axi read channel4 idle state
//Bit   3,        axird3_chan_idle  unsigned  , RO, axi read channel3 idle state
//Bit   2,        axird2_chan_idle  unsigned  , RO, axi read channel2 idle state
//Bit   1,        axird1_chan_idle  unsigned  , RO, axi read channel1 idle state
//Bit   0,        axird0_chan_idle  unsigned  , RO, axi read channel0 idle state
#define VPU_WRARB_MODE_L1C2                        ((0x27ae  << 2) + 0xff000000)
//Bit   31:18,    reserved
//Bit   17:16,    wrarb_sel           uns, default = 0 ,
//                                    wrarb_sel[0]==0 slave dc0 connect master port0 wrarb_sel[0]==1 slave dc0 connect master port1
//                                    wrarb_sel[1]==0 slave dc1 connect master port0 wrarb_sel[1]==1 slave dc1 connect master port1
//Bit   15:9,     reserved
//Bit   8,        wrarb_arb_mode      uns, default = 0 ,
//                                    wrarb_arb_mode[0] master port0 arb way,
//Bit   7:2,      reserved
//Bit   1:0,      wrarb_gate_clk_ctrl uns, default = 0 ,
//                                    wrarb_gate_clk_ctrl[1:0] master port0 clk gate control
#define VPU_WRARB_REQEN_SLV_L1C2                   ((0x27af  << 2) + 0xff000000)
//Bit   31:2,     reserved
//Bit    1:0,     wrarb_dc_req_en     unsigned  , default = 0
//                                    wrarb_dc_req_en[0]: the slv0 req to mst port0 enable,
//                                    wrarb_dc_req_en[1]: the slv1 req to mst port0 enable,
#define VPU_WRARB_WEIGH0_SLV_L1C2                  ((0x27b0  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[0*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[1*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[2*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[3*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[4*6+:6]: the slv1 req weigh number
#define VPU_WRARB_WEIGH1_SLV_L1C2                  ((0x27b1  << 2) + 0xff000000)
//Bit   31:18,    reserved
//Bit   17:0,     wrdc_weigh_sxn     unsigned  , default = 0
//                                    wrdc_weigh_sxn[5*6+:6]: the slv0 req weigh number
//                                    wrdc_weigh_sxn[6*6+:6]: the slv1 req weigh number
//                                    wrdc_weigh_sxn[7*6+:6]: the slv1 req weigh number
#define VPU_RDARB_WEIGH1_SLV_L1C2                  ((0x27b2  << 2) + 0xff000000)
//Bit   31:18,    reserved
//Bit   17:0,     rddc_weigh_sxn     unsigned  , default = 0
//                                    rddc_weigh_sxn[5*6+:6]: the slv0 req weigh number
//                                    rddc_weigh_sxn[6*6+:6]: the slv1 req weigh number
//                                    rddc_weigh_sxn[7*6+:6]: the slv2 req weigh number
#define VPU_ARB_DBG_CTRL_L1C1                      ((0x27b3  << 2) + 0xff000000)
#define VPU_ARB_DBG_STAT_L1C1                      ((0x27b4  << 2) + 0xff000000)
#define VPU_ARB_DBG_CTRL_L1C2                      ((0x27b5  << 2) + 0xff000000)
#define VPU_ARB_DBG_STAT_L1C2                      ((0x27b6  << 2) + 0xff000000)
#define VPU_ARB_DBG_CTRL_L2C1                      ((0x27b7  << 2) + 0xff000000)
#define VPU_ARB_DBG_STAT_L2C1                      ((0x27b8  << 2) + 0xff000000)
#define VPU_ARB_PATH_CTRL                          ((0x27b9  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP00                         ((0x27ba  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP01                         ((0x27bb  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP02                         ((0x27bc  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP03                         ((0x27bd  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP10                         ((0x27be  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP11                         ((0x27bf  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP12                         ((0x27c0  << 2) + 0xff000000)
#define VPU_ARB_PATH_MAP13                         ((0x27c1  << 2) + 0xff000000)
#define VPU_RDARB_UGT_L2C1                         ((0x27c2  << 2) + 0xff000000)
#define VPU_WRARB_UGT_L2C1                         ((0x27c3  << 2) + 0xff000000)
#define VPU_RDARB_LIMT0_L2C1                       ((0x27c4  << 2) + 0xff000000)
#define VPU_RDARB_LIMT1_L2C1                       ((0x27c5  << 2) + 0xff000000)
#define VPU_ARB_AXIWR_PROT                         ((0x27c6  << 2) + 0xff000000)
#define VPU_ARB_AXIRD0_PROT                        ((0x27c7  << 2) + 0xff000000)
#define VPU_ARB_AXIRD1_PROT                        ((0x27c8  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_arb_axi_regs.h
//
// vpu lut dma
// the segment is 8'h50~8'h7f & 8'hca-8'hdf
//
// Reading file:  ./vpu_lut_dma_regs.h
//
// synopsys translate_off
// synopsys translate_on
// 0x50~0x7f
//
// Reading file:  ./viu_dma_top.h
//
#define VPU_DMA_RDMIF0_CTRL                        ((0x2750  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd0_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd0_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd0_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd0_enable_int           // unsigned ,    RW , default = 0     channel0 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd0_stride               // unsigned ,    RW , default = 512   channel0 send number
#define VPU_DMA_RDMIF1_CTRL                        ((0x2751  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd1_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd1_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd1_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd1_enable_int           // unsigned ,    RW , default = 0     channel1 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd1_stride               // unsigned ,    RW , default = 512   channel1 send number
#define VPU_DMA_RDMIF2_CTRL                        ((0x2752  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd2_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd2_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd2_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd2_enable_int           // unsigned ,    RW , default = 0     channel2 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd2_stride               // unsigned ,    RW , default = 512   channel2 send number
#define VPU_DMA_RDMIF3_CTRL                        ((0x2753  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd3_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd3_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd3_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd3_enable_int           // unsigned ,    RW , default = 0     channel3 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd3_stride               // unsigned ,    RW , default = 512   channel3 send number
#define VPU_DMA_RDMIF4_CTRL                        ((0x2754  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd4_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd4_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd4_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd4_enable_int           // unsigned ,    RW , default = 0     channel4 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd4_stride               // unsigned ,    RW , default = 512   channel4 send number
#define VPU_DMA_RDMIF5_CTRL                        ((0x2755  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd5_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd5_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd5_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd5_enable_int           // unsigned ,    RW , default = 0     channel5 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd5_stride               // unsigned ,    RW , default = 512   channel5 send number
#define VPU_DMA_RDMIF6_CTRL                        ((0x2756  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd6_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd6_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd6_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd6_enable_int           // unsigned ,    RW , default = 0     channel6 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd6_stride               // unsigned ,    RW , default = 512   channel6 send number
#define VPU_DMA_RDMIF7_CTRL                        ((0x2757  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit    27        reg_rd7_frm_ctrl             // unsigned ,    RW , default = 0
//Bit    26        reg_rd7_frm_force            // unsigned ,    RW , default = 0
//Bit 25:24        reg_rd7_frm_ini              // unsigned ,    RW , default = 0
//Bit 23:16        reg_rd7_enable_int           // unsigned ,    RW , default = 0     channel7 select interrupt source
//Bit 15:13        reserved
//Bit 12:0         reg_rd7_stride               // unsigned ,    RW , default = 512   channel7 send number
#define VPU_DMA_RDMIF0_BADR0                       ((0x2758  << 2) + 0xff000000)
//Bit 31:0  lut0_reg_baddr0
#define VPU_DMA_RDMIF0_BADR1                       ((0x2759  << 2) + 0xff000000)
//Bit 31:0  lut0_reg_baddr1
#define VPU_DMA_RDMIF0_BADR2                       ((0x275a  << 2) + 0xff000000)
//Bit 31:0  lut0_reg_baddr2
#define VPU_DMA_RDMIF0_BADR3                       ((0x275b  << 2) + 0xff000000)
//Bit 31:0  lut0_reg_baddr3
#define VPU_DMA_RDMIF1_BADR0                       ((0x275c  << 2) + 0xff000000)
//Bit 31:0  lut1_reg_baddr0
#define VPU_DMA_RDMIF1_BADR1                       ((0x275d  << 2) + 0xff000000)
//Bit 31:0  lut1_reg_baddr1
#define VPU_DMA_RDMIF1_BADR2                       ((0x275e  << 2) + 0xff000000)
//Bit 31:0  lut1_reg_baddr2
#define VPU_DMA_RDMIF1_BADR3                       ((0x275f  << 2) + 0xff000000)
//Bit 31:0  lut1_reg_baddr3
#define VPU_DMA_RDMIF2_BADR0                       ((0x2760  << 2) + 0xff000000)
//Bit 31:0  lut2_reg_baddr0
#define VPU_DMA_RDMIF2_BADR1                       ((0x2761  << 2) + 0xff000000)
//Bit 31:0  lut2_reg_baddr1
#define VPU_DMA_RDMIF2_BADR2                       ((0x2762  << 2) + 0xff000000)
//Bit 31:0  lut2_reg_baddr2
#define VPU_DMA_RDMIF2_BADR3                       ((0x2763  << 2) + 0xff000000)
//Bit 31:0  lut2_reg_baddr3
#define VPU_DMA_RDMIF3_BADR0                       ((0x2764  << 2) + 0xff000000)
//Bit 31:0  lut3_reg_baddr0
#define VPU_DMA_RDMIF3_BADR1                       ((0x2765  << 2) + 0xff000000)
//Bit 31:0  lut3_reg_baddr1
#define VPU_DMA_RDMIF3_BADR2                       ((0x2766  << 2) + 0xff000000)
//Bit 31:0  lut3_reg_baddr2
#define VPU_DMA_RDMIF3_BADR3                       ((0x2767  << 2) + 0xff000000)
//Bit 31:0  lut3_reg_baddr3
#define VPU_DMA_RDMIF4_BADR0                       ((0x2768  << 2) + 0xff000000)
//Bit 31:0  lut4_reg_baddr0
#define VPU_DMA_RDMIF4_BADR1                       ((0x2769  << 2) + 0xff000000)
//Bit 31:0  lut4_reg_baddr1
#define VPU_DMA_RDMIF4_BADR2                       ((0x276a  << 2) + 0xff000000)
//Bit 31:0  lut4_reg_baddr2
#define VPU_DMA_RDMIF4_BADR3                       ((0x276b  << 2) + 0xff000000)
//Bit 31:0  lut4_reg_baddr3
#define VPU_DMA_RDMIF5_BADR0                       ((0x276c  << 2) + 0xff000000)
//Bit 31:0  lut5_reg_baddr0
#define VPU_DMA_RDMIF5_BADR1                       ((0x276d  << 2) + 0xff000000)
//Bit 31:0  lut5_reg_baddr1
#define VPU_DMA_RDMIF5_BADR2                       ((0x276e  << 2) + 0xff000000)
//Bit 31:0  lut5_reg_baddr2
#define VPU_DMA_RDMIF5_BADR3                       ((0x276f  << 2) + 0xff000000)
//Bit 31:0  lut5_reg_baddr3
#define VPU_DMA_RDMIF6_BADR0                       ((0x2770  << 2) + 0xff000000)
//Bit 31:0  lut6_reg_baddr0
#define VPU_DMA_RDMIF6_BADR1                       ((0x2771  << 2) + 0xff000000)
//Bit 31:0  lut6_reg_baddr1
#define VPU_DMA_RDMIF6_BADR2                       ((0x2772  << 2) + 0xff000000)
//Bit 31:0  lut6_reg_baddr2
#define VPU_DMA_RDMIF6_BADR3                       ((0x2773  << 2) + 0xff000000)
//Bit 31:0  lut6_reg_baddr3
#define VPU_DMA_RDMIF7_BADR0                       ((0x2774  << 2) + 0xff000000)
//Bit 31:0  lut7_reg_baddr0
#define VPU_DMA_RDMIF7_BADR1                       ((0x2775  << 2) + 0xff000000)
//Bit 31:0  lut7_reg_baddr1
#define VPU_DMA_RDMIF7_BADR2                       ((0x2776  << 2) + 0xff000000)
//Bit 31:0  lut7_reg_baddr2
#define VPU_DMA_RDMIF7_BADR3                       ((0x2777  << 2) + 0xff000000)
//Bit 31:0  lut7_reg_baddr3
//
// Closing file:  ./viu_dma_top.h
//
// 0x00~0x06
//`include"viu_com_rdmif_regs.h"
#define VPU_DMA_RDMIF_CTRL1                        ((0x27ca  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_CTRL2                        ((0x27cb  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_RO_STAT                      ((0x27d0  << 2) + 0xff000000)
//0x07~0x0d
//`include"viu_com_wrmif_regs.h"
#define VPU_DMA_WRMIF_CTRL1                        ((0x27d1  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_CTRL2                        ((0x27d2  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_CTRL3                        ((0x27d3  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_BADDR0                       ((0x27d4  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_RO_STAT                      ((0x27d7  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_CTRL                         ((0x27d8  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_BADDR1                       ((0x27d9  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_BADDR2                       ((0x27da  << 2) + 0xff000000)
#define VPU_DMA_RDMIF_BADDR3                       ((0x27db  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_CTRL                         ((0x27dc  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_BADDR1                       ((0x27dd  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_BADDR2                       ((0x27de  << 2) + 0xff000000)
#define VPU_DMA_WRMIF_BADDR3                       ((0x27df  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_lut_dma_regs.h
//
//new added 4x4 dither
// the segment is 8'hf0
#define VPU_HDMI_DITH_01_04                        ((0x27f0  << 2) + 0xff000000)
#define VPU_HDMI_DITH_01_15                        ((0x27f1  << 2) + 0xff000000)
#define VPU_HDMI_DITH_01_26                        ((0x27f2  << 2) + 0xff000000)
#define VPU_HDMI_DITH_01_37                        ((0x27f3  << 2) + 0xff000000)
#define VPU_HDMI_DITH_10_04                        ((0x27f4  << 2) + 0xff000000)
#define VPU_HDMI_DITH_10_15                        ((0x27f5  << 2) + 0xff000000)
#define VPU_HDMI_DITH_10_26                        ((0x27f6  << 2) + 0xff000000)
#define VPU_HDMI_DITH_10_37                        ((0x27f7  << 2) + 0xff000000)
#define VPU_HDMI_DITH_11_04                        ((0x27f8  << 2) + 0xff000000)
#define VPU_HDMI_DITH_11_15                        ((0x27f9  << 2) + 0xff000000)
#define VPU_HDMI_DITH_11_26                        ((0x27fa  << 2) + 0xff000000)
#define VPU_HDMI_DITH_11_37                        ((0x27fb  << 2) + 0xff000000)
#define VPU_HDMI_DITH_CNTL                         ((0x27fc  << 2) + 0xff000000)
#define VPU_HDMI_TIMING_STAT                       ((0x27fd  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_top_regs.h
//
//===========================================================================
//  MIPI CSI2 Controller Adaptor    (16'h2a00 - 16'h2aff)
//===========================================================================
//`include "csi2_regs.h"
//===========================================================================
// D2D3 registers
//===========================================================================
//
// Reading file:  ./d2d3_regs.h
//
//===========================================================================
// D2D3 Registers    0x - 0x
//===========================================================================
// -----------------------------------------------
// REG_BASE:  D2D3_VCBUS_BASE = 0x2b
// -----------------------------------------------
//------------------------------------------------------------------------------
// D2D3 top-level registers
//------------------------------------------------------------------------------
// Bit 31    RW, rd_lock_en,     1 to allow update some read-only registers based on filed
// Bit 30    RW, sw_rst_nobuf,   1 to reset the whole d2d3 unit
// Bit 29:28 RW, clk_auto_dis,   [29] DBR clock disable
//                               [28] DPG clock disable
// Bit 27:16 RW, clk_ctrl,       [27:26] gated clock control for register unit
//                               [25:24] gated clock control for DBR unit
//                               [23:22] gated clock control for LBDG unit
//                               [21:20] gated clock control for MBDG unit
//                               [19:18] gated clock control for CBDG unit
//                               [17:16] gated clock control for DBLD unit and SCD81 unit
// Bit 15:12 Reserved
// Bit 11    RW, lo_chroma_sign, 0: negate the u/v component of DBR left channel video output, 1: bypass
// Bit 10    RW, ro_chroma_sign, 0: negate the u/v component of DBR right channel video output, 1: bypass
// Bit 9     RW, vi0_chroma_sign, 0: negate the u/v component of DPG video input, 1: bypass
// Bit 8     RW, vi1_chroma_sign, 0: negate the u/v component of DBR video input, 1: bypass
// Bit 7:5   Reserved
// Bit 4     RW, lg_en,          Enable the LBDG unit and LBDG clock
// Bit 3     RW, mg_en,          Enable the MBDG unit and MBDG clock
// Bit 2     RW, cg_en,          Enable the CBDG unit and CBDG clock
// Bit 1     RW, dbr_en,         Enable the DBR unit and DBR clock
// Bit 0     RW, dpg_en,         Enable the DPG unit and clock except sub-unit CBDG, MBDG and LBDG
#define D2D3_GLB_CTRL                              ((0x2b00  << 2) + 0xff000000)
// Indicate the input picture size in DPG unit
// Bit 31:16 RW, szx_vi_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vi_m1,      The vertical size minus 1
#define D2D3_DPG_INPIC_SIZE                        ((0x2b01  << 2) + 0xff000000)
// Indicate the output picture size in DBR unit
// Bit 31:16 RW, szx_vo_m1,      The horizontal size minus 1
// Bit 15:0  RW, szy_vo_m1,      The vertical size minus 1
#define D2D3_DBR_OUTPIC_SIZE                       ((0x2b02  << 2) + 0xff000000)
// Indicate the rectangular window to generate the "depth" in DPG unit
// Bit 31:16 RW, dg_win_x_start, Horizontal start position, count from 0
// Bit 15:0  RW, dg_win_x_end,   Horizontal end position, count from 0
#define D2D3_DGEN_WIN_HOR                          ((0x2b03  << 2) + 0xff000000)
// Indicate the rectangular window to generate the "depth" in DPG unit
// Bit 31:16 RW, dg_win_y_start, Vertical start position, count from 0
// Bit 15:0  RW, dg_win_y_end,   Vertical end position, count from 0
#define D2D3_DGEN_WIN_VER                          ((0x2b04  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// CBDG SCU18 SCD81 SCD81_PRE registers
// cg: color based depth generate module
// scu18: scale up module
// scd81: scale down module
// scd81_pre: scd81 pre-scale-down module
//------------------------------------------------------------------------------
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_hphs_step, horizontal step
// Bit 15:0  RW, scd81_hphs_ini, horizontal initial phase
#define D2D3_PRE_SCD_H                             ((0x2b05  << 2) + 0xff000000)
// Bit 31:16 RW, scu18_iniph,    initial phase in SCU18,
//                               [23:16] indicate the horizontal phase offset from the first data of every line
//                               [31:24] indicate the vertical phase offset from the first line of every frame
// Bit 15:12 Reserved
// Bit 11    RW, scd81_predrop_en, 1 to enable scd81 pre-scale-down function
// Bit 10:9  RW, cg_csc_sel,     Color Space Conversion(CSC) matrix mode selector in CBDG
//                               0: BT.601 (16-235/240)
//                               1: BT.709 (16-235/240)
//                               2: BT.601 (0-255)
//                               3: BT.709 (0-255)
// Bit 8     RW, scu18_rep_en,   1 to double each line of the SCU18 output
// Bit 7:4   RW, scu18_factor,   up-scale factor in SCU18 on DBR input depth data
//                               [7:6] for vertical, 0->1:1, 1->1:2, 2->1:4, 3->1:8
//                               [5:4] for horizontal, 0->1:1, 1->1:2, 2->1:4, 3->1:8
// Bit 3:0   RW, scd81_factor,   down-scale factor in SCD81 on DPG source video
//                               [3:2] for vertical, 0->1:1, 1->2:1, 2->4:1, 3->8:1
//                               [1:0] for horizontal, 0->1:1, 1->2:1, 2->4:1, 3->8:1
#define D2D3_SCALER_CTRL                           ((0x2b06  << 2) + 0xff000000)
// Bit 31:24 RW, cg_rpg_dth,     the down |r-g| threshold for sky detect
// Bit 23:16 RW, cg_rpg_uth,     the up |r-g| threshold for sky detect
// Bit 15:8  RW, cg_lum_dth,     the down Y threshold for sky detect
// Bit 7:0   RW, cg_lum_uth,     the up Y threshold for sky detect
#define D2D3_CG_THRESHOLD_1                        ((0x2b07  << 2) + 0xff000000)
// Bit 31:24 RW, cg_rpb_dth,     the down |r-b| threshold for sky detect
// Bit 23:16 RW, cg_rpb_uth,     the up |r-b| threshold for sky detect
// Bit 15:8  RW, cg_bpg_dth,     the down |b-g| threshold for sky detect
// Bit 7:0   RW, cg_bpg_uth,     the up |b-g| threshold for sky detect
#define D2D3_CG_THRESHOLD_2                        ((0x2b08  << 2) + 0xff000000)
// Bit 31:24 RW, cg_vp_rel_k,    parameter to calculate vanish point reliability
// Bit 23:16 RW, cg_vp_y_thr,    the max limitation to calculate the vanish-point's vertical position
// Bit 15:8  RW, cg_meet_dval,   signed depth value in the sky-bitmap
// Bit 7:0   RW, cg_unmt_dval,   signed depth value not in the sky-bitmap
#define D2D3_CG_PARAM_1                            ((0x2b09  << 2) + 0xff000000)
// Bit 31:16 RW, cg_vpos_thr,    Maximal vertical limitation for sky-bit map when cg_vpos_en=1 and cg_vpos_adpt_en=0
// Bit 15:8  Reserved
// Bit 7     RW, cg_vpos_en,     1 to enable the max vertical limitation for sky-bitmap
// Bit 6     RW, cg_vpos_adpt_en, 1 to enable the adaptive max vertical limitation for sky-bitmap.
//                               It is only valid when cg_vpos_en=1.
//                               The max vertical limitation is the previous field's vanish-point (vertical position) if cg_vpos_adpt_en=1.
// Bit 5:4   RW, cg_lpf_bypass,  bypass of low pass filter
//                               [5]:Vertical bypass, 1: bypass the vertical LPF on the CBDG depth
//                               [4]:Horizontal bypass, 1: bypass the horizontal LPF on the CBDG depth
// Bit 3:0   RW, cg_vp_rel_s,    parameter to calculate vanish point reliability
#define D2D3_CG_PARAM_2                            ((0x2b0a  << 2) + 0xff000000)
// Indicate parameters of pre-scale-down unit
// Bit 31:16 RW, scd81_vphs_step, vertical step
// Bit 15:0  RW, scd81_vphs_ini, vertical initial phase
#define D2D3_PRE_SCD_V                             ((0x2b0b  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// D2P registers
// d2p: depth to parallax transform module
//------------------------------------------------------------------------------
// Bit 31:24 RW, d2p_brdwid,     Horizontal boundary width for parallax, the parallax value would be forced to 0 in boundary,
//                               the d2p_brdwid should not 0 when D2P_WRAP is enabled
// Bit 23:22 Reserved
// Bit 21:20 RW, d2p_lomode,     line output mode,
//                               0:whole line is left or right;  1:whole line is left or right;
//                               2:left/right pixel interleaved;  3:left/right half-line interleaved
// Bit 19    RW, d2p_neg,        1 to exchange the left and right parallax value
// Bit 18    Reserved
// Bit 17    RW, d2p_wrap_en,    1 to enable D2P_WRAP unit
// Bit 16    RW, d2p_lar,        Indicate the first output for left or right, 0: left; 1: right
// Bit 15    RW, d2p_lr_switch,  enable left/right flag filed switch automatically, only valid when parallax output mode is field interleaved
// Bit 14    RW, d2p_1dtolr,     enable to generate 2 parallax data (left and right) from one depth
// Bit 13:12 RW, d2p_out_mode,   Parallax output mode
//                               0:left/right pixel interleaved; 1:line or half line interleaved; 2:field interleaved
// Bit 11:8  RW, d2p_smode,      Shift mode,
//                               0: no shift; 1: enable left shift;
//                               2: enable right shift; 3: both left and right shift are enabled
// Bit 7:0   RW, d2p_offset,     depth offset, signed,
#define D2D3_D2P_PARAM_1                           ((0x2b0c  << 2) + 0xff000000)
// Bit 31:24 RW, d2p_pg0,        positive parallax gain when Parallax value < pt
// Bit 23:16 RW, d2p_pg1,        positive parallax gain when Parallax value >= pt
// Bit 15:8  RW, d2p_pt,         unsigned value used to separate the positive parallax range
// Bit 7:0   RW, d2p_plimit,     The limitation for positive parallax
#define D2D3_D2P_PARAM_2                           ((0x2b0d  << 2) + 0xff000000)
// Bit 31:24 RW, d2p_ng0,        negative parallax gain when Parallax value > -nt
// Bit 23:16 RW, d2p_ng1,        negative parallax gain when Parallax value <= -nt
// Bit 15:8  RW, d2p_nt,         unsigned value used to separate the negative parallax range
// Bit 7:0   RW, d2p_nlimit,     The limitation for negative parallax
#define D2D3_D2P_PARAM_3                           ((0x2b0e  << 2) + 0xff000000)
// Indicate step parameters of SCU18 unit
// Bit 31:17 Reserved
// Bit 16    RW, scu18_step_en,   step set enable in SCU18
// Bit 15:8  RW, scu18_hphs_step, horizontal step in SCU18
// Bit 7:0   RW, scu18_vphs_step, vertical step in SCU18
#define D2D3_SCU18_STEP                            ((0x2b0f  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// LBDG and DBLD registers
// lg: luma based depth generate module
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:22 Reserved
// Bit 21:20 RW, db_lpf_bpcoeff, [21]:Vertical factor of low pass filter,
//                               1: Vfactor = 0/0/64/0/0, 0: Vfactor = {db_vf_a,db_vf_b,db_vf_c,db_vf_b,db_vf_a}, see D2D3_CTRL_15
//                               [20]:Horizontal factor of low pass filter,
//                               1: Hfactor = 0/0/64/0/0, 0: Hfactor = {db_hf_a,db_hf_b,db_hf_c,db_hf_b,db_hf_a}, see D2D3_CTRL_14
// Bit 19:18 RW, lg_lpf_bpcoeff, [19]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [18]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 17:16 RW, cg_lpf_bpcoeff, [17]:Vertical factor of low pass filter, 1: Vfactor = 0/64/0, 0: Vfactor = 20/24/20
//                               [16]:Horizontal factor of low pass filter, 1: Hfactor = 0/64/0, 0: Hfactor = 16/32/16
// Bit 15:10 Reserved
// Bit 9:8   RW, db_lpf_bypass,  [9] 1 to bypass the vertical LPF on the DBLD depth
//                               [8] 1 to bypass the horizontal LPF on the DBLD depth
// Bit 7:6   RW, lg_lpf_bypass,  [7] 1 to bypass the vertical LPF on the LBDG depth
//                               [6] 1 to bypass the horizontal LPF on the LBDG depth
// Bit 5:0   RW, lg_kc,          gain of CPL(v-u+256-y) to calculate the depth in LBDG
#define D2D3_DPF_LPF_CTRL                          ((0x2b10  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// DBLD registers
// db: depth blending module
//------------------------------------------------------------------------------
// Bit 31:24 RW, db_g2_cg,       gain of CBDG depth in DBLD
// Bit 23:16 RW, db_o2_cg,       offset of CBDG depth in DBLD
// Bit 15:8  RW, db_g1_cg,       gain of CBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_cg,       offset of CBDG depth using for summary in DBLD
#define D2D3_DBLD_CG_PARAM                         ((0x2b11  << 2) + 0xff000000)
// Bit 31:24 RW, db_g2_mg,       gain of MBDG depth in DBLD
// Bit 23:16 RW, db_o2_mg,       offset of MBDG depth in DBLD
// Bit 15:8  RW, db_g1_mg,       gain of MBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_mg,       offset of MBDG depth using for summary in DBLD
#define D2D3_DBLD_MG_PARAM                         ((0x2b12  << 2) + 0xff000000)
// Bit 31:24 RW, db_g2_lg,       gain of LBDG depth in DBLD
// Bit 23:16 RW, db_o2_lg,       offset of LBDG depth in DBLD
// Bit 15:8  RW, db_g1_lg,       gain of LBDG depth using for summary in DBLD
// Bit 7:0   RW, db_o1_lg,       offset of LBDG depth using for summary in DBLD
#define D2D3_DBLD_LG_PARAM                         ((0x2b13  << 2) + 0xff000000)
// Bit 31:24 RW, db_factor,      unsigned gain of difference in DBLD
// Bit 23:16 RW, db_hf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_hf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_hf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define D2D3_DBLD_LPF_HCOEFF                       ((0x2b14  << 2) + 0xff000000)
// Bit 31:24 RW, db_owin_fill,   signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 23:16 RW, db_vf_a,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 15:8  RW, db_vf_b,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
// Bit 7:0   RW, db_vf_c,        see register DPF_LPF_CTRL:db_lpf_bpcoeff, sign
#define D2D3_DBLD_LPF_VCOEFF                       ((0x2b15  << 2) + 0xff000000)
// Bit 31:28 RW, hist_depth_idx,
// Bit 27:26 Reserved
// Bit 25    RW, mbdg_dep_neg,   1 to negate the output data of MBDG
// Bit 24    RW, lbdg_dep_neg,   1 to negate the output data of LBDG
// Bit 23:16 RW, db_f1_ctrl,     MUX1 selector
//                               [1:0] MUX1 path1 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX1 path2 selector, 0:summary, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX1 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX1out0, others:summary
//                               [7] MUX1OUT0 selector, 0:MIN (MUX1PATH1,MUX1Path2), 1:MAX (MUX1Path1,MUX1Path2)
// Bit 15:8  RW, db_f2_ctrl,     MUX2 selector
//                               [1:0] MUX2 path1 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [3:2] MUX2 path2 selector, 0:MUX1OUT1, 1:CBDG, 2:MBDG, 3:LBDG
//                               [6:4] MUX2 out1 selector, 1:CBDG, 2:MBDG, 3:LBDG, 4:summary, 5:MUX2out0, others:MUX2out0
//                               [7] MUX2OUT0 selector, 0:MIN (MUX2PATH1,MUX2Path2), 1:MAX (MUX2Path1,MUX2Path2)
// Bit 7:4   RW, db_fifo0_sel,   the source input of FIFO0
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG others:reserved
// Bit 3:0   RW, db_fifo1_sel,   the source input of FIFO1
//                               0: no use; 1:from CBDG; 2:from MBDG; 3:from LBDG 4: from FIFO0; others:reserved
#define D2D3_DBLD_PATH_CTRL                        ((0x2b16  << 2) + 0xff000000)
// Indicate the input picture size in SCU18 unit
// Bit 31:16 RW, szy_scui,       The vertical size
// Bit 15:0  RW, szx_scui,       The horizontal size
#define D2D3_SCU18_INPIC_SIZE                      ((0x2b17  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// MBDG registers
// mg: model based depth generate module
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, mg_vp_en,       mdg vanish point enable, not used
// Bit 16    RW, mg_sw_en,       1 to use the software forced parameter for the point D, U and C in MBDG
// Bit 15:8  RW, mg_owin_fill,   Signed depth value outside the rectangular window defined in register DGEN_WIN_HOR and DGEN_WIN_VER
// Bit 7     RW, mg_iir_en,      1 to enable the 2-taps IIR filter in MBDG
// Bit 6:0   RW, mg_iir,         [6]: 1 to bypass the 2-taps IIR filter in MBDG
//                               [5:0]:Unsigned coefficient of the 2-taps IIR filter in MBDG
//                               [6]:bypass, 1:bypass, 0:not bypass
#define D2D3_MBDG_CTRL                             ((0x2b18  << 2) + 0xff000000)
// Bit 31:28 RW, mg_dtl_pxl_left, Max pixel number (1<< mg_dtl_pxl_left) using in the left window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_right, Max pixel number (1<< mg_dtl_pxl_right) using in the right window for activities in MBDG
// Bit 23:16 RW, mg_cx_sw,       Depth of point C in horizontal curve in MBDG for software forced
// Bit 15:8  RW, mg_ux_sw,       Depth of point U in horizontal curve in MBDG for software forced
// Bit 7:0   RW, mg_dx_sw,       Depth of point D in horizontal curve in MBDG for software forced
#define D2D3_MBDG_PARAM_0                          ((0x2b19  << 2) + 0xff000000)
// Bit 31:28 RW, mg_dtl_pxl_up,  Max pixel number (1<< mg_dtl_pxl_up) using in the top window for activities in MBDG
// Bit 27:24 RW, mg_dtl_pxl_dn,  Max pixel number (1<< mg_dtl_pxl_dn) using in the bottom window for activities in MBDG
// Bit 23:16 RW, mg_cy_sw,       Depth of point C in vertical curve in MBDG for software forced
// Bit 15:8  RW, mg_uy_sw,       Depth of point U in vertical curve in MBDG for software forced
// Bit 7:0   RW, mg_dy_sw,       Depth of point D in vertical curve in MBDG for software forced
#define D2D3_MBDG_PARAM_1                          ((0x2b1a  << 2) + 0xff000000)
// Bit 31:24 RW, mg_dtl_ln_up,   Line number in the top window for activities in MBDG
// Bit 23:16 RW, mg_dtl_ln_dn,   Line number in the bottom window for activities in MBDG
// Bit 15:8  RW, mg_dtl_ln_left, Column number in the left window for activities in MBDG
// Bit 7:0   RW, mg_dtl_ln_right,Column number in the right window for activities in MBDG
#define D2D3_MBDG_PARAM_2                          ((0x2b1b  << 2) + 0xff000000)
// Bit 31:24 RW, mg_y_max,       Software initial depth of point D and U in vertical curve
// Bit 23:16 RW, mg_y_min,       Software initial depth of point C in vertical curve
// Bit 15:8  RW, mg_x_max,       Software initial depth of point D and U in horizontal curve
// Bit 7:0   RW, mg_x_min,       Software initial depth of point C in horizontal curve
#define D2D3_MBDG_PARAM_3                          ((0x2b1c  << 2) + 0xff000000)
// Bit 31:27 Reserved
// Bit 26    RW, mg_y_adapt_en,  1 to enable the adaptive mode for point U/D in vertical curve calculation
// Bit 25    RW, mg_xmm_adapt_en, 1 to enable the XMM adaptive mode for point U/D in horizontal curve calculation
// Bit 24    RW, mg_x_adapt_en,  1 to enable the adaptive mode for point U/D in horizontal curve calculation
// Bit 23:20 RW, mg_ytrans_1,    Shifter controller in vertical curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 19:16 RW, mg_xtrans_1,    Shifter controller in horizontal curve calculation, if mg_xtrans_1<0, right shift abs(mg_xtrans_1) bits, others left shift abs(mg_xtrans_1) bits
// Bit 15:8  RW, mg_yk_0,        The based activities value of the ACT for vertical curve
// Bit 7:0   RW, mg_xk_0,        The based activities value of the ACT for horizontal curve
#define D2D3_MBDG_PARAM_4                          ((0x2b1d  << 2) + 0xff000000)
// Bit 31:24 RW, mg_ysu3,        Quantized value 3 in vertical curve adaptive calculation
// Bit 23:16 RW, mg_ysu2,        Quantized value 2 in vertical curve adaptive calculation
// Bit 15:8  RW, mg_ysu1,        Quantized value 1 in vertical curve adaptive calculation
// Bit 7:0   RW, mg_ysu0,        Quantized value 0 in vertical curve adaptive calculation
#define D2D3_MBDG_PARAM_5                          ((0x2b1e  << 2) + 0xff000000)
// Bit 31:24 RW, mg_xsu3,        Quantized value 3 in horizontal curve adaptive calculation
// Bit 23:16 RW, mg_xsu2,        Quantized value 2 in horizontal curve adaptive calculation
// Bit 15:8  RW, mg_xsu1,        Quantized value 1 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_xsu0,        Quantized value 0 in horizontal curve adaptive calculation
#define D2D3_MBDG_PARAM_6                          ((0x2b1f  << 2) + 0xff000000)
// Bit 31:16 Reserved
// Bit 15:8  RW, mg_xsu4,        Quantized value 4 in horizontal curve adaptive calculation
// Bit 7:0   RW, mg_ysu4,        Quantized value 4 in vertical curve adaptive calculation
#define D2D3_MBDG_PARAM_7                          ((0x2b20  << 2) + 0xff000000)
// Bit 31:28 RW, dbg_hscnt_sel   see DBG_STATUS_2
// Bit 27:25 Reserved
// Bit 24    RW, dbg_dbr_en,     1 to enable debug mode in DBR
// Bit 23:16 RW, dbg_force_data, Forced data in debug mode
// Bit 15:12 RW, dbg_bld_ctrl,   debug controller for DBLD
//                               [12]:enable;  [13]: 0 for passive mode, 0 for handshake mode
//                               [15:14]: 0 for constant mode, 1 for step1 mode
// Bit 11:8  RW, dbg_mg_ctrl,    debug controller for MBDG
//                               [8]:enable;  [9]: 0 for passive mode, 0 for handshake mode
//                               [11:10]: 0 for constant mode, 1 for step1 mode
// Bit 7:4   RW, dbg_cg_ctrl,    debug controller for CBDG
//                               [4]:enable;  [5]: 0 for passive mode, 0 for handshake mode
//                               [7:6]: 0 for constant mode, 1 for step1 mode
// Bit 3:0   RW, dbg_lg_ctrl,    debug controller for LBDG
//                               [0]:enable;  [1]: 0 for passive mode, 0 for handshake mode
//                               [3:2]: 0 for constant mode, 1 for step1 mode
#define D2D3_DBG_CTRL                              ((0x2b23  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// DWMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dw_x_rev        0: Normal write data from left to right in horizontal
//                               1: Reversed write data from left to right in horizontal
// Bit 16    RW, dw_y_rev        0: Normal write data from top to bottom in horizontal
//                               1: Reversed write data from bottom to top in horizontal
// Bit 15    RW, dw_done_clr     1 to clear register depw_done (DWMIF_STATUS)
// Bit 14    RW, dw_little_endian, 0: data is ordered in big-endian, 1: little endian
// Bit 13:12 RW, dw_pic_struct,  0:read every line, 1:reserved, 2:read even line, 3:read odd line
// Bit 11    RW, dw_urgent,      urgent index
// Bit 10    RW, dw_clr_wrrsp,   1:clear the write fifo counter
// Bit 9     RW, dw_canvas_wr,   canvas write initialization again
// Bit 8     RW, dw_req_en,      1 to enable write request
// Bit 7:0   RW, dw_canvas_index,Canvas index for the MSB of memory address for memory write
#define D2D3_DWMIF_CTRL                            ((0x2b24  << 2) + 0xff000000)
// Bit 31    Reserved
// Bit 30:16 RW, dw_end_x,       Horizontal end position for memory write, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dw_start_x,     Horizontal start position for memory write, count by BYTE
#define D2D3_DWMIF_HPOS                            ((0x2b25  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, dw_end_y,       Vertical end position for memory write, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dw_start_y,     Vertical start position for memory write, count by BYTE
#define D2D3_DWMIF_VPOS                            ((0x2b26  << 2) + 0xff000000)
// Bit 31:28 Reserved
// Bit 27:16 RW, dw_vsizem1,     Vertical size for memory write, equal the size minus 1
// Bit 15:12 Reserved
// Bit 11:0  RW, dw_hsizem1,     Horizontal size for memory write, equal the size minus 1
#define D2D3_DWMIF_SIZE                            ((0x2b27  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// DRMIF registers
//------------------------------------------------------------------------------
// Bit 31:18 Reserved
// Bit 17    RW, dr_y_rev,       0: Normal Read data from top to bottom in horizontal
//                               1: Reversed read data from bottom to top in horizontal
// Bit 16    RW, dr_x_rev,       0: Normal Read data from left to right in horizontal
//                               1: Reversed read data from right to left in horizontal
// Bit 15    RW, dr_clr_fifo_error, 1 to clear the overflow flag of the sticky FIFO
// Bit 14    RW, dr_little_endian, 0: data is ordered in big-endian; 1: little-endian
// Bit 13:12 RW, dr_pic_struct,  0: progressive;  1: Reserved;
//                               2: interlaced, even line;  3: interlaced, odd line
// Bit 11    RW, dr_urgent,      urgent index, no use in this system
// Bit 10:9  RW, dr_burst_size,  Burst read length for each request; 0=24,1=32,2=48,3=64
// Bit 8     RW, dr_req_en,      1 to enable read request
// Bit 7:0   RW, dr_canvas_index, Canvas index for the MSB of memory address for memory read
#define D2D3_DRMIF_CTRL                            ((0x2b28  << 2) + 0xff000000)
// Bit 31    Reserved
// Bit 30:16 RW, dr_end_x,       Horizontal end position for memory read, count by BYTE
// Bit 15    Reserved
// Bit 14:0  RW, dr_start_x,     Horizontal start position for memory read, count by BYTE
#define D2D3_DRMIF_HPOS                            ((0x2b29  << 2) + 0xff000000)
// Bit 31:29 Reserved
// Bit 28:16 RW, dr_end_y,       Vertical end position for memory read, count by BYTE
// Bit 15:13 Reserved
// Bit 12:0  RW, dr_start_y,     Vertical start position for memory read, count by BYTE
#define D2D3_DRMIF_VPOS                            ((0x2b2a  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// PDR registers
// ddd: parallax based render
//------------------------------------------------------------------------------
// Bit 31:8  Reserved
// Bit 7     RW, ddd_brdlpf_en,  1 to enable the smooth filter on the depth around the boundary
// Bit 6     RW, ddd_extn_black, 1 to enable the function to fill black colour when interpolated pixels is outside the picture in DBR
// Bit 5     RW, ddd_wrap_en,    Reserved
// Bit 4     RW, ddd_hhalf,      1 to indicate the left/right line length is a half of original line.
// Bit 3:2   RW, ddd_out_mode,   Reserved
// Bit 1:0   RW, ddd_lomode,     wrap & pbr interleave mode:
//                               2'b0x: whole line is left or right;
//                               2'b10: d2p_lar=1(D2P_PARAM_1), rlrlrlrl interleave in one line,
//                                      d2p_lar=0(D2P_PARAM_1), lrlrlrlr interleave in one line,
//                               2'b11: d2p_lar=1(D2P_PARAM_1), rrrrrlllll, half line is right, another half is left,
//                                      d2p_lar=0(D2P_PARAM_1), lllllrrrrr, half line is left, another half is right,
#define D2D3_DBR_DDD_CTRL                          ((0x2b2c  << 2) + 0xff000000)
// Bit 31:0  RW, ddd_dbg_ctrl,   no use
#define D2D3_DBR_DDD_DBG                           ((0x2b2d  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// LRDMX registers
//------------------------------------------------------------------------------
// Bit 31:9  Reserved
// Bit 8     RW, lr_merge,       1: all the left/right input go to the left channel output
// Bit 7:6   RW, lrd_ff0_sel,    FF0 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 5:4   RW, lrd_ff1_sel,    FF1 source selector
//                               0:from left input; 1:from right input; 2:from FF0; 3:no used
// Bit 3:2   RW, lrd_lout_sel,   left channel DEMUX
//                               00: ff0  01:ff1   10: left input  11:right input
// Bit 1:0   RW, lrd_rout_sel,   right channel DEMUX
//                               00: ff1  01:ff0   10: left input  11:right input
#define D2D3_DBR_LRDMX_CTRL                        ((0x2b2f  << 2) + 0xff000000)
//------------------------------------------------------------------------------
// Read Only registers
//------------------------------------------------------------------------------
// Bit 31:24 RO, ro_cg_vprel,    vanish point's reliability in CBDG
// Bit 23:12 RO, ro_cg_vpx,      vanish point's X-Axis in CBDG
// Bit 11:0  RO, ro_cg_vpy,      vanish point's Y-Axis in CBDG
#define D2D3_CBDG_STATUS_1                         ((0x2b30  << 2) + 0xff000000)
// Bit 31:24 RO, ro_mg_cx[7:0],  X-Axis of point C in horizontal curve in MBDG
// Bit 23:16 RO, ro_mg_ux,       Depth value of point U in horizontal curve in MBDG
// Bit 15:8  RO, ro_mg_dx,       Depth value of point D in horizontal curve in MBDG
// Bit 7:0   RO, ro_mg_minx,     Depth value of point C in horizontal curve in MBDG
#define D2D3_MBDG_STATUS_1                         ((0x2b31  << 2) + 0xff000000)
// Bit 31:24 RO, ro_mg_cy[7:0],  X-Axis of point C in vertical curve in MBDG
// Bit 23:16 RO, ro_mg_uy,       Depth value of point U in vertical curve in MBDG
// Bit 15:8  RO, ro_mg_dy,       Depth value of point D in vertical curve in MBDG
// Bit 7:0   RO, ro_mg_miny,     Depth value of point C in vertical curve in MBDG
#define D2D3_MBDG_STATUS_2                         ((0x2b32  << 2) + 0xff000000)
// Bit 31    RO, ro_wrap_status, 1 indicate the D2P_WRAP is busy to perform the initialization
// Bit 30:8  Reserved
// Bit 7:4   RO, ro_mg_cy[11:8], X-Axis of point C in vertical curve in MBDG
// Bit 3:0   RO, ro_mg_cx[11:8], X-Axis of point C in horizontal curve in MBDG
#define D2D3_MBDG_STATUS_3                         ((0x2b33  << 2) + 0xff000000)
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_u,    ACT(top): activities of the top part
#define D2D3_MBDG_STATUS_4                         ((0x2b34  << 2) + 0xff000000)
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_d,    ACT(bottom): activities of the bottom part
#define D2D3_MBDG_STATUS_5                         ((0x2b35  << 2) + 0xff000000)
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_l,    ACT(left): activities of the left part
#define D2D3_MBDG_STATUS_6                         ((0x2b36  << 2) + 0xff000000)
// Bit 31:21 Reserved
// Bit 20:0  RO, ro_mg_sum_r,    ACT(right): activities of the right part
#define D2D3_MBDG_STATUS_7                         ((0x2b37  << 2) + 0xff000000)
// Bit 31:0 dbg_handshake_ro0,   handshake signal for debug, internal srdy and rrdy
#define D2D3_DBG_STATUS_1                          ((0x2b38  << 2) + 0xff000000)
// Bit 31:0 dbg_hscnt,           dbg_hscnt_sel == 4'h0, output lg hscnt
//                               dbg_hscnt_sel == 4'h1, output cg hscnt
//                               dbg_hscnt_sel == 4'h2, output mg hscnt
//                               dbg_hscnt_sel == 4'h3, output bld hscnt
//                               dbg_hscnt_sel == other value, output 32'h0
#define D2D3_DBG_STATUS_2                          ((0x2b39  << 2) + 0xff000000)
// Bit 31:0 RO, drmif_status,    drmif module internal status
#define D2D3_DRMIF_STATUS                          ((0x2b3a  << 2) + 0xff000000)
// Bit 31:2 RO, Reserved
// Bit 1:0  RO, d2d3_status0,    [1]: depw_done, one field depth write to ddr has done
//                               [0]: dwmif_pending_ddr_wrrsp, 1 to indicate write response from ddr
#define D2D3_DWMIF_STATUS                          ((0x2b3b  << 2) + 0xff000000)
// Bit 31:24 Reserved
// Bit 23:0  RO, ro_meet_sum,    register sumxy_sum_dbg in CBDG
#define D2D3_CBDG_STATUS_2                         ((0x2b3c  << 2) + 0xff000000)
// Bit 31:20 Reserved
// Bit 19:0  RO, ro_hist_depth,
#define D2D3_DBLD_STATUS                           ((0x2b3d  << 2) + 0xff000000)
// Bit 31:0 Reserved
#define D2D3_RESEV_STATUS1                         ((0x2b3e  << 2) + 0xff000000)
// Bit 31:0  Reserved
#define D2D3_RESEV_STATUS2                         ((0x2b3f  << 2) + 0xff000000)
//
// Closing file:  ./d2d3_regs.h
//
//===========================================================================
//  MIPI DSI Host Controller        (16'h2c00 - 16'h2cff)
//===========================================================================
//`include "dsi_regs.h"
//===========================================================================
//  ISP register    (16'h2d00 - 16'h2dff)
//===========================================================================
//`include "isp_reg.h"
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_dnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MADB_VCBUS_BASE = 0x2d
// -----------------------------------------------
#define DNR_CTRL                                   ((0x2d00  << 2) + 0xff000000)
//Bit 31:17,        reserved
//Bit 16,            reg_dnr_en		                                , dnr enable                  . unsigned  , default = 1
//Bit 15,            reg_dnr_db_vdbstep                          , vdb step, 0: 4, 1: 8        . unsigned  , default = 1
//Bit 14,            reg_dnr_db_vdbprten                         , vdb protection enable       . unsigned  , default = 1
//Bit 13,            reg_dnr_gbs_difen                           , enable dif (between LR and LL/RR) condition for gbs stat.. unsigned  , default = 0
//Bit 12,            reg_dnr_luma_en                             , enable ycbcr2luma module    . unsigned  , default = 1
//Bit 11:10,        reg_dnr_db_mod                              , deblocking mode, 0: disable, 1: horizontal deblocking, 2: vertical deblocking, 3: horizontal & vertical deblocking. unsigned  , default = 3
//Bit  9,            reg_dnr_db_chrmen                           , enable chroma deblocking    . unsigned  , default = 1
//Bit  8,            reg_dnr_hvdif_mod                           , 0: calc. difs by original Y, 1: by new luma. unsigned  , default = 1
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_demo_lften                          , b0: Y b1:U b2:V             . unsigned  , default = 7
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_demo_rgten                          , b0: Y b1:U b2:V             . unsigned  , default = 7
#define DNR_HVSIZE                                 ((0x2d01  << 2) + 0xff000000)
//Bit 31:29,        reserved
//Bit 28:16,        reg_dnr_hsize                               , hsize                       . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 0,        reg_dnr_vsize                               , vsize                       . unsigned  , default = 0
#define DNR_DBLK_BLANK_NUM                         ((0x2d02  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dblk_hblank_num                         , deblock hor blank num       . unsigned  , default = 16
//Bit  7: 0,        reg_dblk_vblank_num                         , deblock ver blank num       . unsigned  , default = 45
#define DNR_BLK_OFFST                              ((0x2d03  << 2) + 0xff000000)
//Bit 31: 7,        reserved
//Bit  6: 4,        reg_dnr_hbofst                              , horizontal block offset may provide by software calc.. unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_vbofst                              , vertical block offset may provide by software calc.. unsigned  , default = 0
#define DNR_GBS                                    ((0x2d04  << 2) + 0xff000000)
//Bit 31: 2,        reserved
//Bit  1: 0,        reg_dnr_gbs                                 , global block strength may update by software calc.. unsigned  , default = 0
#define DNR_HBOFFST_STAT                           ((0x2d05  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_hbof_difthd                         , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
//Bit 23:16,        reg_dnr_hbof_edgethd                        , edge threshold (<=) for LR  . unsigned  , default = 32
//Bit 15: 8,        reg_dnr_hbof_flatthd                        , flat threshold (>=) for LR  . unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_hbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_hbof_statmod                        , statistic mode for horizontal block offset, 0: count flags for 8-bin, 1: count LRs for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count LRs for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
#define DNR_VBOFFST_STAT                           ((0x2d06  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_vbof_difthd                         , dif threshold (>=) between Up and Dw. unsigned  , default = 1
//Bit 23:16,        reg_dnr_vbof_edgethd                        , edge threshold (<=) for Up/Dw. unsigned  , default = 16
//Bit 15: 8,        reg_dnr_vbof_flatthd                        , flat threshold (>=) for Up/Dw. unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_dnr_vbof_delta                          , delta for weighted bin accumulator. unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_dnr_vbof_statmod                        , statistic mode for vertical block offset, 0: count flags for 8-bin, 1: count Ups for 8-bin, 2: count difs for 8-bin, 3: count weighted flags for 8-bin, 4: count flags for first 32-bin, 5: count Ups for first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2
#define DNR_GBS_STAT                               ((0x2d07  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_gbs_edgethd                         , edge threshold (<=) for LR  . unsigned  , default = 32
//Bit 23:16,        reg_dnr_gbs_flatthd                         , flat threshold (>=) for LR  . unsigned  , default = 0
//Bit 15: 8,        reg_dnr_gbs_varthd                          , variation threshold (<=) for Lvar/Rvar. unsigned  , default = 16
//Bit  7: 0,        reg_dnr_gbs_difthd                          , dif threshold (>=) between LR and LL/RR. unsigned  , default = 2
#define DNR_STAT_X_START_END                       ((0x2d08  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:16,        reg_dnr_stat_xst                                                          . unsigned  , default = 24
//Bit 15:14,        reserved
//Bit 13: 0,        reg_dnr_stat_xed                                                          . unsigned  , default = HSIZE - 25
#define DNR_STAT_Y_START_END                       ((0x2d09  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:16,        reg_dnr_stat_yst                                                          . unsigned  , default = 24
//Bit 15:14,        reserved
//Bit 13: 0,        reg_dnr_stat_yed                                                          . unsigned  , default = VSIZE - 25
#define DNR_LUMA                                   ((0x2d0a  << 2) + 0xff000000)
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_luma_sqrtshft                       , left shift for fast squart of chroma, [0, 4]. unsigned  , default = 2
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_luma_sqrtoffst                      , offset for fast squart of chroma. signed    , default = 0
//Bit 15,            reserved
//Bit 14:12,        reg_dnr_luma_wcmod                          , theta related to warm/cool segment line, 0: 0, 1: 45, 2: 90, 3: 135, 4: 180, 5: 225, 6: 270, 7: 315. . unsigned  , default = 3
//Bit 11: 8,        reg_dnr_luma_cshft                          , shift for calc. delta part, 0~8,  . unsigned  , default = 8
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_luma_cgain                          , final gain for delta part, 32 normalized to "1". unsigned  , default = 4
#define DNR_DB_YEDGE_THD                           ((0x2d0b  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_db_yedgethd0                        , edge threshold0 for luma    . unsigned  , default = 12
//Bit 23:16,        reg_dnr_db_yedgethd1                        , edge threshold1 for luma    . unsigned  , default = 15
//Bit 15: 8,        reg_dnr_db_yedgethd2                        , edge threshold2 for luma    . unsigned  , default = 18
//Bit  7: 0,        reg_dnr_db_yedgethd3                        , edge threshold3 for luma    . unsigned  , default = 25
#define DNR_DB_CEDGE_THD                           ((0x2d0c  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_db_cedgethd0                        , edge threshold0 for chroma  . unsigned  , default = 12
//Bit 23:16,        reg_dnr_db_cedgethd1                        , edge threshold1 for chroma  . unsigned  , default = 15
//Bit 15: 8,        reg_dnr_db_cedgethd2                        , edge threshold2 for chroma  . unsigned  , default = 18
//Bit  7: 0,        reg_dnr_db_cedgethd3                        , edge threshold3 for chroma  . unsigned  , default = 25
#define DNR_DB_HGAP                                ((0x2d0d  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_db_hgapthd                          , horizontal gap thd (<=) for very sure blockiness . unsigned  , default = 8
//Bit 15: 8,        reg_dnr_db_hgapdifthd                       , dif thd between hgap and lft/rgt hdifs. unsigned  , default = 1
//Bit  7: 1,        reserved
//Bit  0,            reg_dnr_db_hgapmod                          , horizontal gap calc. mode, 0: just use current col x, 1: find max between (x-1, x, x+1) . unsigned  , default = 0
#define DNR_DB_HBS                                 ((0x2d0e  << 2) + 0xff000000)
//Bit 31: 6,        reserved
//Bit  5: 4,        reg_dnr_db_hbsup                            , horizontal bs up value      . unsigned  , default = 1
//Bit  3: 2,        reg_dnr_db_hbsmax                           , max value of hbs for global control. unsigned  , default = 3
//Bit  1: 0,        reg_dnr_db_hgbsthd                          , gbs thd (>=) for hbs calc.  . unsigned  , default = 1
#define DNR_DB_HACT                                ((0x2d0f  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_db_hactthd0                         , thd0 of hact, for block classification. unsigned  , default = 10
//Bit  7: 0,        reg_dnr_db_hactthd1                         , thd1 of hact, for block classification. unsigned  , default = 32
#define DNR_DB_YHDELTA_GAIN                        ((0x2d10  << 2) + 0xff000000)
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_db_yhdeltagain1                     , (p1-q1) gain for Y's delta calc. when bs=1, normalized 8 as "1" . unsigned  , default = 2
//Bit 23,            reserved
//Bit 22:20,        reg_dnr_db_yhdeltagain2                     , (p1-q1) gain for Y's delta calc. when bs=2, normalized 8 as "1" . unsigned  , default = 0
//Bit 19,            reserved
//Bit 18:16,        reg_dnr_db_yhdeltagain3                     , (p1-q1) gain for Y's delta calc. when bs=3, normalized 8 as "1" . unsigned  , default = 0
//Bit 15,            reserved
//Bit 14: 8,        reg_dnr_db_yhdeltaadjoffst                  , offset for adjust Y's hdelta (-64, 63). signed    , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_db_yhdeltaadjgain                   , gain for adjust Y's hdelta, normalized 32 as "1" . unsigned  , default = 32
#define DNR_DB_YHDELTA2_GAIN                       ((0x2d11  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_yhdelta2gain2                    , gain for bs=2's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 8
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_db_yhdelta2offst2                   , offset for bs=2's adjust Y's hdelta2 (-16, 15). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_yhdelta2gain3                    , gain for bs=3's adjust Y's hdelta2, normalized 64 as "1" . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_yhdelta2offst3                   , offset for bs=3's adjust Y's hdelta2 (-16, 15). signed    , default = 0
#define DNR_DB_CHDELTA_GAIN                        ((0x2d12  << 2) + 0xff000000)
//Bit 31:27,        reserved
//Bit 26:24,        reg_dnr_db_chdeltagain1                     , (p1-q1) gain for UV's delta calc. when bs=1, normalized 8 as "1". unsigned  , default = 2
//Bit 23,            reserved
//Bit 22:20,        reg_dnr_db_chdeltagain2                     , (p1-q1) gain for UV's delta calc. when bs=2, normalized 8 as "1". unsigned  , default = 0
//Bit 19,            reserved
//Bit 18:16,        reg_dnr_db_chdeltagain3                     , (p1-q1) gain for UV's delta calc. when bs=3, normalized 8 as "1". unsigned  , default = 0
//Bit 15,            reserved
//Bit 14: 8,        reg_dnr_db_chdeltaadjoffst                  , offset for adjust UV's hdelta (-64, 63). signed    , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_db_chdeltaadjgain                   , gain for adjust UV's hdelta, normalized 32 as "1". unsigned  , default = 32
#define DNR_DB_CHDELTA2_GAIN                       ((0x2d13  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_chdelta2gain2                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 8
//Bit 23:21,        reserved
//Bit 20:16,        reg_dnr_db_chdelta2offst2                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_chdelta2gain3                    , gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_chdelta2offst3                   , offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0
#define DNR_DB_YC_VEDGE_THD                        ((0x2d14  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_db_yvedgethd                        , special Y's edge thd for vdb. unsigned  , default = 12
//Bit  7: 0,        reg_dnr_db_cvedgethd                        , special UV's edge thd for vdb. unsigned  , default = 12
#define DNR_DB_VBS_MISC                            ((0x2d15  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_db_vgapthd                          , vertical gap thd (<=) for very sure blockiness . unsigned  , default = 8
//Bit 23:16,        reg_dnr_db_vactthd                          , thd of vact, for block classification . unsigned  , default = 10
//Bit 15: 8,        reg_dnr_db_vgapdifthd                       , dif thd between vgap and vact. unsigned  , default = 4
//Bit  7: 4,        reserved
//Bit  3: 2,        reg_dnr_db_vbsmax                           , max value of vbs for global control. unsigned  , default = 2
//Bit  1: 0,        reg_dnr_db_vgbsthd                          , gbs thd (>=) for vbs calc.  . unsigned  , default = 1
#define DNR_DB_YVDELTA_GAIN                        ((0x2d16  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_yvdeltaadjgain                   , gain for adjust Y's vdelta, normalized 32 as "1". unsigned  , default = 32
//Bit 23,            reserved
//Bit 22:16,        reg_dnr_db_yvdeltaadjoffst                  , offset for adjust Y's vdelta (-64, 63). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_yvdelta2gain                     , gain for adjust Y's vdelta2, normalized 64 as "1". unsigned  , default = 8
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_yvdelta2offst                    , offset for adjust Y's vdelta2 (-16, 15). signed    , default = 0
#define DNR_DB_CVDELTA_GAIN                        ((0x2d17  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_dnr_db_cvdeltaadjgain                   , gain for adjust UV's vdelta, normalized 32 as "1". unsigned  , default = 32
//Bit 23,            reserved
//Bit 22:16,        reg_dnr_db_cvdeltaadjoffst                  , offset for adjust UV's vdelta (-64, 63). signed    , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_db_cvdelta2gain                     , gain for adjust UV's vdelta2, normalized 64 as "1". unsigned  , default = 8
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_db_cvdelta2offst                    , offset for adjust UV's vdelta2 (-16, 15). signed    , default = 0
#define DNR_RO_GBS_STAT_LR                         ((0x2d18  << 2) + 0xff000000)
//Bit 31: 0,        ro_gbs_stat_lr                                                            . unsigned  , default = 0
#define DNR_RO_GBS_STAT_LL                         ((0x2d19  << 2) + 0xff000000)
//Bit 31: 0,        ro_gbs_stat_ll                                                            . unsigned  , default = 0
#define DNR_RO_GBS_STAT_RR                         ((0x2d1a  << 2) + 0xff000000)
//Bit 31: 0,        ro_gbs_stat_rr                                                            . unsigned  , default = 0
#define DNR_RO_GBS_STAT_DIF                        ((0x2d1b  << 2) + 0xff000000)
//Bit 31: 0,        ro_gbs_stat_dif                                                           . unsigned  , default = 0
#define DNR_RO_GBS_STAT_CNT                        ((0x2d1c  << 2) + 0xff000000)
//Bit 31: 0,        ro_gbs_stat_cnt                                                           . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_0                     ((0x2d1d  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt0                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_1                     ((0x2d1e  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt1                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_2                     ((0x2d1f  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt2                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_3                     ((0x2d20  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt3                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_4                     ((0x2d21  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt4                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_5                     ((0x2d22  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt5                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_6                     ((0x2d23  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt6                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_7                     ((0x2d24  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt7                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_8                     ((0x2d25  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt8                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_9                     ((0x2d26  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt9                                                         . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_10                    ((0x2d27  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt10                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_11                    ((0x2d28  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt11                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_12                    ((0x2d29  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt12                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_13                    ((0x2d2a  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt13                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_14                    ((0x2d2b  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt14                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_15                    ((0x2d2c  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt15                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_16                    ((0x2d2d  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt16                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_17                    ((0x2d2e  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt17                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_18                    ((0x2d2f  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt18                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_19                    ((0x2d30  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt19                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_20                    ((0x2d31  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt20                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_21                    ((0x2d32  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt21                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_22                    ((0x2d33  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt22                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_23                    ((0x2d34  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt23                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_24                    ((0x2d35  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt24                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_25                    ((0x2d36  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt25                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_26                    ((0x2d37  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt26                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_27                    ((0x2d38  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt27                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_28                    ((0x2d39  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt28                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_29                    ((0x2d3a  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt29                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_30                    ((0x2d3b  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt30                                                        . unsigned  , default = 0
#define DNR_RO_HBOF_STAT_CNT_31                    ((0x2d3c  << 2) + 0xff000000)
//Bit 31: 0,        ro_hbof_stat_cnt31                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_0                     ((0x2d3d  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt0                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_1                     ((0x2d3e  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt1                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_2                     ((0x2d3f  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt2                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_3                     ((0x2d40  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt3                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_4                     ((0x2d41  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt4                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_5                     ((0x2d42  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt5                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_6                     ((0x2d43  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt6                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_7                     ((0x2d44  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt7                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_8                     ((0x2d45  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt8                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_9                     ((0x2d46  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt9                                                         . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_10                    ((0x2d47  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt10                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_11                    ((0x2d48  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt11                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_12                    ((0x2d49  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt12                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_13                    ((0x2d4a  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt13                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_14                    ((0x2d4b  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt14                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_15                    ((0x2d4c  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt15                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_16                    ((0x2d4d  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt16                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_17                    ((0x2d4e  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt17                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_18                    ((0x2d4f  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt18                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_19                    ((0x2d50  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt19                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_20                    ((0x2d51  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt20                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_21                    ((0x2d52  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt21                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_22                    ((0x2d53  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt22                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_23                    ((0x2d54  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt23                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_24                    ((0x2d55  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt24                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_25                    ((0x2d56  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt25                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_26                    ((0x2d57  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt26                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_27                    ((0x2d58  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt27                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_28                    ((0x2d59  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt28                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_29                    ((0x2d5a  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt29                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_30                    ((0x2d5b  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt30                                                        . unsigned  , default = 0
#define DNR_RO_VBOF_STAT_CNT_31                    ((0x2d5c  << 2) + 0xff000000)
//Bit 31: 0,        ro_vbof_stat_cnt31                                                        . unsigned  , default = 0
#define DNR_DM_ADP_EN                              ((0x2d5d  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7           reg_dnr_scene_change_flg    // unsigned , default = 1  , scence change flag for dnr(dm);
//Bit  6           reg_dnr_dm_lpf_en           // unsigned , default = 1  , enable lpf for demosquito filter
//Bit  5           reg_dnr_dm_adp_level_en     // unsigned , default = 1  , enable adaptive demosquito level
//Bit  4           reg_dnr_dm_flg2bdif_en      // unsigned , default = 1  , enable edge flg to blkdif calc.
//Bit  3: 2        reg_dnr_dm_edgeiir          // unsigned , default = 1  , edge flag iir mode, 0: cur, 1: max(pre, cur), 2: choice 0/1 by org mtn, 3: choice 0/1 by ref mtn
//Bit  1           reg_dnr_dm_dirdifmod        // unsigned , default = 1  , dif mode for direction calc, 0: abs(dif02), 1: (abs(dif01)+abs(dif21))/2
//Bit  0           reg_dnr_dm_sur_dir_mod      // unsigned , default = 0  , sure direction mode for cordif calc.
#define DNR_DM_EDGE_DIR                            ((0x2d5e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_dnr_dm_dirdifcor        // unsigned , default = 2  , dif coring threshold for direction calc
//Bit 15: 8        reg_dnr_dm_edgecordifthd    // unsigned , default = 160  , edge flg down when cordif is large than threshold
//Bit  7: 0        reg_dnr_dm_mtnrt            // unsigned , default = 60  , motion ratio for mtn decision
#define DNR_DM_CTRL                                ((0x2d60  << 2) + 0xff000000)
//Bit 31:13,        reserved
//Bit 12,            reg_dnr_dm_fedgeflg_en                      , enable edge flag calc. of each frame. unsigned  , default = 1
//Bit 11,            reg_dnr_dm_fedgeflg_cl                      , clear frame edge flag if needed. unsigned  , default = 1
//Bit 10,            reg_dnr_dm_fedgeflg_df                      , user defined edge when reg_dnr_dm_fedgeflg_en=0, default = 1
//Bit  9,            reg_dnr_dm_en                               , enable demosquito function  . unsigned  , default = 1
//Bit  8,            reg_dnr_dm_chrmen                           , enable chrome processing for demosquito. unsigned  , default = 1
//Bit  7: 6,        reg_dnr_dm_level                            , demosquito level            . unsigned  , default = 3
//Bit  5: 4,        reg_dnr_dm_leveldw0                         , level down when gbs is small. unsigned  , default = 1
//Bit  3: 2,        reg_dnr_dm_leveldw1                         , level down for no edge/flat blocks. unsigned  , default = 1
//Bit  1: 0,        reg_dnr_dm_gbsthd                           , small/large threshold for gbs (<=). unsigned  , default = 0
#define DNR_DM_NR_BLND                             ((0x2d61  << 2) + 0xff000000)
//Bit 31:25,        reserved
//Bit 24,            reg_dnr_dm_defalpen                         , enable user define alpha for dm & nr blend. unsigned  , default = 0
//Bit 23:16,        reg_dnr_dm_defalp                           , user define alpha for dm & nr blend if enable. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_dnr_dm_alpgain                          , gain for nr/dm alpha, normalized 32 as "1". unsigned  , default = 32
//Bit  7: 0,        reg_dnr_dm_alpoffst                         , (-128, 127), offset for nr/dm alpha. signed    , default = 0
#define DNR_DM_RNG_THD                             ((0x2d62  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_dm_rngminthd                                                      . unsigned  , default = 2
//Bit 15: 8,        reg_dnr_dm_rngmaxthd                                                      . unsigned  , default = 64
//Bit  7: 0,        reg_dnr_dm_rngdifthd                                                      . unsigned  , default = 4
#define DNR_DM_RNG_GAIN_OFST                       ((0x2d63  << 2) + 0xff000000)
//Bit 31:14,        reserved
//Bit 13: 8,        reg_dnr_dm_rnggain                          , normalized 16 as "1"        . unsigned  , default = 16
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_dnr_dm_rngofst                                                        . unsigned  , default = 0
#define DNR_DM_DIR_MISC                            ((0x2d64  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29,            reg_dnr_dm_diralpen                                                       . unsigned  , default = 1
//Bit 28:24,        reg_dnr_dm_diralpgain                                                     . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_dnr_dm_diralpofst                                                     . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_diralpmin                                                      . unsigned  , default = 0
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_diralpmax                                                      . unsigned  , default = 31
#define DNR_DM_COR_DIF                             ((0x2d65  << 2) + 0xff000000)
//Bit 31: 4,        reserved
//Bit  3: 1,        reg_dnr_dm_cordifshft                                                     . unsigned  , default = 3
//Bit  0,            reg_dnr_dm_cordifmod                        , 0:use max dir dif as cordif, 1: use max3x3 - min3x3 as cordif. unsigned  , default = 1
#define DNR_DM_FLT_THD                             ((0x2d66  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_dm_fltthd00                         , block flat threshold0 for block average difference when gbs is small, for flat block detection. unsigned  , default = 4
//Bit 23:16,        reg_dnr_dm_fltthd01                         , block flat threshold1 for block average difference when gbs is small, for flat block detection. unsigned  , default = 6
//Bit 15: 8,        reg_dnr_dm_fltthd10                         , block flat threshold0 for block average difference when gbs is large, for flat block detection. unsigned  , default = 9
//Bit  7: 0,        reg_dnr_dm_fltthd11                         , block flat threshold1 for block average difference when gbs is large, for flat block detection. unsigned  , default = 12
#define DNR_DM_VAR_THD                             ((0x2d67  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_dm_varthd00                         , block variance threshold0 (>=) when gbs is small, for flat block detection. unsigned  , default = 2
//Bit 23:16,        reg_dnr_dm_varthd01                         , block variance threshold1 (<=) when gbs is small, for flat block detection. unsigned  , default = 15
//Bit 15: 8,        reg_dnr_dm_varthd10                         , block variance threshold0 (>=) when gbs is large, for flat block detection. unsigned  , default = 3
//Bit  7: 0,        reg_dnr_dm_varthd11                         , block variance threshold1 (<=) when gbs is large, for flat block detection. unsigned  , default = 24
#define DNR_DM_EDGE_DIF_THD                        ((0x2d68  << 2) + 0xff000000)
//Bit 31:24,        reg_dnr_dm_edgethd0                         , block edge threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 32
//Bit 23:16,        reg_dnr_dm_edgethd1                         , block edge threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 48
//Bit 15: 8,        reg_dnr_dm_difthd0                          , block dif threshold (<=) when gbs is small, for flat block detection. unsigned  , default = 48
//Bit  7: 0,        reg_dnr_dm_difthd1                          , block dif threshold (<=) when gbs is large, for flat block detection. unsigned  , default = 64
#define DNR_DM_AVG_THD                             ((0x2d69  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_dm_avgthd0                          , block average threshold (>=), for flat block detection. unsigned  , default = 160
//Bit  7: 0,        reg_dnr_dm_avgthd1                          , block average threshold (<=), for flat block detection. unsigned  , default = 128
#define DNR_DM_AVG_VAR_DIF_THD                     ((0x2d6a  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnr_dm_avgdifthd                        , block average dif threshold (<) between cur and up block, for flat block detection. unsigned  , default = 12
//Bit  7: 0,        reg_dnr_dm_vardifthd                        , block variance dif threshold (>=) between cur and up block, for flat block detection. unsigned  , default = 1
#define DNR_DM_VAR_EDGE_DIF_THD2                   ((0x2d6b  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_dnr_dm_varthd2                          , block variance threshold (>=), for edge block detection. unsigned  , default = 24
//Bit 15: 8,        reg_dnr_dm_edgethd2                         , block edge threshold (>=), for edge block detection. unsigned  , default = 40
//Bit  7: 0,        reg_dnr_dm_difthd2                          , block dif threshold (>=), for edge block detection. unsigned  , default = 80
#define DNR_DM_DIF_FLT_MISC                        ((0x2d6c  << 2) + 0xff000000)
//Bit 31:28,        reg_dnr_dm_ldifoob                          , pre-defined large dif when pixel out of blocks. unsigned  , default = 0
//Bit 27:24,        reg_dnr_dm_bdifoob                          , pre-defined block dif when pixel out of blocks;. unsigned  , default = 0
//Bit 23:16,        reg_dnr_dm_fltalp                           , pre-defined alpha for dm and nr blending, when block is flat with mos.. unsigned  , default = 200
//Bit 15:12,        reserved
//Bit 11: 8,        reg_dnr_dm_fltminbdif                       , pre-defined min block dif for dm filter, when block is flat with mos.. unsigned  , default = 12
//Bit  7,            reserved
//Bit  6: 2,        reg_dnr_dm_difnormgain                      , gain for pixel dif normalization for dm filter, normalized 16 as "1". unsigned  , default = 16
//Bit  1,            reg_dnr_dm_difnormen                        , enable pixel dif normalization for dm filter. unsigned  , default = 1
//Bit  0,            reg_dnr_dm_difupden                         , enable block dif update using max of left, cur, right difs. unsigned  , default = 0
#define DNR_DM_SDIF_LUT0_2                         ((0x2d6d  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut0                         , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut1                         , normally 0-16               . unsigned  , default = 14
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut2                         , normally 0-16               . unsigned  , default = 13
#define DNR_DM_SDIF_LUT3_5                         ((0x2d6e  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut3                         , normally 0-16               . unsigned  , default = 10
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut4                         , normally 0-16               . unsigned  , default = 7
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut5                         , normally 0-16               . unsigned  , default = 5
#define DNR_DM_SDIF_LUT6_8                         ((0x2d6f  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_sdiflut6                         , normally 0-16               . unsigned  , default = 3
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_sdiflut7                         , normally 0-16               . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_sdiflut8                         , normally 0-16               . unsigned  , default = 0
#define DNR_DM_LDIF_LUT0_2                         ((0x2d70  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut0                         , normally 0-16               . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut1                         , normally 0-16               . unsigned  , default = 4
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut2                         , normally 0-16               . unsigned  , default = 12
#define DNR_DM_LDIF_LUT3_5                         ((0x2d71  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut3                         , normally 0-16               . unsigned  , default = 14
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut4                         , normally 0-16               . unsigned  , default = 15
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut5                         , normally 0-16               . unsigned  , default = 16
#define DNR_DM_LDIF_LUT6_8                         ((0x2d72  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_ldiflut6                         , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_ldiflut7                         , normally 0-16               . unsigned  , default = 16
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_ldiflut8                         , normally 0-16               . unsigned  , default = 16
#define DNR_DM_DIF2NORM_LUT0_2                     ((0x2d73  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut0                     , normally 0-16               . unsigned  , default = 16
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut1                     , normally 0-16               . unsigned  , default = 5
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut2                     , normally 0-16               . unsigned  , default = 3
#define DNR_DM_DIF2NORM_LUT3_5                     ((0x2d74  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut3                     , normally 0-16               . unsigned  , default = 2
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut4                     , normally 0-16               . unsigned  , default = 2
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut5                     , normally 0-16               . unsigned  , default = 1
#define DNR_DM_DIF2NORM_LUT6_8                     ((0x2d75  << 2) + 0xff000000)
//Bit 31:21,        reserved
//Bit 20:16,        reg_dnr_dm_dif2normlut6                     , normally 0-16               . unsigned  , default = 1
//Bit 15:13,        reserved
//Bit 12: 8,        reg_dnr_dm_dif2normlut7                     , normally 0-16               . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_dnr_dm_dif2normlut8                     , normally 0-16               . unsigned  , default = 1
#define DNR_DM_GMS_THD                             ((0x2d76  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_gms_stat_thd0                                                         . unsigned  , default = 0
//Bit  7: 0,        reg_gms_stat_thd1                                                         . unsigned  , default = 128
#define DNR_RO_DM_GMS_STAT_CNT                     ((0x2d77  << 2) + 0xff000000)
//Bit 31: 0,        ro_dm_gms_stat_cnt                                                        . unsigned  , default = 0
#define DNR_RO_DM_GMS_STAT_MS                      ((0x2d78  << 2) + 0xff000000)
//Bit 31: 0,        ro_dm_gms_stat_ms                                                        . unsigned  , default = 0
#define DNR_DM_EDGE_GAIN                           ((0x2d79  << 2) + 0xff000000)
//Bit 31:24        reg_dnr_dm_alpedgegain0   // unsigned , default = 8  , edge based gain for alpha, normalized 16 as "1"
//Bit 23:16        reg_dnr_dm_alpedgegain1   // unsigned , default = 16  , edge based gain for alpha, normalized 16 as "1"
//Bit 15: 8        reg_dnr_dm_alpedgegain2   // unsigned , default = 24  , edge based gain for alpha, normalized 16 as "1"
//Bit  7: 0        reg_dnr_dm_alpedgegain3   // unsigned , default = 32  , edge based gain for alpha, normalized 16 as "1"
#define DNR_DM_FLG_BDIF                            ((0x2d7a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_dnr_dm_flg2bdif0      // unsigned , default = 0  , (0-16), edge flg to blkdif calc.
//Bit 23:21        reserved
//Bit 20:16        reg_dnr_dm_flg2bdif1      // unsigned , default = 6  , (0-16), edge flg to blkdif calc.
//Bit 15:13        reserved
//Bit 12: 8        reg_dnr_dm_flg2bdif2      // unsigned , default = 10  , (0-16), edge flg to blkdif calc.
//Bit  7: 5        reserved
//Bit  4: 0        reg_dnr_dm_flg2bdif3      // unsigned , default = 12  , (0-16), edge flg to blkdif calc.
#define DNR_DM_GBS_RORM                            ((0x2d7b  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_dnr_dm_gbs4difnorm0   // unsigned , default = 0  , gbs=0 for dif norm calc.
//Bit 11: 8        reg_dnr_dm_gbs4difnorm1   // unsigned , default = 1  , gbs=1 for dif norm calc.
//Bit  7: 4        reg_dnr_dm_gbs4difnorm2   // unsigned , default = 4  , gbs=2 for dif norm calc.
//Bit  3: 0        reg_dnr_dm_gbs4difnorm3   // unsigned , default = 6  , gbs=3 for dif norm calc.
#define DNR_DM_FLG_LEV                             ((0x2d7c  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_dnr_dm_flg2lev0       // unsigned , default = 1  , edge flg to filter level calc.
//Bit 11:10        reserved
//Bit  9: 8        reg_dnr_dm_flg2lev1       // unsigned , default = 3  , edge flg to filter level calc.
//Bit  7: 6        reserved
//Bit  5: 4        reg_dnr_dm_flg2lev2       // unsigned , default = 3  , edge flg to filter level calc.
//Bit  3: 2        reserved
//Bit  1: 0        reg_dnr_dm_flg2lev3       // unsigned , default = 3  , edge flg to filter level calc.
#define DNR_DM_DIF_FLG_TH                          ((0x2d7d  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_dnr_dm_dif2flgthd1    // unsigned , default = 128  , dif to edge flg threshold 1
//Bit  7: 0        reg_dnr_dm_dif2flgthd2    // unsigned , default = 192  , dif to edge flg threshold 2
#define DNR_DM_CALP_GAIN_OFST                      ((0x2d7e  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_dnr_dm_calpgain       // unsigned , default = 16  , chroma gain for nr/dm alpha, normalized 32 as "1"
//Bit 15: 9        reserved
//Bit  8: 0        reg_dnr_dm_calpoffst      // signed , default = -64  , (-255, 255), chroma offset for nr/dm alpha
// 0x80-0x90
//
// Reading file:  ./vpu_decomb_regs.h
//
    // defined registers
#define DECOMB_DET_VERT_CON0                       ((0x2d80  << 2) + 0xff000000)
//Bit  31:24   reg_di_dcmb_det_vcon_thd0      default = 60  // u8
//Bit  23:16   reg_di_dcmb_det_vcon_thd1      default = 80  // u8
//Bit  15: 8   reg_di_dcmb_det_valp_lmt0      default = 63  // u8
//Bit   7: 0   reg_di_dcmb_det_valp_lmt1      default = 4   // u8
#define DECOMB_DET_VERT_CON1                       ((0x2d81  << 2) + 0xff000000)
//Bit  23:16   reg_di_dcmb_det_valp_lmt2      default = 0   // u8
//Bit  15: 8   reg_di_dcmb_det_vrate0         default = 32  // u8
//Bit   7: 0   reg_di_dcmb_det_vrate1         default = 4   // u8
#define DECOMB_DET_EDGE_CON0                       ((0x2d82  << 2) + 0xff000000)
//Bit  31:24   reg_di_dcmb_det_econ_thd0      default = 60  // u8
//Bit  23:16   reg_di_dcmb_det_econ_thd1      default = 80  // u8
//Bit  15: 8   reg_di_dcmb_det_ealp_lmt0      default = 63  // u8
//Bit   7: 0   reg_di_dcmb_det_ealp_lmt1      default = 4   // u8
#define DECOMB_DET_EDGE_CON1                       ((0x2d83  << 2) + 0xff000000)
//Bit  23:16   reg_di_dcmb_det_ealp_lmt2      default = 0   // u8
//Bit  15: 8   reg_di_dcmb_det_erate0         default = 32  // u8
//Bit   7: 0   reg_di_dcmb_det_erate1         default = 4  // u8
#define DECOMB_PARA                                ((0x2d84  << 2) + 0xff000000)
//Bit  31:30   reserved
//Bit  29:28   reg_di_dcmb_cmb_lpf            default = 1  // u2, 0:no lpf, 1:[1 2 1], 2,3: [1 2 2 2 1]
//Bit  27:26   reg_di_dcmb_vedge_chk          default = 0  // u2, vertical edge check, 0: no check, 1: vrt!=0, 2: vrt==3
//Bit  25:24   reg_di_dcmb_nedge_chk          default = 0  // u2, no idea edge check, 0, no check, 1, check
//Bit  23:20   reg_di_dcmb_edge_min           default = 0   // u4, min edge for edge cmb
//Bit  19:16   reg_di_dcmb_edge_max           default = 15  // u4, min edge for edge cmb
//Bit   15:8   reg_di_dcmb_bld_alp            default = 255  // u8, user defined alpha for di & decmb blend
//Bit    7:0   reg_di_dcmb_bld_alp_beta       default = 40  // u8, beta for mtn & cmb blend, for bld alpha calc.
#define DECOMB_BLND_CON0                           ((0x2d85  << 2) + 0xff000000)
//Bit  31:24   reg_di_dcmb_bld_con_thd0       default = 100  // u8
//Bit  23:16   reg_di_dcmb_bld_con_thd1       default = 120  // u8
//Bit  15: 8   reg_di_dcmb_bld_alp_lmt0       default = 0  // u8
//Bit   7: 0   reg_di_dcmb_bld_alp_lmt1       default = 128   // u8
#define DECOMB_BLND_CON1                           ((0x2d86  << 2) + 0xff000000)
//Bit  23:16   reg_di_dcmb_bld_alp_lmt2       default = 255   // u8
//Bit  15: 8   reg_di_dcmb_bld_rate0          default = 32 // u8
//Bit   7: 0   reg_di_dcmb_bld_rate1          default = 32  // u8
#define DECOMB_YC_THRD                             ((0x2d87  << 2) + 0xff000000)
//Bit  31:16   reserved
//Bit  15: 8   reg_di_dcmb_ythd               default = 2 // u8, default = 2
//Bit   7: 0   reg_di_dcmb_cthd               default = 2 // u8, default = 2
#define DECOMB_MTN_GAIN_OFST                       ((0x2d88  << 2) + 0xff000000)
//Bit  31:22   reserved
//Bit  21:16   reg_di_dcmb_mtn_alp_gain       default = 16  // u6, 16 is normalized to '1'
//Bit   15:9   reserved
//Bit    8:0   reg_di_dcmb_mtn_alp_ofst       default = 0  // s9, [-256, 255]
#define DECOMB_CMB_SEL_GAIN_OFST                   ((0x2d89  << 2) + 0xff000000)
//Bit  31:22   reserved
//Bit  21:16   reg_di_dcmb_cmb_sel_gain       default = 48  // u6, 16 is normalized to '1'
//Bit   15:9   reserved
//Bit    8:0   reg_di_dcmb_cmb_sel_ofst       default = 0  // s9, [-256, 255]
#define DECOMB_WIND00                              ((0x2d8a  << 2) + 0xff000000)
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd00              default = 0 // u13, x0 for window 0, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd01              default = 719 // u13, x1 for window 0, HSIZE-1, software control
#define DECOMB_WIND01                              ((0x2d8b  << 2) + 0xff000000)
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd02              default = 0 // u13, y0 for window 0, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd03              default = 39 // u13, y1 for window 0, software control
#define DECOMB_WIND10                              ((0x2d8c  << 2) + 0xff000000)
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd10              default = 0 // u13, x0 for window 1, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd11              default = 719 // u13, x1 for window 1, HSIZE-1, software control
#define DECOMB_WIND11                              ((0x2d8d  << 2) + 0xff000000)
//Bit  31:29   reserved
//Bit  28:16   reg_di_dcmb_wnd12              default = 40 // u13, y0 for window 1, software control
//Bit  15:13   reserved
//Bit   12:0   reg_di_dcmb_wnd13              default = 239 // u13, y1 for window 1, VSIZE-1-40, software control
#define DECOMB_MODE                                ((0x2d8e  << 2) + 0xff000000)
//Bit  31:16   reserved
//Bit     15   reg_di_dcmb_is_cmb_bef         default = 1  // u1, 1: decide is_cmb before cmbing refine, 0: decide is_cmb after cmbing refine
//Bit     14   reg_di_dcmb_en0                default = 1 // u1, enable decmobing for wind0
//Bit     13   reg_di_dcmb_en1                default = 1 // u1, enable decmobing for wind1
//Bit     12   reg_di_dcmb_en2                default = 1 // u1, enable decmobing for wind2
//Bit  11:10   reg_di_dcmb_lpf_mod0           default = 2  // u2, get combing free pixels of wind0 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit    9:8   reg_di_dcmb_lpf_mod1           default = 2  // u2, get combing free pixels of wind1 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit    7:6   reg_di_dcmb_lpf_mod2           default = 0  // u2, get combing free pixels of wind2 by: 0, vertical lpf, 1, edge lpf, 2,3, ei data
//Bit      5   reg_di_dcmb_cmb_sel0           default = 1  // u1, wind0 decmb based on: 0, vert cmb, 1, edge cmb
//Bit      4   reg_di_dcmb_cmb_sel1           default = 1  // u1, wind1 decmb based on: 0, vert cmb, 1, edge cmb
//Bit      3   reg_di_dcmb_cmb_sel2           default = 0  // u1, wind2 decmb based on: 0, vert cmb, 1, edge cmb
//Bit      2   reg_di_dcmb_alp_mod0           default = 1  // u1, wind0 decmb alpha based on: 0, user-defined, 1, motion adaptive
//Bit      1   reg_di_dcmb_alp_mod1           default = 1  // u1, wind1 decmb alpha based on: 0, user-defined, 1, motion adaptive
//Bit      0   reg_di_dcmb_alp_mod2           default = 1  // u1, wind2 decmb alpha based on: 0, user-defined, 1, motion adaptive
#define DECOMB_FRM_SIZE                            ((0x2d8f  << 2) + 0xff000000)
//Bit  31:29   reserved
//Bit  28:16   hsize_in                       default = 1920  // u13, pic horz size in  unit: pixel
//Bit  15:13   reserved
//Bit   12:0   vsize_in                       default = 1080  // u13, pic vert size in  unit: pixel
#define DECOMB_HV_BLANK                            ((0x2d90  << 2) + 0xff000000)
//Bit  31:16   reserved
//Bit   15:8   hblank_num                     default = 20  // u8, hor blank time
//Bit    7:0   vblank_num                     default = 50  // u8, ver blank time
//
// Closing file:  ./vpu_decomb_regs.h
//
// 0x98-0xa3
//
// Reading file:  ./vpu_nr2_dpolar_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR2_POLAR3_MODE                            ((0x2d98  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:18        reg_polar3_f02lpf_mod0    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vert lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
//Bit 17:16        reg_polar3_f02lpf_mod1    // unsigned , default = 3  low pass filter mode for field 0 and field2 before polar3 detection; 0 for no lpf, 1: [1 2 1]/4 vert lpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 no hlpf; 2: [1 2 1; 2 4 2; 1 2 1]/16 2d lpf, p1 [1 2 1]/4 hlpf
//Bit 15: 8        reg_polar3_dif02_thrd0    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
//Bit  7: 0        reg_polar3_dif02_thrd1    // unsigned , default = 5  threshold of dif for polar3 detection except for 32 detection, only do polar3 detection on obvious motion, [0] for luma, 1[1] for chroma
#define NR2_POLAR3_THRD                            ((0x2d99  << 2) + 0xff000000)
//Bit 31:24        reg_polar3_txtf02_thrd0   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit 23:16        reg_polar3_txtf02_thrd1   // unsigned , default = 30  threshold to vertical f0f2 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit 15: 8        reg_polar3_txtf1_thrd0    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
//Bit  7: 0        reg_polar3_txtf1_thrd1    // unsigned , default = 20  threshold to vertical f1 texture, if texture larger than this threshold, will not do the polar3 decision.
#define NR2_POLAR3_PARA0                           ((0x2d9a  << 2) + 0xff000000)
//Bit 31:28        reg_polar3_rate00         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
//Bit 27:24        reg_polar3_rate01         // unsigned , default = 6  delt = rate*dif02/32, e.g. f2<f0, if f1 within((f0+f2)/2 - delt), ((f0+f2)/2 + delt), then polar3_smoothmv++;
//Bit 23:20        reg_polar3_rate10         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
//Bit 19:16        reg_polar3_rate11         // unsigned , default = 8  delt = rate*dif02/32, e.g. f2-ofst1<f0, if f1<((f0+f2)/2 - delt), then polar3_m1++; if f1>((f0+f2)/2 + delt), then polar3_p1++;
//Bit 15:12        reg_polar3_rate20         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit 11: 8        reg_polar3_rate21         // unsigned , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit  7: 1        reserved
//Bit  0           reg_polar3_ro_reset       // unsigned , default = 0  reset signal of the polar3 read only registers
#define NR2_POLAR3_PARA1                           ((0x2d9b  << 2) + 0xff000000)
//Bit 31:24        reg_polar3_rate30         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 23:16        reg_polar3_rate31         // unsigned , default = 48  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 15:12        reg_polar3_ofst30         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit 11: 8        reg_polar3_ofst31         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt-ofst3) or f1>((f0 + delt+ofst3), then polar3_32++;
//Bit  7: 4        reg_polar3_ofst20         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
//Bit  3: 0        reg_polar3_ofst21         // signed , default = 2  delt = rate*dif02/32, e.g. f2<f0, if f1<(f2 - delt- ofset2), then polar3_m2++; if f1>((f0 + delt+ ofset2), then polar3_p2++;
#define NR2_POLAR3_CTRL                            ((0x2d9c  << 2) + 0xff000000)
//Bit 31:24        reg_polar3_ofst10         // signed , default = 1
//Bit 23:16        reg_polar3_ofst11         // signed , default = 1
//Bit 15: 8        reg_polar3_h_mute         // unsigned , default = 10  horizontal pixels to mute for left right sides for polar3 detection;
//Bit  7: 0        reg_polar3_v_mute         // unsigned , default = 10  vertical pixels to mute for top and bottom sides for polar3 detection;
#define NR2_RO_POLAR3_NUMOFPIX                     ((0x2d9d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_numofpix        // unsigned , default = 0  number of pixels detected as polar3
#define NR2_RO_POLAR3_SMOOTHMV                     ((0x2d9e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_smoothmv        // unsigned , default = 0  number of pixels with smooth mv, F(t) is close between avg of f(t-1) and f(t+1);
#define NR2_RO_POLAR3_M1                           ((0x2d9f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_m1              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but in between [f(t-1), f(t+1)];
#define NR2_RO_POLAR3_P1                           ((0x2da0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_p1              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but in between [f(t-1), f(t+1)];
#define NR2_RO_POLAR3_M2                           ((0x2da1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_m2              // unsigned , default = 0  number of pixels with F(t) is close to f(t-1) instead of f(t+1), but out side of (f(t-1), f(t+1));
#define NR2_RO_POLAR3_P2                           ((0x2da2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_p2              // unsigned , default = 0  number of pixels with F(t) is close to f(t+1) instead of f(t-1), but out side of (f(t-1), f(t+1));
#define NR2_RO_POLAR3_32                           ((0x2da3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_polar3_32              // unsigned , default = 0  number of pixels with F(t) far from [f(t-1),f(t+1)] and f(t-1) is close to f(t+1);
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_nr2_dpolar_regs.h
//
// 0xa4-0xf7 / 0xff
//
// Reading file:  ./vpu_nr4_regs.h
//
// synopsys translate_off
// synopsys translate_on
//========== nr4_drt_regs register begin ==========//
#define NR4_DRT_CTRL                               ((0x2da4  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_ydrt_3line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
//Bit 23:16        reg_nr4_ydrt_5line_ssd_gain    // unsigned , default = 16  gain to max ssd normalized 16 as '1'
//Bit 15            reserved
//Bit 14:13        reg_nr4_drt_yhsad_mode         // unsigned , default = 1  mode for luma horizontal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
//Bit 12:11        reg_nr4_drt_chsad_mode         // unsigned , default = 1  mode for chroma horizontal sad calc., 0: no vertical lpf, 1: vertical [1 2 1], 2 or 3: vertical [ 1 2 2 2 1] if 5 lines
//Bit 10           reg_nr4_drt_yhsad_hlpf         // unsigned , default = 1  hlpf for luma hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  9           reg_nr4_drt_yvsad_hlpf         // unsigned , default = 1  hlpf for luma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  8           reg_nr4_drt_ydsad_hlpf         // unsigned , default = 1  hlpf for luma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  7           reg_nr4_drt_chsad_hlpf         // unsigned , default = 1  hlpf for chrome hsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  6           reg_nr4_drt_cvsad_hlpf         // unsigned , default = 1  hlpf for chroma vsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  5           reg_nr4_drt_cdsad_hlpf         // unsigned , default = 1  hlpf for chroma dsad of drt calculation, 0: no lpf, 1: with [1 2 1] hlpf
//Bit  4           reg_nr4_ydrt_dif_mode          // unsigned , default = 1  0:y_dif, 1: y_dif + (u_dif + v_dif)/2
//Bit  3: 2        reg_nr4_cdrt_dif_mode          // unsigned , default = 2  0:(u_dif + v_dif), 1: y_dif/4 + (u_dif + v_dif)*3/4, 2:y_dif/2 + (u_dif + v_dif)/2, 3: y_dif (not recommended)
//Bit  1: 0        reserved
#define NR4_DRT_YSAD_GAIN                          ((0x2da5  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_ysad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
//Bit 23:16        reg_nr4_ysad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
//Bit 15: 8        reg_nr4_ysad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_drt_ysad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
#define NR4_DRT_CSAD_GAIN                          ((0x2da6  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_csad_hrz_gain           // unsigned , default = 16  gain for horizontal sad, 16 normalized to "1"
//Bit 23:16        reg_nr4_csad_diag_gain          // unsigned , default = 20  gain for diagonal sad, 16 normalized to "1"
//Bit 15: 8        reg_nr4_csad_vrt_gain           // unsigned , default = 16  gain for vertical sad, 16 normalized to "1"
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_drt_csad_core_rate      // unsigned , default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
#define NR4_DRT_SAD_ALP_CORE                       ((0x2da7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_nr4_ydrt_alp_core_rate     // unsigned , default = 0  luma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
//Bit 19:16        reg_nr4_cdrt_alp_core_rate     // unsigned , default = 0  chroma ratio to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 0/32
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_ydrt_alp_core_ofst     // unsigned , default = 10  luma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_cdrt_alp_core_ofst     // unsigned , default = 10  chroma offset to min_err, alpha = (min_err - (max_err - min_err)*rate + ofst)/max_err * 64; dft = 10
#define NR4_DRT_ALP_MINMAX                         ((0x2da8  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_ydrt_alp_min           // unsigned , default = 0  luma min value of alpha, dft = 0
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_ydrt_alp_max           // unsigned , default = 63  luma max value of alpha, dft = 63
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_cdrt_alp_min           // unsigned , default = 0  chroma min value of alpha, dft = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_cdrt_alp_max           // unsigned , default = 63  chroma max value of alpha, dft = 63
//========== nr4_drt_regs register end ==========//
//========== nr4_snr_regs register begin ==========//
#define NR4_SNR_CTRL_REG                           ((0x2da9  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12           reg_nr4_bet2_sel              // unsigned , default = 1
//Bit 11: 9        reg_nr4_snr2_sel_mode         // unsigned , default = 0  0: no filter, 1: adpgau, adp_drt_lpf blend; 2: adpgau, drt4_lpf blend; 3: adp_drt_lpf method, 4: drt4_lpf method, 5: adp_drt_                                                             //original image blend, 6: drt4_lpf, original image blend, 7: adpgau method; dft=1
//Bit  8           reg_nr4_snr2_gaulpf_mode      // unsigned , default = 1    0: 3*5 or 5*5 gaussian lpf;  1: 3*3 (window size) gaussian lpf;   dft=1
//Bit  7: 6        reg_nr4_snr2_alpha0_sad_mode  // unsigned , default = 3  0: max_sad*max_ssd;  1: max_sad*max_sad; 2: adp_max_sad*max_ssd; 3: adp_max_sad*adp_max_sad  dft=3
//Bit  5: 4        reg_nr4_snr2_alpha1_sad_mode  // unsigned , default = 2  0: max_sad;  1: cross_max_sad; 2 or 3: adp_sad  dft=2
//Bit  3: 2        reserved
//Bit  1: 0        reg_nr4_snr2_adp_drtlpf_mode  // unsigned , default = 3  0: adp_drtlpf [2 1 1]/4, 1: adp_drtlpf [4 2 1 1]/8; 2: adp_drtlpf [2 2 2 1 1]/8; 3: adp_drtlpf [7 7 7 6 5]/32;  dft=3;
#define NR4_SNR_ALPHA0_MAX_MIN                     ((0x2daa  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:23        reg_nr4_snr2_alp0_ymin    // unsigned , default = 127  normalized to 128 as '1'
//Bit 22:16        reg_nr4_snr2_alp0_ymax    // unsigned , default = 127  normalized to 128 as '1'
//Bit 15:14        reserved
//Bit 13: 7        reg_nr4_snr2_alp0_cmin    // unsigned , default = 127  normalized to 128 as '1'
//Bit  6: 0        reg_nr4_snr2_alp0_cmax    // unsigned , default = 127  normalized to 128 as '1'
#define NR4_ALP0C_ERR2CURV_LIMIT0                  ((0x2dab  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_snr2_alp0_minerr_cpar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.
//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.
#define NR4_ALP0C_ERR2CURV_LIMIT1                  ((0x2dac  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp0_minerr_cpar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_cpar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_cpar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel,   that we can do for texture region. 0~255.
#define NR4_ALP0Y_ERR2CURV_LIMIT0                  ((0x2dad  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_snr2_alp0_minerr_ypar0  // unsigned , default = 0  threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.
//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar1  // unsigned , default = 25  threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar5  // unsigned , default = 40  rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar6  // unsigned , default = 40  rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.
#define NR4_ALP0Y_ERR2CURV_LIMIT1                  ((0x2dae  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp0_minerr_ypar2  // unsigned , default = 127  level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel,  set to alp0 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp0_minerr_ypar3  // unsigned , default = 0  level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp0_minerr_ypar4  // unsigned , default = 127  level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, alp0 that we can do for texture region. 0~255.
#define NR4_SNR_ALPA1_RATE_AND_OFST                ((0x2daf  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:18        reg_nr4_snr2_alp1_ycore_rate      // unsigned , default = 0    normalized 64 as "1"
//Bit 17:12        reg_nr4_snr2_alp1_ccore_rate      // unsigned , default = 0    normalized 64 as "1"
//Bit 11: 6        reg_nr4_snr2_alp1_ycore_ofst      // signed , default = 3    normalized 64 as "1"
//Bit  5: 0        reg_nr4_snr2_alp1_ccore_ofst      // signed , default = 3    normalized 64 as "1"
#define NR4_SNR_ALPHA1_MAX_MIN                     ((0x2db0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:18        reg_nr4_snr2_alp1_ymin            // unsigned , default = 0    normalized to 64 as '1'
//Bit 17:12        reg_nr4_snr2_alp1_ymax            // unsigned , default = 63   normalized to 64 as '1'
//Bit 11: 6        reg_nr4_snr2_alp1_cmin            // unsigned , default = 0    normalized to 64 as '1'
//Bit  5: 0        reg_nr4_snr2_alp1_cmax            // unsigned , default = 63   normalized to 64 as '1'
#define NR4_ALP1C_ERR2CURV_LIMIT0                  ((0x2db1  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_snr2_alp1_minerr_cpar0  // unsigned , default = 0    annel, this will be set value of flat region mierr that no need directional NR. 0~255.
//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar1  // unsigned , default = 24   hannel,this will be set value of texture region mierr that can not do directional NR. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar5  // unsigned , default = 0    a/chroma  channel. the larger of the value, the deep of the slope.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar6  // unsigned , default = 20   a/chroma  channel. the larger of the value, the deep of the slope. 0~255
#define NR4_ALP1C_ERR2CURV_LIMIT1                  ((0x2db2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp1_minerr_cpar2  // unsigned , default = 0    will be set to alp1 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_cpar3  // unsigned , default = 16   this will be set to alp1 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_cpar4  // unsigned , default = 63   will be set to alp1 that we can do for texture region. 0~255.255 before
#define NR4_ALP1Y_ERR2CURV_LIMIT0                  ((0x2db3  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_snr2_alp1_minerr_ypar0  // unsigned , default = 0    thra/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.
//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar1  // unsigned , default = 24   thra/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar5  // unsigned , default = 0    ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar6  // unsigned , default = 20   ratlp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255
#define NR4_ALP1Y_ERR2CURV_LIMIT1                  ((0x2db4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_snr2_alp1_minerr_ypar2  // unsigned , default = 0    lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.
//Bit 15: 8        reg_nr4_snr2_alp1_minerr_ypar3  // unsigned , default = 16   levierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.
//Bit  7: 0        reg_nr4_snr2_alp1_minerr_ypar4  // unsigned , default = 63   lev to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before
//========== nr4_snr_regs register end ==========//
//========== nr4_tnr_regs register begin ==========//
#define NR4_MTN_CTRL                               ((0x2db5  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_nr4_mtn_ref_en        // unsigned , default = 1  enable motion refinement, dft = 1
//Bit  0           reg_nr4_mtn_ref_bet_sel   // unsigned , default = 0  beta selection mode for motion refinement, 0: beta1, 1: beta2, dft = 0
#define NR4_MTN_REF_PAR0                           ((0x2db6  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_mtn_ref_par0      // unsigned , default = 24  par0 for beta to gain, dft =
//Bit 23:16        reg_nr4_mtn_ref_par1      // unsigned , default = 60  par1 for beta to gain, dft =
//Bit 15: 8        reg_nr4_mtn_ref_par2      // unsigned , default = 4  par2 for beta to gain, dft =
//Bit  7: 0        reg_nr4_mtn_ref_par3      // unsigned , default = 32  par3 for beta to gain, dft =
#define NR4_MTN_REF_PAR1                           ((0x2db7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_mtn_ref_par4      // unsigned , default = 128  par4 for beta to gain, dft =
//Bit 15: 8        reg_nr4_mtn_ref_par5      // unsigned , default = 40  par5 for beta to gain, dft =
//Bit  7: 0        reg_nr4_mtn_ref_par6      // unsigned , default = 20  par6 for beta to gain, dft =
//========== nr4_tnr_regs register end ==========//
//========== nr4_mcnr_regs register begin ==========//
#define NR4_MCNR_LUMA_ENH_CTRL                     ((0x2db8  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3           reg_nr4_luma_plus_en           // unsigned , default = 1  enable luma enhancement, dft = 1
//Bit  2           reg_nr4_luma_plus_wt_mode      // unsigned , default = 1  luma weight calc mode, 0:sqrt(1+x^2), 1: 1+abs(x), dft = 0
//Bit  1: 0        reg_nr4_luma_plus_orient_mode  // unsigned , default = 1  0: only use previous orient for pre and cur luma plus, 1: 0: only use current orient for pre and cur luma plus
#define NR4_MCNR_LUMA_STAT_LIMTX                   ((0x2db9  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_luma_plus_xst        // unsigned , default = 8    start for luma plus statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_luma_plus_xed        // unsigned , default = 711  end for luma plus statistic, dft = HSIZE-8-1;
#define NR4_MCNR_LUMA_STAT_LIMTY                   ((0x2dba  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_luma_plus_yst          // unsigned , default = 8  start for luma plus statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_luma_plus_yed          // unsigned , default = 231  end for luma plus statistic, dft = VSIZE-8-1
#define NR4_MCNR_LUMA_DIF_CALC                     ((0x2dbb  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_luma_plus_ugain        // unsigned , default = 8  U's gain for luma enhancement, 16 normalized as '1'
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_luma_plus_vgain        // unsigned , default = 8  V's gain for luma enhancement, 16 normalized as '1'
//Bit 15: 8        reg_nr4_luma_plus_ycor_thd     // unsigned , default = 2  Y coring threshold for difference calc., dft = 0
//Bit  7: 0        reg_nr4_luma_plus_ccor_thd     // unsigned , default = 0  C coring threshold for difference calc., dft = 0
#define NR4_MCNR_LUMAPRE_CAL_PRAM                  ((0x2dbc  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_pre_u_orient           // signed , default = 0  orientation of previous U, initial to 0, and will be updated by software
//Bit 23:18        reserved
//Bit 17:16        reg_nr4_pre_v_orient           // signed , default = 0  orientation of previous V, initial to 0, and will be updated by software
//Bit 15: 8        reg_nr4_pre_u_mean             // unsigned , default = 0  mean of previous U, initial to 0, and will be updated by software
//Bit  7: 0        reg_nr4_pre_v_mean             // unsigned , default = 0  mean of previousV, initial to 0, and will be updated by software
#define NR4_MCNR_LUMACUR_CAL_PRAM                  ((0x2dbd  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_cur_u_orient           // signed , default = 0  orientation of current U, initial to 0, and will be updated by software
//Bit 23:18        reserved
//Bit 17:16        reg_nr4_cur_v_orient           // signed , default = 0  orientation of current V, initial to 0, and will be updated by software
//Bit 15: 8        reg_nr4_cur_u_mean             // unsigned , default = 0  mean of current U, initial to 0, and will be updated by software
//Bit  7: 0        reg_nr4_cur_v_mean             // unsigned , default = 0  mean of current, initial to 0, and will be updated by software
#define NR4_MCNR_MV_CTRL_REG                       ((0x2dbe  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_nr4_sad_bitw          // unsigned , default = 2  sad bit width (8 + x) before clip to u8, dft = 1
//Bit 11: 4        reg_nr4_glb_gain          // unsigned , default = 64  global gain calc. by software, 64 is normalized as '1'
//Bit  3: 0        reg_nr4_mv_err_rsft       // unsigned , default = 8  right shift for mv err calc., dft = 9
#define NR4_MCNR_MV_GAIN0                          ((0x2dbf  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_lftmvx_gain       // unsigned , default = 1  left mvx gain for err calc., dft = 1
//Bit 27:24        reg_nr4_lftmvy_gain       // unsigned , default = 1  left mvy gain for err calc., dft = 1
//Bit 23:20        reg_nr4_zmvx_gain         // unsigned , default = 5  zero mvx gain for err calc., dft = 2
//Bit 19:16        reg_nr4_zmvy_gain         // unsigned , default = 5  zero mvy gain for err calc., dft = 4
//Bit 15:12        reg_nr4_lmvx0_gain        // unsigned , default = 2  line mvx0 gain for err calc., dft = 1
//Bit 11: 8        reg_nr4_lmvx1_gain        // unsigned , default = 2  line mvx1 gain for err calc., dft = 1
//Bit  7: 4        reg_nr4_lmvy0_gain        // unsigned , default = 2  line mvy0 gain for err calc., dft = 1
//Bit  3: 0        reg_nr4_lmvy1_gain        // unsigned , default = 2  line mvy1 gain for err calc., dft = 1
#define NR4_MCNR_LMV_PARM                          ((0x2dc0  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_lmv_rt0		         // unsigned , default = 3  ratio of max lmv
//Bit 27:24        reg_nr4_lmv_rt1		         // unsigned , default = 3  ratio of second max lmv
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_lmv_num_lmt0	     // unsigned , default = 16  lmv0 least/limit number of (total number - zero_bin)
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_lmv_num_lmt1	     // unsigned , default = 8  lmv1 least/limit number of (total number - zero_bin - max0)
//Bit  7: 2        reserved
//Bit  1: 0        reg_nr4_max_sad_rng       // unsigned , default = 1  search range of max2 sad in small region, dft = 1
#define NR4_MCNR_ALP0_REG                          ((0x2dc1  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25           reg_nr4_alp0_fail_chk     // unsigned , default = 1  enable check for alp0 fail status
//Bit 24           reg_nr4_bet0_coef_ref_en  // unsigned , default = 1  bet1 refinement by coef_blt
//Bit 23:16        reg_nr4_alp0_posad_gain   // unsigned , default = 255  the sad (norm) gain for pixel pointed by MV;
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_alp0_norm_mode    // unsigned , default = 0  alp0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_alp0_norm_gain    // unsigned , default = 16  alp0 gain for sad norm, '32' as '1', dft = 1
#define NR4_MCNR_ALP1_AND_BET0_REG                 ((0x2dc2  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_alp1_norm_mode    // unsigned , default = 3  alp1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_alp1_norm_gain    // unsigned , default = 3  alp1 gain for sad norm, '32' as '1', dft = 1
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_bet0_norm_mode    // unsigned , default = 3  bet0 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bet0_norm_gain    // unsigned , default = 8  bet0 gain for sad norm, '32' as '1', dft = 1
#define NR4_MCNR_BET1_AND_BET2_REG                 ((0x2dc3  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_nr4_bet1_norm_mode    // unsigned , default = 3  bet1 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bet1_norm_gain    // unsigned , default = 8  bet1 gain for sad norm, '32' as '1', dft = 1
//Bit 15:10        reserved
//Bit  9: 8        reg_nr4_bet2_norm_mode    // unsigned , default = 0  bet2 select sad norm mode, 0: disable, 1: enable dc norm, 2: enable ac norm, 3: enable both (dc/ac) norm, dft = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bet2_norm_gain    // unsigned , default = 16  bet2 gain for sad norm, '32' as '1', dft = 1
#define NR4_MCNR_AC_DC_CRTL                        ((0x2dc4  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reserved
//Bit 11           reg_nr4_dc_mode           // unsigned , default = 1  mode for dc selection,0: Y_lpf, 1: Y_lpf + (U_Lpf+V_lpf)/2,
//Bit 10           reg_nr4_ac_mode           // unsigned , default = 1  mode for ac selection, 0: Y_abs_dif, 1: Y_abs_dif + (U_abs_dif + V_abs_dif)/2
//Bit  9           reg_nr4_dc_sel            // unsigned , default = 0  selection mode for dc value, 0: 3x5, 1: 5x5, dft = 1
//Bit  8           reg_nr4_ac_sel            // unsigned , default = 0  selection mode for ac value, 0: 3x5, 1: 5x5, dft = 1
//Bit  7            reserved
//Bit  6: 4        reg_nr4_dc_shft           // unsigned , default = 2  right shift for dc value, dft = 2
//Bit  3            reserved
//Bit  2: 0        reg_nr4_ac_shft           // unsigned , default = 0  right shift for ac value, dft = 2
#define NR4_MCNR_CM_CTRL0                          ((0x2dc5  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28           reg_nr4_cm_skin_prc_bet0      // unsigned , default = 0  enable skin tone processing for mcnr bet0 calc., dft = 1
//Bit 27:26        reg_nr4_cm_chrm_sel           // unsigned , default = 1  chrome selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
//Bit 25:24        reg_nr4_cm_luma_sel           // unsigned , default = 1  luma selection for color match, 0: 1x1, 1: 3X3LPF, 2: 3x5LPF, 3: 5x5LPF for 5lines, 3x5LPF for 3lines, dft = 3
//Bit 23:21        reg_nr4_cm_skin_rshft_bet0    // unsigned , default = 3  right shift for bet0's skin color gains, dft = 3
//Bit 20           reg_nr4_cm_var_sel            // unsigned , default = 1  variation selection for color match, 0: 3x5, 1: 5x5 for 5lines, 3x5 for 3lines, dft = 1
//Bit 19           reg_nr4_cm_green_prc_bet0     // unsigned , default = 1  enable green processing for mcnr bet0 calc., dft = 1
//Bit 18:16        reg_nr4_cm_green_rshft_bet0   // unsigned , default = 4  right shift for bet0's green color gains, dft = 4
//Bit 15:14        reg_nr4_preflt_mod            // unsigned , default = 2  pre filter mode in mcnr, 0: mv pointed pixel, 1: bilater filter
//Bit 13:12        reg_nr4_alp1_mode             // unsigned , default = 1  mode for alpha1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad
//Bit 11:10        reserved
//Bit  9: 8        reg_nr4_bet0_mode             // unsigned , default = 0  mode for bet0's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
//Bit  7: 6        reserved
//Bit  5: 4        reg_nr4_bet1_mode             // unsigned , default = 2  mode for bet1's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
//Bit  3: 2        reserved
//Bit  1: 0        reg_nr4_bet2_mode             // unsigned , default = 1  mode for bet2's sad selection, 0: max sad, 1: three min sads, 2: min sad, 3: co sad, else: (co sad) - (min sad)
#define NR4_MCNR_CM_PRAM                           ((0x2dc6  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           reg_nr4_cm_blue_prc_alp0      // unsigned , default = 1  enable blue processing for mcnr alpha0 calc., dft = 1
//Bit 28           reg_nr4_cm_blue_prc_alp1      // unsigned , default = 1  enable blue processing for mcnr alpha1 calc., dft = 1
//Bit 27           reg_nr4_cm_skin_prc_alp0      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
//Bit 26           reg_nr4_cm_green_prc_alp0     // unsigned , default = 1  enable green processing for mcnr alpha0 clac., dft = 1
//Bit 25           reg_nr4_cm_skin_prc_alp1      // unsigned , default = 1  enable skin tone processing for mcnr alpha0 calc., dft = 1
//Bit 24           reg_nr4_cm_green_prc_alp1     // unsigned , default = 1  enable green processing for mcnr alpha1 clac., dft = 1
//Bit 23:20        reg_nr4_cm_blue_hue_st        // unsigned , default = 13  hue start of blue, dft =
//Bit 19:16        reg_nr4_cm_blue_hue_ed        // unsigned , default = 15  hue end  of blue, dft =
//Bit 15:12        reg_nr4_cm_green_hue_st       // unsigned , default = 7  hue start of green, dft =
//Bit 11: 8        reg_nr4_cm_green_hue_ed       // unsigned , default = 10  hue end  of green, dft =
//Bit  7: 4        reg_nr4_cm_skin_hue_st        // unsigned , default = 5  hue start of skin, dft =
//Bit  3: 0        reg_nr4_cm_skin_hue_ed        // unsigned , default = 6  hue end  of skin, dft =
#define NR4_MCNR_CM_RSHFT_ALP0                     ((0x2dc7  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:25        reg_nr4_cm_blue_rshft_bet0    // unsigned , default = 5  right shift for bet0's blue color gains, dft = 5
//Bit 24           reg_nr4_cm_blue_prc_bet0      // unsigned , default = 1  enable blue processing for mcnr bet0 calc., dft = 1
//Bit 23            reserved
//Bit 22:20        reg_nr4_cm_blue_rshft_alp0    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
//Bit 19            reserved
//Bit 18:16        reg_nr4_cm_blue_rshft_alp1    // unsigned , default = 5  right shift for alpha0/1's blue color gains, dft = 5
//Bit 15            reserved
//Bit 14:12        reg_nr4_cm_green_rshft_alp0   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
//Bit 11            reserved
//Bit 10: 8        reg_nr4_cm_green_rshft_alp1   // unsigned , default = 4  right shift for alpha0/1's green color gains, dft = 4
//Bit  7            reserved
//Bit  6: 4        reg_nr4_cm_skin_rshft_alp0    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
//Bit  3            reserved
//Bit  2: 0        reg_nr4_cm_skin_rshft_alp1    // unsigned , default = 3  right shift for alpha0/1's skin color gains, dft = 3
#define NR4_MCNR_BLUE_CENT                         ((0x2dc8  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_centx         // unsigned , default = 157  x coordinate of center of blue, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_blue_centy         // unsigned , default = 110  y coordinate of center of blue, dft =
#define NR4_MCNR_BLUE_GAIN_PAR0                    ((0x2dc9  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_blue_gain_par0   // unsigned , default = 32  par0 for blue gain, dft =
//Bit 23:16        reg_nr4_cm_blue_gain_par1   // unsigned , default = 255  par1 for blue gain, dft =
//Bit 15: 8        reg_nr4_cm_blue_gain_par2   // unsigned , default = 4  par2 for blue gain, dft =
//Bit  7: 0        reg_nr4_cm_blue_gain_par3   // unsigned , default = 32  par3 for blue gain, dft =
#define NR4_MCNR_BLUE_GAIN_PAR1                    ((0x2dca  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_gain_par4   // unsigned , default = 32  par4 for blue gain, dft =
//Bit 15: 8        reg_nr4_cm_blue_gain_par5   // unsigned , default = 32  par5 for blue gain, dft =
//Bit  7: 0        reg_nr4_cm_blue_gain_par6   // unsigned , default = 0  par6 for blue gain, dft =
#define NR4_MCNR_CM_BLUE_CLIP0                     ((0x2dcb  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_blue_luma_min      // unsigned , default = 40  luma min for blue color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_blue_luma_max      // unsigned , default = 180  luma max for blue color matching, dft =
#define NR4_MCNR_CM_BLUE_CLIP1                     ((0x2dcc  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_blue_sat_min       // unsigned , default = 5  saturation min for blue color matching, dft =
//Bit 23:16        reg_nr4_cm_blue_sat_max       // unsigned , default = 255  saturation max for blue color matching, dft =
//Bit 15: 8        reg_nr4_cm_blue_var_min       // unsigned , default = 0  variation min for blue color matching, dft =
//Bit  7: 0        reg_nr4_cm_blue_var_max       // unsigned , default = 12  variation max for blue color matching, dft =
#define NR4_MCNR_GREEN_CENT                        ((0x2dcd  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_centx         // unsigned , default = 114  x coordinate of center of green, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_green_centy         // unsigned , default = 126  y coordinate of center of green, dft =
#define NR4_MCNR_GREEN_GAIN_PAR0                   ((0x2dce  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_green_gain_par0   // unsigned , default = 16  par0 for green gain, dft =
//Bit 23:16        reg_nr4_cm_green_gain_par1   // unsigned , default = 255  par1 for green gain, dft =
//Bit 15: 8        reg_nr4_cm_green_gain_par2   // unsigned , default = 255  par2 for green gain, dft =
//Bit  7: 0        reg_nr4_cm_green_gain_par3   // unsigned , default = 16  par3 for green gain, dft =
#define NR4_MCNR_GREEN_GAIN_PAR1                   ((0x2dcf  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_gain_par4   // unsigned , default = 16  par4 for green gain, dft =
//Bit 15: 8        reg_nr4_cm_green_gain_par5   // unsigned , default = 128  par5 for green gain, dft =
//Bit  7: 0        reg_nr4_cm_green_gain_par6   // unsigned , default = 0  par6 for green gain, dft =
#define NR4_MCNR_GREEN_CLIP0                       ((0x2dd0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_green_luma_min      // unsigned , default = 40  luma min for green color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_green_luma_max      // unsigned , default = 160  luma max for green color matching, dft =
#define NR4_MCNR_GREEN_CLIP2                       ((0x2dd1  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_green_sat_min       // unsigned , default = 4  saturation min for green color matching, dft =
//Bit 23:16        reg_nr4_cm_green_sat_max       // unsigned , default = 255  saturation max for green color matching, dft =
//Bit 15: 8        reg_nr4_cm_green_var_min       // unsigned , default = 0  variation min for green color matching, dft =
//Bit  7: 0        reg_nr4_cm_green_var_max       // unsigned , default = 12  variation max for green color matching, dft =
#define NR4_MCNR_SKIN_CENT                         ((0x2dd2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_centx         // unsigned , default = 112  x coordinate of center of skin tone, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_skin_centy         // unsigned , default = 149  y coordinate of center of skin tone, dft =
#define NR4_MCNR_SKIN_GAIN_PAR0                    ((0x2dd3  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_skin_gain_par0   // unsigned , default = 20  par0 for skin gain, dft =
//Bit 23:16        reg_nr4_cm_skin_gain_par1   // unsigned , default = 255  par1 for skin gain, dft =
//Bit 15: 8        reg_nr4_cm_skin_gain_par2   // unsigned , default = 255  par2 for skin gain, dft =
//Bit  7: 0        reg_nr4_cm_skin_gain_par3   // unsigned , default = 8  par3 for skin gain, dft =
#define NR4_MCNR_SKIN_GAIN_PAR1                    ((0x2dd4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_gain_par4   // unsigned , default = 8  par4 for skin gain, dft =
//Bit 15: 8        reg_nr4_cm_skin_gain_par5   // unsigned , default = 128  par5 for skin gain, dft =
//Bit  7: 0        reg_nr4_cm_skin_gain_par6   // unsigned , default = 0  par6 for skin gain, dft =
#define NR4_MCNR_SKIN_CLIP0                        ((0x2dd5  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_cm_skin_luma_min      // unsigned , default = 40  luma min for skin color matching, dft =
//Bit 15: 8        reserved
//Bit  7: 0        reg_nr4_cm_skin_luma_max      // unsigned , default = 180  luma max for skin color matching, dft =
#define NR4_MCNR_SKIN_CLIP1                        ((0x2dd6  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_cm_skin_sat_min       // unsigned , default = 5  saturation min for skin color matching, dft =
//Bit 23:16        reg_nr4_cm_skin_sat_max       // unsigned , default = 255  saturation max for skin color matching, dft =
//Bit 15: 8        reg_nr4_cm_skin_var_min       // unsigned , default = 0  variation min for skin color matching, dft =
//Bit  7: 0        reg_nr4_cm_skin_var_max       // unsigned , default = 12  variation max for skin color matching, dft =
#define NR4_MCNR_ALP1_GLB_CTRL                     ((0x2dd7  << 2) + 0xff000000)
//Bit 31           reg_nr4_alp1_glb_gain_en     // unsigned , default = 0  alp1 adjust by global gain, dft = 1
//Bit 30:28        reg_nr4_alp1_glb_gain_lsft   // unsigned , default = 6  alp1 left shift before combine with global gain
//Bit 27           reg_nr4_bet0_glb_gain_en     // unsigned , default = 1  bet0 adjust by global gain, dft = 1
//Bit 26:24        reg_nr4_bet0_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
//Bit 23           reg_nr4_bet1_glb_gain_en     // unsigned , default = 0  bet1 adjust by global gain, dft = 0
//Bit 22:20        reg_nr4_bet1_glb_gain_lsft   // unsigned , default = 6  bet1 left shift before combine with global gain
//Bit 19           reg_nr4_bet2_glb_gain_en     // unsigned , default = 1  bet2 adjust by global gain, dft = 1
//Bit 18:16        reg_nr4_bet2_glb_gain_lsft   // unsigned , default = 6  bet2 left shift before combine with global gain
//Bit 15           reg_nr4_alp1_ac_en           // unsigned , default = 1  alp1 adjust by ac, dft = 1
//Bit 14:12        reg_nr4_alp1_ac_lsft         // unsigned , default = 5  alp1 left shift before combine with ac
//Bit 11           reg_nr4_bet0_ac_en           // unsigned , default = 0  bet0 adjust by ac, dft = 1
//Bit 10: 8        reg_nr4_bet0_ac_lsft         // unsigned , default = 5  bet0 left shift before combine with ac
//Bit  7           reg_nr4_bet1_ac_en           // unsigned , default = 0  bet1 adjust by ac, dft = 1
//Bit  6: 4        reg_nr4_bet1_ac_lsft         // unsigned , default = 5  bet1 left shift before combine with ac
//Bit  3           reg_nr4_bet2_ac_en           // unsigned , default = 0  bet2 adjust by ac, dft = 1
//Bit  2: 0        reg_nr4_bet2_ac_lsft         // unsigned , default = 5  bet2 left shift before combine with ac
#define NR4_MCNR_DC2NORM_LUT0                      ((0x2dd8  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_dc2norm_lut0         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_dc2norm_lut1         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_dc2norm_lut2         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut3         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
#define NR4_MCNR_DC2NORM_LUT1                      ((0x2dd9  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_dc2norm_lut4         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_dc2norm_lut5         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_dc2norm_lut6         // unsigned , default = 16  normal 0~16, dc to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut7         // unsigned , default = 12  normal 0~16, dc to norm for alpha adjust, dft =
#define NR4_MCNR_DC2NORM_LUT2                      ((0x2dda  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_nr4_dc2norm_lut8        // unsigned , default = 8   normal 0~16, dc to norm for alpha adjust, dft =
#define NR4_MCNR_AC2NORM_LUT0                      ((0x2ddb  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_ac2norm_lut0         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_ac2norm_lut1         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_ac2norm_lut2         // unsigned , default = 16  normal 0~16, ac to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut3         // unsigned , default = 12  normal 0~16, ac to norm for alpha adjust, dft =
#define NR4_MCNR_AC2NORM_LUT1                      ((0x2ddc  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_nr4_ac2norm_lut4         // unsigned , default = 4  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 23:21        reserved
//Bit 20:16        reg_nr4_ac2norm_lut5         // unsigned , default = 2  normal 0~16, ac to norm for alpha adjust, dft =
//Bit 15:13        reserved
//Bit 12: 8        reg_nr4_ac2norm_lut6         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
//Bit  7: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut7         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
#define NR4_MCNR_AC2NORM_LUT2                      ((0x2ddd  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_nr4_ac2norm_lut8         // unsigned , default = 1  normal 0~16, ac to norm for alpha adjust, dft =
#define NR4_MCNR_SAD2ALP0_LUT0                     ((0x2dde  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp0_lut0        // unsigned , default = 255  sad to alpha0 for temporal pixel value, dft = 255
//Bit 23:16        reg_nr4_sad2alp0_lut1        // unsigned , default = 252  sad to alpha0 for temporal pixel value, dft = 252
//Bit 15: 8        reg_nr4_sad2alp0_lut2        // unsigned , default = 249  sad to alpha0 for temporal pixel value, dft = 249
//Bit  7: 0        reg_nr4_sad2alp0_lut3        // unsigned , default = 235  sad to alpha0 for temporal pixel value, dft = 70
#define NR4_MCNR_SAD2ALP0_LUT1                     ((0x2ddf  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp0_lut4        // unsigned , default = 185  sad to alpha0 for temporal pixel value, dft = 12
//Bit 23:16        reg_nr4_sad2alp0_lut5        // unsigned , default = 70  sad to alpha0 for temporal pixel value, dft = 1
//Bit 15: 8        reg_nr4_sad2alp0_lut6        // unsigned , default = 14  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut7        // unsigned , default = 1  sad to alpha0 for temporal pixel value, dft = 0
#define NR4_MCNR_SAD2ALP0_LUT2                     ((0x2de0  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp0_lut8        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 23:16        reg_nr4_sad2alp0_lut9        // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 15: 8        reg_nr4_sad2alp0_lut10       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut11       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
#define NR4_MCNR_SAD2ALP0_LUT3                     ((0x2de1  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp0_lut12       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 23:16        reg_nr4_sad2alp0_lut13       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit 15: 8        reg_nr4_sad2alp0_lut14       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
//Bit  7: 0        reg_nr4_sad2alp0_lut15       // unsigned , default = 0  sad to alpha0 for temporal pixel value, dft = 0
#define NR4_MCNR_SAD2ALP1_LUT0                     ((0x2de2  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp1_lut0        // unsigned , default = 192  sad to alpha1 for temporal blending, dft = 128
//Bit 23:16        reg_nr4_sad2alp1_lut1        // unsigned , default = 160  sad to alpha1 for temporal blending, dft = 128
//Bit 15: 8        reg_nr4_sad2alp1_lut2        // unsigned , default = 128  sad to alpha1 for temporal blending, dft = 128
//Bit  7: 0        reg_nr4_sad2alp1_lut3        // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 64
#define NR4_MCNR_SAD2ALP1_LUT1                     ((0x2de3  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp1_lut4        // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 64
//Bit 23:16        reg_nr4_sad2alp1_lut5        // unsigned , default = 32  sad to alpha1 for temporal blending, dft = 128
//Bit 15: 8        reg_nr4_sad2alp1_lut6        // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut7        // unsigned , default = 8  sad to alpha1 for temporal blending, dft = 255
#define NR4_MCNR_SAD2ALP1_LUT2                     ((0x2de4  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp1_lut8        // unsigned , default = 4  sad to alpha1 for temporal blending, dft = 255
//Bit 23:16        reg_nr4_sad2alp1_lut9        // unsigned , default = 0  sad to alpha1 for temporal blending, dft = 255
//Bit 15: 8        reg_nr4_sad2alp1_lut10       // unsigned , default = 16  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut11       // unsigned , default = 64  sad to alpha1 for temporal blending, dft = 255
#define NR4_MCNR_SAD2ALP1_LUT3                     ((0x2de5  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2alp1_lut12       // unsigned , default = 96  sad to alpha1 for temporal blending, dft = 255
//Bit 23:16        reg_nr4_sad2alp1_lut13       // unsigned , default = 224  sad to alpha1 for temporal blending, dft = 255
//Bit 15: 8        reg_nr4_sad2alp1_lut14       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
//Bit  7: 0        reg_nr4_sad2alp1_lut15       // unsigned , default = 255  sad to alpha1 for temporal blending, dft = 255
#define NR4_MCNR_SAD2BET0_LUT0                     ((0x2de6  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet0_lut0        // unsigned , default = 0  sad to beta0 for tnr and mcnr blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet0_lut1        // unsigned , default = 2  sad to beta0 for tnr and mcnr blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet0_lut2        // unsigned , default = 4  sad to beta0 for tnr and mcnr blending, dft = 4
//Bit  7: 0        reg_nr4_sad2bet0_lut3        // unsigned , default = 8  sad to beta0 for tnr and mcnr blending, dft = 8
#define NR4_MCNR_SAD2BET0_LUT1                     ((0x2de7  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet0_lut4        // unsigned , default = 16  sad to beta0 for tnr and mcnr blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet0_lut5        // unsigned , default = 32  sad to beta0 for tnr and mcnr blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet0_lut6        // unsigned , default = 48  sad to beta0 for tnr and mcnr blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet0_lut7        // unsigned , default = 64  sad to beta0 for tnr and mcnr blending, dft = 64
#define NR4_MCNR_SAD2BET0_LUT2                     ((0x2de8  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet0_lut8        // unsigned , default = 80  sad to beta0 for tnr and mcnr blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet0_lut9        // unsigned , default = 96  sad to beta0 for tnr and mcnr blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet0_lut10       // unsigned , default = 112  sad to beta0 for tnr and mcnr blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet0_lut11       // unsigned , default = 128  sad to beta0 for tnr and mcnr blending, dft = 128
#define NR4_MCNR_SAD2BET0_LUT3                     ((0x2de9  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet0_lut12       // unsigned , default = 196  sad to beta0 for tnr and mcnr blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet0_lut13       // unsigned , default = 224  sad to beta0 for tnr and mcnr blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet0_lut14       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet0_lut15       // unsigned , default = 255  sad to beta0 for tnr and mcnr blending, dft = 255
#define NR4_MCNR_SAD2BET1_LUT0                     ((0x2dea  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet1_lut0        // unsigned , default = 0  sad to beta1 for deghost blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet1_lut1        // unsigned , default = 2  sad to beta1 for deghost blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet1_lut2        // unsigned , default = 4  sad to beta1 for deghost blending, dft = 4
//Bit  7: 0        reg_nr4_sad2bet1_lut3        // unsigned , default = 8  sad to beta1 for deghost blending, dft = 8
#define NR4_MCNR_SAD2BET1_LUT1                     ((0x2deb  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet1_lut4        // unsigned , default = 16  sad to beta1 for deghost blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet1_lut5        // unsigned , default = 32  sad to beta1 for deghost blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet1_lut6        // unsigned , default = 48  sad to beta1 for deghost blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet1_lut7        // unsigned , default = 64  sad to beta1 for deghost blending, dft = 64
#define NR4_MCNR_SAD2BET1_LUT2                     ((0x2dec  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet1_lut8        // unsigned , default = 80  sad to beta1 for deghost blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet1_lut9        // unsigned , default = 96  sad to beta1 for deghost blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet1_lut10       // unsigned , default = 112  sad to beta1 for deghost blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet1_lut11       // unsigned , default = 128  sad to beta1 for deghost blending, dft = 128
#define NR4_MCNR_SAD2BET1_LUT3                     ((0x2ded  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet1_lut12       // unsigned , default = 160  sad to beta1 for deghost blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet1_lut13       // unsigned , default = 192  sad to beta1 for deghost blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet1_lut14       // unsigned , default = 224  sad to beta1 for deghost blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet1_lut15       // unsigned , default = 255  sad to beta1 for deghost blending, dft = 255
#define NR4_MCNR_SAD2BET2_LUT0                     ((0x2dee  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet2_lut0        // unsigned , default = 0  sad to beta2 for snr and mcnr blending, dft = 0
//Bit 23:16        reg_nr4_sad2bet2_lut1        // unsigned , default = 1  sad to beta2 for snr and mcnr blending, dft = 2
//Bit 15: 8        reg_nr4_sad2bet2_lut2        // unsigned , default = 2  sad to beta2 for snr and mcnr blending, dft  = 4
//Bit  7: 0        reg_nr4_sad2bet2_lut3        // unsigned , default = 4  sad to beta2 for snr and mcnr blending, dft = 8
#define NR4_MCNR_SAD2BET2_LUT1                     ((0x2def  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet2_lut4        // unsigned , default = 8  sad to beta2 for snr and mcnr blending, dft = 16
//Bit 23:16        reg_nr4_sad2bet2_lut5        // unsigned , default = 16  sad to beta2 for snr and mcnr blending, dft = 32
//Bit 15: 8        reg_nr4_sad2bet2_lut6        // unsigned , default = 32  sad to beta2 for snr and mcnr blending, dft = 48
//Bit  7: 0        reg_nr4_sad2bet2_lut7        // unsigned , default = 48  sad to beta2 for snr and mcnr blending, dft = 64
#define NR4_MCNR_SAD2BET2_LUT2                     ((0x2df0  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet2_lut8        // unsigned , default = 64  sad to beta2 for snr and mcnr blending, dft = 80
//Bit 23:16        reg_nr4_sad2bet2_lut9        // unsigned , default = 80  sad to beta2 for snr and mcnr blending, dft = 96
//Bit 15: 8        reg_nr4_sad2bet2_lut10       // unsigned , default = 96  sad to beta2 for snr and mcnr blending, dft = 112
//Bit  7: 0        reg_nr4_sad2bet2_lut11       // unsigned , default = 112  sad to beta2 for snr and mcnr blending, dft = 128
#define NR4_MCNR_SAD2BET2_LUT3                     ((0x2df1  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_sad2bet2_lut12       // unsigned , default = 128  sad to beta2 for snr and mcnr blending, dft = 160
//Bit 23:16        reg_nr4_sad2bet2_lut13       // unsigned , default = 160  sad to beta2 for snr and mcnr blending, dft = 192
//Bit 15: 8        reg_nr4_sad2bet2_lut14       // unsigned , default = 224  sad to beta2 for snr and mcnr blending, dft = 224
//Bit  7: 0        reg_nr4_sad2bet2_lut15       // unsigned , default = 255  sad to beta2 for snr and mcnr blending, dft = 255
#define NR4_MCNR_RO_U_SUM                          ((0x2df2  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_u_sum                // unsigned , default = 0  sum of U of current field/frame
#define NR4_MCNR_RO_V_SUM                          ((0x2df3  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_v_sum                // unsigned , default = 0  sum of V of current field/frame
#define NR4_MCNR_RO_GRDU_SUM                       ((0x2df4  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_grdu_sum             // unsigned , default = 0  sum of gradient U of current field/frame
#define NR4_MCNR_RO_GRDV_SUM                       ((0x2df5  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_grdv_sum             // unsigned , default = 0  sum of gradient V of current field/frame
#define NR4_TOP_CTRL                               ((0x2dff  << 2) + 0xff000000)
//Bit 31:20        reg_gclk_ctrl                 // unsigned , default = 0
//Bit 19           reserved
//Bit 18           reg_nr4_mcnr_en              // unsigned , default = 1  ncnr enable or bypass, dft = 1
//Bit 17           reg_nr2_en                 // unsigned , default = 1  nr2 enable, dft = 1
//Bit 16           reg_nr4_en                   // unsigned , default = 1  nr4 enable, dft = 1
//Bit 15           reg_nr2_proc_en            // unsigned , default = 1
//Bit 14           reg_det3d_en               // unsigned , default = 1
//Bit 13           di_polar_en                   // unsigned , default = 1  do does not have in C
//Bit 12           reg_cfr_enable             // unsigned , default = 0  0-disable;  1:enable
//Bit 11: 9        reg_3dnr_enable_l          // unsigned , default = 7  b0: Y b1:U b2:V
//Bit  8: 6        reg_3dnr_enable_r          // unsigned , default = 7  b0: Y b1:U b2:V
//Bit  5           reg_nr4_lnbuf_ctrl           // unsigned , default = 1  line buf ctrl for nr4: 0, 3lines, 1, 5lines, dft = 1
//Bit  4           reg_nr4_snr2_en              // unsigned , default = 0  snr2 enable, 0: use old snr, 1: use new snr2,   dft = 1
//Bit  3           reg_nr4_scene_change_en      // unsigned , default = 1  enable scene change proc. dft = 1
//Bit  2           nr2_sw_en                     // unsigned , default = 1  do does not have in C
//Bit  1            reserved
//Bit  0           reg_nr4_scene_change_flg     // unsigned , default = 0  flags for scene change, dft = 0
//========== nr4_mcnr_regs register end ==========//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_nr4_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_dnr_regs.h
//
//===========================================================================
// VI_HIST_SPL register    (16'h2e00 - 16'h2eff)
//===========================================================================
//
// Reading file:  ./vi_hist_spl_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VI_HIST_SPL 0x2e
// ----------------------------
// -----------------------------------------------
// REG_BASE:  VI_HIST_SPL_VCBUS_BASE = 0x2e
// -----------------------------------------------
//BIT 14: 34bin only, 0&255 and other 32bins
//Bit 13:11 hist_din_sel, 00: from vdin0 dout,  1: from vdin1, 2: from nr dout, 3: di output, 4: vpp output, 5: vd1_din, 6: vd2_din, 7:osd1_dout
//Bit 10:8   hist_din_comp_mux, mux of [29:22], [19:12], [9:2] for hist detect
//Bit 7:5   hist_dnlp_low   the real pixels in each bins got by VI_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics.  00: from matrix0 dout,  01: from vsc_dout, 10: from matrix1 dout, 11: form matrix1 din
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define VI_HIST_CTRL                               ((0x2e00  << 2) + 0xff000000)
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define VI_HIST_H_START_END                        ((0x2e01  << 2) + 0xff000000)
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define VI_HIST_V_START_END                        ((0x2e02  << 2) + 0xff000000)
//Bit 15:8  hist_max    maximum value
//Bit 7:0   hist_min    minimum value
//read only
#define VI_HIST_MAX_MIN                            ((0x2e03  << 2) + 0xff000000)
//Bit 31:0  hist_spl_rd
//counts for the total luma value
//read only
#define VI_HIST_SPL_VAL                            ((0x2e04  << 2) + 0xff000000)
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define VI_HIST_SPL_PIX_CNT                        ((0x2e05  << 2) + 0xff000000)
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value
//read only
#define VI_HIST_CHROMA_SUM                         ((0x2e06  << 2) + 0xff000000)
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VI_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VI_DNLP_HIST00[15:0]  counts for the first  bin
//VI_DNLP_HIST00[31:16] counts for the second bin
//VI_DNLP_HIST01[15:0]  counts for the third  bin
//VI_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define VI_DNLP_HIST00                             ((0x2e07  << 2) + 0xff000000)
#define VI_DNLP_HIST01                             ((0x2e08  << 2) + 0xff000000)
#define VI_DNLP_HIST02                             ((0x2e09  << 2) + 0xff000000)
#define VI_DNLP_HIST03                             ((0x2e0a  << 2) + 0xff000000)
#define VI_DNLP_HIST04                             ((0x2e0b  << 2) + 0xff000000)
#define VI_DNLP_HIST05                             ((0x2e0c  << 2) + 0xff000000)
#define VI_DNLP_HIST06                             ((0x2e0d  << 2) + 0xff000000)
#define VI_DNLP_HIST07                             ((0x2e0e  << 2) + 0xff000000)
#define VI_DNLP_HIST08                             ((0x2e0f  << 2) + 0xff000000)
#define VI_DNLP_HIST09                             ((0x2e10  << 2) + 0xff000000)
#define VI_DNLP_HIST10                             ((0x2e11  << 2) + 0xff000000)
#define VI_DNLP_HIST11                             ((0x2e12  << 2) + 0xff000000)
#define VI_DNLP_HIST12                             ((0x2e13  << 2) + 0xff000000)
#define VI_DNLP_HIST13                             ((0x2e14  << 2) + 0xff000000)
#define VI_DNLP_HIST14                             ((0x2e15  << 2) + 0xff000000)
#define VI_DNLP_HIST15                             ((0x2e16  << 2) + 0xff000000)
#define VI_DNLP_HIST16                             ((0x2e17  << 2) + 0xff000000)
#define VI_DNLP_HIST17                             ((0x2e18  << 2) + 0xff000000)
#define VI_DNLP_HIST18                             ((0x2e19  << 2) + 0xff000000)
#define VI_DNLP_HIST19                             ((0x2e1a  << 2) + 0xff000000)
#define VI_DNLP_HIST20                             ((0x2e1b  << 2) + 0xff000000)
#define VI_DNLP_HIST21                             ((0x2e1c  << 2) + 0xff000000)
#define VI_DNLP_HIST22                             ((0x2e1d  << 2) + 0xff000000)
#define VI_DNLP_HIST23                             ((0x2e1e  << 2) + 0xff000000)
#define VI_DNLP_HIST24                             ((0x2e1f  << 2) + 0xff000000)
#define VI_DNLP_HIST25                             ((0x2e20  << 2) + 0xff000000)
#define VI_DNLP_HIST26                             ((0x2e21  << 2) + 0xff000000)
#define VI_DNLP_HIST27                             ((0x2e22  << 2) + 0xff000000)
#define VI_DNLP_HIST28                             ((0x2e23  << 2) + 0xff000000)
#define VI_DNLP_HIST29                             ((0x2e24  << 2) + 0xff000000)
#define VI_DNLP_HIST30                             ((0x2e25  << 2) + 0xff000000)
#define VI_DNLP_HIST31                             ((0x2e26  << 2) + 0xff000000)
#define VI_DNLP_HIST32                             ((0x2e27  << 2) + 0xff000000)
//Bit 28:16 hist_pic_height  active input data window height
//Bit 12:0  hist_pic_width   active input data window width
#define VI_HIST_PIC_SIZE                           ((0x2e28  << 2) + 0xff000000)
//Bit 15:8 hist_pix_white_value: >= this value will be white pixel
//Bit 7:0 hist_pix_black_value: <= this value will be black pixel
#define VI_HIST_BLACK_WHITE_VALUE                  ((0x2e29  << 2) + 0xff000000)
#define VI_HIST_GCLK_CTRL                          ((0x2e2a  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vi_hist_spl_reg.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./mcdi_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MCDI_VCBUS_BASE = 0x2f
// -----------------------------------------------
////=================================================================////
//// memc di core 0
////=================================================================////
#define MCDI_HV_SIZEIN                             ((0x2f00  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_hsize               image horizontal size (number of cols)   default=1024
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_vsize               image vertical size   (number of rows)   default=1024
#define MCDI_HV_BLKSIZEIN                          ((0x2f01  << 2) + 0xff000000)
//Bit    31, reg_mcdi_vrev					 default = 0
//Bit    30, reg_mcdi_hrev					 default = 0
//Bit 29:28, reserved
//Bit 27:16, reg_mcdi_blkhsize               image horizontal blk size (number of cols)   default=1024
//Bit 15:13, reserved
//Bit 11: 0, reg_mcdi_blkvsize               image vertical blk size   (number of rows)   default=1024
#define MCDI_BLKTOTAL                              ((0x2f02  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23: 0, reg_mcdi_blktotal
#define MCDI_MOTINEN                               ((0x2f03  << 2) + 0xff000000)
//Bit 31: 2, reserved
//Bit     1, reg_mcdi_motionrefen.           enable motion refinement of MA, default = 1
//Bit     0, reg_mcdi_motionparadoxen.       enable motion paradox detection, default = 1
#define MCDI_CTRL_MODE                             ((0x2f04  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:26, reg_mcdi_lmvlocken	             0:disable, 1: use max Lmv, 2: use no-zero Lmv, lmv lock enable mode, default = 2
//Bit 25,    reg_mcdi_reldetrptchken
//                                           0: unable; 1: enable, enable repeat pattern check (not repeat mv detection) in rel det part, default = 1
//Bit 24,    reg_mcdi_reldetgmvpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check in gmv lock mode for rel det, default = 1
//Bit 23,    reg_mcdi_pd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check (lock) function, default = 1
//Bit 22,    reg_mcdi_reldetlpfen
//                                           0: unable; 1: enable, enable det value lpf, default = 1
//Bit 21,    reg_mcdi_reldetlmvpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check in lmv lock mode for rel det, default = 1
//Bit 20,    reg_mcdi_reldetlmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
//Bit 19,    reg_mcdi_reldetgmvdifchken
//                                           0: unable; 1: enable, enable lmv dif check in lmv lock mode for rel det, default = 1
//Bit 18,    reg_mcdi_reldetpd22chken
//                                           0: unable; 1: enable, enable pull-down 22 mode check for rel det refinement, default = 1
//Bit 17,    reg_mcdi_reldetfrqchken
//                                           0: unable; 1: enable, enable mv frequency check in rel det, default = 1
//Bit 16,    reg_mcdi_qmeen
//                                           0: unable; 1: enable, enable quarter motion estimation, default = 1
//Bit 15,    reg_mcdi_refrptmven
//                                           0: unable; 1: enable, use repeat mv in refinement, default = 1
//Bit 14,    reg_mcdi_refgmven
//                                           0: unable; 1: enable, use gmv in refinement, default = 1
//Bit 13,    reg_mcdi_reflmven
//                                           0: unable; 1: enable, use lmvs in refinement, default = 1
//Bit 12,    reg_mcdi_refnmven
//                                           0: unable; 1: enable, use neighboring mvs in refinement, default = 1
//Bit 11,    reserved
//Bit 10,    reg_mcdi_referrfrqchken
//                                           0: unable; 1: enable, enable mv frquency check while finding min err in ref, default = 1
//Bit 9,     reg_mcdi_refen
//                                           0: unable; 1: enable, enable mv refinement, default = 1
//Bit 8,     reg_mcdi_horlineen
//                                           0: unable; 1: enable,enable horizontal lines detection by sad map, default = 1
//Bit 7,     reg_mcdi_highvertfrqdeten
//                                           0: unable; 1: enable, enable high vertical frequency pattern detection, default = 1
//Bit 6,     reg_mcdi_gmvlocken
//                                           0: unable; 1: enable, enable gmv lock mode, default = 1
//Bit 5,     reg_mcdi_rptmven
//                                           0: unable; 1: enable, enable repeat pattern detection, default = 1
//Bit 4,     reg_mcdi_gmven
//                                           0: unable; 1: enable, enable global motion estimation, default = 1
//Bit 3,     reg_mcdi_lmven
//                                           0: unable; 1: enable, enable line mv estimation for hme, default = 1
//Bit 2,     reg_mcdi_chkedgeen
//                                           0: unable; 1: enable, enable check edge function, default = 1
//Bit 1,     reg_mcdi_txtdeten
//                                           0: unable; 1: enable, enable texture detection, default = 1
//Bit 0,     reg_mcdi_memcen
//                                           0: unable; 1: enable, enable of memc di, default = 1
#define MCDI_UNI_MVDST                             ((0x2f05  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:17, reg_mcdi_unimvdstabsseg0                     segment0 for uni-mv abs, default = 1
//Bit 16:12, reg_mcdi_unimvdstabsseg1                     segment1 for uni-mv abs, default = 15
//Bit 11: 8, reg_mcdi_unimvdstabsdifgain0	          2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2
//Bit  7: 5, reg_mcdi_unimvdstabsdifgain1                 2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2
//Bit  4: 2, reg_mcdi_unimvdstabsdifgain2                 2/2, gain2 of uni-mv abs dif beyond segment1, normalized 2 to '1', default = 2
//Bit  1: 0, reg_mcdi_unimvdstsgnshft		          shift for neighboring distance of uni-mv, default = 0
#define MCDI_BI_MVDST                              ((0x2f06  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:17, reg_mcdi_bimvdstabsseg0                      segment0 for bi-mv abs, default = 1
//Bit 16:12, reg_mcdi_bimvdstabsseg1                      segment1 for bi-mv abs, default = 9
//Bit 11: 8, reg_mcdi_bimvdstabsdifgain0	          6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6
//Bit  7: 5, reg_mcdi_bimvdstabsdifgain1                  3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3
//Bit  4: 2, reg_mcdi_bimvdstabsdifgain2                  2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2
//Bit  1: 0, reg_mcdi_bimvdstsgnshft	                  shift for neighboring distance of bi-mv, default = 0
#define MCDI_SAD_GAIN                              ((0x2f07  << 2) + 0xff000000)
//Bit 31:19, reserved
//Bit 18:17, reg_mcdi_unisadcorepxlgain                   uni-sad core pixels gain, default = 3
//Bit 16,    reg_mcdi_unisadcorepxlnormen                 enable uni-sad core pixels normalization, default = 0
//Bit 15:11, reserved
//Bit 10: 9, reg_mcdi_bisadcorepxlgain                    bi-sad core pixels gain, default = 3
//Bit  8,    reg_mcdi_bisadcorepxlnormen                  enable bi-sad core pixels normalization, default = 1
//Bit  7: 3, reserved
//Bit  2: 1, reg_mcdi_biqsadcorepxlgain                   bi-qsad core pixels gain, default = 3
//Bit  0,    reg_mcdi_biqsadcorepxlnormen                 enable bi-qsad core pixels normalization, default = 1
#define MCDI_TXT_THD                               ((0x2f08  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_txtminmaxdifthd,                    min max dif threshold (>=) for texture detection, default = 24
//Bit 15: 8, reg_mcdi_txtmeandifthd,                      mean dif threshold (<) for texture detection, default = 9
//Bit  7: 3, reserved
//Bit  2: 0, reg_mcdi_txtdetthd,                          texture detecting threshold, 0~4, default = 2
#define MCDI_FLT_MODESEL                           ((0x2f09  << 2) + 0xff000000)
//Bit 31	 reserved
//Bit 30:28, reg_mcdi_flthorlineselmode                   mode for horizontal line detecting flat calculation, default = 1, same as below
//Bit 27	 reserved
//Bit 26:24, reg_mcdi_fltgmvselmode                       mode for gmv flat calculation, default = 4, same as below
//Bit 23,	 reserved
//Bit 22:20, reg_mcdi_fltsadselmode                       mode for sad flat calculation, default = 2, same as below
//Bit 19,	 reserved
//Bit 18:16, reg_mcdi_fltbadwselmode                      mode for badw flat calculation, default = 3, same as below
//Bit 15,	 reserved
//Bit 14:12, reg_mcdi_fltrptmvselmode                     mode for repeat mv flat calculation, default = 4, same as below
//Bit 11,	 reserved
//Bit 10: 8, reg_mcdi_fltbadrelselmode                    mode for bad rel flat calculation, default = 4, same as below
//Bit  7,	 reserved
//Bit  6: 4, reg_mcdi_fltcolcfdselmode                    mode for col cfd flat calculation, default = 2, same as below
//Bit  3,	 reserved
//Bit  2: 0, reg_mcdi_fltpd22chkselmode                   mode for pd22 check flat calculation, default = 2, # 0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v, 4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre)
#define MCDI_CHK_EDGE_THD                          ((0x2f0a  << 2) + 0xff000000)
//Bit 23:28, reserved.
//Bit 27:24, reg_mcdi_chkedgedifsadthd.                   thd (<=) for sad dif check, 0~8, default = 1
//Bit 23:16, reserved.
//Bit 15:12, reg_mcdi_chkedgemaxedgethd.                  max drt of edge, default = 15
//Bit 11: 8, reg_mcdi_chkedgeminedgethd.                  min drt of edge, default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_chkedgevdifthd.                     thd for vertical dif in check edge, default = 14
#define MCDI_CHK_EDGE_GAIN_OFFST                   ((0x2f0b  << 2) + 0xff000000)
//Bit 31:24, reserved.
//Bit 23:20, reg_mcdi_chkedgedifthd1.                     thd1 for edge dif check (<=), default = 4
//Bit 19:16, reg_mcdi_chkedgedifthd0.                     thd0 for edge dif check (>=), default = 15
//Bit   :15, reserved.
//Bit 14:10, reg_mcdi_chkedgechklen.                      total check length for edge check, 1~24 (>0), default = 24
//Bit  9: 8, reg_mcdi_chkedgeedgesel.                     final edge select mode, 0: original start edge, 1: lpf start edge, 2: orignal start+end edge, 3: lpf start+end edge, default = 1
//Bit  7: 3, reg_mcdi_chkedgesaddstgain.                  distance gain for sad calc while getting edges, default = 4
//Bit     2, reg_mcdi_chkedgechkmode.                     edge used in check mode, 0: original edge, 1: lpf edge, default = 1
//Bit     1, reg_mcdi_chkedgestartedge.                   edge mode for start edge, 0: original edge, 1: lpf edge, default = 0
//Bit     0, reg_mcdi_chkedgeedgelpf.                     edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0
#define MCDI_LMV_RT                                ((0x2f0c  << 2) + 0xff000000)
//BIt 31:15, reserved
//Bit 14:12, reg_mcdi_lmvvalidmode                        valid mode for lmv calc., 100b: use char det, 010b: use flt, 001b: use hori flg
//Bit 11:10, reg_mcdi_lmvgainmvmode                       four modes of mv selection for lmv weight calculation, default = 1
//                                                        0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1); 2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3); 3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2);
//Bit  9,    reg_mcdi_lmvinitmode                         initial lmvs at first row of input field, 0: intial value = 0; 1: inital = 32 (invalid), default = 0
//Bit  8,    reserved
//Bit  7: 4, reg_mcdi_lmvrt0                              ratio of max mv, default = 5
//Bit  3: 0, reg_mcdi_lmvrt1                              ratio of second max mv, default = 5
#define MCDI_LMV_GAINTHD                           ((0x2f0d  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_lmvvxmaxgain                        max gain of lmv weight, default = 96
//Bit 23,    reserved
//Bit 22:20, reg_mcdi_lmvdifthd0                          dif threshold 0 (<) for small lmv, default = 1
//Bit 19:17, reg_mcdi_lmvdifthd1                          dif threshold 1 (<) for median lmv, default = 2
//Bit 16:14, reg_mcdi_lmvdifthd2                          dif threshold 2 (<) for large lmv, default = 3
//Bit 13: 8, reg_mcdi_lmvnumlmt                           least/limit number of (total number - max0), default = 20
//Bit  7: 0, reg_mcdi_lmvfltthd                           flt cnt thd (<) for lmv, default = 9
#define MCDI_RPTMV_THD0                            ((0x2f0e  << 2) + 0xff000000)
//Bit 31:25, reg_mcdi_rptmvslpthd2			  slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64
//Bit 24:20, reg_mcdi_rptmvslpthd1                        slope thd (>=) between i and i+2/i-2, default = 4
//Bit 19:10, reg_mcdi_rptmvampthd2                        amplitude thd (>=) between max and min, when count cycles, default = 300
//Bit  9: 0, reg_mcdi_rptmvampthd1                        amplitude thd (>=) between average of max and min, default = 400
#define MCDI_RPTMV_THD1                            ((0x2f0f  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:25, reg_mcdi_rptmvcyccntthd                      thd (>=) of total cycles count, default = 2
//Bit 24:21, reg_mcdi_rptmvcycdifthd                      dif thd (<) of cycles length, default = 3
//Bit 20:18, reg_mcdi_rptmvcycvldthd                      thd (>) of valid cycles number, default = 1
//Bit 17:15, reg_mcdi_rptmvhalfcycminthd                  min length thd (>=) of half cycle, default = 2
//Bit 14:11, reg_mcdi_rptmvhalfcycdifthd                  neighboring half cycle length dif thd (<), default = 5
//Bit 10: 8, reg_mcdi_rptmvminmaxcntthd                   least number of valid max and min, default = 2
//Bit  7: 5, reg_mcdi_rptmvcycminthd                      min length thd (>=) of cycles, default = 2
//Bit  4: 0, reg_mcdi_rptmvcycmaxthd                      max length thd (<) of cycles, default = 17
#define MCDI_RPTMV_THD2                            ((0x2f10  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_rptmvhdifthd0                       higher hdif thd (>=) (vertical edge) for rpt detection, default = 8
//Bit 15: 8, reg_mcdi_rptmvhdifthd1                       hdif thd (>=) (slope edge) for rpt detection, default = 4
//Bit  7: 0, reg_mcdi_rptmvvdifthd                        vdif thd (>=) (slope edge) for rpt detection, default = 1
#define MCDI_RPTMV_SAD                             ((0x2f11  << 2) + 0xff000000)
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_rptmvsaddifthdgain                  7x3x(16/16), gain for sad dif thd in rpt mv detection, 0~672, normalized 16 as '1', default = 336
//Bit 15:10, reserved
//Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst                 offset for sad dif thd in rpt mv detection, -512~511, default = 16
#define MCDI_RPTMV_FLG                             ((0x2f12  << 2) + 0xff000000)
//Bit 31:18,  reserved
//Bit 17:16,  reg_mcdi_rptmvmode                          select mode of mvs for repeat motion estimation, 0: hmv, 1: qmv/2, 2 or 3: qmv/4, default = 2
//Bit 15: 8,  reg_mcdi_rptmvflgcntthd                     thd (>=) of min count number for rptmv of whole field, for rptmv estimation, default = 64
//Bit  7: 5,  reserved
//Bit  4: 0,  reg_mcdi_rptmvflgcntrt                      4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32,
#define MCDI_RPTMV_GAIN                            ((0x2f13  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_rptmvlftgain                        up repeat mv gain for hme, default = 96
//Bit 23:16, reg_mcdi_rptmvuplftgain                      up left repeat mv gain for hme, default = 32
//Bit 15: 8, reg_mcdi_rptmvupgain                         up repeat mv gain for hme, default = 64
//Bit  7: 0, reg_mcdi_rptmvuprightgain                    up right repeat mv gain for hme, default = 32
#define MCDI_GMV_RT                                ((0x2f14  << 2) + 0xff000000)
//Bit 31,    reserved
//Bit 30:24, reg_mcdi_gmvmtnrt0                           ratio 0 for motion senario, set 127 to 128, normalized 128 as '1', default =32
//Bit 23,    reserved
//Bit 22:16, reg_mcdi_gmvmtnrt1                           ratio 1 for motion senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit 15,    reserved
//Bit 14: 8, reg_mcdi_gmvstlrt0                           ratio 0 for still senario, set 127 to 128, normalized 128 as '1', default = 56
//Bit  7,    reserved
//Bit  6: 0, reg_mcdi_gmvstlrt1                           ratio 1 for still senario, set 127 to 128, normalized 128 as '1', default = 80
#define MCDI_GMV_GAIN                              ((0x2f15  << 2) + 0xff000000)
//Bit 31:25, reg_mcdi_gmvzeromvlockrt0                    ratio 0 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 100
//Bit 24:18, reg_mcdi_gmvzeromvlockrt1                    ratio 1 for locking zero mv, set 127 to 128, normalized 128 as '1', default = 112
//Bit 17:16, reg_mcdi_gmvvalidmode                        valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3
//Bit 15: 8, reg_mcdi_gmvvxgain                           gmv's vx gain when gmv locked for hme, default = 0
//Bit  7: 0, reg_mcdi_gmvfltthd                           flat thd (<) for gmv calc. default = 3
#define MCDI_HOR_SADOFST                           ((0x2f16  << 2) + 0xff000000)
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_horsaddifthdgain                    21*1/8, gain/divisor for sad dif threshold in hor line detection, normalized 8 as '1', default = 21
//Bit 15: 8, reg_mcdi_horsaddifthdoffst                   offset for sad dif threshold in hor line detection, -128~127, default = 0
//Bit  7: 0, reg_mcdi_horvdifthd                          threshold (>=) of vertical dif of next block for horizontal line detection, default = 24
#define MCDI_REF_MV_NUM                            ((0x2f17  << 2) + 0xff000000)
//Bit 31: 2, reserved
//Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0
#define MCDI_REF_BADW_THD_GAIN                     ((0x2f18  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_refbadwcnt2gain.   gain for badwv count num==3, default = 6
//Bit 23:20, reg_mcdi_refbadwcnt1gain.   gain for badwv count num==2, default = 3
//Bit 19:16, reg_mcdi_refbadwcnt0gain.   gain for badwv count num==1, default = 1
//Bit 15:12, reg_mcdi_refbadwthd3.       threshold 3 for detect badweave with largest average luma, default = 4
//Bit 11: 8, reg_mcdi_refbadwthd2.       threshold 2 for detect badweave with third smallest average luma, default = 3
//Bit  7: 4, reg_mcdi_refbadwthd1.       threshold 1 for detect badweave with second smallest average luma, default = 2
//Bit  3: 0, reg_mcdi_refbadwthd0.       threshold 0 for detect badweave with smallest average luma, default = 1
#define MCDI_REF_BADW_SUM_GAIN                     ((0x2f19  << 2) + 0xff000000)
//Bit 31:13, reserved
//Bit 12: 8, reg_mcdi_refbadwsumgain0.   sum gain for r channel, 0~16, default = 8
//Bit  7: 5, reserved
//Bit     4, reg_mcdi_refbadwcalcmode.   mode for badw calculation, 0:sum, 1:max, default = 0
//Bit  3: 0, reserved
#define MCDI_REF_BS_THD_GAIN                       ((0x2f1a  << 2) + 0xff000000)
//Bit 31:28, reg_mcdi_refbsudgain1.      up & down block strength gain1, normalized to 8 as '1', default = 2
//Bit 27:24, reg_mcdi_refbsudgain0.      up & down block strength gain0, normalized to 8 as '1', default = 4
//Bit 23:19, reserved
//Bit 18:16, reg_mcdi_refbslftgain.      left block strength gain, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_refbsthd1.         threshold 1 for detect block strength in refinment, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_refbsthd0.         threshold 0 for detect block strength in refinment, default = 8
#define MCDI_REF_ERR_GAIN0                         ((0x2f1b  << 2) + 0xff000000)
//Bit    31, reserved
//Bit 30:24, reg_mcdi_referrnbrdstgain.            neighboring mv distances gain for err calc. in ref, normalized to 8 as '1', default = 48
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_referrbsgain.                bs gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit    15, reserved
//Bit 14: 8, reg_mcdi_referrbadwgain.              badw gain for err calc. in ref, normalized to 8 as '1', default = 64
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrsadgain.               sad gain for err calc. in ref, normalized to 8 as '1', default = 4
#define MCDI_REF_ERR_GAIN1                         ((0x2f1c  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_referrchkedgegain.           check edge gain for err calc. in ref, normalized to 8 as '1', default = 4
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_referrlmvgain.               (locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_referrgmvgain.               (locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0
#define MCDI_REF_ERR_FRQ_CHK                       ((0x2f1d  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_referrfrqgain.               gain for mv frquency, normalized to 4 as '1', default = 10
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_referrfrqmax.                max gain for mv frquency check, default = 31
//Bit    15, reserved
//Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.         mv dif threshold 2 (<) for mv frquency check, default = 3
//Bit    11, reserved
//Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.         mv dif threshold 1 (<) for mv frquency check, default = 2
//Bit     7, reserved
//Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.         mv dif threshold 0 (<) for mv frquency check, default = 1
//Bit  3: 0, reserved
#define MCDI_QME_LPF_MSK                           ((0x2f1e  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.           lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_qmebslpfmsk0.                lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.              lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_qmesadlpfmsk0.               lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0), normalized to 8 as '1', default = 7
#define MCDI_REL_DIF_THD_02                        ((0x2f1f  << 2) + 0xff000000)
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldifthd2.                  thd (<) for (hdif+vdif), default = 9
//Bit 15: 8, reg_mcdi_reldifthd1.                  thd (<) for (vdif), default = 5
//Bit  7: 0, reg_mcdi_reldifthd0.                  thd (>=) for (hdif-vdif), default = 48
#define MCDI_REL_DIF_THD_34                        ((0x2f20  << 2) + 0xff000000)
//Bit 31:16, reserved.
//Bit 15: 8, reg_mcdi_reldifthd4.                  thd (<) for (hdif), default = 255
//Bit  7: 0, reg_mcdi_reldifthd3.                  thd (>=) for (vdif-hdif), default = 48
#define MCDI_REL_BADW_GAIN_OFFST_01                ((0x2f21  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_relbadwoffst1.               offset for badw adj, for flat block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain1.                gain for badw adj, for flat block, default = 128
//Bit 15: 8, reg_mcdi_relbadwoffst0.               offset for badw adj, for vertical block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain0.                gain for badw adj, for vertical block, default = 160
#define MCDI_REL_BADW_GAIN_OFFST_23                ((0x2f22  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_relbadwoffst3.               offset for badw adj, for other block, -128~127, default = 0
//Bit 23:16, reg_mcdi_relbadwgain3.                gain for badw adj, for other block, default = 48
//Bit 15: 8, reg_mcdi_relbadwoffst2.               offset for badw adj, for horizontal block, -128~127, default = 0
//Bit  7: 0, reg_mcdi_relbadwgain2.                gain for badw adj, for horizontal block, default = 48
#define MCDI_REL_BADW_THD_GAIN_OFFST               ((0x2f23  << 2) + 0xff000000)
//Bit 31:23, reserved.
//Bit 22:16, reg_mcdi_relbadwoffst.                offset for badw thd adj, -64~63, default = 0
//Bit 15: 8, reserved.
//Bit  7: 0, reg_mcdi_relbadwthdgain.              gain0 for badw thd adj, normalized to 16 as '1', default = 16
#define MCDI_REL_BADW_THD_MIN_MAX                  ((0x2f24  << 2) + 0xff000000)
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_relbadwthdmax.               max for badw thd adj, default = 256
//Bit  7: 0, reg_mcdi_relbadwthdmin.               min for badw thd adj, default = 16
#define MCDI_REL_SAD_GAIN_OFFST_01                 ((0x2f25  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_relsadoffst1.                offset for sad adj, for flat block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain1.                 gain for sad adj, for flat block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst0.                offset for sad adj, for vertical block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain0.                 gain for sad adj, for vertical block, normalized to 8 as '1', default = 6
#define MCDI_REL_SAD_GAIN_OFFST_23                 ((0x2f26  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_relsadoffst3.                offset for sad adj, for other block, -128~127, default = 0
//Bit 23:20, reserved.
//Bit 19:16, reg_mcdi_relsadgain3.                 gain for sad adj, for other block, normalized to 8 as '1', default = 8
//Bit 15: 8, reg_mcdi_relsadoffst2.                offset for sad adj, for horizontal block, -128~127, default = 0
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_relsadgain2.                 gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12
#define MCDI_REL_SAD_THD_GAIN_OFFST                ((0x2f27  << 2) + 0xff000000)
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_relsadoffst.                 offset for sad thd adj, -128~127, default = 0
//Bit 15:10, reserved.
//Bit  9: 0, reg_mcdi_relsadthdgain.               gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42
#define MCDI_REL_SAD_THD_MIN_MAX                   ((0x2f28  << 2) + 0xff000000)
//Bit 31:27, reserved.
//Bit 26:16, reg_mcdi_relsadthdmax.                max for sad thd adj, 21*32, default = 672
//Bit 15: 9, reserved.
//Bit  8: 0, reg_mcdi_relsadthdmin.                min for sad thd adj, 21*2, default = 42
#define MCDI_REL_DET_GAIN_00                       ((0x2f29  << 2) + 0xff000000)
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain0.               gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1', default = 8
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain0.             gain0 (gmv locked) for badw, for det. calc. normalized to 16 as '1', default = 12
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain0.              gain0 (gmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define MCDI_REL_DET_GAIN_01                       ((0x2f2a  << 2) + 0xff000000)
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain0.          gain0 (gmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 2
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain0.           gain0 (gmv locked) for neighboring dist, for det. calc. normalized to 16 as '1', default = 24
#define MCDI_REL_DET_GAIN_10                       ((0x2f2b  << 2) + 0xff000000)
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain1.               gain1 (lmv locked) for bs, for det. calc. normalized to 16 as '1', default = 0
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain1.             gain1 (lmv locked) for badw, for det. calc. normalized to 16 as '1', default = 8
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain1.              gain1 (lmv locked) for qsad, for det. calc. normalized to 16 as '1', default = 8
#define MCDI_REL_DET_GAIN_11                       ((0x2f2c  << 2) + 0xff000000)
//Bit 31:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain1.          gain1 (lmv locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 0
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain1.           gain1 (lmv locked) for neighboring dist, for det. calc. normalized to 16 as '1', default = 24
#define MCDI_REL_DET_GAIN_20                       ((0x2f2d  << 2) + 0xff000000)
//Bit 31:21, reserved.
//Bit 20:16, reg_mcdi_reldetbsgain2.               gain2 (no locked) for bs, for det. calc. normalized to 16 as '1', default = 12
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetbadwgain2.             gain2 (no locked) for badw, for det. calc. normalized to 16 as '1', default = 32
//Bit  7: 5, reserved.
//Bit  4: 0, reg_mcdi_reldetsadgain2.              gain2 (no locked) for qsad, for det. calc. normalized to 16 as '1', default = 16
#define MCDI_REL_DET_GAIN_21                       ((0x2f2e  << 2) + 0xff000000)
//Bit 31:26, reserved
//Bit 25:16, reg_mcdi_reldetoffst.                 offset for rel calculation, for det. calc. -512~511,  default = 0
//Bit 15:14, reserved.
//Bit 12: 8, reg_mcdi_reldetchkedgegain2.          gain2 (no locked) for chk_edge, for det. calc. normalized to 16 as '1', default = 10
//Bit     7, reserved.
//Bit  6: 0, reg_mcdi_reldetnbrdstgain2.           gain2 (no locked) for neighboring dist, for det. calc. normalized to 16 as '1', default = 32
#define MCDI_REL_DET_GMV_DIF_CHK                   ((0x2f2f  << 2) + 0xff000000)
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetgmvfltthd.             flat thd (>=) for gmv lock decision, default = 0
//Bit    15, reserved.
//Bit 14:12, reg_mcdi_reldetgmvdifthd.             dif thd (>=) for current mv different from gmv for gmv dif check, actually used in Lmv lock check, default = 3
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetgmvdifmin.             min mv dif for gmv dif check, default = 1, note: dif between reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min should be; 0,1,3,7, not work for others
//Bit  7: 4, reg_mcdi_reldetgmvdifmax.             max mv dif for gmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetgmvdifmvmode.          mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0
#define MCDI_REL_DET_LMV_DIF_CHK                   ((0x2f30  << 2) + 0xff000000)
//Bit 31:24, reserved.
//Bit 23:16, reg_mcdi_reldetlmvfltthd.             flat thd (>=) for lmv lock decision, default = 12
//Bit 15:14, reserved.
//Bit 13:12, reg_mcdi_reldetlmvlockchkmode.        lmv lock check mode, 0:cur Lmv, 1: cur & (last | next), 2: last & cur & next Lmv, default = 1
//Bit    11, reserved.
//Bit 10: 8, reg_mcdi_reldetlmvdifmin.             min mv dif for lmv dif check, default = 1, note: dif between reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be; 0,1,3,7, not work for others
//Bit  7: 4, reg_mcdi_reldetlmvdifmax.             max mv dif for lmv dif check, default = 4
//Bit  3: 1, reserved
//Bit     0, reg_mcdi_reldetlmvdifmvmode.          mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0
#define MCDI_REL_DET_FRQ_CHK                       ((0x2f31  << 2) + 0xff000000)
//Bit 31:12, reserved.
//Bit 11: 8, reg_mcdi_reldetfrqgain.               gain for frequency check, normalized to 4 as '1', default = 10
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetfrqmax.                max value for frequency check, default = 31
#define MCDI_REL_DET_PD22_CHK                      ((0x2f32  << 2) + 0xff000000)
//Bit 31:18, reserved.
//Bit 17: 8, reg_mcdi_reldetpd22chkoffst.          offset for pd22 check happened, default = 512
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetpd22chkgain.           gain for pd22 check happened, normalized to 8 as '1', default = 12
#define MCDI_REL_DET_RPT_CHK_ROW                   ((0x2f33  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_reldetrptchkendrow.          end row (<) number for repeat check, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_reldetrptchkstartrow.        start row (>=) number for repeat check, default = 0
#define MCDI_REL_DET_RPT_CHK_GAIN_QMV              ((0x2f34  << 2) + 0xff000000)
//Bit 31:30, reserved
//Bit 29:24, reg_mcdi_reldetrptchkqmvmax.          max thd (<) of abs qmv for repeat check, default = 15, note that quarter mv's range is -63~63
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_reldetrptchkqmvmin.          min thd (>=) of abs qmv for repeat check, default = 10, note that quarter mv's range is -63~63
//Bit    15, reserved/
//Bit 14: 4, reg_mcdi_reldetrptchkoffst.           offset for repeat check, default = 512
//Bit  3: 0, reg_mcdi_reldetrptchkgain.            gain for repeat check, normalized to 8 as '1', default = 4
#define MCDI_REL_DET_RPT_CHK_THD_0                 ((0x2f35  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.      zero sad thd (<) for repeat check, default = 255
//Bit 15:14, reserved.
//Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.     zero badw thd (>=) for repeat check, default = 16
//Bit  7: 4, reserved
//Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.       frequency dif thd (<) for repeat check, 0~10, default = 5
#define MCDI_REL_DET_RPT_CHK_THD_1                 ((0x2f36  << 2) + 0xff000000)
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.         vertical dif thd (<) for repeat check, default = 16
//Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.         horizontal dif thd (>=) for repeat check, default = 16
#define MCDI_REL_DET_LPF_DIF_THD                   ((0x2f37  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetlpfdifthd3.            hdif thd (<) for lpf selection of horizontal block, default = 9
//Bit 23:16, reg_mcdi_reldetlpfdifthd2.            vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48
//Bit 15: 8, reg_mcdi_reldetlpfdifthd1.            vdif thd (<) for lpf selection of vertical block, default = 9
//Bit  7: 0, reg_mcdi_reldetlpfdifthd0.            hdif-vdif thd (>=) for lpf selection of vertical block, default = 48
#define MCDI_REL_DET_LPF_MSK_00_03                 ((0x2f38  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk03.              det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk02.              det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk01.              det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk00.              det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8
#define MCDI_REL_DET_LPF_MSK_04_12                 ((0x2f39  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk12.              det lpf mask12 for vertical blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk11.              det lpf mask11 for vertical blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk10.              det lpf mask10 for vertical blocks, 0~16, default = 16
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk04.              det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1
#define MCDI_REL_DET_LPF_MSK_13_21                 ((0x2f3a  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk21.              det lpf mask21 for horizontal blocks, 0~16, default = 6
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk20.              det lpf mask20 for horizontal blocks, 0~16, default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk14.              det lpf mask14 for vertical blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk13.              det lpf mask13 for vertical blocks, 0~16, default = 0
#define MCDI_REL_DET_LPF_MSK_22_30                 ((0x2f3b  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk30.              det lpf mask30 for other blocks, 0~16, default = 16
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk24.              det lpf mask24 for horizontal blocks, 0~16, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk23.              det lpf mask23 for horizontal blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk22.              det lpf mask22 for horizontal blocks, 0~16, default = 1
#define MCDI_REL_DET_LPF_MSK_31_34                 ((0x2f3c  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_reldetlpfmsk34.              det lpf mask34 for other blocks, 0~16, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_reldetlpfmsk33.              det lpf mask33 for other blocks, 0~16, default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_reldetlpfmsk32.              det lpf mask32 for other blocks, 0~16, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_reldetlpfmsk31.              det lpf mask31 for other blocks, 0~16, default = 0
//Note: there are four group lpf masks from addr 37~3b, each group sum equal to 16.
#define MCDI_REL_DET_MIN                           ((0x2f3d  << 2) + 0xff000000)
//Bit 31: 7, reserved
//Bit  6: 0, reg_mcdi_reldetmin.                   min of detected value, default = 16
#define MCDI_REL_DET_LUT_0_3                       ((0x2f3e  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8
//Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4
//Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2
//Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0
#define MCDI_REL_DET_LUT_4_7                       ((0x2f3f  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64
//Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48
//Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32
//Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16
#define MCDI_REL_DET_LUT_8_11                      ((0x2f40  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160
//Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128
//Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96
//Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80
#define MCDI_REL_DET_LUT_12_15                     ((0x2f41  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255
//Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240
//Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224
//Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192
#define MCDI_REL_DET_COL_CFD_THD                   ((0x2f42  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetcolcfdfltthd.          thd for flat smaller than (<) of column confidence, default = 5
//Bit 23:16, reg_mcdi_reldetcolcfdthd1.            thd for rel larger than (>=) in rel calc. mode col confidence without gmv locking, default = 160
//Bit 15: 8, reg_mcdi_reldetcolcfdthd0.            thd for rel larger than (>=) in rel calc. mode col confidence when gmv locked, default = 100
//Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.         thd for badw larger than (>=) in qbadw calc. mode of column confidence, default = 16
//Bit     1, reserved
//Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc. mode for column confidence, 0: use rel, 1: use qbadw, default = 0
#define MCDI_REL_DET_COL_CFD_AVG_LUMA              ((0x2f43  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.         avg luma min1 (>=) for column confidence, valid between 16~235, default = 235
//Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.         avg luma max1 (<)  for column confidence, valid between 16~235, default = 235
//Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.         avg luma min0 (>=) for column confidence, valid between 16~235, default = 16
//Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.         avg luma max0 (<)  for column confidence, valid between 16~235, default = 21
#define MCDI_REL_DET_BAD_THD_0                     ((0x2f44  << 2) + 0xff000000)
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_reldetbadsadthd.             thd (>=) for bad sad, default = 120 (480/4)
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_reldetbadbadwthd.            thd (>=) for bad badw, 0~42, default = 12
#define MCDI_REL_DET_BAD_THD_1                     ((0x2f45  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_reldetbadrelfltthd.          thd (>=) of flat for bad rel detection, default = 4
//Bit 15: 8, reg_mcdi_reldetbadrelthd1.            thd (>=) for bad rel without gmv/lmv locked, default = 160
//Bit  7: 0, reg_mcdi_reldetbadrelthd0.            thd (>=) for bad rel with gmv/lmv locked, default = 120
#define MCDI_PD22_CHK_THD                          ((0x2f46  << 2) + 0xff000000)
//Bit 31:25, reserved
//Bit 24:16, reg_mcdi_pd22chksaddifthd.            sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64
//Bit 15:14, reserved
//Bit 13: 8, reg_mcdi_pd22chkqmvthd.               thd (>=) of abs qmv for pd22 check, default = 2
//Bit  7: 0, reg_mcdi_pd22chkfltthd.               thd (>=) of flat for pd22 check, default = 4
#define MCDI_PD22_CHK_GAIN_OFFST_0                 ((0x2f47  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_pd22chkedgeoffst0.           offset0 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain0.            gain0 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.           offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain0.            gain0 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 8
#define MCDI_PD22_CHK_GAIN_OFFST_1                 ((0x2f48  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_pd22chkedgeoffst1.           offset1 of pd22chkedge from right film22 phase, -128~127, default = 0
//Bit 23:21, reserved
//Bit 20:16, reg_mcdi_pd22chkedgegain1.            gain1 of pd22chkedge from right film22 phase, normalized to 16 as '1', default = 16
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.           offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkbadwgain1.            gain1 of pd22chkbadw from right film22 phase, normalized to 16 as '1', default = 12
#define MCDI_LMV_LOCK_CNT_THD_GAIN                 ((0x2f49  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_lmvlockcntmax.               max lmv lock count number, default = 6
//Bit 15:12, reg_mcdi_lmvlockcntoffst.             offset for lmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_lmvlockcntgain.              gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockcntthd.               lmv count thd (>=) before be locked, 1~31, default = 4
#define MCDI_LMV_LOCK_ABS_DIF_THD                  ((0x2f4a  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockdifthd2.              lmv dif thd for third part, before locked, default = 1
//Bit    23, reserved
//Bit 22:20, reg_mcdi_lmvlockdifthd1.              lmv dif thd for second part, before locked, default = 1
//Bit    19, reserved
//Bit 18:16, reg_mcdi_lmvlockdifthd0.              lmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_lmvlockabsmax.               max abs (<) of lmv to be locked, default = 24
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_lmvlockabsmin.               min abs (>=) of lmv to be locked, default = 1
#define MCDI_LMV_LOCK_ROW                          ((0x2f4b  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_lmvlockendrow.               end row (<) for lmv lock, default = 2047
//Bit 15:11, reserved
//Bit 10: 0, reg_mcdi_lmvlockstartrow.             start row (>=) for lmv lock, default = 0
#define MCDI_LMV_LOCK_RT_MODE                      ((0x2f4c  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_lmvlockextmode.              extend lines for lmv lock check, check how many lines for lmv locking, default = 2
//Bit 23:16, reg_mcdi_lmvlockfltcntrt.             ratio of flt cnt for lock check, normalized 256 as '1', 255 is set to 256, default = 32
//Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.            ratio when use non-zero lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 48
//Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.            ratio when use max lmv for lock check, normalized 256 as '1', 255 is set to 256, default = 106
#define MCDI_GMV_LOCK_CNT_THD_GAIN                 ((0x2f4d  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_gmvlockcntmax.               max gmv lock count number, default = 6
//Bit 15:12, reg_mcdi_gmvlockcntoffst.             offset for gmv lock count, -8~7, default =  0
//Bit 11: 8, reg_mcdi_gmvlockcntgain.              gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockcntthd.               gmv count thd (>=) before be locked, 1~31, default = 4
#define MCDI_GMV_LOCK_ABS_DIF_THD                  ((0x2f4e  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:24, reg_mcdi_gmvlockdifthd2.              gmv dif thd for third part, before locked, default = 3
//Bit    23, reserved
//Bit 22:20, reg_mcdi_gmvlockdifthd1.              gmv dif thd for second part, before locked, default = 2
//Bit    19, reserved
//Bit 18:16, reg_mcdi_gmvlockdifthd0.              gmv dif thd for first part, before locked, default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_gmvlockabsmax.               max abs of gmv to be locked, default = 15
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_gmvlockabsmin.               min abs of gmv to be locked, default = 1
#define MCDI_HIGH_VERT_FRQ_DIF_THD                 ((0x2f4f  << 2) + 0xff000000)
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.     high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define MCDI_HIGH_VERT_FRQ_DIF_DIF_THD             ((0x2f50  << 2) + 0xff000000)
//Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.  high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height, set by software, default = 103680
#define MCDI_HIGH_VERT_FRQ_RT_GAIN                 ((0x2f51  << 2) + 0xff000000)
//Bit 31:20, reserved
//Bit 19:16, reg_mcdi_highvertfrqcntthd.           high_vert_frq count thd (>=) before locked, 1~31, default = 4
//Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.         ratio for high_vert_frq bad sad count, normalized 256 as '1', 255 is set to 256, default = 24
//Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.        ratio for high_vert_frq badw count, normalized 256 as '1', 255 is set to 256, default = 130
#define MCDI_MOTION_PARADOX_THD                    ((0x2f52  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:24, reg_mcdi_motionparadoxcntthd.         motion paradox count thd (>=) before locked, 1~31, default = 4
//Bit 23:22, reserved
//Bit 21:16, reg_mcdi_motionparadoxgmvthd.         abs gmv thd (<) of motion paradox, 0~32, note that 32 means invalid gmv, be careful, default = 32
//Bit 15: 0, reserved
#define MCDI_MOTION_PARADOX_RT                     ((0x2f53  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_motionparadoxbadsadrt.       ratio for field bad sad count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 24
//Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.       ratio for field bad reliability count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 120
//Bit  7: 0, reg_mcdi_motionparadoxmtnrt.          ratio for field motion count of motion paradox, normalized 256 as '1', 255 is set to 256, default = 218
#define MCDI_MOTION_REF_THD                        ((0x2f54  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:20, reg_mcdi_motionrefoffst.              motion ref additive offset, default = 15
//Bit 19:16, reg_mcdi_motionrefgain.               motion ref gain, normalized 8 as '1', default = 8
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_motionrefrptmvthd.           abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1
//Bit  7: 2, reg_mcdi_motionrefqmvthd.             min thd (>=) of abs qmv for motion ref, note that quarter mv's range is -63~63, default = 2
//Bit  1: 0, reg_mcdi_motionreflpfmode.            Mv and (8 x repeat flg) 's lpf mode of motion refinement, 0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1
#define MCDI_REL_COL_REF_RT                        ((0x2f55  << 2) + 0xff000000)
//Bit 31: 8, reserved
//Bit  7: 0, reg_mcdi_relcolrefrt.                 ratio for column confidence level against column number, for refinement, default = 135
#define MCDI_PD22_CHK_THD_RT                       ((0x2f56  << 2) + 0xff000000)
//Bit 31:27, reserved
//Bit 26:16, reg_mcdi_pd22chkfltcntrt.             ratio for flat count of field pulldown 22 check, normalized 2048 as '1', 2047 is set to 2048, default = 1
//Bit 15: 8, reg_mcdi_pd22chkcntrt.                ratio of pulldown 22 check count, normalized 256 as '1', 255 is set to 256, default = 100
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_pd22chkcntthd.               thd (>=) for pd22 count before locked, 1~31, default = 4
#define MCDI_CHAR_DET_DIF_THD                      ((0x2f57  << 2) + 0xff000000)
//Bit 31:24, reserved
//Bit 23:16, reg_mcdi_chardetminmaxdifthd.         thd (>=) for dif between min and max value, default = 64
//Bit 15: 8, reg_mcdi_chardetmaxdifthd.            thd (<) for dif between max value, default = 17
//Bit  7: 0, reg_mcdi_chardetmindifthd.            thd (<) for dif between min value, default = 17
#define MCDI_CHAR_DET_CNT_THD                      ((0x2f58  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_chardettotcntthd.            thd (>=) for total count, 0~21, default = 18
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_chardetmaxcntthd.            thd (>=) for max count, 0~21, default = 1
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_chardetmincntthd.            thd (>=) for min count, 0~21, default = 1
//new add
#define MCDI_PD_22_CHK_WND0_X                      ((0x2f59  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd0_x1                 u13, x1 for window 0, HSIZE-1, software control, default = 719
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd0_x0                 u13, x0 for window 0, software control, default = 0
#define MCDI_PD_22_CHK_WND0_Y                      ((0x2f5a  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd0_y1                 u13, y1 for window 0  software control, default = 39
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd0_y0                 u13, y0 for window 0, software control, default = 0
#define MCDI_PD_22_CHK_WND1_X                      ((0x2f5b  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd1_x1                 u13, x1 for window 1, HSIZE-1, software control, default = 719
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd1_x0                 u13, x0 for window 1, software control, default = 0
#define MCDI_PD_22_CHK_WND1_Y                      ((0x2f5c  << 2) + 0xff000000)
//Bit 31:29, reserved
//Bit 28:16, reg_mcdi_pd22chkwnd1_y1                 u13, y1 for window 1  software control, default = 199
//Bit 15:13, reserved
//Bit 12: 0, reg_mcdi_pd22chkwnd1_y0                 u13, y0 for window 1, software control, default = 40
#define MCDI_PD_22_CHK_FRC_LMV                     ((0x2f5d  << 2) + 0xff000000)
//Bit 31:11, reserved
//Bit    10, reg_mcdi_pd22chklmvchk2               u1, lmv lock check while force vof for each windows, default = 1
//Bit     9, reg_mcdi_pd22chklmvchk1               u1, lmv lock check while force vof for each windows, default = 0
//Bit     8, reg_mcdi_pd22chklmvchk0               u1, lmv lock check while force vof for each windows, default = 0
//Bit     7, reserved
//Bit     6, reg_mcdi_pd22chkfrcpd2                u1, force pd flags for each windows, default = 0
//Bit     5, reg_mcdi_pd22chkfrcpd1                u1, force pd flags for each windows, default = 0
//Bit     4, reg_mcdi_pd22chkfrcpd0                u1, force pd flags for each windows, default = 0
//Bit     3, reserved
//Bit     2, reg_mcdi_pd22chkfrcvof2               u1, force vof flags for each windows, default = 1
//Bit     1, reg_mcdi_pd22chkfrcvof1               u1, force vof flags for each windows, default = 0
//Bit     0, reg_mcdi_pd22chkfrcvof0               u1, force vof flags for each windows, default = 0
#define MCDI_PD_22_CHK_FLG_CNT                     ((0x2f5e  << 2) + 0xff000000)
//Bit 31:27, reserved.
//Bit    26, reg_mcdi_pd22chkflg2.                     pull down 22 flag of previous one field. initial = 0
//Bit    25, reg_mcdi_pd22chkflg1.                     pull down 22 flag of previous one field. initial = 0
//Bit    24, reg_mcdi_pd22chkflg.                      pull down 22 flag of previous one field. initial = 0
//Bit 23:16, reg_mcdi_pd22chkcnt2.                     pull down 22 count till previous one field. initial = 0
//Bit 15: 8, reg_mcdi_pd22chkcnt1.                     pull down 22 count till previous one field. initial = 0
//Bit  7: 0, reg_mcdi_pd22chkcnt.                      pull down 22 count till previous one field. initial = 0
#define MCDI_RO_FLD_PD_22_PRE_CNT1                 ((0x2fca  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22precnt1.              previous pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FOR_CNT1                 ((0x2fcb  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22forcnt1.              forward pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FLT_CNT1                 ((0x2fcc  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22fltcnt1.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_PRE_CNT2                 ((0x2fcd  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22precnt2.              previous pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FOR_CNT2                 ((0x2fce  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22forcnt2.              forward pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FLT_CNT2                 ((0x2fcf  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22fltcnt2.              flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define MCDI_FIELD_MV                              ((0x2f60  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_pd22chkcnt
//Bit 23:16, reg_mcdi_fieldgmvcnt
//Bit    15, reg_mcdi_pd22chkflg
//Bit    14, reg_mcdi_fieldgmvlock
//Bit 13: 8, reg_mcdi_fieldrptmv.    	           last field rpt mv
//Bit  7: 6, reserved
//Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv
#define MCDI_FIELD_HVF_PRDX_CNT                    ((0x2f61  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_motionparadoxcnt.
//Bit 23:17, reserved
//Bit    16, reg_mcdi_motionparadoxflg.
//Bit 15: 8, reg_mcdi_highvertfrqcnt.
//Bit  7: 4, reserved
//Bit  3: 2, reg_mcdi_highvertfrqphase.
//Bit     1, reserved
//Bit     0, reg_mcdi_highvertfrqflg.
#define MCDI_FIELD_LUMA_AVG_SUM_0                  ((0x2f62  << 2) + 0xff000000)
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum0.
#define MCDI_FIELD_LUMA_AVG_SUM_1                  ((0x2f63  << 2) + 0xff000000)
//Bit 31: 0, reg_mcdi_fld_luma_avg_sum1.
#define MCDI_YCBCR_BLEND_CRTL                      ((0x2f64  << 2) + 0xff000000)
//Bit 31:16, reserved
//Bit 15: 8, reg_mcdi_ycbcrblendgain.              ycbcr blending gain for cbcr in ycbcr. default = 0
//Bit  7: 2, reserved.
//Bit  1: 0, reg_mcdi_ycbcrblendmode.              0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2
#define MCDI_MCVECWR_CANVAS_SIZE                   ((0x2f65  << 2) + 0xff000000)
#define MCDI_MCVECRD_CANVAS_SIZE                   ((0x2f66  << 2) + 0xff000000)
#define MCDI_MCINFOWR_CANVAS_SIZE                  ((0x2f67  << 2) + 0xff000000)
#define MCDI_MCINFORD_CANVAS_SIZE                  ((0x2f68  << 2) + 0xff000000)
#define MCDI_MCVECWR_X                             ((0x2f92  << 2) + 0xff000000)
#define MCDI_MCVECWR_Y                             ((0x2f93  << 2) + 0xff000000)
#define MCDI_MCVECWR_CTRL                          ((0x2f94  << 2) + 0xff000000)
#define MCDI_MCVECRD_X                             ((0x2f95  << 2) + 0xff000000)
#define MCDI_MCVECRD_Y                             ((0x2f96  << 2) + 0xff000000)
#define MCDI_MCVECRD_CTRL                          ((0x2f97  << 2) + 0xff000000)
#define MCDI_MCINFOWR_X                            ((0x2f98  << 2) + 0xff000000)
#define MCDI_MCINFOWR_Y                            ((0x2f99  << 2) + 0xff000000)
#define MCDI_MCINFOWR_CTRL                         ((0x2f9a  << 2) + 0xff000000)
#define MCDI_MCINFORD_X                            ((0x2f9b  << 2) + 0xff000000)
#define MCDI_MCINFORD_Y                            ((0x2f9c  << 2) + 0xff000000)
#define MCDI_MCINFORD_CTRL                         ((0x2f9d  << 2) + 0xff000000)
#define MCDI_LMVLCKSTEXT_0                         ((0x2f69  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:16, mcdi_lmvlckstext_1                    lmv lck blog 1 line start
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckstext_0                    lmv lck blog 0 line start
#define MCDI_LMVLCKSTEXT_1                         ((0x2f6a  << 2) + 0xff000000)
//Bit 31   , mcdi_refnewmode                       new ref me mv array order
//Bit 30   , mcdi_ref_lmv_lck_en                   use locked line mvs for ref
//Bit 29:28, mcdi_lmvlckupdw_ext                   up/down extend lines for locked lmv line's
//Bit 27:12, mcdi_lmvlckmin                        lmv lck blog height limit
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckstext_2                    lmv lck blog 2 line start
#define MCDI_LMVLCKEDEXT_0                         ((0x2f6b  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:16, mcdi_lmvlckedext_1                    lmv lck blog 1 line end
//Bit 15:12, reserved
//Bit 11: 0, mcdi_lmvlckedext_0                    lmv lck blog 0 line end
#define MCDI_LMVLCKEDEXT_1                         ((0x2f6c  << 2) + 0xff000000)
//Bit 31:12, reserved
//Bit 11: 0, mcdi_lmvlckedext_2                    lmv lck blog 2 line end
// ================================================================== MC registers ========================================================================================================
#define MCDI_MC_CRTL                               ((0x2f70  << 2) + 0xff000000)
//Bit 31: 9, reserved
//Bit     8, reg_mcdi_mcpreflg.                    flag to use previous field for MC, 0:forward field, 1: previous field, default = 1
//Bit     7, reg_mcdi_mcrelrefbycolcfden.          enable rel refinement by column confidence in mc blending, default = 1
//Bit  6: 5, reg_mcdi_mclpfen.                     enable mc pixles/rel lpf, 0:disable, 1: lpf rel, 2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0
//Bit  4: 2, reg_mcdi_mcdebugmode.                 enable mc debug mode, 0:disable, 1: split left/right, 2: split top/bottom, 3: debug mv, 4: debug rel, default = 0
//Bit  1: 0, reg_mcdi_mcen.                        mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1
#define MCDI_MC_LPF_MSK_0                          ((0x2f71  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk02.                  mc lpf coef. 2 for pixel 0 of current block, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk01.                  mc lpf coef. 1 for pixel 0 of current block, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk00.                  mc lpf coef. 0 for pixel 0 of current block, normalized 16 as '1', default = 7
#define MCDI_MC_LPF_MSK_1                          ((0x2f72  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk12.                  mc lpf coef. 2 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 0
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk11.                  mc lpf coef. 1 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk10.                  mc lpf coef. 0 for pixel 1 of current block, 0~16, normalized 16 as '1', default = 5
#define MCDI_MC_LPF_MSK_2                          ((0x2f73  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk22.                  mc lpf coef. 2 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk21.                  mc lpf coef. 1 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 14
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk20.                  mc lpf coef. 0 for pixel 2 of current block, 0~16, normalized 16 as '1', default = 1
#define MCDI_MC_LPF_MSK_3                          ((0x2f74  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk32.                  mc lpf coef. 2 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 5
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk31.                  mc lpf coef. 1 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 11
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk30.                  mc lpf coef. 0 for pixel 3 of current block, 0~16, normalized 16 as '1', default = 0
#define MCDI_MC_LPF_MSK_4                          ((0x2f75  << 2) + 0xff000000)
//Bit 31:21, reserved
//Bit 20:16, reg_mcdi_mclpfmsk42.                  mc lpf coef. 2 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 7
//Bit 15:13, reserved
//Bit 12: 8, reg_mcdi_mclpfmsk41.                  mc lpf coef. 1 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 9
//Bit  7: 5, reserved
//Bit  4: 0, reg_mcdi_mclpfmsk40.                  mc lpf coef. 0 for pixel 4 of current block, 0~16, normalized 16 as '1', default = 0
#define MCDI_MC_REL_GAIN_OFFST_0                   ((0x2f76  << 2) + 0xff000000)
//Bit 31:26, reserved
//Bit    25, reg_mcdi_mcmotionparadoxflg.          flag of motion paradox, initial with 0 and read from software, default = 0
//Bit    24, reg_mcdi_mchighvertfrqflg.            flag of high vert frq, initial with 0 and read from software, default = 0
//Bit 23:16, reg_mcdi_mcmotionparadoxoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 128
//Bit 15:12, reserved
//Bit 11: 8, reg_mcdi_mcmotionparadoxgain.         gain for rel (MC blending coef.) refinement if motion paradox detected before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset (alpha - offset) for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, default = 15
//Bit  3: 0, reg_mcdi_mchighvertfrqgain.           gain for motion (MA blending coef.) refinement if high vertical frequency detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8
#define MCDI_MC_REL_GAIN_OFFST_1                   ((0x2f77  << 2) + 0xff000000)
//Bit 31:24, reg_mcdi_mcoutofboundrayoffst.        offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending before MC blending, default = 255
//Bit 23:20, reserved
//Bit 19:16, reg_mcdi_mcoutofboundraygain.         gain for rel (MC blending coef.) refinement if MC pointed out of boundray before MC blending, normalized 8 as '1', set 15 to 16, default = 8
//Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.       offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox detected before MC blending before MC blending, default = 255
//Bit  7: 4, reserved.
//Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.        gain for rel (MC blending coef.) refinement if column confidence failed before MC blending, normalized 8 as '1', set 15 to 16, default = 8
#define MCDI_MC_COL_CFD_0                          ((0x2f78  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_0.                    column confidence value 0 read from software. initial = 0
#define MCDI_MC_COL_CFD_1                          ((0x2f79  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_1.                    column confidence value 1 read from software. initial = 0
#define MCDI_MC_COL_CFD_2                          ((0x2f7a  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_2.                    column confidence value 2 read from software. initial = 0
#define MCDI_MC_COL_CFD_3                          ((0x2f7b  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_3.                    column confidence value 3 read from software. initial = 0
#define MCDI_MC_COL_CFD_4                          ((0x2f7c  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_4.                    column confidence value 4 read from software. initial = 0
#define MCDI_MC_COL_CFD_5                          ((0x2f7d  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_5.                    column confidence value 5 read from software. initial = 0
#define MCDI_MC_COL_CFD_6                          ((0x2f7e  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_6.                    column confidence value 6 read from software. initial = 0
#define MCDI_MC_COL_CFD_7                          ((0x2f7f  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_7.                    column confidence value 7 read from software. initial = 0
#define MCDI_MC_COL_CFD_8                          ((0x2f80  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_8.                    column confidence value 8 read from software. initial = 0
#define MCDI_MC_COL_CFD_9                          ((0x2f81  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_9.                    column confidence value 9 read from software. initial = 0
#define MCDI_MC_COL_CFD_10                         ((0x2f82  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_10.                   column confidence value 10 read from software. initial = 0
#define MCDI_MC_COL_CFD_11                         ((0x2f83  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_11.                   column confidence value 11 read from software. initial = 0
#define MCDI_MC_COL_CFD_12                         ((0x2f84  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_12.                   column confidence value 12 read from software. initial = 0
#define MCDI_MC_COL_CFD_13                         ((0x2f85  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_13.                   column confidence value 13 read from software. initial = 0
#define MCDI_MC_COL_CFD_14                         ((0x2f86  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_14.                   column confidence value 14 read from software. initial = 0
#define MCDI_MC_COL_CFD_15                         ((0x2f87  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_15.                   column confidence value 15 read from software. initial = 0
#define MCDI_MC_COL_CFD_16                         ((0x2f88  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_16.                   column confidence value 16 read from software. initial = 0
#define MCDI_MC_COL_CFD_17                         ((0x2f89  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_17.                   column confidence value 17 read from software. initial = 0
#define MCDI_MC_COL_CFD_18                         ((0x2f8a  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_18.                   column confidence value 18 read from software. initial = 0
#define MCDI_MC_COL_CFD_19                         ((0x2f8b  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_19.                   column confidence value 19 read from software. initial = 0
#define MCDI_MC_COL_CFD_20                         ((0x2f8c  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_20.                   column confidence value 20 read from software. initial = 0
#define MCDI_MC_COL_CFD_21                         ((0x2f8d  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_21.                   column confidence value 21 read from software. initial = 0
#define MCDI_MC_COL_CFD_22                         ((0x2f8e  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_22.                   column confidence value 22 read from software. initial = 0
#define MCDI_MC_COL_CFD_23                         ((0x2f8f  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_23.                   column confidence value 23 read from software. initial = 0
#define MCDI_MC_COL_CFD_24                         ((0x2f90  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_24.                   column confidence value 24 read from software. initial = 0
#define MCDI_MC_COL_CFD_25                         ((0x2f91  << 2) + 0xff000000)
//Bit 31: 0, mcdi_mc_col_cfd_25.                   column confidence value 25 read from software. initial = 0
// ===================================================================================== PRE RO Registers ==========================================================================================
#define MCDI_RO_FLD_LUMA_AVG_SUM                   ((0x2fa0  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldlumaavgsum.                block's luma avg sum of current filed (block based). initial = 0
#define MCDI_RO_GMV_VLD_CNT                        ((0x2fa1  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_gmvvldcnt.                    valid gmv's count of pre one filed (block based). initial = 0
#define MCDI_RO_RPT_FLG_CNT                        ((0x2fa2  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_rptflgcnt.                    repeat mv's count of pre one filed (block based). initial = 0
#define MCDI_RO_FLD_BAD_SAD_CNT                    ((0x2fa3  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldbadsadcnt.                 bad sad count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_BAD_BADW_CNT                   ((0x2fa4  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldbadbadwcnt.                bad badw count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_BAD_REL_CNT                    ((0x2fa5  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldbadrelcnt.                 bad rel count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_MTN_CNT                        ((0x2fa6  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldmtncnt.                    motion count of whole pre one field (pixel based). initial = 0
#define MCDI_RO_FLD_VLD_CNT                        ((0x2fa7  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldvldcnt.                    valid motion count of whole pre one field (pixel based). initial = 0
#define MCDI_RO_FLD_PD_22_PRE_CNT                  ((0x2fa8  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22precnt.                previous pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FOR_CNT                  ((0x2fa9  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22forcnt.                forward pd22 check count of whole pre one field (block based). initial = 0
#define MCDI_RO_FLD_PD_22_FLT_CNT                  ((0x2faa  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_fldpd22fltcnt.                flat count (for pd22 check) of whole pre one field (block based). initial = 0
#define MCDI_RO_HIGH_VERT_FRQ_FLG                  ((0x2fab  << 2) + 0xff000000)
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_highvertfrqcnt.               high vertical frequency count till previous one field. initial = 0
//Bit  7: 3, reserved.
//Bit  2: 1, ro_mcdi_highvertfrqphase.             high vertical frequency phase of previous one field. initial = 2
//Bit     0, ro_mcdi_highvertfrqflg.               high vertical frequency flag of previous one field. initial = 0
#define MCDI_RO_GMV_LOCK_FLG                       ((0x2fac  << 2) + 0xff000000)
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_gmvlckcnt.                    global mv lock count till previous one field. initial = 0
//Bit  7: 2, ro_mcdi_gmv.                          global mv of previous one field. -31~31, initial = 32 (invalid value)
//Bit     1, ro_mcdi_zerogmvlckflg.                zero global mv lock flag of previous one field. initial = 0
//Bit     0, ro_mcdi_gmvlckflg.                    global mv lock flag of previous one field. initial = 0
#define MCDI_RO_RPT_MV                             ((0x2fad  << 2) + 0xff000000)
//Bit 5: 0, ro_mcdi_rptmv.                         repeate mv of previous one field. -31~31, initial = 32 (invalid value)
#define MCDI_RO_MOTION_PARADOX_FLG                 ((0x2fae  << 2) + 0xff000000)
//Bit 31:16, reserved.
//Bit 15: 8, ro_mcdi_motionparadoxcnt.             motion paradox count till previous one field. initial = 0
//Bit  7: 1, reserved.
//Bit     0, ro_mcdi_motionparadoxflg.             motion paradox flag of previous one field. initial = 0
#define MCDI_RO_PD_22_FLG                          ((0x2faf  << 2) + 0xff000000)
//Bit 31:27, reserved.
//Bit    26, ro_mcdi_pd22flg2.                     pull down 22 flag of previous one field. initial = 0
//Bit    25, ro_mcdi_pd22flg1.                     pull down 22 flag of previous one field. initial = 0
//Bit    24, ro_mcdi_pd22flg.                      pull down 22 flag of previous one field. initial = 0
//Bit 23:16, ro_mcdi_pd22cnt2.                     pull down 22 count till previous one field. initial = 0
//Bit 15: 8, ro_mcdi_pd22cnt1.                     pull down 22 count till previous one field. initial = 0
//Bit  7: 0, ro_mcdi_pd22cnt.                      pull down 22 count till previous one field. initial = 0
#define MCDI_RO_COL_CFD_0                          ((0x2fb0  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_0.                    column confidence value 0. initial = 0
#define MCDI_RO_COL_CFD_1                          ((0x2fb1  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_1.                    column confidence value 1. initial = 0
#define MCDI_RO_COL_CFD_2                          ((0x2fb2  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_2.                    column confidence value 2. initial = 0
#define MCDI_RO_COL_CFD_3                          ((0x2fb3  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_3.                    column confidence value 3. initial = 0
#define MCDI_RO_COL_CFD_4                          ((0x2fb4  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_4.                    column confidence value 4. initial = 0
#define MCDI_RO_COL_CFD_5                          ((0x2fb5  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_5.                    column confidence value 5. initial = 0
#define MCDI_RO_COL_CFD_6                          ((0x2fb6  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_6.                    column confidence value 6. initial = 0
#define MCDI_RO_COL_CFD_7                          ((0x2fb7  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_7.                    column confidence value 7. initial = 0
#define MCDI_RO_COL_CFD_8                          ((0x2fb8  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_8.                    column confidence value 8. initial = 0
#define MCDI_RO_COL_CFD_9                          ((0x2fb9  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_9.                    column confidence value 9. initial = 0
#define MCDI_RO_COL_CFD_10                         ((0x2fba  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_10.                   column confidence value 10. initial = 0
#define MCDI_RO_COL_CFD_11                         ((0x2fbb  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_11.                   column confidence value 11. initial = 0
#define MCDI_RO_COL_CFD_12                         ((0x2fbc  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_12.                   column confidence value 12. initial = 0
#define MCDI_RO_COL_CFD_13                         ((0x2fbd  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_13.                   column confidence value 13. initial = 0
#define MCDI_RO_COL_CFD_14                         ((0x2fbe  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_14.                   column confidence value 14. initial = 0
#define MCDI_RO_COL_CFD_15                         ((0x2fbf  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_15.                   column confidence value 15. initial = 0
#define MCDI_RO_COL_CFD_16                         ((0x2fc0  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_16.                   column confidence value 16. initial = 0
#define MCDI_RO_COL_CFD_17                         ((0x2fc1  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_17.                   column confidence value 17. initial = 0
#define MCDI_RO_COL_CFD_18                         ((0x2fc2  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_18.                   column confidence value 18. initial = 0
#define MCDI_RO_COL_CFD_19                         ((0x2fc3  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_19.                   column confidence value 19. initial = 0
#define MCDI_RO_COL_CFD_20                         ((0x2fc4  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_20.                   column confidence value 20. initial = 0
#define MCDI_RO_COL_CFD_21                         ((0x2fc5  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_21.                   column confidence value 21. initial = 0
#define MCDI_RO_COL_CFD_22                         ((0x2fc6  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_22.                   column confidence value 22. initial = 0
#define MCDI_RO_COL_CFD_23                         ((0x2fc7  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_23.                   column confidence value 23. initial = 0
#define MCDI_RO_COL_CFD_24                         ((0x2fc8  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_24.                   column confidence value 24. initial = 0
#define MCDI_RO_COL_CFD_25                         ((0x2fc9  << 2) + 0xff000000)
//Bit 31: 0, ro_mcdi_col_cfd_25.                   column confidence value 25. initial = 0
// add space 8'hd0-8'hef
//
// Reading file:  ./dipd_regs.h
//
// synopsys translate_off
// synopsys translate_on
// using 8'he0-8'hef
#define DIPD_COMB_CTRL0                            ((0x2fd0  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl0
#define DIPD_COMB_CTRL1                            ((0x2fd1  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl1
#define DIPD_COMB_CTRL2                            ((0x2fd2  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl2
#define DIPD_COMB_CTRL3                            ((0x2fd3  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl3
#define DIPD_COMB_CTRL4                            ((0x2fd4  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl4
#define DIPD_COMB_CTRL5                            ((0x2fd5  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl5
#define DIPD_RO_COMB_0                             ((0x2fd6  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_0
#define DIPD_RO_COMB_1                             ((0x2fd7  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_1
#define DIPD_RO_COMB_2                             ((0x2fd8  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_2
#define DIPD_RO_COMB_3                             ((0x2fd9  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_3
#define DIPD_RO_COMB_4                             ((0x2fda  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_4
#define DIPD_RO_COMB_5                             ((0x2fdb  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_5
#define DIPD_RO_COMB_6                             ((0x2fdc  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_6
#define DIPD_RO_COMB_7                             ((0x2fdd  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_7
#define DIPD_RO_COMB_8                             ((0x2fde  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_8
#define DIPD_RO_COMB_9                             ((0x2fdf  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_9
#define DIPD_RO_COMB_10                            ((0x2fe0  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_10
#define DIPD_RO_COMB_11                            ((0x2fe1  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_11
#define DIPD_RO_COMB_12                            ((0x2fe2  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_12
#define DIPD_RO_COMB_13                            ((0x2fe3  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_13
#define DIPD_RO_COMB_14                            ((0x2fe4  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_14
#define DIPD_RO_COMB_15                            ((0x2fe5  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_15
#define DIPD_RO_COMB_16                            ((0x2fe6  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_16
#define DIPD_RO_COMB_17                            ((0x2fe7  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_17
#define DIPD_RO_COMB_18                            ((0x2fe8  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_18
#define DIPD_RO_COMB_19                            ((0x2fe9  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_19
#define DIPD_RO_COMB_20                            ((0x2fea  << 2) + 0xff000000)
//Bit 31:0,								ro_pd_comb_20
#define DIPD_COMB_CTRL6                            ((0x2feb  << 2) + 0xff000000)
//Bit 31:0,								reg_pd_comb_ctrl6
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dipd_regs.h
//
// addr space 8'hf0-8'hff
//
// Reading file:  ./nr3_tnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR3_MODE                                   ((0x2ff0  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5           reg_nr3_vtxt_mode         // unsigned , default = 0  0: avg; 1:MAX
//Bit  4           reg_3dnr_nr3_cbyy_ignore_coop    // unsigned , default = 0  ignore coop condition for cbyy motion decision
//Bit  3           reg_3dnr_nr3_ybyc_ignore_cnoop   // unsigned , default = 0  ignore cnoop condition for ybyc motion decision
//Bit  2: 0        reg_3dnr_nr3_suremot_txt_mode   // unsigned , default = 3  0: cur, 1:p2; 2: (cur+p2)/2; 3/up: min(cur,p2)
#define NR3_COOP_PARA                              ((0x2ff1  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:20        reg_3dnr_nr3_coop_mode    // unsigned , default = 2  0 original pixel 1: [1 2 1]/4 lpf; 2: [1 2 2 2 1]/8; 3: 3x3 lpf
//Bit 19:16        reg_3dnr_nr3_coop_ratio    // unsigned , default = 8  cur and p2 color oop decision ratio:  (avg1<(dif1*ratio/8 + ofst));
//Bit 15: 8        reg_3dnr_nr3_coop_ofset    // signed , default = -1  cur and p2 color oop decision ofst:  (avg1<(dif1*ratio/8 + ofst));
//Bit  7: 0        reg_3dnr_nr3_coop_sat_thrd // unsigned , default = 0  cur and p2 color oop decision min(sat0,sat1) threshold;
#define NR3_CNOOP_GAIN                             ((0x2ff2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_3dnr_nr3_cnoop_ratio0   // unsigned , default = 8  cur and p2 color noop decision ratio0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
//Bit 19:16        reg_3dnr_nr3_cnoop_ratio1   // unsigned , default = 8  cur and p2 color noop decision ratio1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
//Bit 15: 8        reg_3dnr_nr3_cnoop_ofset0   // signed , default = 25  cur and p2 color noop decision ofset0:  (avg1<(MAX(sat0,sat2)*ratio0/8 + ofst0));
//Bit  7: 0        reg_3dnr_nr3_cnoop_ofset1   // signed , default = 0  cur and p2 color noop decision ofset1:  (dif1<(MIN(sat0,sat2)*ratio1/8 + ofst1));
#define NR3_YMOT_PARA                              ((0x2ff3  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_3dnr_nr3_ymot_only_en  // unsigned , default = 1  enable signal for ignore chroma motion: (ytxt &coop)
//Bit 18           reg_3dnr_nr3_ymot_only_cmtmode  // unsigned , default = 1  0: cmot=ymot; 1: cmot = MIN(ymot, cmot)
//Bit 17:16        reg_3dnr_nr3_ymot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15: 8        reg_3dnr_nr3_ymot_only_txtthrd  // unsigned , default = 10  threshold to luma texture to decide use ymot only
//Bit  7: 0        reg_3dnr_nr3_ymot_only_motthrd  // unsigned , default = 30  threshold to luma motion to decide use ymot only
#define NR3_CMOT_PARA                              ((0x2ff4  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_3dnr_nr3_cmot_only_en  // unsigned , default = 1  enable signal for ignore luma motion: (ctxt &cnoop)
//Bit 18           reg_3dnr_nr3_cmot_only_ymtmode  // unsigned , default = 0  0: ymot=cmot+ymot/4; 1: ymot = MIN(ymot, cmot)
//Bit 17:16        reg_3dnr_nr3_cmot_only_txtmode  // unsigned , default = 0  0, min(txt0,txt2); 1, max(txt0,txt2);2, (txt0+txt2)/2; 3: sat(txt0, txt2)
//Bit 15: 8        reg_3dnr_nr3_cmot_only_txtthrd  // unsigned , default = 20  threshold to chroma texture to decide use cmot only
//Bit  7: 0        reg_3dnr_nr3_cmot_only_motthrd  // unsigned , default = 15  threshold to chroma motion to decide use cmot only
#define NR3_SUREMOT_YGAIN                          ((0x2ff5  << 2) + 0xff000000)
//Bit 31:24        reg_3dnr_nr3_suremot_dec_yrate  // unsigned , default = 16  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16        reg_3dnr_nr3_suremot_dec_yofst  // unsigned , default = 12   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15: 8        reg_3dnr_nr3_suremot_frc_ygain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7: 0        reg_3dnr_nr3_suremot_frc_yofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
#define NR3_SUREMOT_CGAIN                          ((0x2ff6  << 2) + 0xff000000)
//Bit 31:24        reg_3dnr_nr3_suremot_dec_crate  // unsigned , default = 34  (norm 16)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 23:16        reg_3dnr_nr3_suremot_dec_cofst  // unsigned , default = 38   lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit 15: 8        reg_3dnr_nr3_suremot_frc_cgain  // unsigned , default = 64  (norm 8)lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
//Bit  7: 0        reg_3dnr_nr3_suremot_frc_cofst  // unsigned , default = 20  lpfMot>(dec_rate*txt +ofst) then force lpfMot*frc_gain+frc_ofset
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./nr3_tnr_regs.h
//
#define LBUF_TOP_CTRL                              ((0x2fff  << 2) + 0xff000000)
//bit 23:22   mode_444c422
//bit 21:20   mode_422c444
//bit 17      lbuf_fmt444_mode
//bit 16      lbuf_line5_mode
//bit 12:0    pre_lbuf_size
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mcdi_regs.h
//
//===========================================================================
// VPU_VLOCK register    (16'h3000 - 16'h30ff)
//===========================================================================
//
// Reading file:  ./vpu_vlock_reg.h
//
// synopsys translate_off
// synopsys translate_on
// ----------------------------
// VPU_VLOCK 0x30
// ----------------------------
// -----------------------------------------------
// REG_BASE:  VPU_VLOCK_VCBUS_BASE = 0x30
// -----------------------------------------------
#define VPU_VLOCK_CTRL                             ((0x3000  << 2) + 0xff000000)
#define VPU_VLOCK_MISC_CTRL                        ((0x3001  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP0_ACCUM_LMT                  ((0x3002  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP0_CTRL0                      ((0x3003  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_CTRL0                      ((0x3004  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_IMISSYNC_MAX               ((0x3005  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_IMISSYNC_MIN               ((0x3006  << 2) + 0xff000000)
#define VPU_VLOCK_OVWRITE_ACCUM0                   ((0x3007  << 2) + 0xff000000)
#define VPU_VLOCK_OVWRITE_ACCUM1                   ((0x3008  << 2) + 0xff000000)
#define VPU_VLOCK_OUTPUT0_CAPT_LMT                 ((0x3009  << 2) + 0xff000000)
#define VPU_VLOCK_OUTPUT0_PLL_LMT                  ((0x300a  << 2) + 0xff000000)
#define VPU_VLOCK_OUTPUT1_CAPT_LMT                 ((0x300b  << 2) + 0xff000000)
#define VPU_VLOCK_OUTPUT1_PLL_LMT                  ((0x300c  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_PHSDIF_TGT                 ((0x300d  << 2) + 0xff000000)
#define VPU_VLOCK_RO_LOOP0_ACCUM                   ((0x300e  << 2) + 0xff000000)
#define VPU_VLOCK_RO_LOOP1_ACCUM                   ((0x300f  << 2) + 0xff000000)
#define VPU_VLOCK_OROW_OCOL_MAX                    ((0x3010  << 2) + 0xff000000)
#define VPU_VLOCK_RO_VS_I_DIST                     ((0x3011  << 2) + 0xff000000)
#define VPU_VLOCK_RO_VS_O_DIST                     ((0x3012  << 2) + 0xff000000)
#define VPU_VLOCK_RO_LINE_PIX_ADJ                  ((0x3013  << 2) + 0xff000000)
#define VPU_VLOCK_RO_OUTPUT_00_01                  ((0x3014  << 2) + 0xff000000)
#define VPU_VLOCK_RO_OUTPUT_10_11                  ((0x3015  << 2) + 0xff000000)
#define VPU_VLOCK_MX4096                           ((0x3016  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_WIN0_WIN1                 ((0x3017  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_CLP                       ((0x3018  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_ABS_WIN0                  ((0x3019  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_ABS_WIN1                  ((0x301a  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_SGN_WIN0                  ((0x301b  << 2) + 0xff000000)
#define VPU_VLOCK_STBDET_SGN_WIN1                  ((0x301c  << 2) + 0xff000000)
#define VPU_VLOCK_ADJ_EN_SYNC_CTRL                 ((0x301d  << 2) + 0xff000000)
#define VPU_VLOCK_GCLK_EN                          ((0x301e  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_ACCUM_LMT                  ((0x301f  << 2) + 0xff000000)
#define VPU_VLOCK_RO_M_INT_FRAC                    ((0x3020  << 2) + 0xff000000)
#define VPU_VLOCK_RO_PH_DIS                        ((0x3021  << 2) + 0xff000000)
#define VPU_VLOCK_RO_PH_ERR                        ((0x3022  << 2) + 0xff000000)
#define VPU_VLOCK_LOCK_TH                          ((0x3023  << 2) + 0xff000000)
#define VPU_VLOCK_RO_LCK_FRM                       ((0x3024  << 2) + 0xff000000)
#define VPU_VLOCK_WIN0_TH                          ((0x3025  << 2) + 0xff000000)
#define VPU_VLOCK_WIN0_RATIO                       ((0x3026  << 2) + 0xff000000)
#define VPU_VLOCK_WIN0_FILTER_CNTL                 ((0x3027  << 2) + 0xff000000)
#define VPU_VLOCK_WIN1_TH                          ((0x3028  << 2) + 0xff000000)
#define VPU_VLOCK_WIN1_RATIO                       ((0x3029  << 2) + 0xff000000)
#define VPU_VLOCK_WIN1_FILTER_CNTL                 ((0x302a  << 2) + 0xff000000)
#define VPU_VLOCK_LOCK_TH1                         ((0x302b  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP0_ERR_LMT                    ((0x302c  << 2) + 0xff000000)
#define VPU_VLOCK_LOOP1_ERR_LMT                    ((0x302d  << 2) + 0xff000000)
#define VPU_VLOCK_ERR_CTRL0                        ((0x302e  << 2) + 0xff000000)
#define VPU_VLOCK_RO_VS_O_ABS_CNT_LSB              ((0x302f  << 2) + 0xff000000)
#define VPU_VLOCK_RO_VS_I_ABS_CNT_LSB              ((0x3030  << 2) + 0xff000000)
#define VPU_VLOCK_RO_VS_ABS_CNT_MSB                ((0x3031  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_vlock_reg.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpp_partb_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPPB_VCBUS_BASE = 0x31
// -----------------------------------------------
////=================================================================////
//// vkeystone
////=================================================================////
// 8'h00-8'h17
//
// Reading file:  ./vkstone_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VKS_CTRL                                   ((0x3100  << 2) + 0xff000000)
//Bit 31           reg_vks_en                // unsigned , default = 1  enable signal of the vks function
//Bit 30           reg_vks_scl_mode0         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
//Bit 29           reg_vks_scl_mode1         // unsigned , default = 1  : b0 mode of vks ofset mode, 0: offset= offset; 1: offset= offset*step= ofset/scale;
//Bit 28           reg_vks_fill_mode         // unsigned , default = 1  mode of out-of-boundary fill, 0 extension, 1: fill with the fill_value
//Bit 27:26        reg_vks_row_inp_mode      // unsigned , default = 1  , interpolation mode from 16pieces ofset/step to each line ofset and step; 0: linear interpolation; 1: cubic interpolation (using ccoef)
//Bit 25           reg_vks_border_ext_mode0  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extrapolate the border one
//Bit 24           reg_vks_border_ext_mode1  // unsigned , default = 0  , extend mode of the border data of luma and chroma, 0: copy the most border one; 1: extrapolate the border one
//Bit 23           reg_vks_obuf_mode0        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
//Bit 22           reg_vks_obuf_mode1        // unsigned , default = 1  , mode of output buffer left/right side. 0: no precalculate active pixels during output fill region; 1: precaclc active pixels during output fill regions
//Bit 21:20        reg_vks_obuf_mrgn0        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
//Bit 19:18        reg_vks_obuf_mrgn1        // unsigned , default = 3  , margin pixels for left right most active pixel to the fill pixels to avoid jump
//Bit 17:16        reg_vks_phs_qmode         // unsigned , default = 2  , interpolation mode of the phase, 0: floor to 1/64 phase; 1: round to 1/64 phase; 2/3 linear intp
//Bit 15: 0        reg_vks_row_scl           // unsigned , default = 11651  , scale of row to make it fit to the 16 pieces, scl = (2^23)/RowMax
#define VKS_OUT_WIN_SIZE                           ((0x3101  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_vks_ocolmax           // unsigned , default = 1280  output outer window col number, decided by the projector
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_orowmax           // unsigned , default = 720  output outer window row number, decided by the projector
#define VKS_PRELPF_YCOEF0                          ((0x3102  << 2) + 0xff000000)
//Bit 31:24        reg_vks_prelpf_ycoef0     // signed , default = -128  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit 23:16        reg_vks_prelpf_ycoef1     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit 15: 8        reg_vks_prelpf_ycoef2     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ycoef3     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
#define VKS_PRELPF_YCOEF1                          ((0x3103  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_vks_prelpf_ycoef4     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ycoef5     // signed , default = 0  coef of horizontal luma prelpf for Keystone, normalized 128 as '1'
#define VKS_PRELPF_CCOEF0                          ((0x3104  << 2) + 0xff000000)
//Bit 31:24        reg_vks_prelpf_ccoef0     // signed , default = -128  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit 23:16        reg_vks_prelpf_ccoef1     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit 15: 8        reg_vks_prelpf_ccoef2     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ccoef3     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
#define VKS_PRELPF_CCOEF1                          ((0x3105  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_vks_prelpf_ccoef4     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
//Bit  7: 0        reg_vks_prelpf_ccoef5     // signed , default = 0  mode of horizontal chroma prelpf for Keystone, normalized 128 as '1'
#define VKS_FILL_VAL                               ((0x3106  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_vks_fill_value0       // unsigned , default = 0  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
//Bit 15: 8        reg_vks_fill_value1       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
//Bit  7: 0        reg_vks_fill_value2       // unsigned , default = 128  , border fill color define. yuv: [0 128 128];   rgb:[0 0 0]
#define VKS_IWIN_HSIZE                             ((0x3107  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_vks_iwinx0            // unsigned , default = 160  , input start-col and end-col;
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_iwinx1            // unsigned , default = 1279  , input start-col and end-col;
#define VKS_IWIN_VSIZE                             ((0x3108  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_vks_iwiny0            // unsigned , default = 0  , input start-row and end-row;
//Bit 15:14        reserved
//Bit 13: 0        reg_vks_iwiny1            // unsigned , default = 719  , input start-row and end-row;
#define VKS_TOP_MISC                               ((0x3109  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18           reg_flt_en                // unsigned , default = 1
//Bit 17           reg_frm_rst               // unsigned , default = 0
//Bit 16           reg_ctrl_sync             // unsigned , default = 0
//Bit 15: 8        blank_num                 // unsigned , default = 4
//Bit  7: 0        flt_blank_num             // unsigned , default = 9
#define VKS_START_CTRL                             ((0x310a  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16           reg_vks_en_mode           // unsigned , default = 0
//Bit 15: 0        reg_hold_phnum            // unsigned , default = 5
#define VKS_LBUF_SIZE                              ((0x310b  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_lbuf_depth            // unsigned , default = 1024
#define VKS_PARA_ADDR_PORT                         ((0x310e  << 2) + 0xff000000)
#define VKS_PARA_DATA_PORT                         ((0x310f  << 2) + 0xff000000)

    #define VKS_SCL_OFSET00                        0x9  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset0        // unsigned , default = 118534  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET01                        0xa  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset1        // unsigned , default = 111450  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET02                        0xb  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset2        // unsigned , default = 104366  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET03                        0xc  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset3        // unsigned , default = 97283  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET04                        0xd  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset4        // unsigned , default = 90199  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET05                        0xe  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset5        // unsigned , default = 83115  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET06                        0xf  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset6        // unsigned , default = 76031  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET07                       0x10  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset7        // unsigned , default = 68947  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET08                       0x11  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset8        // unsigned , default = 61864  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET09                       0x12  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset9        // unsigned , default = 54780  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET10                       0x13  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset10       // unsigned , default = 47696  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET11                       0x14  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset11       // unsigned , default = 40612  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET12                       0x15  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset12       // unsigned , default = 33528  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET13                       0x16  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset13       // unsigned , default = 26444  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET14                       0x17  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset14       // unsigned , default = 19361  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET15                       0x18  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset15       // unsigned , default = 12277  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_OFSET16                       0x19  //
//Bit 31:20        reserved
//Bit 19: 0        reg_vks_scl_ofset16       // unsigned , default = 5193  , left offset of the input pixel offset from left, 12.8 12bits pixel + 8bits float phase
    #define VKS_SCL_STEP00                        0x1a  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step0         // unsigned , default = 331378  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP01                        0x1b  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step1         // unsigned , default = 383191  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP02                        0x1c  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step2         // unsigned , default = 435004  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP03                        0x1d  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step3         // unsigned , default = 486818  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP04                        0x1e  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step4         // unsigned , default = 538631  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP05                        0x1f  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step5         // unsigned , default = 590444  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP06                        0x20  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step6         // unsigned , default = 642257  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP07                        0x21  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step7         // unsigned , default = 694070  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP08                        0x22  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step8         // unsigned , default = 745884  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP09                        0x23  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step9         // unsigned , default = 797697  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP10                        0x24  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step10        // unsigned , default = 849510  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP11                        0x25  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step11        // unsigned , default = 901323  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP12                        0x26  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step12        // unsigned , default = 953136  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP13                        0x27  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step13        // unsigned , default = 1004949  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP14                        0x28  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step14        // unsigned , default = 1056763  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP15                        0x29  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step15        // unsigned , default = 1108576  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_SCL_STEP16                        0x2a  //
//Bit 31:24        reserved
//Bit 23: 0        reg_vks_scl_step16        // unsigned , default = 1160389  , for ratio of each line (defined piece),step: 4.20 opixnum = (ipixnum<<20)/step;  scale:4.20 = 1/step
    #define VKS_PPS_YCOEF00                       0x2b  //
//Bit 31:24        reg_vks_ycoef0            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef1            // signed , default = 128  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef2            // signed , default = 0  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef3            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF01                       0x2c  //
//Bit 31:24        reg_vks_ycoef4            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef5            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef6            // signed , default = 1  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef7            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF02                       0x2d  //
//Bit 31:24        reg_vks_ycoef8            // signed , default = -1  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef9            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef10           // signed , default = 2  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef11           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF03                       0x2e  //
//Bit 31:24        reg_vks_ycoef12           // signed , default = -2  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef13           // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef14           // signed , default = 3  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef15           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF04                       0x2f  //
//Bit 31:24        reg_vks_ycoef16           // signed , default = -3  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef17           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef18           // signed , default = 5  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef19           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF05                       0x30  //
//Bit 31:24        reg_vks_ycoef20           // signed , default = -4  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef21           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef22           // signed , default = 6  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef23           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF06                       0x31  //
//Bit 31:24        reg_vks_ycoef24           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef25           // signed , default = 125  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef26           // signed , default = 8  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef27           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF07                       0x32  //
//Bit 31:24        reg_vks_ycoef28           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef29           // signed , default = 124  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef30           // signed , default = 9  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef31           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF08                       0x33  //
//Bit 31:24        reg_vks_ycoef32           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef33           // signed , default = 123  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef34           // signed , default = 11  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef35           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_YCOEF09                       0x34  //
//Bit 31:24        reg_vks_ycoef36           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef37           // signed , default = 122  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef38           // signed , default = 13  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef39           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF10                       0x35  //
//Bit 31:24        reg_vks_ycoef40           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef41           // signed , default = 121  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef42           // signed , default = 15  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef43           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF11                       0x36  //
//Bit 31:24        reg_vks_ycoef44           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef45           // signed , default = 119  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef46           // signed , default = 17  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef47           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF12                       0x37  //
//Bit 31:24        reg_vks_ycoef48           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef49           // signed , default = 118  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef50           // signed , default = 19  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef51           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_YCOEF13                       0x38  //
//Bit 31:24        reg_vks_ycoef52           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef53           // signed , default = 116  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef54           // signed , default = 22  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef55           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF14                       0x39  //
//Bit 31:24        reg_vks_ycoef56           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef57           // signed , default = 114  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef58           // signed , default = 24  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef59           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF15                       0x3a  //
//Bit 31:24        reg_vks_ycoef60           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef61           // signed , default = 112  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef62           // signed , default = 26  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef63           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_YCOEF16                       0x3b  //
//Bit 31:24        reg_vks_ycoef64           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef65           // signed , default = 111  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef66           // signed , default = 29  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef67           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF17                       0x3c  //
//Bit 31:24        reg_vks_ycoef68           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef69           // signed , default = 109  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef70           // signed , default = 31  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef71           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF18                       0x3d  //
//Bit 31:24        reg_vks_ycoef72           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef73           // signed , default = 107  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef74           // signed , default = 33  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef75           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF19                       0x3e  //
//Bit 31:24        reg_vks_ycoef76           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef77           // signed , default = 104  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef78           // signed , default = 36  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef79           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_YCOEF20                       0x3f  //
//Bit 31:24        reg_vks_ycoef80           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef81           // signed , default = 102  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef82           // signed , default = 39  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef83           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF21                       0x40  //
//Bit 31:24        reg_vks_ycoef84           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef85           // signed , default = 100  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef86           // signed , default = 41  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef87           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF22                       0x41  //
//Bit 31:24        reg_vks_ycoef88           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef89           // signed , default = 97  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef90           // signed , default = 44  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef91           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_YCOEF23                       0x42  //
//Bit 31:24        reg_vks_ycoef92           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef93           // signed , default = 95  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef94           // signed , default = 47  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef95           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF24                       0x43  //
//Bit 31:24        reg_vks_ycoef96           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef97           // signed , default = 93  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef98           // signed , default = 49  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef99           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF25                       0x44  //
//Bit 31:24        reg_vks_ycoef100          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef101          // signed , default = 90  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef102          // signed , default = 52  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef103          // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_YCOEF26                       0x45  //
//Bit 31:24        reg_vks_ycoef104          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef105          // signed , default = 88  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef106          // signed , default = 55  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef107          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF27                       0x46  //
//Bit 31:24        reg_vks_ycoef108          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef109          // signed , default = 85  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef110          // signed , default = 58  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef111          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF28                       0x47  //
//Bit 31:24        reg_vks_ycoef112          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef113          // signed , default = 82  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef114          // signed , default = 60  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef115          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_YCOEF29                       0x48  //
//Bit 31:24        reg_vks_ycoef116          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef117          // signed , default = 80  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef118          // signed , default = 63  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef119          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF30                       0x49  //
//Bit 31:24        reg_vks_ycoef120          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef121          // signed , default = 77  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef122          // signed , default = 66  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef123          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF31                       0x4a  //
//Bit 31:24        reg_vks_ycoef124          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef125          // signed , default = 74  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef126          // signed , default = 69  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef127          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_YCOEF32                       0x4b  //
//Bit 31:24        reg_vks_ycoef128          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ycoef129          // signed , default = 72  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ycoef130          // signed , default = 72  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ycoef131          // signed , default = -8  poly-phase scalar coefs
    #define VKS_PPS_CCOEF00                       0x4c  //
//Bit 31:24        reg_vks_ccoef0            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef1            // signed , default = 128  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef2            // signed , default = 0  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef3            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF01                       0x4d  //
//Bit 31:24        reg_vks_ccoef4            // signed , default = 0  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef5            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef6            // signed , default = 1  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef7            // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF02                       0x4e  //
//Bit 31:24        reg_vks_ccoef8            // signed , default = -1  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef9            // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef10           // signed , default = 2  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef11           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF03                       0x4f  //
//Bit 31:24        reg_vks_ccoef12           // signed , default = -2  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef13           // signed , default = 127  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef14           // signed , default = 3  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef15           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF04                       0x50  //
//Bit 31:24        reg_vks_ccoef16           // signed , default = -3  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef17           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef18           // signed , default = 5  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef19           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF05                       0x51  //
//Bit 31:24        reg_vks_ccoef20           // signed , default = -4  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef21           // signed , default = 126  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef22           // signed , default = 6  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef23           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF06                       0x52  //
//Bit 31:24        reg_vks_ccoef24           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef25           // signed , default = 125  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef26           // signed , default = 8  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef27           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF07                       0x53  //
//Bit 31:24        reg_vks_ccoef28           // signed , default = -5  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef29           // signed , default = 124  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef30           // signed , default = 9  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef31           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF08                       0x54  //
//Bit 31:24        reg_vks_ccoef32           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef33           // signed , default = 123  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef34           // signed , default = 11  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef35           // signed , default = 0  poly-phase scalar coefs
    #define VKS_PPS_CCOEF09                       0x55  //
//Bit 31:24        reg_vks_ccoef36           // signed , default = -6  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef37           // signed , default = 122  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef38           // signed , default = 13  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef39           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF10                       0x56  //
//Bit 31:24        reg_vks_ccoef40           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef41           // signed , default = 121  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef42           // signed , default = 15  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef43           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF11                       0x57  //
//Bit 31:24        reg_vks_ccoef44           // signed , default = -7  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef45           // signed , default = 119  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef46           // signed , default = 17  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef47           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF12                       0x58  //
//Bit 31:24        reg_vks_ccoef48           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef49           // signed , default = 118  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef50           // signed , default = 19  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef51           // signed , default = -1  poly-phase scalar coefs
    #define VKS_PPS_CCOEF13                       0x59  //
//Bit 31:24        reg_vks_ccoef52           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef53           // signed , default = 116  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef54           // signed , default = 22  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef55           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF14                       0x5a  //
//Bit 31:24        reg_vks_ccoef56           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef57           // signed , default = 114  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef58           // signed , default = 24  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef59           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF15                       0x5b  //
//Bit 31:24        reg_vks_ccoef60           // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef61           // signed , default = 112  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef62           // signed , default = 26  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef63           // signed , default = -2  poly-phase scalar coefs
    #define VKS_PPS_CCOEF16                       0x5c  //
//Bit 31:24        reg_vks_ccoef64           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef65           // signed , default = 111  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef66           // signed , default = 29  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef67           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF17                       0x5d  //
//Bit 31:24        reg_vks_ccoef68           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef69           // signed , default = 109  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef70           // signed , default = 31  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef71           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF18                       0x5e  //
//Bit 31:24        reg_vks_ccoef72           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef73           // signed , default = 107  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef74           // signed , default = 33  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef75           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF19                       0x5f  //
//Bit 31:24        reg_vks_ccoef76           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef77           // signed , default = 104  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef78           // signed , default = 36  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef79           // signed , default = -3  poly-phase scalar coefs
    #define VKS_PPS_CCOEF20                       0x60  //
//Bit 31:24        reg_vks_ccoef80           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef81           // signed , default = 102  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef82           // signed , default = 39  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef83           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF21                       0x61  //
//Bit 31:24        reg_vks_ccoef84           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef85           // signed , default = 100  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef86           // signed , default = 41  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef87           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF22                       0x62  //
//Bit 31:24        reg_vks_ccoef88           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef89           // signed , default = 97  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef90           // signed , default = 44  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef91           // signed , default = -4  poly-phase scalar coefs
    #define VKS_PPS_CCOEF23                       0x63  //
//Bit 31:24        reg_vks_ccoef92           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef93           // signed , default = 95  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef94           // signed , default = 47  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef95           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF24                       0x64  //
//Bit 31:24        reg_vks_ccoef96           // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef97           // signed , default = 93  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef98           // signed , default = 49  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef99           // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF25                       0x65  //
//Bit 31:24        reg_vks_ccoef100          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef101          // signed , default = 90  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef102          // signed , default = 52  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef103          // signed , default = -5  poly-phase scalar coefs
    #define VKS_PPS_CCOEF26                       0x66  //
//Bit 31:24        reg_vks_ccoef104          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef105          // signed , default = 88  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef106          // signed , default = 55  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef107          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF27                       0x67  //
//Bit 31:24        reg_vks_ccoef108          // signed , default = -9  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef109          // signed , default = 85  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef110          // signed , default = 58  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef111          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF28                       0x68  //
//Bit 31:24        reg_vks_ccoef112          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef113          // signed , default = 82  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef114          // signed , default = 60  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef115          // signed , default = -6  poly-phase scalar coefs
    #define VKS_PPS_CCOEF29                       0x69  //
//Bit 31:24        reg_vks_ccoef116          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef117          // signed , default = 80  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef118          // signed , default = 63  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef119          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF30                       0x6a  //
//Bit 31:24        reg_vks_ccoef120          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef121          // signed , default = 77  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef122          // signed , default = 66  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef123          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF31                       0x6b  //
//Bit 31:24        reg_vks_ccoef124          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef125          // signed , default = 74  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef126          // signed , default = 69  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef127          // signed , default = -7  poly-phase scalar coefs
    #define VKS_PPS_CCOEF32                       0x6c  //
//Bit 31:24        reg_vks_ccoef128          // signed , default = -8  poly-phase scalar coefs
//Bit 23:16        reg_vks_ccoef129          // signed , default = 72  poly-phase scalar coefs
//Bit 15: 8        reg_vks_ccoef130          // signed , default = 72  poly-phase scalar coefs
//Bit  7: 0        reg_vks_ccoef131          // signed , default = -8  poly-phase scalar coefs


// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vkstone_regs.h
//
////=================================================================////
//// vpp dither
////=================================================================////
// 8'h20-8'h3f
//
// Reading file:  ./vpp_dither_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_VE_DITHER_CTRL                         ((0x3120  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_1                        ((0x3121  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_2                        ((0x3122  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_3                        ((0x3123  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_4                        ((0x3124  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_5                        ((0x3125  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_6                        ((0x3126  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_7                        ((0x3127  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_8                        ((0x3128  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_9                        ((0x3129  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_10                       ((0x312a  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_11                       ((0x312b  << 2) + 0xff000000)
#define VPP_VE_DITHER_LUT_12                       ((0x312c  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_CTRL                      ((0x3130  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_1                     ((0x3131  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_2                     ((0x3132  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_3                     ((0x3133  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_4                     ((0x3134  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_5                     ((0x3135  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_6                     ((0x3136  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_7                     ((0x3137  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_8                     ((0x3138  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_9                     ((0x3139  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_10                    ((0x313a  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_11                    ((0x313b  << 2) + 0xff000000)
#define VPP_OSDSC_DITHER_LUT_12                    ((0x313c  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_dither_regs.h
//
//register definition for xvycc
// 8'h50-8'h7f
//
// Reading file:  ./xvycc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define XVYCC_INV_LUT_Y_ADDR_PORT                  ((0x3158  << 2) + 0xff000000)
//Bit 31:7, reserved
//Bit  6:0,  xvycc_inv_lut_y_addr;
#define XVYCC_INV_LUT_Y_DATA_PORT                  ((0x3159  << 2) + 0xff000000)
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_y_data;
#define XVYCC_INV_LUT_U_ADDR_PORT                  ((0x315a  << 2) + 0xff000000)
//Bit 31:6, reserved
//Bit  5:0,  xvycc_inv_lut_u_addr;
#define XVYCC_INV_LUT_U_DATA_PORT                  ((0x315b  << 2) + 0xff000000)
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_u_data;
#define XVYCC_INV_LUT_V_ADDR_PORT                  ((0x315c  << 2) + 0xff000000)
//Bit 31:6, reserved
//Bit  5:0,  xvycc_inv_lut_v_addr;
#define XVYCC_INV_LUT_V_DATA_PORT                  ((0x315d  << 2) + 0xff000000)
//Bit 31:12, reserved
//Bit  11:0, xvycc_inv_lut_v_data;
#define XVYCC_LUT_R_ADDR_PORT                      ((0x315e  << 2) + 0xff000000)
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_r_addr;
#define XVYCC_LUT_R_DATA_PORT                      ((0x315f  << 2) + 0xff000000)
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_r_data;
#define XVYCC_LUT_G_ADDR_PORT                      ((0x3160  << 2) + 0xff000000)
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_g_addr;
#define XVYCC_LUT_G_DATA_PORT                      ((0x3161  << 2) + 0xff000000)
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_g_data;
#define XVYCC_LUT_B_ADDR_PORT                      ((0x3162  << 2) + 0xff000000)
//Bit 31:7, reserved
//Bit  6:0,  xvycc_lut_b_addr;
#define XVYCC_LUT_B_DATA_PORT                      ((0x3163  << 2) + 0xff000000)
//Bit 31:10, reserved
//Bit  9:0,  xvycc_lut_b_data;
#define XVYCC_INV_LUT_CTL                          ((0x3164  << 2) + 0xff000000)
//Bit 31:15, reserved
//Bit 14:12, reg_xvycc_cmpr_invlut_enable    enable for xvycc compression inverse-lut [2] for Y, [1] for U, [0] for V default=0
//Bit 11:10, reg_xvycc_cmpr_invlut_vscl_1   v LUT input scale for positive portion   default=0
//Bit  9: 8, reg_xvycc_cmpr_invlut_vscl_0   v LUT input scale for negative portion   default=0
//Bit  7: 6, reg_xvycc_cmpr_invlut_uscl_1   u LUT input scale for positive portion   default=0
//Bit  5: 4, reg_xvycc_cmpr_invlut_uscl_0   u LUT input scale for negative portion   default=0
//Bit  3: 2, reg_xvycc_cmpr_invlut_yscl_1   y LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_cmpr_invlut_yscl_0   y LUT input scale for negative portion   default=0
#define XVYCC_LUT_CTL                              ((0x3165  << 2) + 0xff000000)
//Bit 31: 7, reserved
//Bit  6: 4, reg_xvycc_lut_enable  LUT enable [6] for R, [5] for G, [4] for B  default=0
//Bit  3: 2, reg_xvycc_lut_scl_1   LUT input scale for positive portion   default=0
//Bit  1: 0, reg_xvycc_lut_scl_0   LUT input scale for negative portion   default=0
#define XVYCC_VADJ1_CURV_0                         ((0x3166  << 2) + 0xff000000)
//Bit 31:24, vadj1_softcon_curv0_ci                         default=0
//Bit 23:12, vadj1_softcon_curv0_b                          default=0
//Bit 11: 0, vadj1_softcon_curv0_a                          default=0
#define XVYCC_VADJ1_CURV_1                         ((0x3167  << 2) + 0xff000000)
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv0_cs                         default=0
#define XVYCC_VADJ1_CURV_2                         ((0x3168  << 2) + 0xff000000)
//Bit 31:24, vadj1_softcon_curv1_ci                         default=0
//Bit 23:12, vadj1_softcon_curv1_b                          default=0
//Bit 11: 0, vadj1_softcon_curv1_a                          default=0
#define XVYCC_VADJ1_CURV_3                         ((0x3169  << 2) + 0xff000000)
//Bit 31:13, reserved
//Bit 12: 4, vadj1_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj1_softcon_curv1_cs                         default=0
#define XVYCC_VADJ2_CURV_0                         ((0x316a  << 2) + 0xff000000)
//Bit 31:24, vadj2_softcon_curv0_ci                         default=0
//Bit 23:12, vadj2_softcon_curv0_b                          default=0
//Bit 11: 0, vadj2_softcon_curv0_a                          default=0
#define XVYCC_VADJ2_CURV_1                         ((0x316b  << 2) + 0xff000000)
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv0_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv0_cs                         default=0
#define XVYCC_VADJ2_CURV_2                         ((0x316c  << 2) + 0xff000000)
//Bit 31:24, vadj2_softcon_curv1_ci                         default=0
//Bit 23:12, vadj2_softcon_curv1_b                          default=0
//Bit 11: 0, vadj2_softcon_curv1_a                          default=0
#define XVYCC_VADJ2_CURV_3                         ((0x316d  << 2) + 0xff000000)
//Bit 31:13, reserved
//Bit 12: 4, vadj2_softcon_curv1_g                          default=0
//Bit     3, reserved
//Bit  2: 0, vadj2_softcon_curv1_cs                         default=0
#define XVYCC_VD1_RGB_CTRST                        ((0x3170  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:16, reg_vd1_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved
//Bit 13: 4, reg_vd1_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
//Bit  3: 2, reserved
//Bit     1, reg_vd1_rgbbst_en         u1, enable rgbbst         default=0
//Bit     0, reg_vd1_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
#define XVYCC_VD1_RGB_BRIGHT                        ((0x3171  << 2) + 0xff000000)
//Bit 31:16, reserved
//Bit 15: 4, reg_vd1_rgb_bright        s12, brightness level in rgb domain                              default=0
//Bit  3: 2, reserved
//Bit     1, reg_vd1_rgb_bright_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_vd1_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define XVYCC_VD1_RGB_DLUT_0_3                     ((0x3172  << 2) + 0xff000000)
//Bit 31:24, reg_vd1_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_vd1_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_vd1_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_vd1_rgbbst_dlut3      u8,   default = 147
#define XVYCC_VD1_RGB_DLUT_4_7                     ((0x3173  << 2) + 0xff000000)
//Bit 31:24, reg_vd1_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_vd1_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_vd1_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_vd1_rgbbst_dlut7      u8,   default = 93
#define XVYCC_VD1_RGB_DLUT_8_11                    ((0x3174  << 2) + 0xff000000)
//Bit 31:24, reg_vd1_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_vd1_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_vd1_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_vd1_rgbbst_dlut11     u8,   default = 68
#define XVYCC_POST_RGB_CTRST                       ((0x3175  << 2) + 0xff000000)
//Bit 31:28, reserved
//Bit 27:16, reg_post_rgb_ctrst        u12, contrast in rgb.      default=1024
//Bit 15:14, reserved
//Bit 13: 4, reg_post_rgb_ctrst_blklvl u10, contrast blacklevel   default=64
//Bit  3: 2, reserved
//Bit     1, reg_post_rgbbst_en         u1, enable rgbbst         default=0
//Bit     0, reg_post_rgb_ctrst_prt     u1, enable signal to protect saturation in rgb.  default=1
#define XVYCC_POST_RGB_BRIGHT                       ((0x3176  << 2) + 0xff000000)
//Bit 31:16, reserved
//Bit 15: 4, reg_post_rgb_bright        s12, brightness level in rgb domain                              default=0
//Bit  3: 2, reserved
//Bit     1, reg_post_rgb_bright_prt     u1, enalbe signal to protect saturation in rgb                  default=1
//Bit     0, reg_post_rgbbst_dlut_x2    u1, enable signal to do x2 to the dlut cells before subtracting default=0
#define XVYCC_POST_RGB_DLUT_0_3                    ((0x3177  << 2) + 0xff000000)
//Bit 31:24, reg_post_rgbbst_dlut0      u8,   default = 255
//Bit 23:16, reg_post_rgbbst_dlut1      u8,   default = 205
//Bit 15: 8, reg_post_rgbbst_dlut2      u8,   default = 171
//Bit  7: 0, reg_post_rgbbst_dlut3      u8,   default = 147
#define XVYCC_POST_RGB_DLUT_4_7                    ((0x3178  << 2) + 0xff000000)
//Bit 31:24, reg_post_rgbbst_dlut4      u8,   default = 128
//Bit 23:16, reg_post_rgbbst_dlut5      u8,   default = 113
//Bit 15: 8, reg_post_rgbbst_dlut6      u8,   default = 102
//Bit  7: 0, reg_post_rgbbst_dlut7      u8,   default = 93
#define XVYCC_POST_RGB_DLUT_8_11                   ((0x3179  << 2) + 0xff000000)
//Bit 31:24, reg_post_rgbbst_dlut8      u8,   default = 85
//Bit 23:16, reg_post_rgbbst_dlut9      u8,   default = 78
//Bit 15: 8, reg_post_rgbbst_dlut10     u8,   default = 73
//Bit  7: 0, reg_post_rgbbst_dlut11     u8,   default = 68
#define ADAPTIVE_SCALE_REG0                        ((0x3150  << 2) + 0xff000000)
//Bit 31,    reg_adaptive_scale_enable    u1,  default = 1
//Bit 27:16, reg_adpscl_ys_coef_0        u12,  default = 538
//Bit 11: 0, reg_adpscl_ys_coef_1        u12,  default = 1389
#define ADAPTIVE_SCALE_REG1                        ((0x3151  << 2) + 0xff000000)
//Bit 27:16, reg_adpscl_ys_coef_2        u12,  default = 121
//Bit 11: 0, reg_adpscl_alpha_0          u12,  default = 1024
#define ADAPTIVE_SCALE_REG2                        ((0x3152  << 2) + 0xff000000)
//Bit 27:16, reg_adpscl_alpha_1          u12,  default = 1024
//Bit 11: 0, reg_adpscl_alpha_2          u12,  default = 1024
#define ADAPTIVE_SCALE_REG3                        ((0x3153  << 2) + 0xff000000)
//Bit 31:16, reg_adpscl_beta_0          u16,  default = 0
//Bit 15: 0, reg_adpscl_beta_1          u16,  default = 0
#define ADAPTIVE_SCALE_REG4                        ((0x3154  << 2) + 0xff000000)
//Bit 31:16, reg_adpscl_beta_2          u16,  default = 0
#define ADAPTIVE_SCALE_ADDR                        ((0x3155  << 2) + 0xff000000)
//Bit 6:0,   reg_lut_addr               u7,  default = 0
#define ADAPTIVE_SCALE_DATA                        ((0x3156  << 2) + 0xff000000)
//Bit 11:0,  reg_lut_data               u12,  default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./xvycc_regs.h
//
//register definition for vd2 afbc dec
// 8'h80-8'h9f
//
// Reading file:  ./vd2_afbc_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define VD2_AFBC_ENABLE                            ((0x3180  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:23,    reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22,       reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21,       reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20,       reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19,       reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16,    soft_rst          unsigned  , default = 4
//Bit   15:14,    reserved
//Bit   13:12,    ddr_blk_size      unsigned  , default = 1
//Bit   11:9,     cmd_blk_size      unsigned  , default = 3
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:2,      reserved
//Bit   1,        head_len_sel      unsigned  , default = 1
//Bit   0,        dec_frm_start     unsigned  , default = 0
#define VD2_AFBC_MODE                              ((0x3181  << 2) + 0xff000000)
//Bit   31:30,    reserved
//Bit   29,       ddr_sz_mode       uns, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28,       blk_mem_mode      uns, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26,    rev_mode          uns, default = 0 , reverse mode
//Bit   25:24,    mif_urgent        uns, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num     uns, default = 4 ,
//Bit   15:14,    burst_len         uns, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8,     compbits_yuv      uns, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6,      vert_skip_y       uns, default = 0 , luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4,      horz_skip_y       uns, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2,      vert_skip_uv      uns, default = 0 , chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0,      horz_skip_uv      uns, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define VD2_AFBC_SIZE_IN                           ((0x3182  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
#define VD2_AFBC_DEC_DEF_COLOR                     ((0x3183  << 2) + 0xff000000)
//Bit   31:30,   reserved
//Bit   29:20,   def_color_y        uns, default = 255, afbc dec y default setting value
//Bit   19:10,   def_color_u        uns, default = 128, afbc dec u default setting value
//Bit    9: 0,   def_color_v        uns, default = 128, afbc dec v default setting value
#define VD2_AFBC_CONV_CTRL                         ((0x3184  << 2) + 0xff000000)
//Bit   31:14,   reserved
//Bit   13:12,   fmt_mode            uns, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0,   conv_lbuf_len       uns, default = 256, unit=16 pixel need to set = 2^n
#define VD2_AFBC_LBUF_DEPTH                        ((0x3185  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel
//Bit   15:12,   reserved
//Bit   11:0,    mif_lbuf_depth      uns, default = 128;
#define VD2_AFBC_HEAD_BADDR                        ((0x3186  << 2) + 0xff000000)
//Bit   31:0,   mif_info_baddr      uns, default = 32'h0;
#define VD2_AFBC_BODY_BADDR                        ((0x3187  << 2) + 0xff000000)
//Bit   31:0,   mif_data_baddr      uns, default = 32'h00010000;
#define VD2_AFBC_SIZE_OUT                          ((0x3188  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   hsize_out           uns, default = 1920    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   vsize_out           uns, default = 1080 ; // unit: 1 pixel
#define VD2_AFBC_OUT_YSCOPE                        ((0x3189  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel
//Bit   15:13,   reserved
//Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel
#define VD2_AFBC_STAT                              ((0x318a  << 2) + 0xff000000)
//Bit   31:0,   ro_dbg_top_info      uns
#define VD2_AFBC_VD_CFMT_CTRL                      ((0x318b  << 2) + 0xff000000)
//Bit 31    cfmt_gclk_bit_dis      uns, default = 0    ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      uns, default = 0    ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          uns, default = 0    ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        uns, default = 0    ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        uns, default = 0    ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         uns, default = 0    ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               uns, default = 0    ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en uns, default = 0    ; //if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     uns, default = 0    ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   uns, default = 0    ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     uns, default = 0    ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    uns, default = 0    ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        uns, default = 0    ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       uns, default = 0    ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               uns, default = 0    ; //vertical formatter enable
#define VD2_AFBC_VD_CFMT_W                         ((0x318c  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                uns, default = 0    ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                uns, default = 0    ;vertical formatter width
#define VD2_AFBC_MIF_HOR_SCOPE                     ((0x318d  << 2) + 0xff000000)
//Bit   31:26,   reserved
//Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10,   reserved
//Bit    9: 0,   mif_blk_end_h        uns, default = 59 ; // unit: 32 pixel/block hor
#define VD2_AFBC_MIF_VER_SCOPE                     ((0x318e  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12,   reserved
//Bit   11: 0,   mif_blk_end_v        uns, default = 269; // unit: 32 pixel/block ver
#define VD2_AFBC_PIXEL_HOR_SCOPE                   ((0x318f  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel
#define VD2_AFBC_PIXEL_VER_SCOPE                   ((0x3190  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel
//Bit   15:13,   reserved
//Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel
#define VD2_AFBC_VD_CFMT_H                         ((0x3191  << 2) + 0xff000000)
//Bit 31:13,    reserved
//Bit 12:0      cfmt_h  uns, default = 142  ; //vertical formatter height
#define VD2_AFBCDEC_IQUANT_ENABLE                  ((0x3192  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1  //unsigned, RW, enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0  //unsigned, RW, enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define VD2_AFBCDEC_IQUANT_LUT_1                   ((0x3193  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define VD2_AFBCDEC_IQUANT_LUT_2                   ((0x3194  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define VD2_AFBCDEC_IQUANT_LUT_3                   ((0x3195  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define VD2_AFBCDEC_IQUANT_LUT_4                   ((0x3196  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vd2_afbc_dec_regs.h
//
//register definition for osd1 afbcd dec
// 8'ha0-8'haf
//
// Reading file:  ./osd1_afbcd_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//// reg
////===============================////
#define OSD1_AFBCD_ENABLE                          ((0x31a0  << 2) + 0xff000000)
//Bit   31:16,    reserved
//Bit   15:9,     id_fifo_thrd      unsigned  , default = 64, axi id fifo threshold
//Bit   8,        dec_enable        unsigned  , default = 0
//Bit   7:1,      reserved
//Bit   0,        frm_start         unsigned  , default = 0
#define OSD1_AFBCD_MODE                            ((0x31a1  << 2) + 0xff000000)
//Bit   31,       soft_reset              the use as go_field
//Bit   30:29,    reserved
//Bit   28,       axi_reorder_mode        default=0, the axi reorder mode, note : don't seting
//Bit   27:26,    reserved
//Bit   25:24,    mif_urgent              uns, default = 3 , info mif and data mif urgent
//Bit   22:16,    hold_line_num
//Bit   15:8,     rgba_exchan_ctrl
//Bit   7,        reserved
//Bit   6,        hreg_block_split        uns, default = 1 , Enable/disable block split mode in sparse allocation
//Bit   5,        hreg_half_block         uns, default = 1 , Enable/disable half block decoding. 1=half block, 0=full block
//Bit   4:0,      hreg_pixel_packing_fmt  uns, default = 5 , Pixel format
#define OSD1_AFBCD_SIZE_IN                         ((0x31a2  << 2) + 0xff000000)
//Bit   31:16     hreg_hsize_in          uns, default = 1920 , pic horz size in  unit: pixel
//Bit   15:0,     hreg_vsize_in          uns, default = 1080 , pic vert size in  unit: pixel
#define OSD1_AFBCD_HDR_PTR                         ((0x31a3  << 2) + 0xff000000)
//Bit   31:0      hreg_hdr_ptr           uns, default = 0 ,
#define OSD1_AFBCD_FRAME_PTR                       ((0x31a4  << 2) + 0xff000000)
//Bit   31:0      hreg_frame_ptr         uns, default = 0 , The start address of the target frame buffer.
//                                       For YUV format, this pointer specifies the luma buffer.
#define OSD1_AFBCD_CHROMA_PTR                      ((0x31a5  << 2) + 0xff000000)
//Bit   31:0      hreg_chroma_ptr        uns, default = 0 , Only valid in YUV format, to specify the target chroma buffer.
#define OSD1_AFBCD_CONV_CTRL                       ((0x31a6  << 2) + 0xff000000)
//Bit   31:15,   reserved
//Bit   15: 0,   conv_lbuf_len           uns, default = 1024, unit=16 pixel need to set = 2^n
#define OSD1_AFBCD_STATUS                          ((0x31a8  << 2) + 0xff000000)
//Bit   30:4,     reserved
//Bit   3,        hreg_dec_resp          uns, default = 0 , Decoder error flage from the dec4x4 core
//Bit   2,        hreg_axi_bresp         uns, default = 0 , Bus error flag for AXI write error
//Bit   1,        hreg_axi_rresp         uns, default = 0 , Bus error flag for AXI read error
//Bit   0,        hreg_idle_n            uns, default = 0 , Idle output, value 0 indicates the standalone decoder is free now and can start the next frame.
#define OSD1_AFBCD_PIXEL_HSCOPE                    ((0x31a9  << 2) + 0xff000000)
//Bit   31:16,   dec_pixel_bgn_h         uns, default = 0  ; // unit: pixel
//Bit   15: 0,   dec_pixel_end_h         uns, default = 1919 ; // unit: pixel
#define OSD1_AFBCD_PIXEL_VSCOPE                    ((0x31aa  << 2) + 0xff000000)
//Bit   31:16,   dec_pixel_bgn_v         uns, default = 0  ; // unit: pixel
//Bit   15: 0,   dec_pixel_end_v         uns, default = 1079 ; // unit: pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osd1_afbcd_regs.h
//
//register definition for osd1 afbcd dec
// 8'hb0-8'hca
//
// Reading file:  ./vpp_vmx_wm_regs.h
//
//// synopsys translate_off
//`ifdef VPP_WM_REGS_H
//`else
//    `define VPP_WM_REGS_H
//// synopsys translate_on
#define WM_CTRL                                    ((0x31b0  << 2) + 0xff000000)
//Bit  31,      int_mask					default = 0
//Bit  30:16,	reserved
//Bit  15:8,	strength_multiply			default =1
//Bit  7:6,		reserved
//Bit  5,       shift_en                      default = 0
//Bit  4,		background_embedding_on			default =0
//Bit  3,		mark_en			default =0
//Bit  2,		noise_en			default =0
//Bit  1,		blend_en			default =0
//Bit  0,		wm_en			default =0
#define WM_SPACE_RESOLUTION                        ((0x31b1  << 2) + 0xff000000)
//Bit  31:25,	reserved
//Bit  24:16,	spacing_horz			default =10
//Bit  15:9,    reserved
//Bit  8:0,		spacing_vert			default =12
#define WM_SYMBOLS_NUM                             ((0x31b2  << 2) + 0xff000000)
//Bit  31:8, reserved
//Bit  7:4, symbols_cols		1~10;	default =5
//Bit  3:0, symbols_rows		1~10;	default =2
#define WM_MARK_RESOLUTION                         ((0x31b3  << 2) + 0xff000000)
//Bit  31:20,  mark_hsize		mark_buffer_width;  	default =1820
//Bit  19:8,   mark_vsize		mark_buffer_height; 	default =1820             t =780
//Bit  7:6,		reserved
//Bit  5:0,		scale			default =13                  // scale up
#define WM_FREQ_DIST_LEFT                          ((0x31b4  << 2) + 0xff000000)
//Bit  31:21, reserved
//Bit  20:0, freq_dist_left			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define WM_FREQ_DIST_RIGHT                         ((0x31b5  << 2) + 0xff000000)
//Bit  31:21, reserved
//Bit  20:0, freq_dist_right			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define WM_FREQ_DIST_TOP                           ((0x31b6  << 2) + 0xff000000)
//Bit  31:21, reserved
//Bit  20:0, freq_dist_top			default =21092          // frequency_distance [n][0]  each is 7bits, there is 3 dist
#define WM_SYMBOLS_XPOS                            ((0x31b7  << 2) + 0xff000000)
//Bit  31:29, reserved
//Bit  28:16, symbols_xpos_start			default =1536      // SYMBOLS_XPOS * h_res
//Bit  15:13, reserved
//Bit  12:0,  symbols_xpos_end			default =3356        // SYMBOLS_XPOS * h_res + mark_hsize
#define WM_SYMBOLS_YPOS                            ((0x31b8  << 2) + 0xff000000)
//Bit  31:29, reserved
//Bit  28:16, symbols_ypos_start			default =756      // SYMBOLS_yPOS * y_res
//Bit  15:13, reserved
//Bit  12:0,  symbols_ypos_end			    default =1536        // SYMBOLS_yPOS * y_res + mark_vsize
#define WM_STORAGE_SETTING                         ((0x31b9  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, direction_max		default = 80
//Bit	  15, reserved
//Bit   14:8, storage_s			default =18               // biggest is 72      S
//Bit      7, reserved
//Bit    6:0, storage_max_distance			default =36    // biggest is 72      max_distance
#define WM_VIDEO_RESOLUTION                        ((0x31ba  << 2) + 0xff000000)
//Bit  31:29, reserved
//Bit  28:16, h_res			default =3840                   // video hsize
//Bit  15:13, reserved
//Bit  12:0,  v_res			default =2160                   // video vsize
#define WM_EMBEDDING_STRENGTH_THRESHOLD0           ((0x31bb  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_0		default =48
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_1		default =60
#define WM_EMBEDDING_STRENGTH_THRESHOLD1           ((0x31bc  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_2		default = 68
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_3		default = 80
#define WM_EMBEDDING_STRENGTH_THRESHOLD2           ((0x31bd  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_4		default = 88
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_5		default = 96
#define WM_EMBEDDING_STRENGTH_THRESHOLD3           ((0x31be  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_6		default = 100
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_7		default = 108
#define WM_EMBEDDING_STRENGTH_THRESHOLD4           ((0x31bf  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_8		default = 112
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_9		default = 116
#define WM_EMBEDDING_STRENGTH_THRESHOLD5           ((0x31c0  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_10		default = 120
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_11		default = 124
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG0        ((0x31c1  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_0		default =320
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_1		default = 328
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG1        ((0x31c2  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_2		default = 332
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_3		default = 340
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG2        ((0x31c3  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_4		default = 344
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_5		default = 348
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG3        ((0x31c4  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_6		default = 352
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_7		default = 356
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG4        ((0x31c5  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_8		default = 360
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_9		default = 368
#define WM_EMBEDDING_STRENGTH_THRESHOLD_BG5        ((0x31c6  << 2) + 0xff000000)
//Bit  31:28, reserved
//Bit  27:16, embedding_strength_threshold_bg_10		default = 372
//Bit  15:12, reserved
//Bit  11:0,  embedding_strength_threshold_bg_11		default = 380
#define WM_AM_LUT_DATA_PORT                        ((0x31c7  << 2) + 0xff000000)
#define WM_AM_LUT_ADDR_PORT                        ((0x31c8  << 2) + 0xff000000)
#define WM_STATUS_RO                               ((0x31c9  << 2) + 0xff000000)
//Bit  31,  ro_resolution_changed
//Bit  30:29, reserved
//Bit  30:16, ro_hsize_in
//Bit  15:13, reserved
//Bit  8:0,   ro_vsize_in
#define WM_STATUS_RAM_RO                           ((0x31ca  << 2) + 0xff000000)
//Bit  31:9,  reserved
//Bit  8:0,   ro_ram_addr
#define WM_THRES_ADDR_PORT                         ((0x31cb  << 2) + 0xff000000)
#define WM_THRES_DATA_PORT                         ((0x31cd  << 2) + 0xff000000)
//
// Closing file:  ./vpp_vmx_wm_regs.h
//
//
// Reading file:  ./ngptv_reg.h
//
//// synopsys translate_off
//`ifdef VPP_WM_REGS_H
//`else
//    `define VPP_WM_REGS_H
//// synopsys translate_on
#define REG_NGPTV_CTRL0                            ((0x31ab  << 2) + 0xff000000)
//Bit 31:25,        reserved
//Bit 24,           bypass_latch
//Bit 23,           count_enable                             deafult=1
//Bit 22,           soft_rst
//Bit 21,           count_rst
//Bit 20,           bypass run
//Bit 19:14,        ochannel_sel                             deafult=0x24
//Bit 13:8,         ichannel_sel                             deafult=0x24
//Bit 3,            8bit mode
//Bit 2,            10bit mode
//Bit 1,            reg_sync enable
//Bit 0,            bypass
#define REG_NGPTV_CTRL1                            ((0x31ac  << 2) + 0xff000000)
//Bit 31:7          reserved
//Bit 6             reset sw                            default=0
//Bit 5:0           gclk_ctrl
#define REG_NGPTV_CTRL2                            ((0x31ad  << 2) + 0xff000000)
//Bit 31:8          reserved
//Bit 7             SpareIn
//Bit 6             NG_EnableServiceIn
//Bit 5:4           reserved
//Bit 3             NG_DebugEnableIn
//Bit 2             reserved
//Bit 1             NG_Payload24_56n
//Bit 0             NG_YUVnRGBIn
#define REG_NGPTV_CTRL3                            ((0x31ce  << 2) + 0xff000000)
//Bit 31:0          NG_KeyIn                            default=0x01ac7f33
#define REG_NGPTV_CTRL4                            ((0x31cf  << 2) + 0xff000000)
//Bit 31:0          NG_PayloadDataIn[31:0]              default=0x6789abcd
#define REG_NGPTV_CTRL5                            ((0x31f0  << 2) + 0xff000000)
//Bit 31:26         Reserved
//Bit 25:24         NG_FrameTypeIn                      default=3
//Bit 23:0          NG_PayloadDataIn                    default=0x012345
#define REG_NGPTV_CTRL6                            ((0x31f1  << 2) + 0xff000000)
//Bit 31:0          NG_SettingIn[31:0]                  default=0x18c6318c
#define REG_NGPTV_CTRL7                            ((0x31f2  << 2) + 0xff000000)
//Bit 31:0          NG_SettingIn[63:32]                 default=0x84210842
#define REG_NGPTV_CTRL8                            ((0x31f3  << 2) + 0xff000000)
//Bit 31:0          NG_SettingIn[95:64]                 default=0x21084210
#define REG_NGPTV_CTRL9                            ((0x31f4  << 2) + 0xff000000)
//Bit 31:0          NG_SettingIn[127:96]                default=0x8c631084
#define REG_NGPTV_CTRL10                           ((0x31f5  << 2) + 0xff000000)
//Bit 31:0          NG_SettingIn[159:128]               default=0x84210631
#define REG_NGPTV_CTRL11                           ((0x31f6  << 2) + 0xff000000)
//Bit 31:16         Reserved
//Bit 15:8          NG_FrameRateIn                      default=0x18
//Bit 7             Reserved
//Bit 6:5           NG_CoreIDIn                         default=0
//Bit 4:0           NG_SettingIn[165:160]               default=0x10
#define REG_NGPTV_CTRL12                           ((0x31f7  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         vsize                               default=0x438
//Bit 16:13         Reserved
//Bit 12:0          hsize                               default=0x780
#define REG_NGPTV_CTRL13                           ((0x31f8  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         reg_vphstart                               default=0x0
//Bit 16:13         Reserved
//Bit 12:0          reg_vphend                               default=0x437
#define REG_NGPTV_CTRL14                           ((0x31f9  << 2) + 0xff000000)
//Bit 31:13         Reserved
//Bit 12:0          reg_3d_right_st                               default=0x3c0
#define REG_NGPTV_CTRL15                           ((0x31fa  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart0                               default=0x0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend0                               default=0x437
#define REG_NGPTV_CTRL16                           ((0x31fb  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart1                                default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend1                               default=0
#define REG_NGPTV_CTRL17                           ((0x31fc  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart2                               default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend2                               default=0
#define REG_NGPTV_CTRL18                           ((0x31fd  << 2) + 0xff000000)
//Bit 31:29         Reserved
//Bit 28:16         reg_vpvstart3                               default=0
//Bit 16:13         Reserved
//Bit 12:0          reg_vpvend3                               default=0
#define RO_NGPTV_CTRL19                            ((0x31fe  << 2) + 0xff000000)
//Bit 31            dat_val_in
//Bit 30            in_hold
//Bit 29            out_hold
//Bit 28:16         vcnt
//Bit 15:12         NG_ErrorOut
//Bit 11:0          NG_VersionOut
//
// Closing file:  ./ngptv_reg.h
//
// 8'hd0-8hef
//
// Reading file:  ./bt2020_regs.h
//
// synopsys translate_off
// synopsys translate_on
//Bit 31:27 for all [31] for all eotf enable,[30] for matrix3x3 enable, [29:27] for eotf_ch0~3
//Bit 17:6  for clock gating
//Bit 5:4   pscale_mode ch2
//Bit 3:2   pscale_mode ch1
//Bit 1:0   pscale_mode ch0
#define VPP_EOTF_CTL                               ((0x31d0  << 2) + 0xff000000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define VPP_EOTF_COEF00_01                         ((0x31d1  << 2) + 0xff000000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define VPP_EOTF_COEF02_10                         ((0x31d2  << 2) + 0xff000000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define VPP_EOTF_COEF11_12                         ((0x31d3  << 2) + 0xff000000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define VPP_EOTF_COEF20_21                         ((0x31d4  << 2) + 0xff000000)
//Bit 28:16 coef22
//Bit   2:0 coef_rs
#define VPP_EOTF_COEF22_RS                         ((0x31d5  << 2) + 0xff000000)
#define VPP_EOTF_LUT_ADDR_PORT                     ((0x31d6  << 2) + 0xff000000)
#define VPP_EOTF_LUT_DATA_PORT                     ((0x31d7  << 2) + 0xff000000)
#define VPP_EOTF_3X3_OFST_0                        ((0x31d8  << 2) + 0xff000000)
#define VPP_EOTF_3X3_OFST_1                        ((0x31d9  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./bt2020_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_partb_reg.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPD_VCBUS_BASE = 0x32
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vpp_vadj_regs.h
//
// synopsys translate_off
// synopsys translate_on
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
//`define VD1_IF0_GEN_REG            8'h0
//`define VD1_IF0_CANVAS0            8'h1
//`define VD1_IF0_CANVAS1            8'h2
//`define VD1_IF0_LUMA_X0            8'h3
//`define VD1_IF0_LUMA_Y0            8'h4
//`define VD1_IF0_CHROMA_X0          8'h5
//`define VD1_IF0_CHROMA_Y0          8'h6
//`define VD1_IF0_LUMA_X1            8'h7
//`define VD1_IF0_LUMA_Y1            8'h8
//`define VD1_IF0_CHROMA_X1          8'h9
//`define VD1_IF0_CHROMA_Y1          8'ha
//`define VD1_IF0_RPT_LOOP           8'hb
//`define VD1_IF0_LUMA0_RPT_PAT      8'hc
//`define VD1_IF0_CHROMA0_RPT_PAT    8'hd
//`define VD1_IF0_LUMA1_RPT_PAT      8'he
//`define VD1_IF0_CHROMA1_RPT_PAT    8'hf
//`define VD1_IF0_LUMA_PSEL          8'h10
//`define VD1_IF0_CHROMA_PSEL        8'h11
//`define VD1_IF0_DUMMY_PIXEL        8'h12
//`define VD1_IF0_LUMA_FIFO_SIZE     8'h13
//`define VD1_IF0_AXI_CMD_CNT        8'h14
//`define VD1_IF0_AXI_RDAT_CNT       8'h15
//`define VD1_IF0_GEN_REG3           8'h16
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    vertical formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)
//Bit 0     vertical formatter enable
//`define VIU_VD1_FMT_CTRL           8'h18       //29'h0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
//`define VIU_VD1_FMT_W              8'h19       //28'h0
//`define VD1_IF0_RANGE_MAP_Y        8'h1a
//`define VD1_IF0_RANGE_MAP_CB       8'h1b
//`define VD1_IF0_RANGE_MAP_CR       8'h1c
//`define VD1_IF0_GEN_REG2           8'h1d
//`define VD1_IF0_PROT_CNTL          8'h1e
//`define VD1_IF0_URGENT_CTRL        8'h1f
//------------------------------------------------------------------------------
// VD2 path
//------------------------------------------------------------------------------
//`define VD2_IF0_GEN_REG            8'h20
//`define VD2_IF0_CANVAS0            8'h21
//`define VD2_IF0_CANVAS1            8'h22
//`define VD2_IF0_LUMA_X0            8'h23
//`define VD2_IF0_LUMA_Y0            8'h24
//`define VD2_IF0_CHROMA_X0          8'h25
//`define VD2_IF0_CHROMA_Y0          8'h26
//`define VD2_IF0_LUMA_X1            8'h27
//`define VD2_IF0_LUMA_Y1            8'h28
//`define VD2_IF0_CHROMA_X1          8'h29
//`define VD2_IF0_CHROMA_Y1          8'h2a
//`define VD2_IF0_RPT_LOOP           8'h2b
//`define VD2_IF0_LUMA0_RPT_PAT      8'h2c
//`define VD2_IF0_CHROMA0_RPT_PAT    8'h2d
//`define VD2_IF0_LUMA1_RPT_PAT      8'h2e
//`define VD2_IF0_CHROMA1_RPT_PAT    8'h2f
//`define VD2_IF0_LUMA_PSEL          8'h30
//`define VD2_IF0_CHROMA_PSEL        8'h31
//`define VD2_IF0_DUMMY_PIXEL        8'h32
//`define VD2_IF0_LUMA_FIFO_SIZE     8'h33
//`define VD2_IF0_AXI_CMD_CNT        8'h34
//`define VD2_IF0_AXI_RDAT_CNT       8'h35
//`define VD2_IF0_GEN_REG3           8'h36
//Bit 31    it true, disable clock, otherwise enable clock
//Bit 30    soft rst bit
//Bit 28    if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 17    vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    vertical formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)
//Bit 0     vertical formatter enable
//`define VIU_VD2_FMT_CTRL           8'h38       //29'h0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
//`define VIU_VD2_FMT_W              8'h39       //28'h0
//`define VD2_IF0_RANGE_MAP_Y        8'h3a
//`define VD2_IF0_RANGE_MAP_CB       8'h3b
//`define VD2_IF0_RANGE_MAP_CR       8'h3c
//`define VD2_IF0_GEN_REG2           8'h3d
//`define VD2_IF0_PROT_CNTL          8'h3e
//`define VD2_IF0_URGENT_CTRL        8'h3f
#define VPP_VADJ1_MISC                             ((0x3280  << 2) + 0xff000000)
#define VPP_VADJ1_BLACK_VAL                        ((0x3281  << 2) + 0xff000000)
#define VPP_VADJ1_Y                                ((0x3282  << 2) + 0xff000000)
#define VPP_VADJ1_MA_MB                            ((0x3283  << 2) + 0xff000000)
#define VPP_VADJ1_MC_MD                            ((0x3284  << 2) + 0xff000000)
#define VPP_VADJ1_CURV_0                           ((0x3285  << 2) + 0xff000000)
#define VPP_VADJ1_CURV_1                           ((0x3286  << 2) + 0xff000000)
#define VPP_VADJ1_CURV_2                           ((0x3287  << 2) + 0xff000000)
#define VPP_VADJ1_CURV_3                           ((0x3288  << 2) + 0xff000000)
#define VPP_VD1_RGB_CTRST                          ((0x3289  << 2) + 0xff000000)
#define VPP_VD1_RGB_BRIGHT                          ((0x328a  << 2) + 0xff000000)
#define VPP_VD1_RGB_DLUT_0_3                       ((0x328b  << 2) + 0xff000000)
#define VPP_VD1_RGB_DLUT_4_7                       ((0x328c  << 2) + 0xff000000)
#define VPP_VD1_RGB_DLUT_8_11                      ((0x328d  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF00_01                   ((0x3290  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF02_10                   ((0x3291  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF11_12                   ((0x3292  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF20_21                   ((0x3293  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF22                      ((0x3294  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF13_14                   ((0x3295  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF23_24                   ((0x3296  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_COEF15_25                   ((0x3297  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_CLIP                        ((0x3298  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_OFFSET0_1                   ((0x3299  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_OFFSET2                     ((0x329a  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_PRE_OFFSET0_1               ((0x329b  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_PRE_OFFSET2                 ((0x329c  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_EN_CTRL                     ((0x329d  << 2) + 0xff000000)
#define VPP_VADJ2_MISC                             ((0x32a0  << 2) + 0xff000000)
#define VPP_VADJ2_BLACK_VAL                        ((0x32a1  << 2) + 0xff000000)
#define VPP_VADJ2_Y                                ((0x32a2  << 2) + 0xff000000)
#define VPP_VADJ2_MA_MB                            ((0x32a3  << 2) + 0xff000000)
#define VPP_VADJ2_MC_MD                            ((0x32a4  << 2) + 0xff000000)
#define VPP_VADJ2_CURV_0                           ((0x32a5  << 2) + 0xff000000)
#define VPP_VADJ2_CURV_1                           ((0x32a6  << 2) + 0xff000000)
#define VPP_VADJ2_CURV_2                           ((0x32a7  << 2) + 0xff000000)
#define VPP_VADJ2_CURV_3                           ((0x32a8  << 2) + 0xff000000)
#define VPP_POST_RGB_CTRST                         ((0x32a9  << 2) + 0xff000000)
#define VPP_POST_RGB_BRIGHT                         ((0x32aa  << 2) + 0xff000000)
#define VPP_POST_RGB_DLUT_0_3                      ((0x32ab  << 2) + 0xff000000)
#define VPP_POST_RGB_DLUT_4_7                      ((0x32ac  << 2) + 0xff000000)
#define VPP_POST_RGB_DLUT_8_11                     ((0x32ad  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF00_01                  ((0x32b0  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF02_10                  ((0x32b1  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF11_12                  ((0x32b2  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF20_21                  ((0x32b3  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF22                     ((0x32b4  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF13_14                  ((0x32b5  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF23_24                  ((0x32b6  << 2) + 0xff000000)
#define VPP_POST_MATRIX_COEF15_25                  ((0x32b7  << 2) + 0xff000000)
#define VPP_POST_MATRIX_CLIP                       ((0x32b8  << 2) + 0xff000000)
#define VPP_POST_MATRIX_OFFSET0_1                  ((0x32b9  << 2) + 0xff000000)
#define VPP_POST_MATRIX_OFFSET2                    ((0x32ba  << 2) + 0xff000000)
#define VPP_POST_MATRIX_PRE_OFFSET0_1              ((0x32bb  << 2) + 0xff000000)
#define VPP_POST_MATRIX_PRE_OFFSET2                ((0x32bc  << 2) + 0xff000000)
#define VPP_POST_MATRIX_EN_CTRL                    ((0x32bd  << 2) + 0xff000000)
#define VPP_VD1_MATRIX_SAT                         ((0x32c0  << 2) + 0xff000000)
#define VPP_POST_MATRIX_SAT                        ((0x32c1  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_vadj_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY1A_VCBUS_BASE = 0x33
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby1a_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE1A_REG_START                     ((0x3300  << 2) + 0xff000000)
#define DOLBY_CORE1A_CLKGATE_CTRL                  ((0x33f2  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL0                    ((0x33f3  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL1                    ((0x33f4  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL2                    ((0x33f5  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL3                    ((0x33f6  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL4                    ((0x33f7  << 2) + 0xff000000)
#define DOLBY_CORE1A_SWAP_CTRL5                    ((0x33f8  << 2) + 0xff000000)
#define DOLBY_CORE1A_DMA_CTRL                      ((0x33f9  << 2) + 0xff000000)
#define DOLBY_CORE1A_DMA_STATUS                    ((0x33fa  << 2) + 0xff000000)
#define DOLBY_CORE1A_STATUS0                       ((0x33fb  << 2) + 0xff000000)
#define DOLBY_CORE1A_STATUS1                       ((0x33fc  << 2) + 0xff000000)
#define DOLBY_CORE1A_STATUS2                       ((0x33fd  << 2) + 0xff000000)
#define DOLBY_CORE1A_STATUS3                       ((0x33fe  << 2) + 0xff000000)
#define DOLBY_CORE1A_DMA_PORT                      ((0x33ff  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby1a_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY2A_VCBUS_BASE = 0x34
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby2a_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE2A_REG_START                     ((0x3400  << 2) + 0xff000000)
#define DOLBY_CORE2A_CLKGATE_CTRL                  ((0x3432  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL0                    ((0x3433  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL1                    ((0x3434  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL2                    ((0x3435  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL3                    ((0x3436  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL4                    ((0x3437  << 2) + 0xff000000)
#define DOLBY_CORE2A_SWAP_CTRL5                    ((0x3438  << 2) + 0xff000000)
#define DOLBY_CORE2A_DMA_CTRL                      ((0x3439  << 2) + 0xff000000)
#define DOLBY_CORE2A_DMA_STATUS                    ((0x343a  << 2) + 0xff000000)
#define DOLBY_CORE2A_STATUS0                       ((0x343b  << 2) + 0xff000000)
#define DOLBY_CORE2A_STATUS1                       ((0x343c  << 2) + 0xff000000)
#define DOLBY_CORE2A_STATUS2                       ((0x343d  << 2) + 0xff000000)
#define DOLBY_CORE2A_STATUS3                       ((0x343e  << 2) + 0xff000000)
#define DOLBY_CORE2A_DMA_PORT                      ((0x343f  << 2) + 0xff000000)
#define DOLBY_CORE2A_AXI2DMA_CTRL0                 ((0x3440  << 2) + 0xff000000)
#define DOLBY_CORE2A_AXI2DMA_CTRL1                 ((0x3441  << 2) + 0xff000000)
#define DOLBY_CORE2A_AXI2DMA_CTRL2                 ((0x3442  << 2) + 0xff000000)
#define DOLBY_CORE2A_AXI2DMA_CTRL3                 ((0x3443  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby2a_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY2B_VCBUS_BASE = 0x35
// -----------------------------------------------
//===========================================================================
//`include "dolby2b_regs.h"
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY3_VCBUS_BASE = 0x36
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby3_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE3_REG_START                      ((0x3600  << 2) + 0xff000000)
#define DOLBY_CORE3_CLKGATE_CTRL                   ((0x36f0  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL0                     ((0x36f1  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL1                     ((0x36f2  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL2                     ((0x36f3  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL3                     ((0x36f4  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL4                     ((0x36f5  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL5                     ((0x36f6  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL6                     ((0x36f7  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL7                     ((0x36f8  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL8                     ((0x36f9  << 2) + 0xff000000)
#define DOLBY_CORE3_SWAP_CTRL9                     ((0x36fa  << 2) + 0xff000000)
#define DOLBY_CORE3_STATUS0                        ((0x36fb  << 2) + 0xff000000)
#define DOLBY_CORE3_STATUS1                        ((0x36fc  << 2) + 0xff000000)
#define DOLBY_CORE3_STATUS2                        ((0x36fd  << 2) + 0xff000000)
#define DOLBY_CORE3_STATUS3                        ((0x36fe  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby3_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpu_madc_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  MADC_VCBUS_BASE = 0x37
// -----------------------------------------------
// 0x00-0x28
//
// Reading file:  ./nr4_nm_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR4_MCNR_SAD_GAIN                          ((0x3700  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_nr4_bld12vs3_usemaxsad     // unsigned , default = 0  use minsad/maxsad instead of minsad/avgsad to decision if it was texture or flat region, 1: use minsad/maxsad
//Bit 23:16        reg_nr4_bld12vs3_rate_gain     // unsigned , default = 64  gain to minsad/maxsad or minsad/avgsad before LUT, 64 normalized as "1"
//Bit 15: 8        reg_nr4_bld1vs2_rate_gain      // unsigned , default = 32  gain to minsad/maxsad or minsad/avgsad before the LUT, 64 normalized as"1"
//Bit  7: 0        reg_nr4_coefblt_gain           // unsigned , default = 64  gain to final coefblt, normalized 64 as "1"
#define NR4_MCNR_LPF_CTRL                          ((0x3701  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:22        reg_nr4_preflt_alpofst         // signed , default = 0  pre filter alpha ofst
//Bit 21:16        reg_nr4_preflt_alpgain         // unsigned , default = 16  pre filter alpha gain
//Bit 15:14        reg_nr4_preflt_alpsel          // unsigned , default = 3  pre filter alpha selection for adaptive blending, 0: mv pointed sad, 1: weighted mv pointed sad, 2or3: coefblt
//Bit 13: 8        reg_nr4_avgsad_gain            // unsigned , default = 8  gain for avg sad before luts
//Bit  7            reserved
//Bit  6           reg_nr4_maxsad_mod             // unsigned , default = 1  max sad select mode, 0: mx2_sad, 1: max sad
//Bit  5           reg_nr4_minsad_mod             // unsigned , default = 1  min sad select mode, 0: sad with min err, 1: min sad
//Bit  4           reg_nr4_minmaxsad_lpf          // unsigned , default = 1  mode of lpf for minmaxsad, 0: no LPF, 1: [1 2 1]/4
//Bit  3           reg_nr4_avgsad_lpf             // unsigned , default = 1  mode of lpf for avgsad, 0: no LPF, 1: [1 2 1]/4
//Bit  2           reg_nr4_minavgsad_ratio_lpf    // unsigned , default = 1  mode of lpf for minsad/avgsad and zmvsad/avgsad, 0: no LPF, 1: [1 2 1]/4
//Bit  1           reg_nr4_bldvs_lut_lpf          // unsigned , default = 1  mode of lpf for bld12vs3 and bld1vs2 LUT results, 0: no LPF, 1: [1 2 1]/4
//Bit  0           reg_nr4_final_coef_lpf         // unsigned , default = 1  mode of lpf for final coef_blt_blend123, 0: no LPF, 1: [1 2 1]/4
#define NR4_MCNR_BLD_VS3LUT0                       ((0x3702  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut0     // unsigned , default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut1     // unsigned , default = 8
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut2     // unsigned , default = 10
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut3     // unsigned , default = 11
#define NR4_MCNR_BLD_VS3LUT1                       ((0x3703  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut4     // unsigned , default = 12
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut5     // unsigned , default = 14
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut6     // unsigned , default = 16
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut7     // unsigned , default = 24
#define NR4_MCNR_BLD_VS3LUT2                       ((0x3704  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld12vs3_lut8     // unsigned , default = 50
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld12vs3_lut9     // unsigned , default = 58
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld12vs3_lut10    // unsigned , default = 63
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld12vs3_lut11    // unsigned , default = 63
#define NR4_MCNR_BLD_VS2LUT0                       ((0x3705  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld1vs2_lut0      // unsigned , default = 63
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld1vs2_lut1      // unsigned , default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld1vs2_lut2      // unsigned , default = 16
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld1vs2_lut3      // unsigned , default = 8
#define NR4_MCNR_BLD_VS2LUT1                       ((0x3706  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr4_bld1vs2_lut4      // unsigned , default = 4
//Bit 23:22        reserved
//Bit 21:16        reg_nr4_bld1vs2_lut5      // unsigned , default = 2
//Bit 15:14        reserved
//Bit 13: 8        reg_nr4_bld1vs2_lut6      // unsigned , default = 1
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr4_bld1vs2_lut7      // unsigned , default = 0
#define NR4_COEFBLT_LUT10                          ((0x3707  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut10     // signed , default = -128
//Bit 23:16        reg_nr4_coefblt_lut11     // signed , default = -128
//Bit 15: 8        reg_nr4_coefblt_lut12     // signed , default = -126
//Bit  7: 0        reg_nr4_coefblt_lut13     // signed , default = -124
#define NR4_COEFBLT_LUT11                          ((0x3708  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut14     // signed , default = -120
//Bit 23:16        reg_nr4_coefblt_lut15     // signed , default = -110
//Bit 15: 8        reg_nr4_coefblt_lut16     // signed , default = -100
//Bit  7: 0        reg_nr4_coefblt_lut17     // signed , default = -90
#define NR4_COEFBLT_LUT12                          ((0x3709  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut18     // signed , default = -56
//Bit 23:16        reg_nr4_coefblt_lut19     // signed , default = -32
//Bit 15: 8        reg_nr4_coefblt_lut110    // signed , default = -64
//Bit  7: 0        reg_nr4_coefblt_lut111    // signed , default = -128
#define NR4_COEFBLT_LUT20                          ((0x370a  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut20     // signed , default = -128
//Bit 23:16        reg_nr4_coefblt_lut21     // signed , default = -120
//Bit 15: 8        reg_nr4_coefblt_lut22     // signed , default = -112
//Bit  7: 0        reg_nr4_coefblt_lut23     // signed , default = -104
#define NR4_COEFBLT_LUT21                          ((0x370b  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut24     // signed , default = -96
//Bit 23:16        reg_nr4_coefblt_lut25     // signed , default = -88
//Bit 15: 8        reg_nr4_coefblt_lut26     // signed , default = -76
//Bit  7: 0        reg_nr4_coefblt_lut27     // signed , default = -64
#define NR4_COEFBLT_LUT22                          ((0x370c  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut28     // signed , default = -48
//Bit 23:16        reg_nr4_coefblt_lut29     // signed , default = -32
//Bit 15: 8        reg_nr4_coefblt_lut210    // signed , default = -64
//Bit  7: 0        reg_nr4_coefblt_lut211    // signed , default = -108
#define NR4_COEFBLT_LUT30                          ((0x370d  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut30     // signed , default = 8
//Bit 23:16        reg_nr4_coefblt_lut31     // signed , default = 16
//Bit 15: 8        reg_nr4_coefblt_lut32     // signed , default = 24
//Bit  7: 0        reg_nr4_coefblt_lut33     // signed , default = 30
#define NR4_COEFBLT_LUT31                          ((0x370e  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut34     // signed , default = 36
//Bit 23:16        reg_nr4_coefblt_lut35     // signed , default = 48
//Bit 15: 8        reg_nr4_coefblt_lut36     // signed , default = 70
//Bit  7: 0        reg_nr4_coefblt_lut37     // signed , default = 96
#define NR4_COEFBLT_LUT32                          ((0x370f  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_coefblt_lut38     // signed , default = 120
//Bit 23:16        reg_nr4_coefblt_lut39     // signed , default = 64
//Bit 15: 8        reg_nr4_coefblt_lut310    // signed , default = 16
//Bit  7: 0        reg_nr4_coefblt_lut311    // signed , default = -8
#define NR4_COEFBLT_CONV                           ((0x3710  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_nr4_coefblt_convmin   // unsigned , default = 0  minimum of coef. bilateral conversion
//Bit 15: 8        reg_nr4_coefblt_convmax   // unsigned , default = 255  maximum of coef. bilateral conversion
//Bit  7: 0        reg_nr4_coefblt_convmid   // unsigned , default = 128  value at midpoint of coef. bilateral conversion
#define NR4_DBGWIN_YX0                             ((0x3711  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_dgbwin_yx0        // unsigned , default = 100  ystart for debug window
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_dgbwin_yx1        // unsigned , default = 160  yend   for debug window
#define NR4_DBGWIN_YX1                             ((0x3712  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_dgbwin_yx2        // unsigned , default = 200  xstart for debug window
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_dgbwin_yx3        // unsigned , default = 300  xend   for debug window
#define NR4_NM_X_CFG                               ((0x3713  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_nm_xst            // unsigned , default = 8  start for noise meter statistic, dft = 8
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_nm_xed            // unsigned , default = 711  end for noise meter statistic, dft = HSIZE-8-1;
#define NR4_NM_Y_CFG                               ((0x3714  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_nr4_nm_yst            // unsigned , default = 8  start for noise meter statistic, dft = 8;
//Bit 15:14        reserved
//Bit 13: 0        reg_nr4_nm_yed            // unsigned , default = 231  end for noise meter statistic, dft = VSIZE-8-1;
#define NR4_NM_SAD_THD                             ((0x3715  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_nr4_nm_sad_thd        // unsigned , default = 255  threshold for (flat region) sad count, dft = 4
#define NR4_MCNR_BANDSPLIT_PRAM                    ((0x3716  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4           reg_nr4_mc_use_bandsplit     // unsigned , default = 1  separate lp and us for mc IIR filter, 0: no BS used; 1: use BS
//Bit  3           reg_nr4_mc_apply_on_lp       // unsigned , default = 1  use mcnr only on lowpass portion;
//Bit  2           reg_nr4_mc_apply_on_us       // unsigned , default = 1  use mcnr only on lp complimentary portion;
//Bit  1: 0        reg_nr4_mc_zmvbs_use_adplpf  // unsigned , default = 1  use adaptive LPF for the zmv pointing data for MCNR, for abs(mvx)<th
#define NR4_MCNR_ALP1_SGN_COR                      ((0x3717  << 2) + 0xff000000)
//Bit 31:24        reg_nr4_mc_aph1_sgn_coring0  // unsigned , default = 10  coring to cur-pre before do sgn decision
//Bit 23:16        reg_nr4_mc_aph1_sgn_coring1  // unsigned , default = 7  coring to cur-pre before do sgn decision
//Bit 15: 8        reg_nr4_mc_aph1_sgn_core_max0 // unsigned , default = 90  maximum of coring, default = 30/15
//Bit  7: 0        reg_nr4_mc_aph1_sgn_core_max1 // unsigned , default = 15  maximum of coring, default = 30/15
#define NR4_MCNR_ALP1_SGN_PRAM                     ((0x3718  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10           reg_nr4_mc_alp1_sgn_half       // unsigned , default = 1  half block sgn sum mode enable, 0: only use 3x5 whole block sum of sgns; 1: use max(sgn_3x5, sqrt(sgn_left+sgn_righ))
//Bit  9           reg_nr4_mc_alp1_sgn_frczmv   // unsigned , default = 1  force zmv to calculate the sign_sum;
//Bit  8           reg_nr4_mc_alp1_sgnmvx_mode  // unsigned , default = 1  blend mode of sgnlut and mvxlut blend mode: 0: sgnlut+ mvxlut; 1: max(sgnlut, mvxlut), default =1
//Bit  7: 4        reg_nr4_mc_aph1_sgn_crate0   // unsigned , default = 4  rate to var, norm to 16 as 1, default = 2
//Bit  3: 0        reg_nr4_mc_aph1_sgn_crate1   // unsigned , default = 2  rate to var, norm to 16 as 1, default = 2
#define NR4_MCNR_ALP1_MVX_LUT1                     ((0x3719  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_mc_alp1_mvx_luty3  // unsigned , default = 14  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc3  // unsigned , default = 14  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 23:20        reg_nr4_mc_alp1_mvx_luty2  // unsigned , default = 12  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc2  // unsigned , default = 12  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 15:12        reg_nr4_mc_alp1_mvx_luty1  // unsigned , default = 5  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc1  // unsigned , default = 5  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty0  // unsigned , default = 3  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc0  // unsigned , default = 3  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define NR4_MCNR_ALP1_MVX_LUT2                     ((0x371a  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_mc_alp1_mvx_luty7  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 27:24        reg_nr4_mc_alp1_mvx_lutc7  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 23:20        reg_nr4_mc_alp1_mvx_luty6  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 19:16        reg_nr4_mc_alp1_mvx_lutc6  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 15:12        reg_nr4_mc_alp1_mvx_luty5  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit 11: 8        reg_nr4_mc_alp1_mvx_lutc5  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty4  // unsigned , default = 15  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc4  // unsigned , default = 15  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define NR4_MCNR_ALP1_MVX_LUT3                     ((0x371b  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_nr4_mc_alp1_mvx_luty8  // unsigned , default = 6  alp1 of luma vas mvx(0~7), and alp1 vs mvy(0,1)
//Bit  3: 0        reg_nr4_mc_alp1_mvx_lutc8  // unsigned , default = 6  alp1 of chrm vas mvx(0~7), and alp1 vs mvy(0,1)
#define NR4_MCNR_ALP1_LP_PRAM                      ((0x371c  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nr4_mc_alp1_lp_sel    // unsigned , default = 1  mode for alp1_lp for lp portion IIR, 0: apha1, 1:dc_dif vs ac analysis; 2: gain/ofst of alp1; 3: max of #1/#2 results
//Bit 15: 8        reg_nr4_mc_alp1_lp_gain   // unsigned , default = 64  gain to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =64;
//Bit  7: 0        reg_nr4_mc_alp1_lp_ofst   // signed , default = 0  offset to alp1 to get the alp1_lp = alp1*gain/32 + ofset, default =10;
#define NR4_MCNR_ALP1_SGN_LUT1                     ((0x371d  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_mc_alp1_sgn_lut0  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 27:24        reg_nr4_mc_alp1_sgn_lut1  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 23:20        reg_nr4_mc_alp1_sgn_lut2  // unsigned , default = 3  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 19:16        reg_nr4_mc_alp1_sgn_lut3  // unsigned , default = 4  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 15:12        reg_nr4_mc_alp1_sgn_lut4  // unsigned , default = 5  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut5  // unsigned , default = 6  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut6  // unsigned , default = 7  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut7  // unsigned , default = 8  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
#define NR4_MCNR_ALP1_SGN_LUT2                     ((0x371e  << 2) + 0xff000000)
//Bit 31:28        reg_nr4_mc_alp1_sgn_lut8   // unsigned , default = 9  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 27:24        reg_nr4_mc_alp1_sgn_lut9   // unsigned , default = 10  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 23:20        reg_nr4_mc_alp1_sgn_lut10  // unsigned , default = 11  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 19:16        reg_nr4_mc_alp1_sgn_lut11  // unsigned , default = 12  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 15:12        reg_nr4_mc_alp1_sgn_lut12  // unsigned , default = 13  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit 11: 8        reg_nr4_mc_alp1_sgn_lut13  // unsigned , default = 14  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  7: 4        reg_nr4_mc_alp1_sgn_lut14  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
//Bit  3: 0        reg_nr4_mc_alp1_sgn_lut15  // unsigned , default = 15  alp1 vs x=abs|sgn(cur-pre)|, if x is small, less possibility of flat region move
#define NR4_RO_NM_SAD_SUM                          ((0x371f  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_nm_sad_sum         // unsigned , default = 0  sum of sad, for scene change detection, in noise meter
#define NR4_RO_NM_SAD_CNT                          ((0x3720  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_nm_sad_cnt         // unsigned , default = 0  cnt of sad, for scene change detection, in noise meter
#define NR4_RO_NM_VAR_SUM                          ((0x3721  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_nm_var_sum         // unsigned , default = 0  sum of var, for noise level detection, in noise meter
#define NR4_RO_NM_VAR_SCNT                         ((0x3722  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_nm_var_cnt         // unsigned , default = 0  cnt of var, for noise level detection, in noise meter
#define NR4_RO_NM_VAR_MIN_MAX                      ((0x3723  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:12        ro_nr4_nm_min_var         // unsigned , default = 1023  min of var, for noise level detection, in noise meter
//Bit 11:10        reserved
//Bit  9: 0        ro_nr4_nm_max_var         // unsigned , default = 0  max of var, for noise level detection, in noise meter
#define NR4_RO_NR4_DBGPIX_NUM                      ((0x3724  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        ro_nr4_dbgpix_num         // unsigned , default = 0  number of pixels statistic involved (removed?)
#define NR4_RO_NR4_BLDVS2_SUM                      ((0x3725  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_bld1vs2_sum        // unsigned , default = 0  sum of blend_1vs2 with the debug window
#define NR4_BLDVS3_SUM                             ((0x3726  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_bld12vs3_sum       // unsigned , default = 0  sum of blend_12vs3 with the debug window
#define NR4_COEF12_SUM                             ((0x3727  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_coef12_sum         // signed , default = 0  sum of coef_blt_blend12 with the debug window, under 8 bits precision
#define NR4_COEF123_SUM                            ((0x3728  << 2) + 0xff000000)
//Bit 31: 0        ro_nr4_coef123_sum        // signed , default = 0  sum of coef_final with the debug window, under 8 bits precision
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./nr4_nm_regs.h
//
// 0x30-0x33
//
// Reading file:  ./vpu_xlr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define XLR_CTRL                                   ((0x3730  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22           reg_xlr_en                // unsigned , default = 1   enable bits for xlr function, 1: enable, 0: disable	       default = 1
//Bit 21           reg_xlr_side_en           // unsigned , default = 1   enable to filter the above and below lines with xlr filter, default = 1
//Bit 20           reg_xlr_3lines            // unsigned , default = 1   3 lines version enable                    default= 0
//Bit 19:16        reg_xlr_simlp_gain        // unsigned , default = 12   gain to simlp  to decide if need the XLR, default= 12
//Bit 15:14        reserved
//Bit 13: 8        reg_xlr_ooplp_gain        // unsigned , default = 6    gain to out-of-phase lp error to decide if need the XLR, birn to 16 as 1, default= 3
//Bit  7: 0        reg_xlr_dislp_thrd        // unsigned , default = 64   threshold to lp error to discard XLR. default= 80
#define XLR_THRD                                   ((0x3731  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_xlr_txt_core          // unsigned , default = 3    coring to texture                         default = 3, (3/32)
//Bit 23:16        reg_xlr_err_thrd2         // unsigned , default = 5    threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, defaut= {20, 10, 5}
//Bit 15: 8        reg_xlr_err_thrd1         // unsigned , default = 10   threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, defaut= {20, 10, 5}
//Bit  7: 0        reg_xlr_err_thrd0         // unsigned , default = 20   threshold to error to decide blending coef, 0, 1/4, 1/2, 1.0, defaut= {20, 10, 5}
#define XLR_HCT_THRD                               ((0x3732  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reg_xlr_hct_step          // unsigned , default = 1  horizontal chroma diff steps, 0: abs[-1 (2) -1]; 1: abs[-1 0 (2) 0 -1], 2: abs[-1 0 0 (2) 0 0 -1]; 3:abs[-1 0 0 0 (2) 0 0 0 -1]
//Bit 25:24        reg_xlr_hct_lpf           // unsigned , default = 1  horizontal chroma diff low-pass filter enable, 0: no HLPF; 1: [1 2 1]; 2: max[-1:1]; 3: max[-2:2]
//Bit 23:16        reg_xlr_hct_thr           // unsigned , default = 20  horizontal chroma diff threshold for xlr enable, to save the horizontal no color tran mode
//Bit 15: 8        reg_xlr_sat_thr           // unsigned , default = 8  saturation threshold for xlr enable, the smaller of the threshold , the more will do xlr;
//Bit  7: 2        reg_xlr_hmargin           // unsigned , default = 3  left/right number of pixels without xlr;
//Bit  1            reserved
//Bit  0           reg_xlr_hpf_only          // unsigned , default = 0  enable for only do xlr filter on high pass portion of the data, instead full data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_xlr_regs.h
//
// 0x38-0x3f
//
// Reading file:  ./nr_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR_DB_FLT_CTRL                             ((0x3738  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 0  0 : no reset seed  1: reload chroma seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 0  0 : no reset seed  1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define NR_DB_FLT_YC_THRD                          ((0x3739  << 2) + 0xff000000)
//Bit 31:28        reg_nrdeband_luma_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 27:24        reg_nrdeband_luma_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
//Bit 23:20        reg_nrdeband_luma_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit 19:16        reg_nrdeband_luma_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
//Bit 15:12        reg_nrdeband_chrm_th3     // unsigned , default = 9   threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 11: 8        reg_nrdeband_chrm_th2     // unsigned , default = 7   elseif <th[1] use (lpf*3 + y)/4
//Bit  7: 4        reg_nrdeband_chrm_th1     // unsigned , default = 6   elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  3: 0        reg_nrdeband_chrm_th0     // unsigned , default = 5   elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define NR_DB_FLT_RANDLUT                          ((0x373a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   lut0
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   lut0
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   lut0
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   lut0
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   lut0
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   lut0
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   lut0
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   lut0
#define NR_DB_FLT_PXI_THRD                         ((0x373b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
#define NR_DB_FLT_SEED_Y                           ((0x373c  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define NR_DB_FLT_SEED_U                           ((0x373d  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
#define NR_DB_FLT_SEED_V                           ((0x373e  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
#define NR_DB_FLT_SEED3                            ((0x373f  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./nr_deband_regs.h
//
// 0x40-0x43
//
// Reading file:  ./nr_downscale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define NR_DS_BUF_SIZE                             ((0x3740  << 2) + 0xff000000)
//Bit 31:24        dsbuf_rowmax               // unsigned , default = 96
//Bit 23:16        dsbuf_colmax               // unsigned , default = 128
//Bit 15: 8        dsbuf_orow                 // unsigned , default = 128
//Bit  7: 0        dsbuf_ocol                 // unsigned , default = 128
#define NR_DS_CTRL                                 ((0x3741  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_h_step                 // unsigned , default = 8   rand lut0
//Bit 23:22        reserved
//Bit 21:16        reg_v_step                 // unsigned , default = 8   rand lut0
//Bit 15            reserved
//Bit 14:12        reg_haa_sel                // unsigned , default = 4
//Bit 11            reserved
//Bit 10: 8        reg_vaa_sel                // unsigned , default = 4
//Bit  7            reserved
//Bit  6: 4        reg_use_hphase             // unsigned , default = 1
//Bit  3: 1        reserved
//Bit  0           reg_yuv_bldmode            // unsigned , default = 0
#define NR_DS_OFFSET                               ((0x3742  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_h_ofst                // signed , default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_v_ofst                // signed , default = 0
#define NR_DS_BLD_COEF                             ((0x3743  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_yuv_bldcoef2          // unsigned , default = 128
//Bit 15: 8        reg_yuv_bldcoef1          // unsigned , default = 64
//Bit  7: 0        reg_yuv_bldcoef0          // unsigned , default = 64
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./nr_downscale_regs.h
//
// 0x44-0xbf
//
// Reading file:  ./di_scale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DI_SCO_FIFO_CTRL                           ((0x374e  << 2) + 0xff000000)
#define DI_SC_TOP_CTRL                             ((0x374f  << 2) + 0xff000000)
// dummy data used in the DI preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR
#define DI_SC_DUMMY_DATA                           ((0x3750  << 2) + 0xff000000)
//input line length used in DI
#define DI_SC_LINE_IN_LENGTH                       ((0x3751  << 2) + 0xff000000)
//input Picture height used in DI
#define DI_SC_PIC_IN_HEIGHT                        ((0x3752  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 13    if true, vertical separated coef enable
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8:7   type of index, 00: vertical coef, 01: vertical chroma coef: 10: horizontal coef, 11: resevered
//Bit 6:0 	coef index
#define DI_SC_COEF_IDX                             ((0x3753  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
#define DI_SC_COEF                                 ((0x3754  << 2) + 0xff000000)
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		.
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region
//		.
//  ---------------------------
//  ---------------------------  <------ region1_startp
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define DI_VSC_REGION12_STARTP                     ((0x3755  << 2) + 0xff000000)
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define DI_VSC_REGION34_STARTP                     ((0x3756  << 2) + 0xff000000)
#define DI_VSC_REGION4_ENDP                        ((0x3757  << 2) + 0xff000000)
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define DI_VSC_START_PHASE_STEP                    ((0x3758  << 2) + 0xff000000)
//vertical scaler region0 phase slope, Bit24 signed bit
#define DI_VSC_REGION0_PHASE_SLOPE                 ((0x3759  << 2) + 0xff000000)
//vertical scaler region1 phase slope, Bit24 signed bit
#define DI_VSC_REGION1_PHASE_SLOPE                 ((0x375a  << 2) + 0xff000000)
//vertical scaler region3 phase slope, Bit24 signed bit
#define DI_VSC_REGION3_PHASE_SLOPE                 ((0x375b  << 2) + 0xff000000)
//vertical scaler region4 phase slope, Bit24 signed bit
#define DI_VSC_REGION4_PHASE_SLOPE                 ((0x375c  << 2) + 0xff000000)
//Bit 18:17     double line mode, input/output line width of vscaler becomes 2X,
//           so only 2 line buffer in this case, use for 3D line by line interleave scaling
//           bit1 true, double the input width and half input height, bit0 true, change line buffer 2 lines instead of 4 lines
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field
#define DI_VSC_PHASE_CTRL                          ((0x375d  << 2) + 0xff000000)
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define DI_VSC_INI_PHASE                           ((0x375e  << 2) + 0xff000000)
//Bit 28:16 region1 startp
//Bit 12:0 region2 startp
#define DI_HSC_REGION12_STARTP                     ((0x3760  << 2) + 0xff000000)
//Bit 28:16 region3 startp
//Bit 12:0 region4 startp
#define DI_HSC_REGION34_STARTP                     ((0x3761  << 2) + 0xff000000)
#define DI_HSC_REGION4_ENDP                        ((0x3762  << 2) + 0xff000000)
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part
//Bit 23:0	fraction part
#define DI_HSC_START_PHASE_STEP                    ((0x3763  << 2) + 0xff000000)
//horizontal scaler region0 phase slope, Bit24 signed bit
#define DI_HSC_REGION0_PHASE_SLOPE                 ((0x3764  << 2) + 0xff000000)
//horizontal scaler region1 phase slope, Bit24 signed bit
#define DI_HSC_REGION1_PHASE_SLOPE                 ((0x3765  << 2) + 0xff000000)
//horizontal scaler region3 phase slope, Bit24 signed bit
#define DI_HSC_REGION3_PHASE_SLOPE                 ((0x3766  << 2) + 0xff000000)
//horizontal scaler region4 phase slope, Bit24 signed bit
#define DI_HSC_REGION4_PHASE_SLOPE                 ((0x3767  << 2) + 0xff000000)
//Bit 22:21   horizontal scaler initial repeat pixel0 number0
//Bit 19:16   horizontal scaler initial receiving number0
//Bit 15:0    horizontal scaler top field initial phase0
#define DI_HSC_PHASE_CTRL                          ((0x3768  << 2) + 0xff000000)
// Bit 31 if false, di_scale swap layer bypass
// bit 30 if true, scale before diwr, else scaler before nrwr
// Bit 22 if true, divide VSC line length 2 as the HSC input length, otherwise VSC length length is the same as the VSC line length,
//                 just for special usage, more flexibility
// Bit 21 if true, prevsc uses lin buffer, otherwise prevsc does not use line buffer, it should be same as prevsc_en
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler
// Bit 2:0 vertical scaler bank length
#define DI_SC_MISC                                 ((0x3769  << 2) + 0xff000000)
#define DI_HSC_PHASE_CTRL1                         ((0x376a  << 2) + 0xff000000)
#define DI_HSC_INI_PAT_CTRL                        ((0x376b  << 2) + 0xff000000)
#define DI_SC_GCLK_CTRL                            ((0x376c  << 2) + 0xff000000)
#define DI_SC_HOLD_LINE                            ((0x376d  << 2) + 0xff000000)
#define DI_HDR_IN_HSIZE                            ((0x376e  << 2) + 0xff000000)
#define DI_HDR_IN_VSIZE                            ((0x376f  << 2) + 0xff000000)
#define DI_HDR_OFFSET         0x70
#define DI_HDR2_CTRL                               ((0x3770  << 2) + 0xff000000)
#define DI_HDR2_CLK_GATE                           ((0x3771  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF00_01                  ((0x3772  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF02_10                  ((0x3773  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF11_12                  ((0x3774  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF20_21                  ((0x3775  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF22                     ((0x3776  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF30_31                  ((0x3777  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF32_40                  ((0x3778  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_COEF41_42                  ((0x3779  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_OFFSET0_1                  ((0x377a  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_OFFSET2                    ((0x377b  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_PRE_OFFSET0_1              ((0x377c  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_PRE_OFFSET2                ((0x377d  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF00_01                  ((0x377e  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF02_10                  ((0x377f  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF11_12                  ((0x3780  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF20_21                  ((0x3781  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF22                     ((0x3782  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF30_31                  ((0x3783  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF32_40                  ((0x3784  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_COEF41_42                  ((0x3785  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_OFFSET0_1                  ((0x3786  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_OFFSET2                    ((0x3787  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_PRE_OFFSET0_1              ((0x3788  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_PRE_OFFSET2                ((0x3789  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_CLIP                       ((0x378a  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_CLIP                       ((0x378b  << 2) + 0xff000000)
#define DI_HDR2_CGAIN_OFFT                         ((0x378c  << 2) + 0xff000000)
#define DI_EOTF_LUT_ADDR_PORT                      ((0x378e  << 2) + 0xff000000)
#define DI_EOTF_LUT_DATA_PORT                      ((0x378f  << 2) + 0xff000000)
#define DI_OETF_LUT_ADDR_PORT                      ((0x3790  << 2) + 0xff000000)
#define DI_OETF_LUT_DATA_PORT                      ((0x3791  << 2) + 0xff000000)
#define DI_CGAIN_LUT_ADDR_PORT                     ((0x3792  << 2) + 0xff000000)
#define DI_CGAIN_LUT_DATA_PORT                     ((0x3793  << 2) + 0xff000000)
#define DI_HDR2_CGAIN_COEF0                        ((0x3794  << 2) + 0xff000000)
#define DI_HDR2_CGAIN_COEF1                        ((0x3795  << 2) + 0xff000000)
#define DI_OGAIN_LUT_ADDR_PORT                     ((0x3796  << 2) + 0xff000000)
#define DI_OGAIN_LUT_DATA_PORT                     ((0x3797  << 2) + 0xff000000)
#define DI_HDR2_ADPS_CTRL                          ((0x3798  << 2) + 0xff000000)
#define DI_HDR2_ADPS_ALPHA0                        ((0x3799  << 2) + 0xff000000)
#define DI_HDR2_ADPS_ALPHA1                        ((0x379a  << 2) + 0xff000000)
#define DI_HDR2_ADPS_BETA0                         ((0x379b  << 2) + 0xff000000)
#define DI_HDR2_ADPS_BETA1                         ((0x379c  << 2) + 0xff000000)
#define DI_HDR2_ADPS_BETA2                         ((0x379d  << 2) + 0xff000000)
#define DI_HDR2_ADPS_COEF0                         ((0x379e  << 2) + 0xff000000)
#define DI_HDR2_ADPS_COEF1                         ((0x379f  << 2) + 0xff000000)
#define DI_HDR2_GMUT_CTRL                          ((0x37a0  << 2) + 0xff000000)
#define DI_HDR2_GMUT_COEF0                         ((0x37a1  << 2) + 0xff000000)
#define DI_HDR2_GMUT_COEF1                         ((0x37a2  << 2) + 0xff000000)
#define DI_HDR2_GMUT_COEF2                         ((0x37a3  << 2) + 0xff000000)
#define DI_HDR2_GMUT_COEF3                         ((0x37a4  << 2) + 0xff000000)
#define DI_HDR2_GMUT_COEF4                         ((0x37a5  << 2) + 0xff000000)
#define DI_HDR2_PIPE_CTRL1                         ((0x37a6  << 2) + 0xff000000)
#define DI_HDR2_PIPE_CTRL2                         ((0x37a7  << 2) + 0xff000000)
#define DI_HDR2_PIPE_CTRL3                         ((0x37a8  << 2) + 0xff000000)
#define DI_HDR2_PROC_WIN1                          ((0x37a9  << 2) + 0xff000000)
#define DI_HDR2_PROC_WIN2                          ((0x37aa  << 2) + 0xff000000)
#define DI_HDR2_MATRIXI_EN_CTRL                    ((0x37ab  << 2) + 0xff000000)
#define DI_HDR2_MATRIXO_EN_CTRL                    ((0x37ac  << 2) + 0xff000000)
#define DI_HDR2_HIST_CTRL                          ((0x37ad  << 2) + 0xff000000)
#define DI_HDR2_HIST_H_START_END                   ((0x37ae  << 2) + 0xff000000)
#define DI_HDR2_HIST_V_START_END                   ((0x37af  << 2) + 0xff000000)
#define DI_HDR2_HIST_RD                            ((0x378d  << 2) + 0xff000000)
#define DI_VIU_HSC_WIDTHM1                         ((0x37b0  << 2) + 0xff000000)
#define DI_VIU_HSC_PHASE_STEP                      ((0x37b1  << 2) + 0xff000000)
#define DI_VIU_HSC_CTRL                            ((0x37b2  << 2) + 0xff000000)
#define DI_VIU_HSC_PHASE_CTRL                      ((0x37b3  << 2) + 0xff000000)
#define DI_VIU_HSC_COEF                            ((0x37b4  << 2) + 0xff000000)
#define DI_VIU_HSC_COEF_IDX                        ((0x37b5  << 2) + 0xff000000)
#define DI_SC_PREHSC_COEF                          ((0x37b9  << 2) + 0xff000000)
#define DI_SC_PRE_SCALE_CTRL                       ((0x37ba  << 2) + 0xff000000)
#define DI_SC_PREVSC_COEF                          ((0x37bb  << 2) + 0xff000000)
#define DI_SC_PREHSC_COEF1                         ((0x37bc  << 2) + 0xff000000)
#define DI_DITH_CTRL                               ((0x3744  << 2) + 0xff000000)
#define DI_DITH_LUT_1                              ((0x3745  << 2) + 0xff000000)
#define DI_DITH_LUT_2                              ((0x3746  << 2) + 0xff000000)
#define DI_DITH_LUT_3                              ((0x3747  << 2) + 0xff000000)
#define DI_DITH_LUT_4                              ((0x3748  << 2) + 0xff000000)
#define DI_DITH_LUT_5                              ((0x3749  << 2) + 0xff000000)
#define DI_DITH_LUT_6                              ((0x374a  << 2) + 0xff000000)
#define DI_DITH_LUT_7                              ((0x374b  << 2) + 0xff000000)
#define DI_DITH_LUT_8                              ((0x374c  << 2) + 0xff000000)
#define DI_DITH_LUT_9                              ((0x374d  << 2) + 0xff000000)
#define DI_DITH_LUT_10                             ((0x37b6  << 2) + 0xff000000)
#define DI_DITH_LUT_11                             ((0x37b7  << 2) + 0xff000000)
#define DI_DITH_LUT_12                             ((0x37b8  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_scale_regs.h
//
//0x29-0x2f 0x34-0x37 0xc0~0xff
//
// Reading file:  ./di_arb_sub_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DI_SUB_RDARB_MODE                          ((0x37c0  << 2) + 0xff000000)
#define DI_SUB_RDARB_REQEN_SLV                     ((0x37c1  << 2) + 0xff000000)
#define DI_SUB_RDARB_WEIGH0_SLV                    ((0x37c2  << 2) + 0xff000000)
#define DI_SUB_RDARB_WEIGH1_SLV                    ((0x37c3  << 2) + 0xff000000)
#define DI_SUB_RDARB_UGT                           ((0x37c4  << 2) + 0xff000000)
#define DI_SUB_RDARB_LIMT0                         ((0x37c5  << 2) + 0xff000000)
#define DI_SUB_WRARB_MODE                          ((0x37c6  << 2) + 0xff000000)
#define DI_SUB_WRARB_REQEN_SLV                     ((0x37c7  << 2) + 0xff000000)
#define DI_SUB_WRARB_WEIGH0_SLV                    ((0x37c8  << 2) + 0xff000000)
#define DI_SUB_WRARB_WEIGH1_SLV                    ((0x37c9  << 2) + 0xff000000)
#define DI_SUB_WRARB_UGT                           ((0x37ca  << 2) + 0xff000000)
#define DI_SUB_RDWR_ARB_STATUS                     ((0x37cb  << 2) + 0xff000000)
#define DI_SUB_ARB_DBG_CTRL                        ((0x37cc  << 2) + 0xff000000)
#define DI_SUB_ARB_DBG_STAT                        ((0x37cd  << 2) + 0xff000000)
#define CONTRD_CTRL1                               ((0x37d0  << 2) + 0xff000000)
#define CONTRD_CTRL2                               ((0x37d1  << 2) + 0xff000000)
#define CONTRD_SCOPE_X                             ((0x37d2  << 2) + 0xff000000)
#define CONTRD_SCOPE_Y                             ((0x37d3  << 2) + 0xff000000)
#define CONTRD_RO_STAT                             ((0x37d4  << 2) + 0xff000000)
#define CONT2RD_CTRL1                              ((0x37d5  << 2) + 0xff000000)
#define CONT2RD_CTRL2                              ((0x37d6  << 2) + 0xff000000)
#define CONT2RD_SCOPE_X                            ((0x37d7  << 2) + 0xff000000)
#define CONT2RD_SCOPE_Y                            ((0x37d8  << 2) + 0xff000000)
#define CONT2RD_RO_STAT                            ((0x37d9  << 2) + 0xff000000)
#define MTNRD_CTRL1                                ((0x37da  << 2) + 0xff000000)
#define MTNRD_CTRL2                                ((0x37db  << 2) + 0xff000000)
#define MTNRD_SCOPE_X                              ((0x37dc  << 2) + 0xff000000)
#define MTNRD_SCOPE_Y                              ((0x37dd  << 2) + 0xff000000)
#define MTNRD_RO_STAT                              ((0x37de  << 2) + 0xff000000)
#define MCVECRD_CTRL1                              ((0x37df  << 2) + 0xff000000)
#define MCVECRD_CTRL2                              ((0x37e0  << 2) + 0xff000000)
#define MCVECRD_SCOPE_X                            ((0x37e1  << 2) + 0xff000000)
#define MCVECRD_SCOPE_Y                            ((0x37e2  << 2) + 0xff000000)
#define MCVECRD_RO_STAT                            ((0x37e3  << 2) + 0xff000000)
#define MCINFRD_CTRL1                              ((0x37e4  << 2) + 0xff000000)
#define MCINFRD_CTRL2                              ((0x37e5  << 2) + 0xff000000)
#define MCINFRD_SCOPE_X                            ((0x37e6  << 2) + 0xff000000)
#define MCINFRD_SCOPE_Y                            ((0x37e7  << 2) + 0xff000000)
#define MCINFRD_RO_STAT                            ((0x37e8  << 2) + 0xff000000)
#define CONTWR_X                                   ((0x37e9  << 2) + 0xff000000)
#define CONTWR_Y                                   ((0x37ea  << 2) + 0xff000000)
#define CONTWR_CTRL                                ((0x37eb  << 2) + 0xff000000)
#define CONTWR_CAN_SIZE                            ((0x37ec  << 2) + 0xff000000)
#define MTNWR_X                                    ((0x37ed  << 2) + 0xff000000)
#define MTNWR_Y                                    ((0x37ee  << 2) + 0xff000000)
#define MTNWR_CTRL                                 ((0x37ef  << 2) + 0xff000000)
#define MTNWR_CAN_SIZE                             ((0x37f0  << 2) + 0xff000000)
#define MCVECWR_X                                  ((0x37f1  << 2) + 0xff000000)
#define MCVECWR_Y                                  ((0x37f2  << 2) + 0xff000000)
#define MCVECWR_CTRL                               ((0x37f3  << 2) + 0xff000000)
#define MCVECWR_CAN_SIZE                           ((0x37f4  << 2) + 0xff000000)
#define MCINFWR_X                                  ((0x37f5  << 2) + 0xff000000)
#define MCINFWR_Y                                  ((0x37f6  << 2) + 0xff000000)
#define MCINFWR_CTRL                               ((0x37f7  << 2) + 0xff000000)
#define MCINFWR_CAN_SIZE                           ((0x37f8  << 2) + 0xff000000)
#define NRDSWR_X                                   ((0x37f9  << 2) + 0xff000000)
#define NRDSWR_Y                                   ((0x37fa  << 2) + 0xff000000)
#define NRDSWR_CTRL                                ((0x37fb  << 2) + 0xff000000)
#define NRDSWR_CAN_SIZE                            ((0x37fc  << 2) + 0xff000000)
#define CONTRD_BADDR                               ((0x3729  << 2) + 0xff000000)
#define CONT2RD_BADDR                              ((0x372a  << 2) + 0xff000000)
#define MTNRD_BADDR                                ((0x372b  << 2) + 0xff000000)
#define MCVECRD_BADDR                              ((0x372c  << 2) + 0xff000000)
#define MCINFRD_BADDR                              ((0x372d  << 2) + 0xff000000)
#define CONTWR_BADDR                               ((0x3734  << 2) + 0xff000000)
#define CONTWR_STRIDE                              ((0x3735  << 2) + 0xff000000)
#define MTNWR_BADDR                                ((0x3736  << 2) + 0xff000000)
#define MTNWR_STRIDE                               ((0x3737  << 2) + 0xff000000)
#define MCVECWR_BADDR                              ((0x372e  << 2) + 0xff000000)
#define MCVECWR_STRIDE                             ((0x372f  << 2) + 0xff000000)
#define MCINFWR_BADDR                              ((0x37ce  << 2) + 0xff000000)
#define MCINFWR_STRIDE                             ((0x37cf  << 2) + 0xff000000)
#define NRDSWR_BADDR                               ((0x37fd  << 2) + 0xff000000)
#define NRDSWR_STRIDE                              ((0x37fe  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./di_arb_sub_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_madc_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpp_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_HDR2_VCBUS_BASE = 0x38
// -----------------------------------------------
#define VD1_HDR2_OFFSET            0x00
#define VD2_HDR2_OFFSET            0x50
#define OSD1_HDR2_OFFSET           0xa0
//`include "hdr2_top_reg.h"
//vd1 0x00 - -x35
#define VD1_HDR2_CTRL                              ((0x3800  << 2) + 0xff000000)
#define VD1_HDR2_CLK_GATE                          ((0x3801  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF00_01                 ((0x3802  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF02_10                 ((0x3803  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF11_12                 ((0x3804  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF20_21                 ((0x3805  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF22                    ((0x3806  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF30_31                 ((0x3807  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF32_40                 ((0x3808  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_COEF41_42                 ((0x3809  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_OFFSET0_1                 ((0x380a  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_OFFSET2                   ((0x380b  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_PRE_OFFSET0_1             ((0x380c  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_PRE_OFFSET2               ((0x380d  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF00_01                 ((0x380e  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF02_10                 ((0x380f  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF11_12                 ((0x3810  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF20_21                 ((0x3811  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF22                    ((0x3812  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF30_31                 ((0x3813  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF32_40                 ((0x3814  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_COEF41_42                 ((0x3815  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_OFFSET0_1                 ((0x3816  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_OFFSET2                   ((0x3817  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_PRE_OFFSET0_1             ((0x3818  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_PRE_OFFSET2               ((0x3819  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_CLIP                      ((0x381a  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_CLIP                      ((0x381b  << 2) + 0xff000000)
#define VD1_HDR2_CGAIN_OFFT                        ((0x381c  << 2) + 0xff000000)
#define VD1_EOTF_LUT_ADDR_PORT                     ((0x381e  << 2) + 0xff000000)
#define VD1_EOTF_LUT_DATA_PORT                     ((0x381f  << 2) + 0xff000000)
#define VD1_OETF_LUT_ADDR_PORT                     ((0x3820  << 2) + 0xff000000)
#define VD1_OETF_LUT_DATA_PORT                     ((0x3821  << 2) + 0xff000000)
#define VD1_CGAIN_LUT_ADDR_PORT                    ((0x3822  << 2) + 0xff000000)
#define VD1_CGAIN_LUT_DATA_PORT                    ((0x3823  << 2) + 0xff000000)
#define VD1_HDR2_CGAIN_COEF0                       ((0x3824  << 2) + 0xff000000)
#define VD1_HDR2_CGAIN_COEF1                       ((0x3825  << 2) + 0xff000000)
#define VD1_OGAIN_LUT_ADDR_PORT                    ((0x3826  << 2) + 0xff000000)
#define VD1_OGAIN_LUT_DATA_PORT                    ((0x3827  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_CTRL                         ((0x3828  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_ALPHA0                       ((0x3829  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_ALPHA1                       ((0x382a  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_BETA0                        ((0x382b  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_BETA1                        ((0x382c  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_BETA2                        ((0x382d  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_COEF0                        ((0x382e  << 2) + 0xff000000)
#define VD1_HDR2_ADPS_COEF1                        ((0x382f  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_CTRL                         ((0x3830  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_COEF0                        ((0x3831  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_COEF1                        ((0x3832  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_COEF2                        ((0x3833  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_COEF3                        ((0x3834  << 2) + 0xff000000)
#define VD1_HDR2_GMUT_COEF4                        ((0x3835  << 2) + 0xff000000)
#define VD1_HDR2_PIPE_CTRL1                        ((0x3836  << 2) + 0xff000000)
#define VD1_HDR2_PIPE_CTRL2                        ((0x3837  << 2) + 0xff000000)
#define VD1_HDR2_PIPE_CTRL3                        ((0x3838  << 2) + 0xff000000)
#define VD1_HDR2_PROC_WIN1                         ((0x3839  << 2) + 0xff000000)
#define VD1_HDR2_PROC_WIN2                         ((0x383a  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXI_EN_CTRL                   ((0x383b  << 2) + 0xff000000)
#define VD1_HDR2_MATRIXO_EN_CTRL                   ((0x383c  << 2) + 0xff000000)
#define VD1_HDR2_HIST_CTRL                         ((0x383d  << 2) + 0xff000000)
#define VD1_HDR2_HIST_H_START_END                  ((0x383e  << 2) + 0xff000000)
#define VD1_HDR2_HIST_V_START_END                  ((0x383f  << 2) + 0xff000000)
#define VD1_HDR2_HIST_RD                           ((0x381d  << 2) + 0xff000000)
//vd2 0x50 - 0x85
#define VD2_HDR2_CTRL                              ((0x3850  << 2) + 0xff000000)
#define VD2_HDR2_CLK_GATE                          ((0x3851  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF00_01                 ((0x3852  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF02_10                 ((0x3853  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF11_12                 ((0x3854  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF20_21                 ((0x3855  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF22                    ((0x3856  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF30_31                 ((0x3857  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF32_40                 ((0x3858  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_COEF41_42                 ((0x3859  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_OFFSET0_1                 ((0x385a  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_OFFSET2                   ((0x385b  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_PRE_OFFSET0_1             ((0x385c  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_PRE_OFFSET2               ((0x385d  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF00_01                 ((0x385e  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF02_10                 ((0x385f  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF11_12                 ((0x3860  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF20_21                 ((0x3861  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF22                    ((0x3862  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF30_31                 ((0x3863  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF32_40                 ((0x3864  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_COEF41_42                 ((0x3865  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_OFFSET0_1                 ((0x3866  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_OFFSET2                   ((0x3867  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_PRE_OFFSET0_1             ((0x3868  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_PRE_OFFSET2               ((0x3869  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_CLIP                      ((0x386a  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_CLIP                      ((0x386b  << 2) + 0xff000000)
#define VD2_HDR2_CGAIN_OFFT                        ((0x386c  << 2) + 0xff000000)
#define VD2_EOTF_LUT_ADDR_PORT                     ((0x386e  << 2) + 0xff000000)
#define VD2_EOTF_LUT_DATA_PORT                     ((0x386f  << 2) + 0xff000000)
#define VD2_OETF_LUT_ADDR_PORT                     ((0x3870  << 2) + 0xff000000)
#define VD2_OETF_LUT_DATA_PORT                     ((0x3871  << 2) + 0xff000000)
#define VD2_CGAIN_LUT_ADDR_PORT                    ((0x3872  << 2) + 0xff000000)
#define VD2_CGAIN_LUT_DATA_PORT                    ((0x3873  << 2) + 0xff000000)
#define VD2_HDR2_CGAIN_COEF0                       ((0x3874  << 2) + 0xff000000)
#define VD2_HDR2_CGAIN_COEF1                       ((0x3875  << 2) + 0xff000000)
#define VD2_OGAIN_LUT_ADDR_PORT                    ((0x3876  << 2) + 0xff000000)
#define VD2_OGAIN_LUT_DATA_PORT                    ((0x3877  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_CTRL                         ((0x3878  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_ALPHA0                       ((0x3879  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_ALPHA1                       ((0x387a  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_BETA0                        ((0x387b  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_BETA1                        ((0x387c  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_BETA2                        ((0x387d  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_COEF0                        ((0x387e  << 2) + 0xff000000)
#define VD2_HDR2_ADPS_COEF1                        ((0x387f  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_CTRL                         ((0x3880  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_COEF0                        ((0x3881  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_COEF1                        ((0x3882  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_COEF2                        ((0x3883  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_COEF3                        ((0x3884  << 2) + 0xff000000)
#define VD2_HDR2_GMUT_COEF4                        ((0x3885  << 2) + 0xff000000)
#define VD2_HDR2_PIPE_CTRL1                        ((0x3886  << 2) + 0xff000000)
#define VD2_HDR2_PIPE_CTRL2                        ((0x3887  << 2) + 0xff000000)
#define VD2_HDR2_PIPE_CTRL3                        ((0x3888  << 2) + 0xff000000)
#define VD2_HDR2_PROC_WIN1                         ((0x3889  << 2) + 0xff000000)
#define VD2_HDR2_PROC_WIN2                         ((0x388a  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXI_EN_CTRL                   ((0x388b  << 2) + 0xff000000)
#define VD2_HDR2_MATRIXO_EN_CTRL                   ((0x388c  << 2) + 0xff000000)
#define VD2_HDR2_HIST_CTRL                         ((0x388d  << 2) + 0xff000000)
#define VD2_HDR2_HIST_H_START_END                  ((0x388e  << 2) + 0xff000000)
#define VD2_HDR2_HIST_V_START_END                  ((0x388f  << 2) + 0xff000000)
#define VD2_HDR2_HIST_RD                           ((0x386d  << 2) + 0xff000000)
//osd1 0xa0 - 0xd5
#define OSD1_HDR2_CTRL                             ((0x38a0  << 2) + 0xff000000)
#define OSD1_HDR2_CLK_GATE                         ((0x38a1  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF00_01                ((0x38a2  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF02_10                ((0x38a3  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF11_12                ((0x38a4  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF20_21                ((0x38a5  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF22                   ((0x38a6  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF30_31                ((0x38a7  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF32_40                ((0x38a8  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_COEF41_42                ((0x38a9  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_OFFSET0_1                ((0x38aa  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_OFFSET2                  ((0x38ab  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_PRE_OFFSET0_1            ((0x38ac  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_PRE_OFFSET2              ((0x38ad  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF00_01                ((0x38ae  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF02_10                ((0x38af  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF11_12                ((0x38b0  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF20_21                ((0x38b1  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF22                   ((0x38b2  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF30_31                ((0x38b3  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF32_40                ((0x38b4  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_COEF41_42                ((0x38b5  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_OFFSET0_1                ((0x38b6  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_OFFSET2                  ((0x38b7  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_PRE_OFFSET0_1            ((0x38b8  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_PRE_OFFSET2              ((0x38b9  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_CLIP                     ((0x38ba  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_CLIP                     ((0x38bb  << 2) + 0xff000000)
#define OSD1_HDR2_CGAIN_OFFT                       ((0x38bc  << 2) + 0xff000000)
#define OSD1_EOTF_LUT_ADDR_PORT                    ((0x38be  << 2) + 0xff000000)
#define OSD1_EOTF_LUT_DATA_PORT                    ((0x38bf  << 2) + 0xff000000)
#define OSD1_OETF_LUT_ADDR_PORT                    ((0x38c0  << 2) + 0xff000000)
#define OSD1_OETF_LUT_DATA_PORT                    ((0x38c1  << 2) + 0xff000000)
#define OSD1_CGAIN_LUT_ADDR_PORT                   ((0x38c2  << 2) + 0xff000000)
#define OSD1_CGAIN_LUT_DATA_PORT                   ((0x38c3  << 2) + 0xff000000)
#define OSD1_HDR2_CGAIN_COEF0                      ((0x38c4  << 2) + 0xff000000)
#define OSD1_HDR2_CGAIN_COEF1                      ((0x38c5  << 2) + 0xff000000)
#define OSD1_OGAIN_LUT_ADDR_PORT                   ((0x38c6  << 2) + 0xff000000)
#define OSD1_OGAIN_LUT_DATA_PORT                   ((0x38c7  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_CTRL                        ((0x38c8  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_ALPHA0                      ((0x38c9  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_ALPHA1                      ((0x38ca  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_BETA0                       ((0x38cb  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_BETA1                       ((0x38cc  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_BETA2                       ((0x38cd  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_COEF0                       ((0x38ce  << 2) + 0xff000000)
#define OSD1_HDR2_ADPS_COEF1                       ((0x38cf  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_CTRL                        ((0x38d0  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_COEF0                       ((0x38d1  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_COEF1                       ((0x38d2  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_COEF2                       ((0x38d3  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_COEF3                       ((0x38d4  << 2) + 0xff000000)
#define OSD1_HDR2_GMUT_COEF4                       ((0x38d5  << 2) + 0xff000000)
#define OSD1_HDR2_PIPE_CTRL1                       ((0x38d6  << 2) + 0xff000000)
#define OSD1_HDR2_PIPE_CTRL2                       ((0x38d7  << 2) + 0xff000000)
#define OSD1_HDR2_PIPE_CTRL3                       ((0x38d8  << 2) + 0xff000000)
#define OSD1_HDR2_PROC_WIN1                        ((0x38d9  << 2) + 0xff000000)
#define OSD1_HDR2_PROC_WIN2                        ((0x38da  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXI_EN_CTRL                  ((0x38db  << 2) + 0xff000000)
#define OSD1_HDR2_MATRIXO_EN_CTRL                  ((0x38dc  << 2) + 0xff000000)
#define OSD1_HDR2_HIST_CTRL                        ((0x38dd  << 2) + 0xff000000)
#define OSD1_HDR2_HIST_H_START_END                 ((0x38de  << 2) + 0xff000000)
#define OSD1_HDR2_HIST_V_START_END                 ((0x38df  << 2) + 0xff000000)
#define OSD1_HDR2_HIST_RD                          ((0x38bd  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_hdr2_regs.h
//
//===========================================================================
//===========================================================================
//
// Reading file:  ./vpp_misc_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  VPP_MISC_VCBUS_BASE = 0x39
// -----------------------------------------------
//0x01-0a
//
// Reading file:  ./vpp_vd2_mat_3x3_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_VD2_MATRIX_COEF00_01                   ((0x3901  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_COEF02_10                   ((0x3902  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_COEF11_12                   ((0x3903  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_COEF20_21                   ((0x3904  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_COEF22                      ((0x3905  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_OFFSET0_1                   ((0x3906  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_OFFSET2                     ((0x3907  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_CLIP                        ((0x3908  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_PRE_OFFSET0_1               ((0x3909  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_PRE_OFFSET2                 ((0x390a  << 2) + 0xff000000)
#define VPP_VD2_MATRIX_EN_CTRL                     ((0x390b  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_vd2_mat_3x3_regs.h
//
//0x10-1c
//
// Reading file:  ./vpp_osd1_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_OSD1_MATRIX_COEF00_01                  ((0x3910  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define VPP_OSD1_MATRIX_COEF02_10                  ((0x3911  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define VPP_OSD1_MATRIX_COEF11_12                  ((0x3912  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define VPP_OSD1_MATRIX_COEF20_21                  ((0x3913  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define VPP_OSD1_MATRIX_COEF22                     ((0x3914  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define VPP_OSD1_MATRIX_COEF13_14                  ((0x3915  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define VPP_OSD1_MATRIX_COEF23_24                  ((0x3916  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define VPP_OSD1_MATRIX_COEF15_25                  ((0x3917  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define VPP_OSD1_MATRIX_CLIP                       ((0x3918  << 2) + 0xff000000)
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define VPP_OSD1_MATRIX_OFFSET0_1                  ((0x3919  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define VPP_OSD1_MATRIX_OFFSET2                    ((0x391a  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define VPP_OSD1_MATRIX_PRE_OFFSET0_1              ((0x391b  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define VPP_OSD1_MATRIX_PRE_OFFSET2                ((0x391c  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define VPP_OSD1_MATRIX_EN_CTRL                    ((0x391d  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_osd1_mat_3x5_regs.h
//
//0x20-2c
//
// Reading file:  ./vpp_osd2_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_OSD2_MATRIX_COEF00_01                  ((0x3920  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define VPP_OSD2_MATRIX_COEF02_10                  ((0x3921  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define VPP_OSD2_MATRIX_COEF11_12                  ((0x3922  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define VPP_OSD2_MATRIX_COEF20_21                  ((0x3923  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define VPP_OSD2_MATRIX_COEF22                     ((0x3924  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define VPP_OSD2_MATRIX_COEF13_14                  ((0x3925  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define VPP_OSD2_MATRIX_COEF23_24                  ((0x3926  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define VPP_OSD2_MATRIX_COEF15_25                  ((0x3927  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define VPP_OSD2_MATRIX_CLIP                       ((0x3928  << 2) + 0xff000000)
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define VPP_OSD2_MATRIX_OFFSET0_1                  ((0x3929  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define VPP_OSD2_MATRIX_OFFSET2                    ((0x392a  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define VPP_OSD2_MATRIX_PRE_OFFSET0_1              ((0x392b  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define VPP_OSD2_MATRIX_PRE_OFFSET2                ((0x392c  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define VPP_OSD2_MATRIX_EN_CTRL                    ((0x392d  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_osd2_mat_3x5_regs.h
//
//0x33-0x4f
//
// Reading file:  ./vpp_vd2_scale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VD2_SCALE_COEF_IDX                         ((0x3933  << 2) + 0xff000000)
#define VD2_SCALE_COEF                             ((0x3934  << 2) + 0xff000000)
#define VD2_VSC_REGION12_STARTP                    ((0x3935  << 2) + 0xff000000)
#define VD2_VSC_REGION34_STARTP                    ((0x3936  << 2) + 0xff000000)
#define VD2_VSC_REGION4_ENDP                       ((0x3937  << 2) + 0xff000000)
#define VD2_VSC_START_PHASE_STEP                   ((0x3938  << 2) + 0xff000000)
#define VD2_VSC_REGION0_PHASE_SLOPE                ((0x3939  << 2) + 0xff000000)
#define VD2_VSC_REGION1_PHASE_SLOPE                ((0x393a  << 2) + 0xff000000)
#define VD2_VSC_REGION3_PHASE_SLOPE                ((0x393b  << 2) + 0xff000000)
#define VD2_VSC_REGION4_PHASE_SLOPE                ((0x393c  << 2) + 0xff000000)
#define VD2_VSC_PHASE_CTRL                         ((0x393d  << 2) + 0xff000000)
#define VD2_VSC_INI_PHASE                          ((0x393e  << 2) + 0xff000000)
#define VD2_HSC_REGION12_STARTP                    ((0x393f  << 2) + 0xff000000)
#define VD2_HSC_REGION34_STARTP                    ((0x3940  << 2) + 0xff000000)
#define VD2_HSC_REGION4_ENDP                       ((0x3941  << 2) + 0xff000000)
#define VD2_HSC_START_PHASE_STEP                   ((0x3942  << 2) + 0xff000000)
#define VD2_HSC_REGION0_PHASE_SLOPE                ((0x3943  << 2) + 0xff000000)
#define VD2_HSC_REGION1_PHASE_SLOPE                ((0x3944  << 2) + 0xff000000)
#define VD2_HSC_REGION3_PHASE_SLOPE                ((0x3945  << 2) + 0xff000000)
#define VD2_HSC_REGION4_PHASE_SLOPE                ((0x3946  << 2) + 0xff000000)
#define VD2_HSC_PHASE_CTRL                         ((0x3947  << 2) + 0xff000000)
#define VD2_SC_MISC                                ((0x3948  << 2) + 0xff000000)
#define VD2_SCO_FIFO_CTRL                          ((0x3949  << 2) + 0xff000000)
#define VD2_HSC_PHASE_CTRL1                        ((0x394a  << 2) + 0xff000000)
#define VD2_HSC_INI_PAT_CTRL                       ((0x394b  << 2) + 0xff000000)
#define VD2_SC_GCLK_CTRL                           ((0x394c  << 2) + 0xff000000)
#define VD2_PREHSC_COEF                            ((0x394d  << 2) + 0xff000000)
#define VD2_PRE_SCALE_CTRL                         ((0x394e  << 2) + 0xff000000)
#define VD2_PREVSC_COEF                            ((0x394f  << 2) + 0xff000000)
#define VD2_PREHSC_COEF1                           ((0x3950  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_vd2_scale_regs.h
//
#define VPP_PRE_BLEND_CTRL                         ((0x3960  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:20  hold_lines            //unsigned , default = 8'h4
//Bit 19:2   reserved
//Bit 1 :0   gclk_ctrl             //unsigned , default = 2'd0
#define VPP_PRE_BLEND_BLEND_DUMMY_DATA             ((0x3961  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:16  blend0_dummy_data_y       //unsigned , default = 8'h10
//Bit 15:8   blend0_dummy_data_cb      //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr      //unsigned , default = 8'h0
#define VPP_PRE_BLEND_DUMMY_ALPHA                  ((0x3962  << 2) + 0xff000000)
//Bit 31:26  reserved
//Bit 25:16  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 15:9   reserved
//Bit 8 :0   blend0_dummy_alpha        //unsigned , default = 9'h0
#define VPP_PRE_BLEND_RO_CURRENT_XY                ((0x3963  << 2) + 0xff000000)
//Bit 31:0  ro_blend_current_xy          //unsigned , default = 32'h0
#define VPP_PRE_BLEND_DUMMY_ALPHA1                 ((0x3964  << 2) + 0xff000000)
//Bit 31:26  reserved
//Bit 25:16  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 15:9   reserved
//Bit 8 :0   blend0_dummy_alpha        //unsigned , default = 9'h0
#define VPP_POST_BLEND_CTRL                        ((0x3967  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:20  hold_lines            //unsigned , default = 8'h4
//Bit 19:2   reserved
//Bit 1 :0   gclk_ctrl             //unsigned , default = 2'd0
#define VPP_POST_BLEND_BLEND_DUMMY_DATA            ((0x3968  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:16  blend0_dummy_data_y       //unsigned , default = 8'h10
//Bit 15:8   blend0_dummy_data_cb      //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr      //unsigned , default = 8'h0
#define VPP_POST_BLEND_DUMMY_ALPHA                 ((0x3969  << 2) + 0xff000000)
//Bit 31:26  reserved
//Bit 25:16  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 15:9   reserved
//Bit 8 :0   blend0_dummy_alpha        //unsigned , default = 9'h0
#define VPP_POST_BLEND_RO_CURRENT_XY               ((0x396a  << 2) + 0xff000000)
//Bit 31:0  ro_blend_current_xy          //unsigned , default = 32'h0
#define VPP_POST_BLEND_DUMMY_ALPHA1                ((0x396b  << 2) + 0xff000000)
//Bit 31:26  reserved
//Bit 25:16  blend1_dummy_alpha        //unsigned , default = 9'h0
//Bit 15:9   reserved
//Bit 8 :0   blend0_dummy_alpha        //unsigned , default = 9'h0
#define VPP_AFBC_RDARB_MODE                        ((0x3970  << 2) + 0xff000000)
#define VPP_AFBC_RDARB_REQEN_SLV                   ((0x3971  << 2) + 0xff000000)
#define VPP_AFBC_RDARB_WEIGH0_SLV                  ((0x3972  << 2) + 0xff000000)
#define VPP_AFBC_RDWR_ARB_STATUS                   ((0x3973  << 2) + 0xff000000)
#define VPP_AFBC_ARB_DBG_CTRL                      ((0x3974  << 2) + 0xff000000)
#define VPP_AFBC_ARB_DBG_STAT                      ((0x3975  << 2) + 0xff000000)
#define VPP_RDARB_MODE                             ((0x3978  << 2) + 0xff000000)
#define VPP_RDARB_REQEN_SLV                        ((0x3979  << 2) + 0xff000000)
#define VPP_RDARB_WEIGH0_SLV                       ((0x397a  << 2) + 0xff000000)
#define VPP_RDARB_WEIGH1_SLV                       ((0x397b  << 2) + 0xff000000)
#define VPP_RDWR_ARB_STATUS                        ((0x397c  << 2) + 0xff000000)
#define VPP_ARB_DBG_CTRL                           ((0x397e  << 2) + 0xff000000)
#define VPP_ARB_DBG_STAT                           ((0x397f  << 2) + 0xff000000)
//ox80-0x9f & 0xe0-0xef
//
// Reading file:  ./vpu_primesl_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define PRIMESL_LUTC_ADDR_PORT                     ((0x3980  << 2) + 0xff000000)
#define PRIMESL_LUTC_DATA_PORT                     ((0x3981  << 2) + 0xff000000)
#define PRIMESL_LUTP_ADDR_PORT                     ((0x3982  << 2) + 0xff000000)
#define PRIMESL_LUTP_DATA_PORT                     ((0x3983  << 2) + 0xff000000)
#define PRIMESL_LUTD_ADDR_PORT                     ((0x3984  << 2) + 0xff000000)
#define PRIMESL_LUTD_DATA_PORT                     ((0x3985  << 2) + 0xff000000)
#define PRIMESL_CTRL0                              ((0x3990  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           legacy_mode_en            // unsigned , default = 0  = 'h0
//Bit 28           clip_en                   // unsigned , default = 1  = 'h0
//Bit 27            reserved
//Bit 26:16        inv_chroma_ratio          // unsigned , default = 0  = 'h0,
//Bit 15            reserved
//Bit 14: 4        inv_y_ratio               // unsigned , default = 0  = 'h0,
//Bit  3           reg_gclk_ctrl             // unsigned , default = 0  = 'h0,
//Bit  2: 1        gclk_ctrl                 // unsigned , default = 0  = 'h0,
//Bit  0           primesl_en                // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL1                              ((0x3991  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        l_headroom                // unsigned , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        footroom                  // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL2                              ((0x3992  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        c_headroom                // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL3                              ((0x3993  << 2) + 0xff000000)
//Bit 31:16        mub                       // unsigned , default = 0  = 'h0,
//Bit 15: 0        mua                       // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL4                              ((0x3994  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        oct_7_1                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_0                   // signed , default = 0  = 'h0,
#define PRIMESL_CTRL5                              ((0x3995  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        oct_7_3                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_2                   // signed , default = 0  = 'h0,
#define PRIMESL_CTRL6                              ((0x3996  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        oct_7_5                   // signed , default = 0  = 'h0,
//Bit 15:10        reserved
//Bit  9: 0        oct_7_4                   // signed , default = 0  = 'h0,
#define PRIMESL_CTRL7                              ((0x3997  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        oct_7_6                   // signed , default = 0  = 'h0,
#define PRIMESL_CTRL8                              ((0x3998  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        d_lut_threshold_3_1       // unsigned , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        d_lut_threshold_3_0       // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL9                              ((0x3999  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        d_lut_threshold_3_2       // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL10                             ((0x399a  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        d_lut_step_4_3            // unsigned , default = 0  = 'h0,
//Bit 11: 8        d_lut_step_4_2            // unsigned , default = 0  = 'h0,
//Bit  7: 4        d_lut_step_4_1            // unsigned , default = 0  = 'h0,
//Bit  3: 0        d_lut_step_4_0            // unsigned , default = 0  = 'h0,
#define PRIMESL_CTRL11                             ((0x399b  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_0               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_1               // signed , default = 0  = 'h0,
#define PRIMESL_CTRL12                             ((0x399c  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_2               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_3               // signed , default = 0  = 'h0,
#define PRIMESL_CTRL13                             ((0x399d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_4               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_5               // signed , default = 0  = 'h0,
#define PRIMESL_CTRL14                             ((0x399e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        rgb2yuv_9_6               // signed , default = 0  = 'h0,
//Bit 15:13        reserved
//Bit 12: 0        rgb2yuv_9_7               // signed , default = 0  = 'h0,
#define PRIMESL_CTRL15                             ((0x399f  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        rgb2yuv_9_8               // signed , default = 0  = 'h0,
#define PRIMESL_CTRL16                             ((0x39e0  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30           byp_s_lut                 // unsigned , default = 0  = 'h0,
//Bit 29           byp_d_lut                 // unsigned , default = 0  = 'h0,
//Bit 28           byp_mat                   // unsigned , default = 0  = 'h0,
//Bit 27           rgb_swap                  // unsigned , default = 0  = 'h0,
//Bit 26:24        uv_shift                  // unsigned , default = 0  = 'h0,
//Bit 23:22        rgb_shift                 // unsigned , default = 0  = 'h0,
//Bit 21:20        rgb_clip                  // unsigned , default = 3  = 'h3,
//Bit 19:18        reserved
//Bit 17:16        rgb_rs                    // unsigned , default = 0  = 'h0,
//Bit 15:14        reserved
//Bit 13: 0        reg_s                     // signed , default = 1024  = 'h1024,
#define PRIMESL_OMAT_OFFSET0                       ((0x39e1  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        pre_offset0               // unsigned , default = 512  = 'h512
//Bit 15:12        reserved
//Bit 11: 0        pre_offset1               // unsigned , default = 512  = 'h512
#define PRIMESL_OMAT_OFFSET1                       ((0x39e2  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        pre_offset2               // unsigned , default = 512  = 'h512
//Bit 15:12        reserved
//Bit 11: 0        offset0                   // unsigned , default = 256  = 'h256
#define PRIMESL_OMAT_OFFSET2                       ((0x39e3  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        offset1                   // unsigned , default = 2048  = 'h2048
//Bit 15:12        reserved
//Bit 11: 0        offset2                   // unsigned , default = 2048  = 'h2048
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_primesl_regs.h
//
//oxa0-0xaf
//
// Reading file:  ./vpp_post2_mat_3x5_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_POST2_MATRIX_COEF00_01                 ((0x39a0  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef00                //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef01                //signed , default = 0
#define VPP_POST2_MATRIX_COEF02_10                 ((0x39a1  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef02               //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef10               //signed , default = 0
#define VPP_POST2_MATRIX_COEF11_12                 ((0x39a2  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef11              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef12              //signed , default = 0
#define VPP_POST2_MATRIX_COEF20_21                 ((0x39a3  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef20              //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef21              //signed , default = 0
#define VPP_POST2_MATRIX_COEF22                    ((0x39a4  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  coef22             //signed , default = 0
#define VPP_POST2_MATRIX_COEF13_14                 ((0x39a5  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef13             //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef14             //signed , default = 0
#define VPP_POST2_MATRIX_COEF23_24                 ((0x39a6  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef23            //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef24            //signed , default = 0
#define VPP_POST2_MATRIX_COEF15_25                 ((0x39a7  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 coef15           //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  coef25           //signed , default = 0
#define VPP_POST2_MATRIX_CLIP                      ((0x39a8  << 2) + 0xff000000)
//Bit 31:22  reserved
//Bit 21:8   comp_thrd0    //  signed ,default == 0,   mat clip enable
//Bit 7:5    conv_rs       //  unsigned ,default == 0,   mat rs
//Bit 4:3    clmod         //  unsigned ,default == 0,   mat clmod
#define VPP_POST2_MATRIX_OFFSET0_1                 ((0x39a9  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 offset0       //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  offset1       //signed , default = 0
#define VPP_POST2_MATRIX_OFFSET2                   ((0x39aa  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  offset2       //signed , default = 0
#define VPP_POST2_MATRIX_PRE_OFFSET0_1             ((0x39ab  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 pre_offset0   //signed , default = 0
//Bit 15:13 reserved
//Bit 12:0  pre_offset1   //signed , default = 0
#define VPP_POST2_MATRIX_PRE_OFFSET2               ((0x39ac  << 2) + 0xff000000)
//Bit 31:13 reserved
//Bit 12:0  pre_offset2  //signed , default = 0
#define VPP_POST2_MATRIX_EN_CTRL                   ((0x39ad  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_post2_mat_3x5_regs.h
//
//0xb0-0xcf
//
// Reading file:  ./osd_blend_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define VIU_OSD_BLEND_CTRL                         ((0x39b0  << 2) + 0xff000000)
//Bit 31:29  hold_lines                     //unsigned , default = 3'h0
//Bit 28:27  blend2_premult_en              //unsigned , default = 2'h3
//Bit 26     din0_byp_blend                 //unsigned , default = 1'h1
//Bit 25     din2_osd_sel                   //unsigned , default = 1'h1
//Bit 24     din3_osd_sel                   //unsigned , default = 1'h1
//Bit 23:20  blend_din_en                   //unsigned , default = 4'h5
//Bit 19:16  din_premult_en                 //unsigned , default = 4'h0
//Bit 15:0   din_reoder_sel                 //unsigned , default = 16'h2341
#define VIU_OSD_BLEND_CTRL1                        ((0x39c0  << 2) + 0xff000000)
//Bit 31:6  reserved
//Bit 5:4   reg_alp_mapping_mode
//Bit 2:1   reg_div_gclk_en
//Bit 0     reg_div_alpha_en
#define VIU_OSD_BLEND_DIN0_SCOPE_H                 ((0x39b1  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din0_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din0_h_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN0_SCOPE_V                 ((0x39b2  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din0_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din0_v_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN1_SCOPE_H                 ((0x39b3  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din1_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din1_h_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN1_SCOPE_V                 ((0x39b4  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din1_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din1_v_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN2_SCOPE_H                 ((0x39b5  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din2_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din2_h_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN2_SCOPE_V                 ((0x39b6  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din2_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din2_v_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN3_SCOPE_H                 ((0x39b7  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din3_h_end          ///unsigned , default = 13'h2d0
//Bit 15:13  reserved
//Bit 12:0   bld_din3_h_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DIN3_SCOPE_V                 ((0x39b8  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  bld_din3_v_end          ///unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   bld_din3_v_start        ///unsigned , default = 13'h0
#define VIU_OSD_BLEND_DUMMY_DATA0                  ((0x39b9  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 23:16  blend0_dummy_data_y             //unsigned , default = 8'h00
//Bit 15:8   blend0_dummy_data_cb            //unsigned , default = 8'h80
//Bit 7:0    blend0_dummy_data_cr            //unsigned , default = 8'h80
#define VIU_OSD_BLEND_DUMMY_ALPHA                  ((0x39ba  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:20  blend0_dummy_alpha              //unsigned , default = 9'h0
//Bit 19:11  blend1_dummy_alpha              //unsigned , default = 9'h0
//Bit 8:0    blend2_dummy_alpha              //unsigned , default = 9'h0
#define VIU_OSD_BLEND_BLEND0_SIZE                  ((0x39bb  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  blend0_vsize                    //unsigned , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   blend0_hsize                    //unsigned , default = 13'h2d0
#define VIU_OSD_BLEND_BLEND1_SIZE                  ((0x39bc  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  blend1_vsize                    //unsigned  , default = 13'h1e0
//Bit 15:13  reserved
//Bit 12:0   blend1_hsize                    ///unsigned , default = 13'h2d0
//`define   VIU_OSD_BLEND_DOUT0_HV_START       8'hbd
//Bit 31:29  reserved
//Bit 28:0   osd_blend_dout0_hv_start        //unsigned  , default = 29'h0
//`define   VIU_OSD_BLEND_DOUT1_HV_START       8'hbe
//Bit 31:29  reserved
//Bit 28:0   osd_blend_dout1_hv_start        //unsigned  , default = 29'h0
#define VIU_OSD_HOLD_LINE_HIGH_BITS                ((0x39c1  << 2) + 0xff000000)
//Bit 31:8  reserved
//Bit 7:0   hold_line_high_bits              //unsigned , default = 32'h0
#define VIU_OSD_BLEND_RO_CURRENT_XY                ((0x39bf  << 2) + 0xff000000)
//Bit 31:0  ro_blend2_current_xy             //unsigned , default = 32'h0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osd_blend_reg.h
//
#define VPP_LUT3D_CTRL                             ((0x39d0  << 2) + 0xff000000)
#define VPP_LUT3D_CBUS2RAM_CTRL                    ((0x39d1  << 2) + 0xff000000)
#define VPP_LUT3D_RAM_ADDR                         ((0x39d2  << 2) + 0xff000000)
#define VPP_LUT3D_RAM_DATA                         ((0x39d3  << 2) + 0xff000000)
#define VPP_GAMMA_CTRL                             ((0x39d4  << 2) + 0xff000000)
#define VPP_GAMMA_BIN_ADDR                         ((0x39d5  << 2) + 0xff000000)
#define VPP_GAMMA_BIN_DATA                         ((0x39d6  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_misc_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD0_VCBUS_BASE = 0x3a
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vpp_mali_tx300_afbc_regs.h
//
// synopsys translate_off
// synopsys translate_on
 //0x00 - 0x80
#define VPU_MAFBC_BLOCK_ID                         ((0x3a00  << 2) + 0xff000000)
#define VPU_MAFBC_IRQ_RAW_STATUS                   ((0x3a01  << 2) + 0xff000000)
#define VPU_MAFBC_IRQ_CLEAR                        ((0x3a02  << 2) + 0xff000000)
#define VPU_MAFBC_IRQ_MASK                         ((0x3a03  << 2) + 0xff000000)
#define VPU_MAFBC_IRQ_STATUS                       ((0x3a04  << 2) + 0xff000000)
#define VPU_MAFBC_COMMAND                          ((0x3a05  << 2) + 0xff000000)
#define VPU_MAFBC_STATUS                           ((0x3a06  << 2) + 0xff000000)
#define VPU_MAFBC_SURFACE_CFG                      ((0x3a07  << 2) + 0xff000000)
#define VPU_MAFBC_AXI_CFG                          ((0x3a08  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_LOW_S0           ((0x3a10  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S0          ((0x3a11  << 2) + 0xff000000)
#define VPU_MAFBC_FORMAT_SPECIFIER_S0              ((0x3a12  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_WIDTH_S0                  ((0x3a13  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_HEIGHT_S0                 ((0x3a14  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_START_S0          ((0x3a15  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_END_S0            ((0x3a16  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_START_S0          ((0x3a17  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_END_S0            ((0x3a18  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S0           ((0x3a19  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S0          ((0x3a1a  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_STRIDE_S0             ((0x3a1b  << 2) + 0xff000000)
#define VPU_MAFBC_PREFETCH_CFG_S0                  ((0x3a1c  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_LOW_S0               ((0x3a1d  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_HIGH_S0              ((0x3a1e  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_LOW_S0               ((0x3a1f  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_HIGH_S0              ((0x3a20  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_LOW_S1           ((0x3a30  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S1          ((0x3a31  << 2) + 0xff000000)
#define VPU_MAFBC_FORMAT_SPECIFIER_S1              ((0x3a32  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_WIDTH_S1                  ((0x3a33  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_HEIGHT_S1                 ((0x3a34  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_START_S1          ((0x3a35  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_END_S1            ((0x3a36  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_START_S1          ((0x3a37  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_END_S1            ((0x3a38  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S1           ((0x3a39  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S1          ((0x3a3a  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_STRIDE_S1             ((0x3a3b  << 2) + 0xff000000)
#define VPU_MAFBC_PREFETCH_CFG_S1                  ((0x3a3c  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_LOW_S1               ((0x3a3d  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_HIGH_S1              ((0x3a3e  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_LOW_S1               ((0x3a3f  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_HIGH_S1              ((0x3a40  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_LOW_S2           ((0x3a50  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S2          ((0x3a51  << 2) + 0xff000000)
#define VPU_MAFBC_FORMAT_SPECIFIER_S2              ((0x3a52  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_WIDTH_S2                  ((0x3a53  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_HEIGHT_S2                 ((0x3a54  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_START_S2          ((0x3a55  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_END_S2            ((0x3a56  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_START_S2          ((0x3a57  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_END_S2            ((0x3a58  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S2           ((0x3a59  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S2          ((0x3a5a  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_STRIDE_S2             ((0x3a5b  << 2) + 0xff000000)
#define VPU_MAFBC_PREFETCH_CFG_S2                  ((0x3a5c  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_LOW_S2               ((0x3a5d  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_HIGH_S2              ((0x3a5e  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_LOW_S2               ((0x3a5f  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_HIGH_S2              ((0x3a60  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_LOW_S3           ((0x3a70  << 2) + 0xff000000)
#define VPU_MAFBC_HEADER_BUF_ADDR_HIGH_S3          ((0x3a71  << 2) + 0xff000000)
#define VPU_MAFBC_FORMAT_SPECIFIER_S3              ((0x3a72  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_WIDTH_S3                  ((0x3a73  << 2) + 0xff000000)
#define VPU_MAFBC_BUFFER_HEIGHT_S3                 ((0x3a74  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_START_S3          ((0x3a75  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_X_END_S3            ((0x3a76  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_START_S3          ((0x3a77  << 2) + 0xff000000)
#define VPU_MAFBC_BOUNDING_BOX_Y_END_S3            ((0x3a78  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_LOW_S3           ((0x3a79  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_ADDR_HIGH_S3          ((0x3a7a  << 2) + 0xff000000)
#define VPU_MAFBC_OUTPUT_BUF_STRIDE_S3             ((0x3a7b  << 2) + 0xff000000)
#define VPU_MAFBC_PREFETCH_CFG_S3                  ((0x3a7c  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_LOW_S3               ((0x3a7d  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MIN_HIGH_S3              ((0x3a7e  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_LOW_S3               ((0x3a7f  << 2) + 0xff000000)
#define VPU_MAFBC_PAYLOAD_MAX_HIGH_S3              ((0x3a80  << 2) + 0xff000000)
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_mali_tx300_afbc_regs.h
//
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD1_VCBUS_BASE = 0x3b
// -----------------------------------------------
//
// Reading file:  ./vpp_mali_tx300_afbc1_regs.h
//
// synopsys translate_off
// synopsys translate_on
 //0x00 - 0x80
#define VPU_MAFBC1_BLOCK_ID                        ((0x3b00  << 2) + 0xff000000)
#define VPU_MAFBC1_IRQ_RAW_STATUS                  ((0x3b01  << 2) + 0xff000000)
#define VPU_MAFBC1_IRQ_CLEAR                       ((0x3b02  << 2) + 0xff000000)
#define VPU_MAFBC1_IRQ_MASK                        ((0x3b03  << 2) + 0xff000000)
#define VPU_MAFBC1_IRQ_STATUS                      ((0x3b04  << 2) + 0xff000000)
#define VPU_MAFBC1_COMMAND                         ((0x3b05  << 2) + 0xff000000)
#define VPU_MAFBC1_STATUS                          ((0x3b06  << 2) + 0xff000000)
#define VPU_MAFBC1_SURFACE_CFG                     ((0x3b07  << 2) + 0xff000000)
#define VPU_MAFBC1_AXI_CFG                         ((0x3b08  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_LOW_S0          ((0x3b10  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_HIGH_S0         ((0x3b11  << 2) + 0xff000000)
#define VPU_MAFBC1_FORMAT_SPECIFIER_S0             ((0x3b12  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_WIDTH_S0                 ((0x3b13  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_HEIGHT_S0                ((0x3b14  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_START_S0         ((0x3b15  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_END_S0           ((0x3b16  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_START_S0         ((0x3b17  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_END_S0           ((0x3b18  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_LOW_S0          ((0x3b19  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_HIGH_S0         ((0x3b1a  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_STRIDE_S0            ((0x3b1b  << 2) + 0xff000000)
#define VPU_MAFBC1_PREFETCH_CFG_S0                 ((0x3b1c  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_LOW_S0              ((0x3b1d  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_HIGH_S0             ((0x3b1e  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_LOW_S0              ((0x3b1f  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_HIGH_S0             ((0x3b20  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_LOW_S1          ((0x3b30  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_HIGH_S1         ((0x3b31  << 2) + 0xff000000)
#define VPU_MAFBC1_FORMAT_SPECIFIER_S1             ((0x3b32  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_WIDTH_S1                 ((0x3b33  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_HEIGHT_S1                ((0x3b34  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_START_S1         ((0x3b35  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_END_S1           ((0x3b36  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_START_S1         ((0x3b37  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_END_S1           ((0x3b38  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_LOW_S1          ((0x3b39  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_HIGH_S1         ((0x3b3a  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_STRIDE_S1            ((0x3b3b  << 2) + 0xff000000)
#define VPU_MAFBC1_PREFETCH_CFG_S1                 ((0x3b3c  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_LOW_S1              ((0x3b3d  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_HIGH_S1             ((0x3b3e  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_LOW_S1              ((0x3b3f  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_HIGH_S1             ((0x3b40  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_LOW_S2          ((0x3b50  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_HIGH_S2         ((0x3b51  << 2) + 0xff000000)
#define VPU_MAFBC1_FORMAT_SPECIFIER_S2             ((0x3b52  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_WIDTH_S2                 ((0x3b53  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_HEIGHT_S2                ((0x3b54  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_START_S2         ((0x3b55  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_END_S2           ((0x3b56  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_START_S2         ((0x3b57  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_END_S2           ((0x3b58  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_LOW_S2          ((0x3b59  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_HIGH_S2         ((0x3b5a  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_STRIDE_S2            ((0x3b5b  << 2) + 0xff000000)
#define VPU_MAFBC1_PREFETCH_CFG_S2                 ((0x3b5c  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_LOW_S2              ((0x3b5d  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_HIGH_S2             ((0x3b5e  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_LOW_S2              ((0x3b5f  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_HIGH_S2             ((0x3b60  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_LOW_S3          ((0x3b70  << 2) + 0xff000000)
#define VPU_MAFBC1_HEADER_BUF_ADDR_HIGH_S3         ((0x3b71  << 2) + 0xff000000)
#define VPU_MAFBC1_FORMAT_SPECIFIER_S3             ((0x3b72  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_WIDTH_S3                 ((0x3b73  << 2) + 0xff000000)
#define VPU_MAFBC1_BUFFER_HEIGHT_S3                ((0x3b74  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_START_S3         ((0x3b75  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_X_END_S3           ((0x3b76  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_START_S3         ((0x3b77  << 2) + 0xff000000)
#define VPU_MAFBC1_BOUNDING_BOX_Y_END_S3           ((0x3b78  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_LOW_S3          ((0x3b79  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_ADDR_HIGH_S3         ((0x3b7a  << 2) + 0xff000000)
#define VPU_MAFBC1_OUTPUT_BUF_STRIDE_S3            ((0x3b7b  << 2) + 0xff000000)
#define VPU_MAFBC1_PREFETCH_CFG_S3                 ((0x3b7c  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_LOW_S3              ((0x3b7d  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MIN_HIGH_S3             ((0x3b7e  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_LOW_S3              ((0x3b7f  << 2) + 0xff000000)
#define VPU_MAFBC1_PAYLOAD_MAX_HIGH_S3             ((0x3b80  << 2) + 0xff000000)
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_mali_tx300_afbc1_regs.h
//
// -----------------------------------------------
// REG_BASE:  VPP_AFBCD2_VCBUS_BASE = 0x3c
// -----------------------------------------------
//
// Reading file:  ./vpp_mali_tx300_afbc2_regs.h
//
// synopsys translate_off
// synopsys translate_on
 //0x00 - 0x80
#define VPU_MAFBC2_BLOCK_ID                        ((0x3c00  << 2) + 0xff000000)
#define VPU_MAFBC2_IRQ_RAW_STATUS                  ((0x3c01  << 2) + 0xff000000)
#define VPU_MAFBC2_IRQ_CLEAR                       ((0x3c02  << 2) + 0xff000000)
#define VPU_MAFBC2_IRQ_MASK                        ((0x3c03  << 2) + 0xff000000)
#define VPU_MAFBC2_IRQ_STATUS                      ((0x3c04  << 2) + 0xff000000)
#define VPU_MAFBC2_COMMAND                         ((0x3c05  << 2) + 0xff000000)
#define VPU_MAFBC2_STATUS                          ((0x3c06  << 2) + 0xff000000)
#define VPU_MAFBC2_SURFACE_CFG                     ((0x3c07  << 2) + 0xff000000)
#define VPU_MAFBC2_AXI_CFG                         ((0x3c08  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_LOW_S0          ((0x3c10  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_HIGH_S0         ((0x3c11  << 2) + 0xff000000)
#define VPU_MAFBC2_FORMAT_SPECIFIER_S0             ((0x3c12  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_WIDTH_S0                 ((0x3c13  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_HEIGHT_S0                ((0x3c14  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_START_S0         ((0x3c15  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_END_S0           ((0x3c16  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_START_S0         ((0x3c17  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_END_S0           ((0x3c18  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_LOW_S0          ((0x3c19  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_HIGH_S0         ((0x3c1a  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_STRIDE_S0            ((0x3c1b  << 2) + 0xff000000)
#define VPU_MAFBC2_PREFETCH_CFG_S0                 ((0x3c1c  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_LOW_S0              ((0x3c1d  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_HIGH_S0             ((0x3c1e  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_LOW_S0              ((0x3c1f  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_HIGH_S0             ((0x3c20  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_LOW_S1          ((0x3c30  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_HIGH_S1         ((0x3c31  << 2) + 0xff000000)
#define VPU_MAFBC2_FORMAT_SPECIFIER_S1             ((0x3c32  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_WIDTH_S1                 ((0x3c33  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_HEIGHT_S1                ((0x3c34  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_START_S1         ((0x3c35  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_END_S1           ((0x3c36  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_START_S1         ((0x3c37  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_END_S1           ((0x3c38  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_LOW_S1          ((0x3c39  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_HIGH_S1         ((0x3c3a  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_STRIDE_S1            ((0x3c3b  << 2) + 0xff000000)
#define VPU_MAFBC2_PREFETCH_CFG_S1                 ((0x3c3c  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_LOW_S1              ((0x3c3d  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_HIGH_S1             ((0x3c3e  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_LOW_S1              ((0x3c3f  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_HIGH_S1             ((0x3c40  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_LOW_S2          ((0x3c50  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_HIGH_S2         ((0x3c51  << 2) + 0xff000000)
#define VPU_MAFBC2_FORMAT_SPECIFIER_S2             ((0x3c52  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_WIDTH_S2                 ((0x3c53  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_HEIGHT_S2                ((0x3c54  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_START_S2         ((0x3c55  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_END_S2           ((0x3c56  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_START_S2         ((0x3c57  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_END_S2           ((0x3c58  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_LOW_S2          ((0x3c59  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_HIGH_S2         ((0x3c5a  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_STRIDE_S2            ((0x3c5b  << 2) + 0xff000000)
#define VPU_MAFBC2_PREFETCH_CFG_S2                 ((0x3c5c  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_LOW_S2              ((0x3c5d  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_HIGH_S2             ((0x3c5e  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_LOW_S2              ((0x3c5f  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_HIGH_S2             ((0x3c60  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_LOW_S3          ((0x3c70  << 2) + 0xff000000)
#define VPU_MAFBC2_HEADER_BUF_ADDR_HIGH_S3         ((0x3c71  << 2) + 0xff000000)
#define VPU_MAFBC2_FORMAT_SPECIFIER_S3             ((0x3c72  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_WIDTH_S3                 ((0x3c73  << 2) + 0xff000000)
#define VPU_MAFBC2_BUFFER_HEIGHT_S3                ((0x3c74  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_START_S3         ((0x3c75  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_X_END_S3           ((0x3c76  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_START_S3         ((0x3c77  << 2) + 0xff000000)
#define VPU_MAFBC2_BOUNDING_BOX_Y_END_S3           ((0x3c78  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_LOW_S3          ((0x3c79  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_ADDR_HIGH_S3         ((0x3c7a  << 2) + 0xff000000)
#define VPU_MAFBC2_OUTPUT_BUF_STRIDE_S3            ((0x3c7b  << 2) + 0xff000000)
#define VPU_MAFBC2_PREFETCH_CFG_S3                 ((0x3c7c  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_LOW_S3              ((0x3c7d  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MIN_HIGH_S3             ((0x3c7e  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_LOW_S3              ((0x3c7f  << 2) + 0xff000000)
#define VPU_MAFBC2_PAYLOAD_MAX_HIGH_S3             ((0x3c80  << 2) + 0xff000000)
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_mali_tx300_afbc2_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPU_OSDSC_BLD_VCBUS_BASE = 0x3d
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vpu_osdsc_bld_regs.h
//
// synopsys translate_off
// synopsys translate_on
// for osd3 & osd4 blend
#define OSD34_OUT_HSCOPE                           ((0x3d40  << 2) + 0xff000000)
#define OSD34_OUT_VSCOPE                           ((0x3d41  << 2) + 0xff000000)
#define OSD34_DUMMY_DATA                           ((0x3d42  << 2) + 0xff000000)
#define OSD34_BLEND_CTRL0                          ((0x3d43  << 2) + 0xff000000)
#define OSD34_BLEND_CTRL1                          ((0x3d44  << 2) + 0xff000000)
#define OSD34_RO_HV_CNT                            ((0x3d45  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF00_01             ((0x3d60  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF02_10             ((0x3d61  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF11_12             ((0x3d62  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF20_21             ((0x3d63  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF22                ((0x3d64  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF13_14             ((0x3d65  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF23_24             ((0x3d66  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_COEF15_25             ((0x3d67  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_CLIP                  ((0x3d68  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_OFFSET0_1             ((0x3d69  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_OFFSET2               ((0x3d6a  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_PRE_OFFSET0_1         ((0x3d6b  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_PRE_OFFSET2           ((0x3d6c  << 2) + 0xff000000)
#define VPP_WRAP_OSD1_MATRIX_EN_CTRL               ((0x3d6d  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF00_01             ((0x3d70  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF02_10             ((0x3d71  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF11_12             ((0x3d72  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF20_21             ((0x3d73  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF22                ((0x3d74  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF13_14             ((0x3d75  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF23_24             ((0x3d76  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_COEF15_25             ((0x3d77  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_CLIP                  ((0x3d78  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_OFFSET0_1             ((0x3d79  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_OFFSET2               ((0x3d7a  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_PRE_OFFSET0_1         ((0x3d7b  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_PRE_OFFSET2           ((0x3d7c  << 2) + 0xff000000)
#define VPP_WRAP_OSD2_MATRIX_EN_CTRL               ((0x3d7d  << 2) + 0xff000000)
#define VIU_OSD3_CTRL_STAT                         ((0x3d80  << 2) + 0xff000000)
#define VIU_OSD3_CTRL_STAT2                        ((0x3d81  << 2) + 0xff000000)
#define VIU_OSD3_COLOR_ADDR                        ((0x3d82  << 2) + 0xff000000)
#define VIU_OSD3_COLOR                             ((0x3d83  << 2) + 0xff000000)
#define VIU_OSD3_TCOLOR_AG0                        ((0x3d84  << 2) + 0xff000000)
#define VIU_OSD3_TCOLOR_AG1                        ((0x3d85  << 2) + 0xff000000)
#define VIU_OSD3_TCOLOR_AG2                        ((0x3d86  << 2) + 0xff000000)
#define VIU_OSD3_TCOLOR_AG3                        ((0x3d87  << 2) + 0xff000000)
#define VIU_OSD3_BLK0_CFG_W0                       ((0x3d88  << 2) + 0xff000000)
#define VIU_OSD3_BLK1_CFG_W0                       ((0x3d89  << 2) + 0xff000000)
#define VIU_OSD3_BLK2_CFG_W0                       ((0x3d8a  << 2) + 0xff000000)
#define VIU_OSD3_BLK3_CFG_W0                       ((0x3d8b  << 2) + 0xff000000)
#define VIU_OSD3_BLK0_CFG_W1                       ((0x3d8c  << 2) + 0xff000000)
#define VIU_OSD3_BLK1_CFG_W1                       ((0x3d8d  << 2) + 0xff000000)
#define VIU_OSD3_BLK2_CFG_W1                       ((0x3d8e  << 2) + 0xff000000)
#define VIU_OSD3_BLK3_CFG_W1                       ((0x3d8f  << 2) + 0xff000000)
#define VIU_OSD3_BLK0_CFG_W2                       ((0x3d90  << 2) + 0xff000000)
#define VIU_OSD3_BLK1_CFG_W2                       ((0x3d91  << 2) + 0xff000000)
#define VIU_OSD3_BLK2_CFG_W2                       ((0x3d92  << 2) + 0xff000000)
#define VIU_OSD3_BLK3_CFG_W2                       ((0x3d93  << 2) + 0xff000000)
#define VIU_OSD3_BLK0_CFG_W3                       ((0x3d94  << 2) + 0xff000000)
#define VIU_OSD3_BLK1_CFG_W3                       ((0x3d95  << 2) + 0xff000000)
#define VIU_OSD3_BLK2_CFG_W3                       ((0x3d96  << 2) + 0xff000000)
#define VIU_OSD3_BLK3_CFG_W3                       ((0x3d97  << 2) + 0xff000000)
#define VIU_OSD3_BLK0_CFG_W4                       ((0x3d98  << 2) + 0xff000000)
#define VIU_OSD3_BLK1_CFG_W4                       ((0x3d99  << 2) + 0xff000000)
#define VIU_OSD3_BLK2_CFG_W4                       ((0x3d9a  << 2) + 0xff000000)
#define VIU_OSD3_BLK3_CFG_W4                       ((0x3d9b  << 2) + 0xff000000)
#define VIU_OSD3_FIFO_CTRL_STAT                    ((0x3d9c  << 2) + 0xff000000)
#define VIU_OSD3_TEST_RDDATA                       ((0x3d9d  << 2) + 0xff000000)
#define VIU_OSD3_PROT_CTRL                         ((0x3d9e  << 2) + 0xff000000)
#define VIU_OSD3_MALI_UNPACK_CTRL                  ((0x3d9f  << 2) + 0xff000000)
#define VIU_OSD3_DIMM_CTRL                         ((0x3da0  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF00_01                  ((0x3db0  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF02_10                  ((0x3db1  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF11_12                  ((0x3db2  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF20_21                  ((0x3db3  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF22                     ((0x3db4  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF13_14                  ((0x3db5  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF23_24                  ((0x3db6  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_COEF15_25                  ((0x3db7  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_CLIP                       ((0x3db8  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_OFFSET0_1                  ((0x3db9  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_OFFSET2                    ((0x3dba  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_PRE_OFFSET0_1              ((0x3dbb  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_PRE_OFFSET2                ((0x3dbc  << 2) + 0xff000000)
#define VIU_OSD3_MATRIX_EN_CTRL                    ((0x3dbd  << 2) + 0xff000000)
#define VIU_OSD4_CTRL_STAT                         ((0x3dc0  << 2) + 0xff000000)
#define VIU_OSD4_CTRL_STAT2                        ((0x3dc1  << 2) + 0xff000000)
#define VIU_OSD4_COLOR_ADDR                        ((0x3dc2  << 2) + 0xff000000)
#define VIU_OSD4_COLOR                             ((0x3dc3  << 2) + 0xff000000)
#define VIU_OSD4_TCOLOR_AG0                        ((0x3dc4  << 2) + 0xff000000)
#define VIU_OSD4_TCOLOR_AG1                        ((0x3dc5  << 2) + 0xff000000)
#define VIU_OSD4_TCOLOR_AG2                        ((0x3dc6  << 2) + 0xff000000)
#define VIU_OSD4_TCOLOR_AG3                        ((0x3dc7  << 2) + 0xff000000)
#define VIU_OSD4_BLK0_CFG_W0                       ((0x3dc8  << 2) + 0xff000000)
#define VIU_OSD4_BLK1_CFG_W0                       ((0x3dc9  << 2) + 0xff000000)
#define VIU_OSD4_BLK2_CFG_W0                       ((0x3dca  << 2) + 0xff000000)
#define VIU_OSD4_BLK3_CFG_W0                       ((0x3dcb  << 2) + 0xff000000)
#define VIU_OSD4_BLK0_CFG_W1                       ((0x3dcc  << 2) + 0xff000000)
#define VIU_OSD4_BLK1_CFG_W1                       ((0x3dcd  << 2) + 0xff000000)
#define VIU_OSD4_BLK2_CFG_W1                       ((0x3dce  << 2) + 0xff000000)
#define VIU_OSD4_BLK3_CFG_W1                       ((0x3dcf  << 2) + 0xff000000)
#define VIU_OSD4_BLK0_CFG_W2                       ((0x3dd0  << 2) + 0xff000000)
#define VIU_OSD4_BLK1_CFG_W2                       ((0x3dd1  << 2) + 0xff000000)
#define VIU_OSD4_BLK2_CFG_W2                       ((0x3dd2  << 2) + 0xff000000)
#define VIU_OSD4_BLK3_CFG_W2                       ((0x3dd3  << 2) + 0xff000000)
#define VIU_OSD4_BLK0_CFG_W3                       ((0x3dd4  << 2) + 0xff000000)
#define VIU_OSD4_BLK1_CFG_W3                       ((0x3dd5  << 2) + 0xff000000)
#define VIU_OSD4_BLK2_CFG_W3                       ((0x3dd6  << 2) + 0xff000000)
#define VIU_OSD4_BLK3_CFG_W3                       ((0x3dd7  << 2) + 0xff000000)
#define VIU_OSD4_BLK0_CFG_W4                       ((0x3dd8  << 2) + 0xff000000)
#define VIU_OSD4_BLK1_CFG_W4                       ((0x3dd9  << 2) + 0xff000000)
#define VIU_OSD4_BLK2_CFG_W4                       ((0x3dda  << 2) + 0xff000000)
#define VIU_OSD4_BLK3_CFG_W4                       ((0x3ddb  << 2) + 0xff000000)
#define VIU_OSD4_FIFO_CTRL_STAT                    ((0x3ddc  << 2) + 0xff000000)
#define VIU_OSD4_TEST_RDDATA                       ((0x3ddd  << 2) + 0xff000000)
#define VIU_OSD4_PROT_CTRL                         ((0x3dde  << 2) + 0xff000000)
#define VIU_OSD4_MALI_UNPACK_CTRL                  ((0x3ddf  << 2) + 0xff000000)
#define VIU_OSD4_DIMM_CTRL                         ((0x3de0  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF00_01                  ((0x3df0  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF02_10                  ((0x3df1  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF11_12                  ((0x3df2  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF20_21                  ((0x3df3  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF22                     ((0x3df4  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF13_14                  ((0x3df5  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF23_24                  ((0x3df6  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_COEF15_25                  ((0x3df7  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_CLIP                       ((0x3df8  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_OFFSET0_1                  ((0x3df9  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_OFFSET2                    ((0x3dfa  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_PRE_OFFSET0_1              ((0x3dfb  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_PRE_OFFSET2                ((0x3dfc  << 2) + 0xff000000)
#define VIU_OSD4_MATRIX_EN_CTRL                    ((0x3dfd  << 2) + 0xff000000)
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osdsc_bld_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPF_VCBUS_BASE = 0x40
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./lc_stts_curve.h
//
#define LC_CURVE_CTRL                              ((0x4000  << 2) + 0xff000000)
    //Bit 31  :12     reg_lc_misc                        U     RW        default = 'h0     None
    //Bit 11  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :8      reg_lc_hist_curve_nodes_hlpf       U     RW        default = 'h1      horizontal lpf of the ram_curve_nodes, 0: no LPF, 1= [1 2 1]; 2: [1 2 2 2 1]/8
    //Bit 7   :6      reserved                           U     RW        default = 'h0     None
    //Bit 5   :4      reg_lc_hist_curve_nodes_vlpf       U     RW        default = 'h1      vertical lpf of the ram_curve_nodes, 0: no LPF, 1= [1 2 1]; 2: [1 2 2 2 1]/8
    //Bit 3   :2      reserved                           U     RW        default = 'h0     None
    //Bit 1           reg_lc_blackbar_mute_en            U     RW        default = 'h1     mute the black bar corresponding bin, 0: no mute, 1: mute enable; default=1
    //Bit 0           reg_lc_curve_en                    U     RW        default = 'h1      default=0
#define LC_CURVE_HV_NUM                            ((0x4001  << 2) + 0xff000000)
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :8      reg_lc_cur_blk_hnum                U     RW        default = 'hc      lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8), should be same as reg_lc_blk_hnum
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4   :0      reg_lc_cur_blk_vnum                U     RW        default = 'h8      lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12), should be same as reg_lc_blk_vnum
#define LC_CURVE_LMT_RAT                           ((0x4002  << 2) + 0xff000000)
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lmtrat_minmax                  U     RW        default = 'h6     x/1024 of amount
    //Bit 7   :0      reg_lmtrat_valid                   U     RW        default = 'h14     x/1024 of amount
#define LC_CURVE_CONTRAST_LH                       ((0x4003  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_contrast_low                U     RW        default = 'h10     contrast gain to the lc for dark side, normalized 256 as "1", set adaptive TODO
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_contrast_hig                U     RW        default = 'h18     contrast gain to the lc for bright side, normalized 256 as "1"
#define LC_CURVE_CONTRAST__LMT_LH                  ((0x4004  << 2) + 0xff000000)
    //Bit 31  :24     reg_lc_cntstlmt_low_0              U     RW        default = 'ha     limit for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 23  :16     reg_lc_cntstlmt_hig_0              U     RW        default = 'h14     limit for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
    //Bit 15  :8      reg_lc_cntstlmt_low_1              U     RW        default = 'hff     limit for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 7   :0      reg_lc_cntstlmt_hig_1              U     RW        default = 'hff     limit for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define LC_CURVE_CONTRAST_SCL_LH                   ((0x4005  << 2) + 0xff000000)
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_cntstscl_low                U     RW        default = 'h40     scale for the contrast low, norm 8 as 1; delta_low = MIN(delta_low, MIN(MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
    //Bit 7   :0      reg_lc_cntstscl_hig                U     RW        default = 'h20     scale for the contrast high,norm 8 as 1; delta_hig = MIN(delta_hig, MIN(MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define LC_CURVE_CONTRAST_BVN_LH                   ((0x4006  << 2) + 0xff000000)
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_cntstbvn_low                U     RW        default = 'h20     scale to num_m as limit of min_val to minBV distance, to protect mono-color, default = 32; min_val= MAX(min_val, minBV- MAX(num_m-1,0)*bvn_low)
    //Bit 7   :0      reg_lc_cntstbvn_hig                U     RW        default = 'h20     scale to num_m as limit of max_val to maxBV distance, to protect mono-color, default = 32; min_val= MIN(max_val, maxBV+ MAX(num_m-1,0)*bvn_lo
#define LC_CURVE_MISC0                             ((0x4007  << 2) + 0xff000000)
    //Bit 31  :20     reserved                           U     RW        default = 'h0     None
    //Bit 19  :16     reg_lc_num_m_coring                U     RW        default = 'h1     coring to num_m, soft coring,default = 2;
    //Bit 15  :8      reg_lc_vbin_min                    U     RW        default = 'h30     4x is min width of valid histogram bin num,
    //Bit 7   :0      reg_lc_slope_max_face              U     RW        default = 'h38      maximum slope for the pkBin-maxBV range curve to do face protection, normalized to 32 as 1, default= 48
#define LC_CURVE_YPKBV_RAT                         ((0x4008  << 2) + 0xff000000)
    //Bit 31  :24     reg_lc_ypkbv_ratio_0               U     RW        default = 'h8c      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 23  :16     reg_lc_ypkbv_ratio_1               U     RW        default = 'ha0      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 15  :8      reg_lc_ypkbv_ratio_2               U     RW        default = 'h78      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
    //Bit 7   :0      reg_lc_ypkbv_ratio_3               U     RW        default = 'h60      x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
#define LC_CURVE_YPKBV_SLP_LMT                     ((0x4009  << 2) + 0xff000000)
    //Bit 31  :16     reserved                           U     RW        default = 'h0     None
    //Bit 15  :8      reg_lc_ypkbv_slope_lmt_0           U     RW        default = 'hc      min max slop for the curves to avoid artifacts, [0] for min_slope, [1] for max_slop, e.g.max_slope= limit*(pkBv-minBv)+min_val as high bound of the ypkBV; normalized to 32 as 1
    //Bit 7   :0      reg_lc_ypkbv_slope_lmt_1           U     RW        default = 'h60     None
#define LC_CURVE_YMINVAL_LMT_0_1                   ((0x400a  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_0               U     RW        default = 'h30      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_1               U     RW        default = 'h50      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_2_3                   ((0x400b  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_2               U     RW        default = 'h78      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_3               U     RW        default = 'h80      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_4_5                   ((0x400c  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_4               U     RW        default = 'ha0      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_5               U     RW        default = 'hc4      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_6_7                   ((0x400d  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_6               U     RW        default = 'he0      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_7               U     RW        default = 'h100      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_8_9                   ((0x400e  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_8               U     RW        default = 'h120      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_9               U     RW        default = 'h140      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_10_11                 ((0x400f  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_10              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_11              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMAXVAL_LMT_0_1                   ((0x4010  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_0         U     RW        default = 'h78      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_1         U     RW        default = 'h96      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_2_3                   ((0x4011  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_2         U     RW        default = 'he6      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_3         U     RW        default = 'h112      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_4_5                   ((0x4012  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_4         U     RW        default = 'h14a      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_5         U     RW        default = 'h180      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_6_7                   ((0x4013  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_6         U     RW        default = 'h1d4      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_7         U     RW        default = 'h200      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_8_9                   ((0x4014  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_8         U     RW        default = 'h240      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_9         U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_10_11                 ((0x4015  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_10        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_11        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_HISTVLD_THRD                      ((0x4016  << 2) + 0xff000000)
    //Bit 31  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_histvld_thrd                U     RW        default = 'h1fa      threshold to compare to bin to get number of valid bins
#define LC_CURVE_BB_MUTE_THRD                      ((0x4017  << 2) + 0xff000000)
    //Bit 31  :24     reserved                           U     RW        default = 'h0     None
    //Bit 23  :0      reg_lc_blackbar_mute_thrd          U     RW        default = 'h2a30      1/8 of the region
#define LC_CURVE_INT_STATUS                        ((0x4018  << 2) + 0xff000000)
#define LC_CURVE_RAM_CTRL                          ((0x4020  << 2) + 0xff000000)
#define LC_CURVE_RAM_ADDR                          ((0x4021  << 2) + 0xff000000)
#define LC_CURVE_RAM_DATA                          ((0x4022  << 2) + 0xff000000)
#define LC_CURVE_YMINVAL_LMT_12_13                 ((0x4040  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_12              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_13              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMINVAL_LMT_14_15                 ((0x4041  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_yminval_lmt_14              U     RW        default = 'h160      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_yminval_lmt_15              U     RW        default = 'h190      lmt_val = lmt[minBV(64:64:768)], and yminV = MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define LC_CURVE_YMAXVAL_LMT_12_13                 ((0x4042  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_12        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_13        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
#define LC_CURVE_YMAXVAL_LMT_14_15                 ((0x4043  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ymaxval_lmt_14        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ymaxval_lmt_15        U     RW        default = 'h280      lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]), default= ...
//u10, lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV])
#define LC_CURVE_YPKBV_LMT_0_1                     ((0x4044  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_0         U     RW        default = 'h78      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_1         U     RW        default = 'h96      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_2_3                     ((0x4045  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_2         U     RW        default = 'he6      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_3         U     RW        default = 'h112      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_4_5                     ((0x4046  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_4         U     RW        default = 'h14a      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_5         U     RW        default = 'h180      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_6_7                     ((0x4047  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_6         U     RW        default = 'h1d4      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_7         U     RW        default = 'h200      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_8_9                     ((0x4048  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_8         U     RW        default = 'h240      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_9         U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_10_11                   ((0x4049  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_10        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_11        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_12_13                   ((0x404a  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_12        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_13        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
#define LC_CURVE_YPKBV_LMT_14_15                   ((0x404b  << 2) + 0xff000000)
    //Bit 31  :26     reserved                           U     RW        default = 'h0     None
    //Bit 25  :16     reg_lc_ypkbv_lmt_14        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
    //Bit 15  :10     reserved                           U     RW        default = 'h0     None
    //Bit 9   :0      reg_lc_ypkbv_lmt_15        U     RW        default = 'h280      lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]), default= ...
//-------------------------------------------------------------
#define LC_STTS_GCLK_CTRL0                         ((0x4028  << 2) + 0xff000000)
#define LC_STTS_CTRL0                              ((0x4029  << 2) + 0xff000000)
#define LC_STTS_WIDTHM1_HEIGHTM1                   ((0x402a  << 2) + 0xff000000)
#define LC_STTS_MATRIX_COEF00_01                   ((0x402b  << 2) + 0xff000000)
#define LC_STTS_MATRIX_COEF02_10                   ((0x402c  << 2) + 0xff000000)
#define LC_STTS_MATRIX_COEF11_12                   ((0x402d  << 2) + 0xff000000)
#define LC_STTS_MATRIX_COEF20_21                   ((0x402e  << 2) + 0xff000000)
#define LC_STTS_MATRIX_COEF22                      ((0x402f  << 2) + 0xff000000)
#define LC_STTS_MATRIX_OFFSET0_1                   ((0x4030  << 2) + 0xff000000)
#define LC_STTS_MATRIX_OFFSET2                     ((0x4031  << 2) + 0xff000000)
#define LC_STTS_MATRIX_PRE_OFFSET0_1               ((0x4032  << 2) + 0xff000000)
#define LC_STTS_MATRIX_PRE_OFFSET2                 ((0x4033  << 2) + 0xff000000)
#define LC_STTS_MATRIX_HL_COLOR                    ((0x4034  << 2) + 0xff000000)
#define LC_STTS_MATRIX_PROBE_POS                   ((0x4035  << 2) + 0xff000000)
#define LC_STTS_MATRIX_PROBE_COLOR                 ((0x4036  << 2) + 0xff000000)
#define LC_STTS_HIST_REGION_IDX                    ((0x4037  << 2) + 0xff000000)
#define LC_STTS_HIST_SET_REGION                    ((0x4038  << 2) + 0xff000000)
#define LC_STTS_HIST_READ_REGION                   ((0x4039  << 2) + 0xff000000)
#define LC_STTS_HIST_START_RD_REGION               ((0x403a  << 2) + 0xff000000)
#define LC_STTS_WHITE_INFO                         ((0x403b  << 2) + 0xff000000)
#define LC_STTS_BLACK_INFO                         ((0x403c  << 2) + 0xff000000)
//
// Closing file:  ./lc_stts_curve.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VDIN_AFBCE_VCBUS_BASE = 0x41
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vdin_afbce_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// VDIN
//===========================================================================
#define VDIN2_WR_CTRL                              ((0x4101  << 2) + 0xff000000)
#define VDIN2_WR_CTRL2                             ((0x4102  << 2) + 0xff000000)
#define VDIN2_WR_H_START_END                       ((0x4103  << 2) + 0xff000000)
#define VDIN2_WR_V_START_END                       ((0x4104  << 2) + 0xff000000)
#define VDIN2_DBG_AXI_CMD_CNT                      ((0x4105  << 2) + 0xff000000)
#define VDIN2_DBG_AXI_DAT_CNT                      ((0x4106  << 2) + 0xff000000)
#define VDIN2_WR_URGENT_CTRL                       ((0x4107  << 2) + 0xff000000)
#define VDIN2_RO_WRMIF_STATUS                      ((0x4108  << 2) + 0xff000000)
#define VDIN2_WR_BADDR_LUMA                        ((0x4110  << 2) + 0xff000000)
#define VDIN2_WR_BADDR_CHROMA                      ((0x4111  << 2) + 0xff000000)
#define VDIN2_WR_STRIDE_LUMA                       ((0x4112  << 2) + 0xff000000)
#define VDIN2_WR_STRIDE_CHROMA                     ((0x4113  << 2) + 0xff000000)
#define VDIN_TOP_SECURE0_ST_RO                     ((0x4109  << 2) + 0xff000000)
#define VDIN_TOP_SECURE_DUMMY                      ((0x410a  << 2) + 0xff000000)
#define VDIN_TOP_DOUBLE_CTRL                       ((0x410b  << 2) + 0xff000000)
#define VDIN_TOP_SECURE1_ST_RO                     ((0x410c  << 2) + 0xff000000)
#define VDIN_TOP_MISC                              ((0x410d  << 2) + 0xff000000)
#define VDIN_TOP_SECURE_REG0                       ((0x410e  << 2) + 0xff000000)
#define VDIN_TOP_SECURE_REG1                       ((0x410f  << 2) + 0xff000000)
#define VDIN_SECURE_RXIN_DW                        ((0x4116  << 2) + 0xff000000)
#define VDIN_TOP_MEAS_RO_LINE                      ((0x4117  << 2) + 0xff000000)
#define VDIN_TOP_MEAS_RO_PIXF                      ((0x4118  << 2) + 0xff000000)
#define VDIN_TOP_MEAS_RO_PIXB                      ((0x4119  << 2) + 0xff000000)
// 8'ha0 ~ 8'hc6
//
// Reading file:  ./vdin_afbc_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define AFBCE_ENABLE                               ((0x41a0  << 2) + 0xff000000)
//Bit   31:20,    gclk_ctrl        unsigned  , default = 0,
//Bit   19:16,    afbce_sync_sel   unsigned  , default = 0,
//Bit   15:14,    reserved
//Bit   13,       enc_rst_mode     unsigned  , default = 0,
//Bit   12,       enc_en_mode      unsigned  , default = 0,
//Bit   11:9,     reserved
//Bit   8,        enc_enable       unsigned  , default = 0,
//Bit   7:1,      reserved
//Bit   0,        reserved         enc_frm_start pulse use this bit don't use
#define AFBCE_MODE                                 ((0x41a1  << 2) + 0xff000000)
//Bit   31:29,    soft_rst         unsigned, default = 0 ,the use as go_field
//Bit   28,       reserved         unsigned, default = 0 , enable singal of crop
//Bit   27:26,    rev_mode         unsigned, default = 0 , reverse mode
//Bit   25:24,    mif_urgent       unsigned, default = 3 , info mif and data mif urgent
//Bit   23,       reserved
//Bit   22:16,    hold_line_num    unsigned, default = 4, 0: burst1 1:burst2 2:burst4
//Bit   15:14,    burst_mode       unsigned, default = 1, 0: burst1 1:burst2 2:burst4
//Bit   13:1,     reserved
//Bit      0,     reg_fmt444_comb  unsigned, default = 0, 0: 444 8bit uncomb
#define AFBCE_SIZE_IN                              ((0x41a2  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hsize_in         unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vsize_in         unsigned, default = 1080 , pic vert size in  unit: pixel
#define AFBCE_BLK_SIZE_IN                          ((0x41a3  << 2) + 0xff000000)
//Bit   31:29,    reserved
//Bit   28:16     hblk_size        unsigned, default = 60 , pic horz size in  unit: pixel
//Bit   15:13,    reserved
//Bit   12:0,     vblk_size        unsigned, default = 270, pic vert size in  unit: pixel
#define AFBCE_HEAD_BADDR                           ((0x41a4  << 2) + 0xff000000)
//Bit   31:0,     head_baddr         unsigned, default = 32'h00;
#define AFBCE_MIF_SIZE                             ((0x41a5  << 2) + 0xff000000)
//Bit   31:30,  reserved
//Bit   29:28,  ddr_blk_size       unsigned, default = 1;
//Bit   27,     reserved
//Bit   26:24,  cmd_blk_size       unsigned, default = 3;
//Bit   23:21,  reserved
//Bit   20:16,  uncmp_size         unsigned, default = 20;
//Bit   15:0,   mmu_page_size      unsigned, default = 4096;
#define AFBCE_PIXEL_IN_HOR_SCOPE                   ((0x41a6  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_h     unsigned, default = 1919 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_h     unsigned, default = 0    ; //
#define AFBCE_PIXEL_IN_VER_SCOPE                   ((0x41a7  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   enc_win_end_v     unsigned, default = 1079 ; //
//Bit   15:13,   reserved
//Bit   12:0,    enc_win_bgn_v     unsigned, default = 0    ; //
#define AFBCE_CONV_CTRL                            ((0x41a8  << 2) + 0xff000000)
//Bit   31:29,   reserved
//Bit   28:16,   fmt_ybuf_depth    unsigned, default = 2048
//Bit   15:12,   reserved
//Bit   11: 0,   lbuf_depth        unsigned, default = 256, unit=16 pixel need to set = 2^n
#define AFBCE_MIF_HOR_SCOPE                        ((0x41a9  << 2) + 0xff000000)
//Bit   31:26,   reserved
//Bit   25:16,   blk_end_h         unsigned, default = 0    ; //
//Bit   15:10,   reserved
//Bit   9:0,     blk_bgn_h         unsigned, default = 59    ; //
#define AFBCE_MIF_VER_SCOPE                        ((0x41aa  << 2) + 0xff000000)
//Bit   31:28,   reserved
//Bit   27:16,   blk_end_v         unsigned, default = 0    ; //
//Bit   15:12,   reserved
//Bit   11:0,    blk_bgn_v         unsigned, default = 269    ; //
#define AFBCE_STAT1                                ((0x41ab  << 2) + 0xff000000)
//Bit   31,     ro_frm_end_pulse1   unsigned, RO,default = 0  ;frame end status
//Bit   30:0,   ro_dbg_top_info1    unsigned, RO,default = 0  ;
#define AFBCE_STAT2                                ((0x41ac  << 2) + 0xff000000)
//Bit   31,     reserved
//Bit   30:0,   ro_dbg_top_info2    unsigned, RO,default = 0  ;
#define AFBCE_FORMAT                               ((0x41ad  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_format_mode           // unsigned ,    RW, default = 2  data format;0 : YUV444, 1:YUV422, 2:YUV420, 3:RGB
//Bit  7: 4        reg_compbits_c            // unsigned ,    RW, default = 10  chroma bitwidth
//Bit  3: 0        reg_compbits_y            // unsigned ,    RW, default = 10  luma bitwidth
#define AFBCE_MODE_EN                              ((0x41ae  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reserved
//Bit 25           reg_adpt_interleave_ymode // unsigned ,    RW, default = 0  force 0 to disable it: no  HW implementation
//Bit 24           reg_adpt_interleave_cmode // unsigned ,    RW, default = 0  force 0 to disable it: not HW implementation
//Bit 23           reg_adpt_yinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 22           reg_adpt_yinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 21           reg_adpt_xinterleave_luma_ride // unsigned ,    RW, default = 1  vertical interleave piece luma reorder ride;   0: no reorder ride; 1: w/4 as ride
//Bit 20           reg_adpt_xinterleave_chrm_ride // unsigned ,    RW, default = 1  vertical interleave piece chroma reorder ride; 0: no reorder ride; 1: w/2 as ride
//Bit 19            reserved
//Bit 18           reg_disable_order_mode_i_6 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 17           reg_disable_order_mode_i_5 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 16           reg_disable_order_mode_i_4 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 15           reg_disable_order_mode_i_3 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 14           reg_disable_order_mode_i_2 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 13           reg_disable_order_mode_i_1 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 12           reg_disable_order_mode_i_0 // unsigned ,    RW, default = 0  disable order mode0~6: each mode with one  disable bit: 0: no disable, 1: diable
//Bit 11            reserved
//Bit 10           reg_minval_yenc_en        // unsigned ,    RW, default = 0  force disable, final decision to remove this ws 1% performance loss
//Bit  9           reg_16x4block_enable      // unsigned ,    RW, default = 0  block as mission, but permit 16x4 block
//Bit  8           reg_uncompress_split_mode // unsigned ,    RW, default = 0  0: no split; 1: split
//Bit  7: 6        reserved
//Bit  5           reg_input_padding_uv128   // unsigned ,    RW, default = 0  input picture 32x4 block gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  4           reg_dwds_padding_uv128    // unsigned ,    RW, default = 0  downsampled image for double write 32x gap mode: 0:  pad uv=0; 1: pad uv=128
//Bit  3: 1        reg_force_order_mode_value // unsigned ,    RW, default = 0  force order mode 0~7
//Bit  0           reg_force_order_mode_en   // unsigned ,    RW, default = 0  force order mode enable: 0: no force; 1: forced to force_value
#define AFBCE_DWSCALAR                             ((0x41af  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 6        reg_dwscalar_w0           // unsigned ,    RW, default = 3  horizontal 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  5: 4        reg_dwscalar_w1           // unsigned ,    RW, default = 0  horizontal 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  3: 2        reg_dwscalar_h0           // unsigned ,    RW, default = 2  vertical 1st step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
//Bit  1: 0        reg_dwscalar_h1           // unsigned ,    RW, default = 3  vertical 2nd step scalar mode: 0: 1:1 no scalar; 1: 2:1 data drop (0,2,4, 6) pixel kept; 2: 2:1 data drop (1, 3, 5,7..) pixels kept; 3: avg
#define AFBCE_DEFCOLOR_1                           ((0x41b0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_3    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_0    // unsigned ,    RW, default = 4095  Picture wise default color value in [Y Cb Cr]
#define AFBCE_DEFCOLOR_2                           ((0x41b1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_enc_default_color_2    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
//Bit 11: 0        reg_enc_default_color_1    // unsigned ,    RW, default = 2048  wise default color value in [Y Cb Cr]
#define AFBCE_QUANT_ENABLE                         ((0x41b2  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11           reg_quant_expand_en_1     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit 10           reg_quant_expand_en_0     // unsigned ,    RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           // signed ,    RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define AFBCE_IQUANT_LUT_1                         ((0x41b3  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCE_IQUANT_LUT_2                         ((0x41b4  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCE_IQUANT_LUT_3                         ((0x41b5  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27            reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23            reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19            reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCE_IQUANT_LUT_4                         ((0x41b6  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11            reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7            reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3            reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCE_RQUANT_LUT_1                         ((0x41b7  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_0_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_0_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_0_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_0_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_4      // unsigned ,    RW, default = 2
#define AFBCE_RQUANT_LUT_2                         ((0x41b8  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_0_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_0_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_0_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_0_0      // unsigned ,    RW, default = 0
#define AFBCE_RQUANT_LUT_3                         ((0x41b9  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rquant_yclut_1_11     // unsigned ,    RW, default = 5  quantization lut for bctree leavs, quant=2^lut(bc_leav_r+1), can be calculated from iquant_yclut(fw_setting)
//Bit 27            reserved
//Bit 26:24        reg_rquant_yclut_1_10     // unsigned ,    RW, default = 5
//Bit 23            reserved
//Bit 22:20        reg_rquant_yclut_1_9      // unsigned ,    RW, default = 4
//Bit 19            reserved
//Bit 18:16        reg_rquant_yclut_1_8      // unsigned ,    RW, default = 4
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_7      // unsigned ,    RW, default = 3
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_6      // unsigned ,    RW, default = 3
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_5      // unsigned ,    RW, default = 2
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_4      // unsigned ,    RW, default = 2
#define AFBCE_RQUANT_LUT_4                         ((0x41ba  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_rquant_yclut_1_3      // unsigned ,    RW, default = 1
//Bit 11            reserved
//Bit 10: 8        reg_rquant_yclut_1_2      // unsigned ,    RW, default = 1
//Bit  7            reserved
//Bit  6: 4        reg_rquant_yclut_1_1      // unsigned ,    RW, default = 0
//Bit  3            reserved
//Bit  2: 0        reg_rquant_yclut_1_0      // unsigned ,    RW, default = 0
#define AFBCE_YUV_FORMAT_CONV_MODE                 ((0x41bb  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reg_444to422_mode         // unsigned ,    RW, default = 0
//Bit  3           reserved
//Bit  2: 0        reg_422to420_mode         // unsigned ,    RW, default = 0
#define AFBCE_DUMMY_DATA                           ((0x41bc  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29: 0        reg_dummy_data           // unsigned ,  default = 0  ;
#define AFBCE_CLR_FLAG                             ((0x41bd  << 2) + 0xff000000)
//Bit 31:0         reg_afbce_clr_flag           // unsigned, default = 0  ;
#define AFBCE_STA_FLAGT                            ((0x41be  << 2) + 0xff000000)
//Bit 31:0         ro_afbce_sta_flag        // unsigned, RO,default = 0  ;
#define AFBCE_MMU_NUM                              ((0x41bf  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        ro_frm_mmu_num           // unsigned, RO,default = 0  ;
#define AFBCE_MMU_RMIF_CTRL1                       ((0x41c0  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define AFBCE_MMU_RMIF_CTRL2                       ((0x41c1  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:24 reserved
//Bit 23:18 reg_gclk_ctrl
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define AFBCE_MMU_RMIF_CTRL3                       ((0x41c2  << 2) + 0xff000000)
//Bit 31:17 reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define AFBCE_MMU_RMIF_CTRL4                       ((0x41c3  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define AFBCE_MMU_RMIF_SCOPE_X                     ((0x41c4  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define AFBCE_MMU_RMIF_SCOPE_Y                     ((0x41c5  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define AFBCE_MMU_RMIF_RO_STAT                     ((0x41c6  << 2) + 0xff000000)
//Bit 15:0  reg_status        // unsigned ,
#define AFBCE_PIP_CTRL                             ((0x41ca  << 2) + 0xff000000)
//Bit   31:3      reserved
//Bit   2         reg_enc_align_en     //unsigned  , RW,default = 1,
//Bit   1         reg_pip_ini_ctrl     //unsigned  , RW,default = 0,
//Bit   0         reg_pip_mode         //unsigned  , RW,default = 0,
#define AFBCE_ROT_CTRL                             ((0x41cb  << 2) + 0xff000000)
//Bit   31:5      reserved
//Bit   4         reg_rot_en           //unsigned  , RW,default = 0, rotation enable
//Bit   3:0       reg_vstep            //unsigned  , RW,default = 8, rotation vstep ,setting acorrding rotation shrink mode
#define AFBCE_DIMM_CTRL                            ((0x41cc  << 2) + 0xff000000)
//Bit   31        reg_dimm_layer_en   //unsigned  , RW,default = 0,dimm_layer enable singal
//Bit   30        reserved
//Bit   29:0      reg_dimm_data       //unsigned  , RW,default = 29'h00080200,dimm_layer data
#define AFBCE_BND_DEC_MISC                         ((0x41cd  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:26  bnd_dec_rev_mode         //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 25:24  bnd_dec_mif_urgent       //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 23:22  bnd_dec_burst_len        //unsigned , RW,default = 2    only pip mode use those bits,usually don't need configure
//Bit 21:20  bnd_dec_ddr_blk_size     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 19     reserved
//Bit 18:16  bnd_dec_cmd_blk_size     //unsigned , RW,default = 3    only pip mode use those bits,usually don't need configure
//Bit 15     reserved
//Bit 14     bnd_dec_blk_mem_mode     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 13     bnd_dec_addr_link_en     //unsigned , RW,default = 1    only pip mode use those bits,usually don't need configure
//Bit 12     bnd_dec_always_body_rden //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:0   bnd_dec_mif_lbuf_depth   //unsigned , RW,default = 128  only pip mode use those bits,usually don't need configure
#define AFBCE_RD_ARB_MISC                          ((0x41ce  << 2) + 0xff000000)
//Bit 31:13  reserved
//Bit 12     reg_arb_sw_rst          //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 11:10  reserved
//Bit 9      reg_arb_arblk_last1     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 8      reg_arb_arblk_last0     //unsigned , RW,default = 0    only pip mode use those bits,usually don't need configure
//Bit 7:4    reg_arb_weight_ch1      //unsigned , RW,default = 4    only pip mode use those bits,usually don't need configure
//Bit 3:0    reg_arb_weight_ch0      //unsigned , RW,default = 10   only pip mode use those bits,usually don't need configure
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vdin_afbc_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vdin_afbce_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBYTV_VCBUS_BASE = 0x43
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby_tv_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_TV_REG_START                         ((0x4300  << 2) + 0xff000000)
// dolby register address 0~0xDA
#define DOLBY_TV_CLKGATE_CTRL                      ((0x43f1  << 2) + 0xff000000)
//bit[9:8]  R-RW 0~3 0  dma2axi_clkgate_ctrl         : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[7:6]  R-RW 0~3 0  bl_dolby_swaps_clkgate_ctrl  : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[5:4]  R-RW 0~3 0  el_swaps_clkgate_ctrl        : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[3:2]  R-RW 0~3 0  el_buf_clkgate_ctrl          : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
//bit[1:0]  R-RW 0~3 0  top_level_reg_clkgate_ctrl   : 0 "auto gated clock", 1 "closed clock", 2&3 "free run clock"
#define DOLBY_TV_SWAP_CTRL0                        ((0x43f2  << 2) + 0xff000000)
//bit[2]  R-RW 0~1  0   el_41mode      : 1 "bl resolution : el resolution = 4:1", 0 "bl_res : el_res = 1:1"
//bit[1]  R-RW 0~1  0   el_enable      : 1 "enhancement layer is supported", 0 "el is not supported"
//bit[0]  R-RW 0~1  0   source_enable  : 1 "base layer is supported", 0 "bl is not supported"
#define DOLBY_TV_SWAP_CTRL1                        ((0x43f3  << 2) + 0xff000000)
//bit[28:16]  R-RW  0~8191 0  htotal  : total pixels number in each line
//bit[21:0]   R-RW  0~8191 0  vtotal  : total line number in each frame (only support progress frame)
#define DOLBY_TV_SWAP_CTRL2                        ((0x43f4  << 2) + 0xff000000)
//bit[28:16]  R-RW  0~4096 0 hsize  : active pixels number in each line
//bit[21:0]   R-RW  0~3840 0 vsize  : active lines number in each frame
#define DOLBY_TV_SWAP_CTRL3                        ((0x43f5  << 2) + 0xff000000)
//bit[28:16]  R-RW  0~8191 0  hsync_width  : hsync signal width (high effective)
//bit[21:0]   R-RW  0~8191 0  vsync_width  : vysnc singal width (high effective)
#define DOLBY_TV_SWAP_CTRL4                        ((0x43f6  << 2) + 0xff000000)
//bit[28:16]  R-RW  0~8191 0  hsync_backporch  : pixels number between hsync and h_active_duration
//bit[21:0]   R-RW  0~8191 0  vsync_backporch  : lines number between vsync and v_active_duration
#define DOLBY_TV_SWAP_CTRL5                        ((0x43f7  << 2) + 0xff000000)
//[25:8]      R-RW                           :   reg_tunnel_sel for tunnel bit match swap
//bit[4]      R-RW  0~1  0   bl_tunnel_mode  :   1 "hdmi input, source is 12bit422 tunnel in 8bit444", 0 "opt mode, 10 bit 444"
//bit[3:2]    R-RW  0~3  0   bl_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
//bit[1:0]    R-RW  0~3  0   el_uv_mode      :   3 "uv=in_u", 2 "uv[0]=u[0],uv[1]=v[0]", 1 "uv[0]=v[0],uv[1]=u[0]", 0 "uv=in_v"
#define DOLBY_TV_SWAP_CTRL6                        ((0x43f8  << 2) + 0xff000000)
//bit[31]     R-RW  0~1      dm_uv_input     :   uv select
//bit[23:16]  R-RW  0~1  0   dump_ctrl       :   1 "fixed output bitdepth as 12bit", 0 "output bitdepth based on vdr_bit_depth"
//bit[15]     R-RW  0~1      datapath_reset_n_enable : manual reset control
//bit[14]     R-RW  0~1      handshake_reset_n_enable : manual reset control
//bit[13]     R-RW  0~1      axi_reset_n_enable : manual reset control
//bit[5:2]    R-RW  0~15     vdr_bit_depth
//bit[1:0]    R-RW  0~3      reg_hdmi_mode
#define DOLBY_TV_SWAP_CTRL7                        ((0x43f9  << 2) + 0xff000000)
//reserved
#define DOLBY_TV_AXI2DMA_CTRL0                     ((0x43fa  << 2) + 0xff000000)
//bit[31]        R-RW   0~1  0    reg_req_en         :  enable req after line count
//bit[30]        R-RW   0~1  0    reg_id_check       :  check the id of data path and req path
//bit[29]        R-RW   0~1  0    reg_clear_fifo     :  manually reset bit
//bit[28]        R-RW   0~1  0    reg_vsync_rst      :  soft_rst auto reset enable
//bit[27]        R-RW   0~1  0    reg_update_addr    :  manually udpate start addr
//bit[26]        R-RW   0~1  0    reg_addr_auto      :  auto update start addr enable
//bit[25]        R-RW   0~1  0    reg_keep_receive   :  data path keep receive
//bit[24:19]     R-RW   0~63 0    reg_req_th         :  fifo_room > req_th, then send the request
//bit[18:16]     R-RW   0~7  0    reg_arsize         :  axi arsize
//bit[14:12]     R-RW   0~7  0    reg_arprot         :  axi arprot
//bit[11:8]      R-RW   0~15 0    reg_aruser         :  axi aruser
//bit[5:4]       R-RW   0~3  0    reg_arid           :  axi arid
//bit[3:0]       R-RW   0~2  0    reg_lens           :  default request lens, each burst has "reg_lens+1" data
#define DOLBY_TV_AXI2DMA_CTRL1                     ((0x43fb  << 2) + 0xff000000)
//bit[31]        R-RW   0~1     0 axi_addr_mode   :  1 "canvas mode", 0 "normal mode"
//bit[27:16]     R-RW   0~4095  0 dma_size0       :  total data number in dma0
//bit[11:0]      R-RW   0~4095  0 dma_size1       :  total data number in dma1
#define DOLBY_TV_AXI2DMA_CTRL2                     ((0x43fc  << 2) + 0xff000000)
//bit[31:0]      R-RW   0~4294967295  0 axi_start_addr : axi start address
#define DOLBY_TV_AXI2DMA_CTRL3                     ((0x43fd  << 2) + 0xff000000)
//bit[11:0]      R-RW   0~4095        0  hold_line     :  after hold_line the axi slave start requesting
#define DOLBY_TV_STATUS0                           ((0x43fe  << 2) + 0xff000000)
#define DOLBY_TV_STATUS1                           ((0x43ff  << 2) + 0xff000000)
#define DOLBY_TV_ADAPTIVE_SCALE_REGADDR            ((0x43e0  << 2) + 0xff000000)
#define DOLBY_TV_ADAPTIVE_SCALE_REGDATA            ((0x43e1  << 2) + 0xff000000)
#define DOLBY_TV_ADAPTIVE_SCALE_LUTADDR            ((0x43e2  << 2) + 0xff000000)
#define DOLBY_TV_ADAPTIVE_SCALE_LUTDATA            ((0x43e3  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby_tv_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY1B_VCBUS_BASE = 0x44
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby1b_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE1B_REG_START                     ((0x4400  << 2) + 0xff000000)
#define DOLBY_CORE1B_CLKGATE_CTRL                  ((0x44f2  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL0                    ((0x44f3  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL1                    ((0x44f4  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL2                    ((0x44f5  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL3                    ((0x44f6  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL4                    ((0x44f7  << 2) + 0xff000000)
#define DOLBY_CORE1B_SWAP_CTRL5                    ((0x44f8  << 2) + 0xff000000)
#define DOLBY_CORE1B_DMA_CTRL                      ((0x44f9  << 2) + 0xff000000)
#define DOLBY_CORE1B_DMA_STATUS                    ((0x44fa  << 2) + 0xff000000)
#define DOLBY_CORE1B_STATUS0                       ((0x44fb  << 2) + 0xff000000)
#define DOLBY_CORE1B_STATUS1                       ((0x44fc  << 2) + 0xff000000)
#define DOLBY_CORE1B_STATUS2                       ((0x44fd  << 2) + 0xff000000)
#define DOLBY_CORE1B_STATUS3                       ((0x44fe  << 2) + 0xff000000)
#define DOLBY_CORE1B_DMA_PORT                      ((0x44ff  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby1b_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPP_VD12_VCBUS_BASE = 0x48
// -----------------------------------------------
//===========================================================================
//`include "afbcd_mult_regs.h"
//
// Reading file:  ./afbcd_vd12_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//   reg addr map
//   0 -3f :  rdmif
//   40-6f :  afbcd
//   70-7f :  fgrain
////===============================////
#define VD1_IF0_GEN_REG                            ((0x4800  << 2) + 0xff000000)
#define VD1_IF0_CANVAS0                            ((0x4801  << 2) + 0xff000000)
#define VD1_IF0_CANVAS1                            ((0x4802  << 2) + 0xff000000)
#define VD1_IF0_LUMA_X0                            ((0x4803  << 2) + 0xff000000)
#define VD1_IF0_LUMA_Y0                            ((0x4804  << 2) + 0xff000000)
#define VD1_IF0_CHROMA_X0                          ((0x4805  << 2) + 0xff000000)
#define VD1_IF0_CHROMA_Y0                          ((0x4806  << 2) + 0xff000000)
#define VD1_IF0_LUMA_X1                            ((0x4807  << 2) + 0xff000000)
#define VD1_IF0_LUMA_Y1                            ((0x4808  << 2) + 0xff000000)
#define VD1_IF0_CHROMA_X1                          ((0x4809  << 2) + 0xff000000)
#define VD1_IF0_CHROMA_Y1                          ((0x480a  << 2) + 0xff000000)
#define VD1_IF0_RPT_LOOP                           ((0x480b  << 2) + 0xff000000)
#define VD1_IF0_LUMA0_RPT_PAT                      ((0x480c  << 2) + 0xff000000)
#define VD1_IF0_CHROMA0_RPT_PAT                    ((0x480d  << 2) + 0xff000000)
#define VD1_IF0_LUMA1_RPT_PAT                      ((0x480e  << 2) + 0xff000000)
#define VD1_IF0_CHROMA1_RPT_PAT                    ((0x480f  << 2) + 0xff000000)
#define VD1_IF0_LUMA_PSEL                          ((0x4810  << 2) + 0xff000000)
#define VD1_IF0_CHROMA_PSEL                        ((0x4811  << 2) + 0xff000000)
#define VD1_IF0_DUMMY_PIXEL                        ((0x4812  << 2) + 0xff000000)
#define VD1_IF0_LUMA_FIFO_SIZE                     ((0x4813  << 2) + 0xff000000)
#define VD1_IF0_AXI_CMD_CNT                        ((0x4814  << 2) + 0xff000000)
#define VD1_IF0_AXI_RDAT_CNT                       ((0x4815  << 2) + 0xff000000)
#define VD1_IF0_RANGE_MAP_Y                        ((0x4816  << 2) + 0xff000000)
#define VD1_IF0_RANGE_MAP_CB                       ((0x4817  << 2) + 0xff000000)
#define VD1_IF0_RANGE_MAP_CR                       ((0x4818  << 2) + 0xff000000)
#define VD1_IF0_GEN_REG2                           ((0x4819  << 2) + 0xff000000)
#define VD1_IF0_PROT                               ((0x481a  << 2) + 0xff000000)
#define VD1_IF0_URGENT_CTRL                        ((0x481b  << 2) + 0xff000000)
#define VD1_IF0_GEN_REG3                           ((0x481c  << 2) + 0xff000000)
#define VIU_VD1_FMT_CTRL                           ((0x481d  << 2) + 0xff000000)
#define VIU_VD1_FMT_W                              ((0x481e  << 2) + 0xff000000)
#define VD1_IF0_BADDR_Y                            ((0x4820  << 2) + 0xff000000)
#define VD1_IF0_BADDR_CB                           ((0x4821  << 2) + 0xff000000)
#define VD1_IF0_BADDR_CR                           ((0x4822  << 2) + 0xff000000)
#define VD1_IF0_STRIDE_0                           ((0x4823  << 2) + 0xff000000)
#define VD1_IF0_STRIDE_1                           ((0x4824  << 2) + 0xff000000)
#define VD1_IF0_BADDR_Y_F1                         ((0x4825  << 2) + 0xff000000)
#define VD1_IF0_BADDR_CB_F1                        ((0x4826  << 2) + 0xff000000)
#define VD1_IF0_BADDR_CR_F1                        ((0x4827  << 2) + 0xff000000)
#define VD1_IF0_STRIDE_0_F1                        ((0x4828  << 2) + 0xff000000)
#define VD1_IF0_STRIDE_1_F1                        ((0x4829  << 2) + 0xff000000)
//8'h28-8'h6f   for vd1_afbcd
//8'h70-8'h7f   for vd1_fgrain
#define VD2_IF0_GEN_REG                            ((0x4880  << 2) + 0xff000000)
#define VD2_IF0_CANVAS0                            ((0x4881  << 2) + 0xff000000)
#define VD2_IF0_CANVAS1                            ((0x4882  << 2) + 0xff000000)
#define VD2_IF0_LUMA_X0                            ((0x4883  << 2) + 0xff000000)
#define VD2_IF0_LUMA_Y0                            ((0x4884  << 2) + 0xff000000)
#define VD2_IF0_CHROMA_X0                          ((0x4885  << 2) + 0xff000000)
#define VD2_IF0_CHROMA_Y0                          ((0x4886  << 2) + 0xff000000)
#define VD2_IF0_LUMA_X1                            ((0x4887  << 2) + 0xff000000)
#define VD2_IF0_LUMA_Y1                            ((0x4888  << 2) + 0xff000000)
#define VD2_IF0_CHROMA_X1                          ((0x4889  << 2) + 0xff000000)
#define VD2_IF0_CHROMA_Y1                          ((0x488a  << 2) + 0xff000000)
#define VD2_IF0_RPT_LOOP                           ((0x488b  << 2) + 0xff000000)
#define VD2_IF0_LUMA0_RPT_PAT                      ((0x488c  << 2) + 0xff000000)
#define VD2_IF0_CHROMA0_RPT_PAT                    ((0x488d  << 2) + 0xff000000)
#define VD2_IF0_LUMA1_RPT_PAT                      ((0x488e  << 2) + 0xff000000)
#define VD2_IF0_CHROMA1_RPT_PAT                    ((0x488f  << 2) + 0xff000000)
#define VD2_IF0_LUMA_PSEL                          ((0x4890  << 2) + 0xff000000)
#define VD2_IF0_CHROMA_PSEL                        ((0x4891  << 2) + 0xff000000)
#define VD2_IF0_DUMMY_PIXEL                        ((0x4892  << 2) + 0xff000000)
#define VD2_IF0_LUMA_FIFO_SIZE                     ((0x4893  << 2) + 0xff000000)
#define VD2_IF0_AXI_CMD_CNT                        ((0x4894  << 2) + 0xff000000)
#define VD2_IF0_AXI_RDAT_CNT                       ((0x4895  << 2) + 0xff000000)
#define VD2_IF0_RANGE_MAP_Y                        ((0x4896  << 2) + 0xff000000)
#define VD2_IF0_RANGE_MAP_CB                       ((0x4897  << 2) + 0xff000000)
#define VD2_IF0_RANGE_MAP_CR                       ((0x4898  << 2) + 0xff000000)
#define VD2_IF0_GEN_REG2                           ((0x4899  << 2) + 0xff000000)
#define VD2_IF0_PROT                               ((0x489a  << 2) + 0xff000000)
#define VD2_IF0_URGENT_CTRL                        ((0x489b  << 2) + 0xff000000)
#define VD2_IF0_GEN_REG3                           ((0x489c  << 2) + 0xff000000)
#define VIU_VD2_FMT_CTRL                           ((0x489d  << 2) + 0xff000000)
#define VIU_VD2_FMT_W                              ((0x489e  << 2) + 0xff000000)
#define VD2_IF0_BADDR_Y                            ((0x48a0  << 2) + 0xff000000)
#define VD2_IF0_BADDR_CB                           ((0x48a1  << 2) + 0xff000000)
#define VD2_IF0_BADDR_CR                           ((0x48a2  << 2) + 0xff000000)
#define VD2_IF0_STRIDE_0                           ((0x48a3  << 2) + 0xff000000)
#define VD2_IF0_STRIDE_1                           ((0x48a4  << 2) + 0xff000000)
#define VD2_IF0_BADDR_Y_F1                         ((0x48a5  << 2) + 0xff000000)
#define VD2_IF0_BADDR_CB_F1                        ((0x48a6  << 2) + 0xff000000)
#define VD2_IF0_BADDR_CR_F1                        ((0x48a7  << 2) + 0xff000000)
#define VD2_IF0_STRIDE_0_F1                        ((0x48a8  << 2) + 0xff000000)
#define VD2_IF0_STRIDE_1_F1                        ((0x48a9  << 2) + 0xff000000)
//8'hb8-8'hef   for vd2_afbcd
//8'hf0-8'hff   for vd2_fgrain
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./afbcd_vd12_regs.h
//
//`include "fgrain_regs.h"      //nouse
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPP_VD34_VCBUS_BASE = 0x49
// -----------------------------------------------
//===========================================================================
//`include "afbcd_mult_regs.h"
//
// Reading file:  ./afbcd_vd34_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//   reg addr map
//   0 -3f :  rdmif
//   40-6f :  afbcd
//   70-7f :  fgrain
////===============================////
#define VD3_IF0_GEN_REG                            ((0x4900  << 2) + 0xff000000)
#define VD3_IF0_CANVAS0                            ((0x4901  << 2) + 0xff000000)
#define VD3_IF0_CANVAS1                            ((0x4902  << 2) + 0xff000000)
#define VD3_IF0_LUMA_X0                            ((0x4903  << 2) + 0xff000000)
#define VD3_IF0_LUMA_Y0                            ((0x4904  << 2) + 0xff000000)
#define VD3_IF0_CHROMA_X0                          ((0x4905  << 2) + 0xff000000)
#define VD3_IF0_CHROMA_Y0                          ((0x4906  << 2) + 0xff000000)
#define VD3_IF0_LUMA_X1                            ((0x4907  << 2) + 0xff000000)
#define VD3_IF0_LUMA_Y1                            ((0x4908  << 2) + 0xff000000)
#define VD3_IF0_CHROMA_X1                          ((0x4909  << 2) + 0xff000000)
#define VD3_IF0_CHROMA_Y1                          ((0x490a  << 2) + 0xff000000)
#define VD3_IF0_RPT_LOOP                           ((0x490b  << 2) + 0xff000000)
#define VD3_IF0_LUMA0_RPT_PAT                      ((0x490c  << 2) + 0xff000000)
#define VD3_IF0_CHROMA0_RPT_PAT                    ((0x490d  << 2) + 0xff000000)
#define VD3_IF0_LUMA1_RPT_PAT                      ((0x490e  << 2) + 0xff000000)
#define VD3_IF0_CHROMA1_RPT_PAT                    ((0x490f  << 2) + 0xff000000)
#define VD3_IF0_LUMA_PSEL                          ((0x4910  << 2) + 0xff000000)
#define VD3_IF0_CHROMA_PSEL                        ((0x4911  << 2) + 0xff000000)
#define VD3_IF0_DUMMY_PIXEL                        ((0x4912  << 2) + 0xff000000)
#define VD3_IF0_LUMA_FIFO_SIZE                     ((0x4913  << 2) + 0xff000000)
#define VD3_IF0_AXI_CMD_CNT                        ((0x4914  << 2) + 0xff000000)
#define VD3_IF0_AXI_RDAT_CNT                       ((0x4915  << 2) + 0xff000000)
#define VD3_IF0_RANGE_MAP_Y                        ((0x4916  << 2) + 0xff000000)
#define VD3_IF0_RANGE_MAP_CB                       ((0x4917  << 2) + 0xff000000)
#define VD3_IF0_RANGE_MAP_CR                       ((0x4918  << 2) + 0xff000000)
#define VD3_IF0_GEN_REG2                           ((0x4919  << 2) + 0xff000000)
#define VD3_IF0_PROT                               ((0x491a  << 2) + 0xff000000)
#define VD3_IF0_URGENT_CTRL                        ((0x491b  << 2) + 0xff000000)
#define VD3_IF0_GEN_REG3                           ((0x491c  << 2) + 0xff000000)
#define VIU_VD3_FMT_CTRL                           ((0x491d  << 2) + 0xff000000)
#define VIU_VD3_FMT_W                              ((0x491e  << 2) + 0xff000000)
#define VD3_IF0_BADDR_Y                            ((0x4920  << 2) + 0xff000000)
#define VD3_IF0_BADDR_CB                           ((0x4921  << 2) + 0xff000000)
#define VD3_IF0_BADDR_CR                           ((0x4922  << 2) + 0xff000000)
#define VD3_IF0_STRIDE_0                           ((0x4923  << 2) + 0xff000000)
#define VD3_IF0_STRIDE_1                           ((0x4924  << 2) + 0xff000000)
#define VD3_IF0_BADDR_Y_F1                         ((0x4925  << 2) + 0xff000000)
#define VD3_IF0_BADDR_CB_F1                        ((0x4926  << 2) + 0xff000000)
#define VD3_IF0_BADDR_CR_F1                        ((0x4927  << 2) + 0xff000000)
#define VD3_IF0_STRIDE_0_F1                        ((0x4928  << 2) + 0xff000000)
#define VD3_IF0_STRIDE_1_F1                        ((0x4929  << 2) + 0xff000000)
//8'h28-8'h6f   for vd3_afbcd
//8'h70-8'h7f   for vd3_fgrain
//8'h80-8'hff   reserved
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./afbcd_vd34_regs.h
//
//`include "fgrain_regs.h"      //nouse
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPC_VCBUS_BASE = 0x50
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./srsharp_regs.h
//
// synopsys translate_off
// synopsys translate_on
//SRSHARP0        8'h00  - 8'hff
//SRSHARP1        8'h100 - 8'1ff
#define  SRSHARP0_OFFSET   (0x000<<2)
#define  SRSHARP1_OFFSET   (0x200<<2)

//
// Reading file:  ./sharp_regs.h
//
#define SHARP_HVSIZE                               ((0x5000  << 2) + 0xff000000)
//Bit 31:29,        reserved
//Bit 28:16,        reg_pknr_hsize                                                                                                              . unsigned  , default = 1920
//Bit 15:13,        reserved
//Bit 12: 0,        reg_pknr_vsize                                                                                                              . unsigned  , default = 1080
#define SHARP_HVBLANK_NUM                          ((0x5001  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_deband_hblank
//Bit 15: 8,        reg_pknr_hblank_num                                                                                                         . unsigned  , default = 20
//Bit  7: 0,        reg_pknr_vblank_num                                                                                                         . unsigned  , default = 73
#define NR_GAUSSIAN_MODE                           ((0x5002  << 2) + 0xff000000)
//Bit 31:14,        reserved
//Bit 13:12,        reg_nr_gau_ynorm                      : C adaptive coef norm, 0: 128, 1: 256, 2: 512, 3: 1024                         . unsigned  , default = 0
//Bit 11:10,        reserved
//Bit  9: 8,        reg_nr_gau_cnorm                      : C adaptive coef norm, 0: 128, 1: 256, 2: 512, 3: 1024                         . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_nr_gau_ymode                      : 0 3x3 filter; 1: 5x5 filter; 2/3:adaptive coef                                . unsigned  , default = 1
//Bit  3: 2,        reserved
//Bit  1: 0,        reg_nr_gau_cmode                      : 0 3x3 filter; 1: 5x5 filter; 2/3:adaptive coef                                . unsigned  , default = 1
#define PK_CON_2CIRHPGAIN_TH_RATE                  ((0x5005  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_cirhpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 25
//Bit 23:16,        reg_pk_cirhpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 60
//Bit 15: 8,        reg_pk_cirhpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_pk_cirhpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 20
#define PK_CON_2CIRHPGAIN_LIMIT                    ((0x5006  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_cirhpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 155
//Bit 23:16,        reg_pk_cirhpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 150
//Bit 15: 8,        reg_pk_cirhpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define PK_CON_2CIRBPGAIN_TH_RATE                  ((0x5007  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_cirbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 20
//Bit 23:16,        reg_pk_cirbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).. unsigned  , default = 50
//Bit 15: 8,        reg_pk_cirbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 50
//Bit  7: 0,        reg_pk_cirbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 25
#define PK_CON_2CIRBPGAIN_LIMIT                    ((0x5008  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_cirbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 155
//Bit 23:16,        reg_pk_cirbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 150
//Bit 15: 8,        reg_pk_cirbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define PK_CON_2DRTHPGAIN_TH_RATE                  ((0x5009  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_drthpcon2gain0                       : threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 25
//Bit 23:16,        reg_pk_drthpcon2gain1                       : threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 60
//Bit 15: 8,        reg_pk_drthpcon2gain5                       : rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_pk_drthpcon2gain6                       : rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 20
#define PK_CON_2DRTHPGAIN_LIMIT                    ((0x500a  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_drthpcon2gain2                       : level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).. unsigned  , default = 105
//Bit 23:16,        reg_pk_drthpcon2gain3                       : level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 96
//Bit 15: 8,        reg_pk_drthpcon2gain4                       : level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define PK_CON_2DRTBPGAIN_TH_RATE                  ((0x500b  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_drtbpcon2gain0                       : threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 20
//Bit 23:16,        reg_pk_drtbpcon2gain1                       : threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
//Bit 15: 8,        reg_pk_drtbpcon2gain5                       : rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 50
//Bit  7: 0,        reg_pk_drtbpcon2gain6                       : rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 25
#define PK_CON_2DRTBPGAIN_LIMIT                    ((0x500c  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_drtbpcon2gain2                       : level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 55
//Bit 23:16,        reg_pk_drtbpcon2gain3                       : level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 40
//Bit 15: 8,        reg_pk_drtbpcon2gain4                       : level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.. unsigned  , default = 5
//Bit  7: 0,        reserved
#define PK_CIRFB_LPF_MODE                          ((0x500d  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:28,        reg_cirhp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 27:26,        reserved
//Bit 25:24,        reg_cirhp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_cirhp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
//Bit 19:14,        reserved
//Bit 13:12,        reg_cirbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit 11:10,        reserved
//Bit  9: 8,        reg_cirbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8                        . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_cirbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                                                   . unsigned  , default = 1
//Bit  3: 0,        reserved
#define PK_DRTFB_LPF_MODE                          ((0x500e  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:28,        reg_drthp_horz_mode                         : no horz filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 27:26,        reserved
//Bit 25:24,        reg_drthp_vert_mode                         : no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_drthp_diag_mode                         : filter on HP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
//Bit 19:14,        reserved
//Bit 13:12,        reg_drtbp_horz_mode                         : no horz filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit 11:10,        reserved
//Bit  9: 8,        reg_drtbp_vert_mode                         : no vert filter on BP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8  2                     . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 4,        reg_drtbp_diag_mode                         : filter on BP; 1: [1 2 1]/4;                             1                     . unsigned  , default = 1
//Bit  3: 0,        reserved
#define PK_CIRFB_HP_CORING                         ((0x500f  << 2) + 0xff000000)
//Bit 31:22,        reserved
//Bit 21:16,        reg_cirhp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_cirhp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_cirhp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 0
#define PK_CIRFB_BP_CORING                         ((0x5010  << 2) + 0xff000000)
//Bit 31:22,        reserved
//Bit 21:16,        reg_cirbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_cirbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_cirbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define PK_DRTFB_HP_CORING                         ((0x5011  << 2) + 0xff000000)
//Bit 31:22,        reserved
//Bit 21:16,        reg_drthp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_drthp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_drthp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define PK_DRTFB_BP_CORING                         ((0x5012  << 2) + 0xff000000)
//Bit 31:22,        reserved
//Bit 21:16,        reg_drtbp_horz_core                         : coring of HP for Horz                                                         . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_drtbp_vert_core                         : coring of HP for Vert                                                         . unsigned  , default = 1
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_drtbp_diag_core                         : coring of HP for Diag                                                         . unsigned  , default = 1
#define PK_CIRFB_BLEND_GAIN                        ((0x5013  << 2) + 0xff000000)
//Bit 31:28,        reg_hp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 27:24,        reg_hp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 23:20,        reg_hp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 19:16,        reserved
//Bit 15:12,        reg_bp_cir_hgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit 11: 8,        reg_bp_cir_vgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit  7: 4,        reg_bp_cir_dgain                            : normalized 8 as '1'                                                           . unsigned  , default = 8
//Bit  3: 0,        reserved
#define NR_ALPY_SSD_GAIN_OFST                      ((0x5014  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_nr_alp0_ssd_gain                        : gain to max ssd normalized 16 as '1'                                          . unsigned  , default = 16
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp0_ssd_ofst                        : offset to ssd before dividing to min_err                                      . signed    , default = -2
#define NR_ALP0Y_ERR2CURV_TH_RATE                  ((0x5015  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp0_minerr_ypar0                    : threshold0 of curve to map mierr to alp0 for luma channel, this will be set value of flat region mierr that no need blur. 0~255.. unsigned  , default = 10
//Bit 23:16,        reg_nr_alp0_minerr_ypar1                    : threshold1 of curve to map mierr to alp0 for luma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
//Bit 15: 8,        reg_nr_alp0_minerr_ypar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_nr_alp0_minerr_ypar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for luma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
#define NR_ALP0Y_ERR2CURV_LIMIT                    ((0x5016  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp0_minerr_ypar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
//Bit 23:16,        reg_nr_alp0_minerr_ypar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
//Bit 15: 8,        reg_nr_alp0_minerr_ypar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for luma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
//Bit  7: 0,        reserved
#define NR_ALP0C_ERR2CURV_TH_RATE                  ((0x5017  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp0_minerr_cpar0                    : threshold0 of curve to map mierr to alp0 for chroma channel, this will be set value of flat region mierr that no need blur.. unsigned  , default = 10
//Bit 23:16,        reg_nr_alp0_minerr_cpar1                    : threshold1 of curve to map mierr to alp0 for chroma channel,this will be set value of texture region mierr that can not blur.. unsigned  , default = 25
//Bit 15: 8,        reg_nr_alp0_minerr_cpar5                    : rate0 (for mierr<th0) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 80
//Bit  7: 0,        reg_nr_alp0_minerr_cpar6                    : rate1 (for mierr>th1) of curve to map mierr to alp0 for chroma channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 64
#define NR_ALP0C_ERR2CURV_LIMIT                    ((0x5018  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp0_minerr_cpar2                    : level limit(for mierr<th0) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for flat region. 0~255.. unsigned  , default = 63
//Bit 23:16,        reg_nr_alp0_minerr_cpar3                    : level limit(for th0<mierr<th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for misc region. 0~255.. unsigned  , default = 0
//Bit 15: 8,        reg_nr_alp0_minerr_cpar4                    : level limit(for mierr>th1) of curve to map mierr to alp0 for chroma channel, this will be set to alp0 that we can do for texture region. 0~255.. unsigned  , default = 63
//Bit  7: 0,        reserved
#define NR_ALP0_MIN_MAX                            ((0x5019  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_nr_alp0_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_nr_alp0_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp0_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp0_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define NR_ALP1_MIERR_CORING                       ((0x501a  << 2) + 0xff000000)
//Bit 31:17,        reserved
//Bit 16,            reg_nr_alp1_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp1_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp1_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 3
#define NR_ALP1_ERR2CURV_TH_RATE                   ((0x501b  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp1_minerr_par0                     : threshold0 of curve to map mierr to alp1 for luma/chroma channel, this will be set value of flat region mierr that no need directional NR. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_nr_alp1_minerr_par1                     : threshold1 of curve to map mierr to alp1 for luma/chroma  channel,this will be set value of texture region mierr that can not do directional NR. 0~255.. unsigned  , default = 24
//Bit 15: 8,        reg_nr_alp1_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope.. unsigned  , default = 0
//Bit  7: 0,        reg_nr_alp1_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel. the larger of the value, the deep of the slope. 0~255. unsigned  , default = 20
#define NR_ALP1_ERR2CURV_LIMIT                     ((0x501c  << 2) + 0xff000000)
//Bit 31:24,        reg_nr_alp1_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for flat region. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_nr_alp1_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for misc region. 0~255.. unsigned  , default = 16
//Bit 15: 8,        reg_nr_alp1_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp1 for luma/chroma  channel, this will be set to alp1 that we can do for texture region. 0~255.255 before. unsigned  , default = 63
//Bit  7: 0,        reserved
#define NR_ALP1_MIN_MAX                            ((0x501d  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_nr_alp1_ymin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit 23:22,        reserved
//Bit 21:16,        reg_nr_alp1_ymax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
//Bit 15:14,        reserved
//Bit 13: 8,        reg_nr_alp1_cmin                            : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_nr_alp1_cmax                            : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define PK_ALP2_MIERR_CORING                       ((0x501e  << 2) + 0xff000000)
//Bit 31:17,        reserved
//Bit 16,            reg_pk_alp2_maxerr_mode                     : 0 max err; 1: xerr                                                            . unsigned  , default = 1
//Bit 15:14,        reserved
//Bit 13: 8,        reg_pk_alp2_core_rate                       : normalized 64 as "1"                                                          . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_pk_alp2_core_ofst                       : normalized 64 as "1"                                                          . signed    , default = 1
#define PK_ALP2_ERR2CURV_TH_RATE                   ((0x501f  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_alp2_minerr_par0                     : threshold0 of curve to map mierr to alp2 for luma channel, this will be set value of flat region mierr that no need peaking.. unsigned  , default = 0
//Bit 23:16,        reg_pk_alp2_minerr_par1                     : threshold1 of curve to map mierr to alp2 for luma  channel,this will be set value of texture region mierr that can not do peaking. 0~255.. unsigned  , default = 24
//Bit 15: 8,        reg_pk_alp2_minerr_par5                     : rate0 (for mierr<th0) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 0
//Bit  7: 0,        reg_pk_alp2_minerr_par6                     : rate1 (for mierr>th1) of curve to map mierr to alp2 for luma  channel. the larger of the value, the deep of the slope. 0~255.. unsigned  , default = 20
#define PK_ALP2_ERR2CURV_LIMIT                     ((0x5020  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_alp2_minerr_par2                     : level limit(for mierr<th0) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for flat region. 0~255.. unsigned  , default = 0
//Bit 23:16,        reg_pk_alp2_minerr_par3                     : level limit(for th0<mierr<th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for misc region. 0~255.. unsigned  , default = 16
//Bit 15: 8,        reg_pk_alp2_minerr_par4                     : level limit(for mierr>th1) of curve to map mierr to alp2 for luma  channel, this will be set to alp2 that we can do for texture region. 0~255. default = 32;. unsigned  , default = 32
//Bit  7: 0,        reserved
#define PK_ALP2_MIN_MAX                            ((0x5021  << 2) + 0xff000000)
//Bit 31:14,        reserved
//Bit 13: 8,        reg_pk_alp2_min                             : normalized to 64 as '1'                                                       . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_pk_alp2_max                             : normalized to 64 as '1'                                                       . unsigned  , default = 63
#define PK_FINALGAIN_HP_BP                         ((0x5022  << 2) + 0xff000000)
//Bit 31:18,        reserved
//Bit 17:16,        reg_final_gain_rs                           : s2: right shift bits for the gain normalization, 0 normal to 32 as 1; 1 normalize to 64 as 1; -2 normalized to 8 as 1; -1 normalize 16 as 1. default = 0
//Bit 15: 8,        reg_hp_final_gain                           : gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 40
//Bit  7: 0,        reg_bp_final_gain                           : gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32. unsigned  , default = 30
#define PK_OS_HORZ_CORE_GAIN                       ((0x5023  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_os_hsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
//Bit 23:16,        reg_pk_os_hsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
//Bit 15: 8,        reg_pk_os_hmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in horizontal direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
//Bit  7: 0,        reg_pk_os_hmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in horizontal direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
#define PK_OS_VERT_CORE_GAIN                       ((0x5024  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_os_vsidecore                         : side coring (not to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 8
//Bit 23:16,        reg_pk_os_vsidegain                         : side gain (not to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
//Bit 15: 8,        reg_pk_os_vmidcore                          : midd coring (to current pixel) to adaptive overshoot margin in vertical direction. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 2
//Bit  7: 0,        reg_pk_os_vmidgain                          : midd gain (to current pixel) to adaptive overshoot margin in vertical direction. normalized to 32 as '1'. 0~255;. unsigned  , default = 20
#define PK_OS_ADPT_MISC                            ((0x5025  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_os_minerr_core                       : coring to minerr for adaptive overshoot margin. the larger of this value, the less overshoot admitted 0~255;. unsigned  , default = 40
//Bit 23:16,        reg_pk_os_minerr_gain                       : gain to minerr based adaptive overshoot margin. normalized to 64 as '1'. 0~255;. unsigned  , default = 6
//Bit 15: 8,        reg_pk_os_adpt_max                          : maximum limit adaptive overshoot margin (4x). 0~255;                          . unsigned  , default = 200
//Bit  7: 0,        reg_pk_os_adpt_min                          : minimun limit adaptive overshoot margin (1x). 0~255;                          . unsigned  , default = 20
#define PK_OS_STATIC                               ((0x5026  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:28,        reg_pk_osh_mode                             : 0~3: (2x+1) window in H direction                                             . unsigned  , default = 2
//Bit 27:26,        reserved
//Bit 25:24,        reg_pk_osv_mode                             : 0~3: (2x+1) window in V direction                                             . unsigned  , default = 2
//Bit 23:22,        reserved
//Bit 21:12,        reg_pk_os_down                              : static negative overshoot margin. 0~1023;                                     . unsigned  , default = 200
//Bit 11:10,        reserved
//Bit  9: 0,        reg_pk_os_up                                : static positive overshoot margin. 0~1023;                                     . unsigned  , default = 200
#define PK_NR_ENABLE                               ((0x5027  << 2) + 0xff000000)
//Bit 31: 4,        reserved
//Bit  3: 2,        reg_3d_mode                                 , 0: no 3D; 1: L/R; 2: T/B; 3: horizontal interleaved, dft = 0                                             //. unsigned  , default = 0
//Bit  1,            reg_pk_en                                                                                                                   . unsigned  , default = 1
//Bit  0,            reg_nr_en                                                                                                                   . unsigned  , default = 1
#define PK_DRT_SAD_MISC                            ((0x5028  << 2) + 0xff000000)
//Bit 31:24,        reg_pk_sad_ver_gain                         : gain to sad[4], 16 normalized to "1";                                         . unsigned  , default = 32
//Bit 23:16,        reg_pk_sad_hor_gain                         : gain to sad[0], 16 normalized to "1";                                         . unsigned  , default = 24
//Bit 15:12,        reserved
//Bit 11            reserved
//Bit 10: 9,        reg_pk_bias_diag                            : bias towards diag                                                             . unsigned  , default = 0
//Bit  8,           reserved
//Bit  7: 5,        reserved
//Bit  4: 0,        reg_pk_drt_force                            : force direction of drt peaking filter, h2b: 0:hp drt force, 1: bp drt force; 2: bp+hp drt force, 3: no force;. unsigned  , default = 24
#define NR_TI_DNLP_BLEND                           ((0x5029  << 2) + 0xff000000)
//Bit 31:11,        reserved
//Bit 10: 8,        reg_dnlp_input_mode                         : dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os). unsigned  , default = 4
//Bit  7: 4,        reserved
//Bit  3: 2,        reg_nr_cti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:cti; 2: (nr+cti)/2; 3:cti + dlt_nr  . unsigned  , default = 1
//Bit  1: 0,        reg_nr_lti_blend_mode                       : blend mode of nr and lti result: 0: nr; 1:lti; 2: (nr+lti)/2; 3:lti + dlt_nr  . unsigned  , default = 2
////////////////////////////////////////////////////////////////////////////////
// new ti regsters from here
////////////////////////////////////////////////////////////////////////////////
#define LTI_DIR_CORE_ALPHA                         ((0x502a  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_lti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 10
//Bit 23:20,        reserved
//Bit 19:16,        reg_adp_lti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_lti_dir_alpmin                      : min value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=10              . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_lti_dir_alpmax                      : max value of alpha, alpha = (min_err+x +ofst)/max_err*64; dft=63              . unsigned  , default = 63
#define CTI_DIR_ALPHA                              ((0x502b  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_cti_dir_alp_core_ofst               : ofst to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;    dft=10. unsigned  , default = 5
//Bit 23:20,        reserved
//Bit 19:16,        reg_adp_cti_dir_alp_core_rate               : ofset to min_err, alpha = (min_err - (max_err-min_err)*rate + ofst)/max_err*64;   dft=0/32. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_cti_dir_alpmin                      : min value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=10             . unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_cti_dir_alpmax                      : max value of alpha, alpha = (min_err +x+ofst)/max_err*64;  dft=63             . unsigned  , default = 63
#define LTI_CTI_DF_GAIN                            ((0x502c  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_adp_lti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit 23:22,        reserved
//Bit 21:16,        reg_adp_lti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit 15:14,        reserved
//Bit 13: 8,        reg_adp_cti_hdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_adp_cti_vdf_gain                        : 8 normalized to "1";  default = 12                                            . unsigned  , default = 12
#define LTI_CTI_DIR_AC_DBG                         ((0x502d  << 2) + 0xff000000)
//Bit 31,            reserved
//Bit 30,            reg_adp_lti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf                                               . unsigned  , default = 1
//Bit 29,            reserved
//Bit 28,            reg_adp_lti_dir_difmode                     : 0: y_dif; 1: y_dif + (u_dif+v_dif)/2;                                         . unsigned  , default = 1
//Bit 27,            reserved
//Bit 26,            reg_adp_cti_dir_lpf                         : 0: no lpf; 1: [1 2 2 2 1]/8 lpf  dft=1                                        . unsigned  , default = 1
//Bit 25:24,        reg_adp_cti_dir_difmode                     : 0: (u_dif+v_dif); 1: y_dif/2 + (u_dif+v_dif)*3/4; 2: y_dif + (u_dif+v_dif)/2; 3: y_dif*2 (not recommended). unsigned  , default = 2
//Bit 23:22,        reg_adp_hvlti_dcblend_mode                  : 0: hlti_dc; 1:vlti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 3
//Bit 21:20,        reg_adp_hvcti_dcblend_mode                  : 0: hcti_dc; 1:vcti_dc; 2: avg  3; blend on alpha                              . unsigned  , default = 2
//Bit 19:18,        reg_adp_hvlti_acblend_mode                  : hlti_ac; 1:vlti_ac; 2: add  3;:adaptive to alpha                              . unsigned  , default = 3
//Bit 17:16,        reg_adp_hvcti_acblend_mode                  : hcti_ac; 1:vcti_ac; 2: add  3;: adaptive to alpha                             . unsigned  , default = 2
//Bit 15,            reserved
//Bit 14:12,        reg_adp_hlti_debug                          , for hlti debug, default = 0                                                   . unsigned  , default = 0
//Bit 11,            reserved
//Bit 10: 8,        reg_adp_vlti_debug                          , for vlti debug, default = 0                                                   . unsigned  , default = 0
//Bit  7,            reserved
//Bit  6: 4,        reg_adp_hcti_debug                          , for hcti debug, default = 0                                                   . unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_vcti_debug                          , for vcti debug, default = 0                                                   . unsigned  , default = 0
#define HCTI_FLT_CLP_DC                            ((0x502e  << 2) + 0xff000000)
//Bit 31:29,        reserved
//Bit 28,            reg_adp_hcti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
//Bit 27:26,        reg_adp_hcti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8  3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
//Bit 25:24,        reg_adp_hcti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 2. unsigned  , default = 2
//Bit 23:22,        reg_adp_hcti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2     . unsigned  , default = 2
//Bit 21:20,        reg_adp_hcti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
//Bit 19:18,        reg_adp_hcti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
//Bit 17:16,        reg_adp_hcti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
//Bit 15:12,        reg_adp_hcti_hard_clp_win                   , window size, 0~8, default = 5                                                 . unsigned  , default = 5
//Bit 11: 8,        reg_adp_hcti_hard_win_min                   , window size, 0~8, default = 3                                                 . unsigned  , default = 3
//Bit  7: 5,        reserved
//Bit  4,            reg_adp_hcti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 1                                   . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_hcti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 0    . unsigned  , default = 0
#define HCTI_BST_GAIN                              ((0x502f  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hcti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 80                         . unsigned  , default = 80
//Bit 23:16,        reg_adp_hcti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 96                          . unsigned  , default = 96
//Bit 15: 8,        reg_adp_hcti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 64                          . unsigned  , default = 64
//Bit  7: 0,        reg_adp_hcti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 16                       . unsigned  , default = 16
#define HCTI_BST_CORE                              ((0x5030  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hcti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
//Bit 23:16,        reg_adp_hcti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hcti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
//Bit  7: 0,        reg_adp_hcti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 5
#define HCTI_CON_2_GAIN_0                          ((0x5031  << 2) + 0xff000000)
//Bit 31:29,        reg_adp_hcti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: .... default = 1. unsigned  , default = 1
//Bit 28:26,        reg_adp_hcti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 2                       . unsigned  , default = 2
//Bit 25:24,        reg_adp_hcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit 23:16,        reg_adp_hcti_con_2_gain0                    , default = 25                                                                  . unsigned  , default = 25
//Bit 15: 8,        reg_adp_hcti_con_2_gain1                    , default = 60                                                                  . unsigned  , default = 60
//Bit  7: 0,        reg_adp_hcti_con_2_gain2                    0;, default = 5                                                                 . unsigned  , default = 5
#define HCTI_CON_2_GAIN_1                          ((0x5032  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
//Bit 23:16,        reg_adp_hcti_con_2_gain4                    5;, default = 5                                                                 . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit  7: 0,        reg_adp_hcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
#define HCTI_OS_MARGIN                             ((0x5033  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_adp_hcti_os_margin                      : margin for hcti overshoot, default = 0                                        . unsigned  , default = 0
#define HLTI_FLT_CLP_DC                            ((0x5034  << 2) + 0xff000000)
//Bit 31:29,        reserved
//Bit 28,            reg_adp_hlti_en                             , 0: no cti, 1: new cti, default = 1                                            . unsigned  , default = 1
//Bit 27:26,        reg_adp_hlti_vdn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2    . unsigned  , default = 2
//Bit 25:24,        reg_adp_hlti_hdn_flt                        , 0: no lpf; 1:[0, 0, 0, 4, 8, 4, 0, 0, 0], 2:[0, 0, 2, 4, 4, 4, 2, 0, 0], 3: [1, 2, 2, 2, 2, 2, 2, 2, 1], default = 1. unsigned  , default = 1
//Bit 23:22,        reg_adp_hlti_ddn_flt                        , 0: no lpf; 1:[0,2,4,2,0],   2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 1    . unsigned  , default = 1
//Bit 21:20,        reg_adp_hlti_lpf0_flt                       , 0:no filter; 1:sigma=0.75, 2: sigma = 1.0, 3: sigma = 1.5, default = 1        . unsigned  , default = 1
//Bit 19:18,        reg_adp_hlti_lpf1_flt                       , 0:no filter; 1:sigma= 2.0, 2: sigma = 3.0, 3: sigma = 4.0, default = 1        . unsigned  , default = 1
//Bit 17:16,        reg_adp_hlti_lpf2_flt                       , 0:no filter; 1:sigma=5.0,  2: sigma = 9.0, 3: sigma = 13.0, default = 1       . unsigned  , default = 1
//Bit 15:12,        reg_adp_hlti_hard_clp_win                   , window size, 0~8, default = 2                                                 . unsigned  , default = 2
//Bit 11: 8,        reg_adp_hlti_hard_win_min                   , window size, 0~8, default = 1                                                 . unsigned  , default = 1
//Bit  7: 5,        reserved
//Bit  4,            reg_adp_hlti_clp_mode                       , 0: hard clip, 1: adaptive clip, default = 0                                   . unsigned  , default = 0
//Bit  3,            reserved
//Bit  2: 0,        reg_adp_hlti_dc_mode                        , 0:dn, 1:lpf0, 2:lpf1, 3:lpf2, 4: lpf3: 5: vdn result; 6/7:org, default = 4    . unsigned  , default = 4
#define HLTI_BST_GAIN                              ((0x5035  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hlti_bst_gain0                      : gain of the bandpass 0 (lpf1-lpf2)- LBP, default = 32                         . unsigned  , default = 32
//Bit 23:16,        reg_adp_hlti_bst_gain1                      : gain of the bandpass 1 (lpf0-lpf1)- BP, default = 32                          . unsigned  , default = 32
//Bit 15: 8,        reg_adp_hlti_bst_gain2                      : gain of the bandpass 2 (hdn-lpf0)-  HP, default = 28                          . unsigned  , default = 28
//Bit  7: 0,        reg_adp_hlti_bst_gain3                      : gain of the unsharp band (yuvin-hdn) - US, default = 12                       . unsigned  , default = 12
#define HLTI_BST_CORE                              ((0x5036  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hlti_bst_core0                      : core of the bandpass 0 (lpf1-lpf2)- LBP, default = 5                          . unsigned  , default = 5
//Bit 23:16,        reg_adp_hlti_bst_core1                      : core of the bandpass 1 (lpf0-lpf1)- BP, default = 5                           . unsigned  , default = 5
//Bit 15: 8,        reg_adp_hlti_bst_core2                      : core of the bandpass 2 (hdn-lpf0)-  HP, default = 5                           . unsigned  , default = 5
//Bit  7: 0,        reg_adp_hlti_bst_core3                      : core of the unsharp band (yuvin-hdn) - US, default = 3                        . unsigned  , default = 3
#define HLTI_CON_2_GAIN_0                          ((0x5037  << 2) + 0xff000000)
//Bit 31:29,        reg_adp_hlti_con_mode                       : con mode 0:[0, 0,-1, 1, 0, 0, 0]+[0, 0, 0, 1,-1, 0, 0], 1: [0, 0,-1, 0, 1, 0, 0], 2: [0,-1, 0, 0, 0, 1, 0], 3:[-1, 0, 0, 0, 0, 0, 1], 4: ....., default = 1. unsigned  , default = 1
//Bit 28:26,        reg_adp_hlti_dx_mode                        : dx mode 0: [-1 1 0]; 1~7: [-1 (2x+1)"0" 1], default = 1                       . unsigned  , default = 1
//Bit 25:24,        reg_adp_hlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit 23:16,        reg_adp_hlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 15: 8,        reg_adp_hlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit  7: 0,        reg_adp_hlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
#define HLTI_CON_2_GAIN_1                          ((0x5038  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_hlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
//Bit 23:16,        reg_adp_hlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 15: 8,        reg_adp_hlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit  7: 0,        reg_adp_hlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
#define HLTI_OS_MARGIN                             ((0x5039  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_adp_hlti_os_margin                      : margin for hlti overshoot, default = 0                                        . unsigned  , default = 0
#define VLTI_FLT_CON_CLP                           ((0x503a  << 2) + 0xff000000)
//Bit 31:15,        reserved
//Bit 14,            reg_adp_vlti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
//Bit 13:12,        reg_adp_vlti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit 11:10,        reg_adp_vlti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  9: 8,        reg_adp_vlti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  7: 6,        reg_adp_vlti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  5: 4,        reg_adp_vlti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2,            reg_adp_vlti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit  1,            reserved
//Bit  0,            reg_adp_vlti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
#define VLTI_BST_GAIN                              ((0x503b  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vlti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 32                                 . unsigned  , default = 32
//Bit 15: 8,        reg_adp_vlti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 32                             . unsigned  , default = 32
//Bit  7: 0,        reg_adp_vlti_bst_gain2                      : gain to boost filter usf, default = 32                                        . unsigned  , default = 32
#define VLTI_BST_CORE                              ((0x503c  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vlti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
//Bit 15: 8,        reg_adp_vlti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vlti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
#define VLTI_CON_2_GAIN_0                          ((0x503d  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_vlti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 23:16,        reg_adp_vlti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit 15: 8,        reg_adp_vlti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vlti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
#define VLTI_CON_2_GAIN_1                          ((0x503e  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_vlti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 23:16,        reg_adp_vlti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit 15: 8,        reg_adp_vlti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
//Bit  7: 0,        reg_adp_vlti_os_margin                      : margin for vlti overshoot, default = 0                                        . unsigned  , default = 0
#define VCTI_FLT_CON_CLP                           ((0x503f  << 2) + 0xff000000)
//Bit 31:15,        reserved
//Bit 14,            reg_adp_vcti_en                             : enable bit of vlti, default = 1                                               . unsigned  , default = 1
//Bit 13:12,        reg_adp_vcti_hxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit 11:10,        reg_adp_vcti_dxn_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  9: 8,        reg_adp_vcti_han_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  7: 6,        reg_adp_vcti_dan_flt                        : 0: no dn; 1: [1 2 1]/4;  2 : [1 2 2 2 1]/8 3:[1 0 2 0 1]/4, default = 2       . unsigned  , default = 2
//Bit  5: 4,        reg_adp_vcti_dx_mode                        : 0:[-1 1] 1:[-1 0 -1]; 2/3: [-1 0 0 0 -1], default = 1                         . unsigned  , default = 1
//Bit  3,            reserved
//Bit  2,            reg_adp_vcti_con_lpf                        : lpf mode of the con: 0: [1 2 1]/4; 1:[1 2 2 2 1]/8, default = 0               . unsigned  , default = 0
//Bit  1,            reserved
//Bit  0,            reg_adp_vcti_hard_clp_win                   : window size; 0: 1x3 window; 1: 1x5 window, default = 0                        . unsigned  , default = 0
#define VCTI_BST_GAIN                              ((0x5040  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vcti_bst_gain0                      : gain to boost filter [-1 2 -1];, default = 16                                  . unsigned  , default = 16
//Bit 15: 8,        reg_adp_vcti_bst_gain1                      : gain to boost filter [-1 0 2 0 -1];, default = 16                              . unsigned  , default = 16
//Bit  7: 0,        reg_adp_vcti_bst_gain2                      : gain to boost filter usf, default = 16                                         . unsigned  , default = 16
#define VCTI_BST_CORE                              ((0x5041  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_adp_vcti_bst_core0                      : coring to boost filter [-1 2 -1];, default = 5                                . unsigned  , default = 5
//Bit 15: 8,        reg_adp_vcti_bst_core1                      : coring to boost filter [-1 0 2 0 -1];, default = 5                            . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vcti_bst_core2                      : coring to boost filter usf, default = 3                                       . unsigned  , default = 3
#define VCTI_CON_2_GAIN_0                          ((0x5042  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_vcti_con_2_gain0                    25;, default = 25                                                               . unsigned  , default = 25
//Bit 23:16,        reg_adp_vcti_con_2_gain1                    60;, default = 60                                                               . unsigned  , default = 60
//Bit 15: 8,        reg_adp_vcti_con_2_gain2                    0;, default = 5                                                                . unsigned  , default = 5
//Bit  7: 0,        reg_adp_vcti_con_2_gain3                    96;, default = 96                                                               . unsigned  , default = 96
#define VCTI_CON_2_GAIN_1                          ((0x5043  << 2) + 0xff000000)
//Bit 31:24,        reg_adp_vcti_con_2_gain4                    5;, default = 95                                                                . unsigned  , default = 95
//Bit 23:16,        reg_adp_vcti_con_2_gain5                    80;, default = 80                                                               . unsigned  , default = 80
//Bit 15: 8,        reg_adp_vcti_con_2_gain6                    20;, default = 20                                                               . unsigned  , default = 20
//Bit  7: 0,        reg_adp_vcti_os_margin                      : margin for vcti overshoot, default = 0                                        . unsigned  , default = 0
#define SHARP_3DLIMIT                              ((0x5044  << 2) + 0xff000000)
//Bit 31:29,        reserved
//Bit 28:16,        reg_3d_mid_width                            ,width of left part of 3d input, dft = half size of input width  default = 0    . unsigned  , default = 960
//Bit 15:13,        reserved
//Bit 12: 0,        reg_3d_mid_height                           ,height of left part of 3d input, dft = half size of input height  default = 0  . unsigned  , default = 540
#define DNLP_EN                                    ((0x5045  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_dnlp_hblank
//Bit  7: 1,        reserved
//Bit  0,           reg_dnlp_en                                                                                                                 . unsigned  , default = 1
#define DEMO_CRTL                                  ((0x5056  << 2) + 0xff000000)
//Bit 31:19,        reserved
//Bit 18:17,        demo_disp_position                                                                                                          . unsigned  , default = 2
//Bit 16,           demo_hsvsharp_enable                                                                                                        . unsigned  , default = 0
//Bit 15:13,        reserved
//Bit 12: 0,        demo_left_top_screen_width                  :                                                                               . unsigned  , default = 360
#define SHARP_SR2_CTRL                             ((0x5057  << 2) + 0xff000000)
//Bit 31:25,    reserved
//Bit 24        reg_sr2_bic_pknr_bypass            :
//Bit 23:22     reserved
//Bit 21:16,    reg_sr2_pk_la_err_dis_rate         :     . unsigned  , low angle and high angle error should not be no less than nearby_error*rate/64; default = 24
//Bit 15:8,     reg_sr2_pk_sad_diag_gain           :     . unsigned  , gain to sad[2] and sad[6], 16 normalized to "1"; default = 16
//Bit 7,        reg_sr2_vert_outphs                :     . unsigned  , default = 0
//Bit 6,        reg_sr2_horz_outphs                :     . unsigned  , default = 0
//Bit 5,        reg_sr2_vert_ratio                 :     . unsigned  , default = 0
//Bit 4,        reg_sr2_hori_ratio                 :     . unsigned  , default = 0
//Bit 3,        reg_sr2_bic_norm                   :     . unsigned  , default = 1
//Bit 2,        reg_sr2_enable                     :     . unsigned  , default = 0
//Bit 1,        reg_sr2_sharp_prc_lr_hbic          :     . unsigned  , default = 0
//Bit 0,        reg_sr2_sharp_prc_lr               : lti/cti/nr/peaking processing using LR grid, 0: on HR grid; 1:on LR grid, horizontally no upscale, but using simple bic   . unsigned  , default = 0
#define SHARP_SR2_YBIC_HCOEF0                      ((0x5058  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_y_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel Filter will be normalized to 128 as "1"; default=0
//Bit 23:16, reg_sr2_y_bic_hcoef02            the same as above; default=0
//Bit 15: 8, reg_sr2_y_bic_hcoef01            the same as above; default=64
//Bit  7: 0, reg_sr2_y_bic_hcoef00            the same as above; default=0
#define SHARP_SR2_YBIC_HCOEF1                      ((0x5059  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_y_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as "1"; default=-4
//Bit 23:16, reg_sr2_y_bic_hcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_y_bic_hcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_y_bic_hcoef10            the same as above; default=-4
#define SHARP_SR2_CBIC_HCOEF0                      ((0x505a  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_c_bic_hcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel ,Filter will be normalized to 128 as "1"; default=0
//Bit 23:16, reg_sr2_c_bic_hcoef02            the same as above; default=21
//Bit 15: 8, reg_sr2_c_bic_hcoef01            the same as above; default=22
//Bit  7: 0, reg_sr2_c_bic_hcoef00            the same as above; default=21
#define SHARP_SR2_CBIC_HCOEF1                      ((0x505b  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_c_bic_hcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as "1"; default=-4
//Bit 23:16, reg_sr2_c_bic_hcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_c_bic_hcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_c_bic_hcoef10            the same as above; default=-4
#define SHARP_SR2_YBIC_VCOEF0                      ((0x505c  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_y_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as "1"; default=0
//Bit 23:16, reg_sr2_y_bic_vcoef02            the same as above; default=0
//Bit 15: 8, reg_sr2_y_bic_vcoef01            the same as above; default=64
//Bit  7: 0, reg_sr2_y_bic_vcoef00            the same as above; default=0
#define SHARP_SR2_YBIC_VCOEF1                      ((0x505d  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_y_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channe, lFilter will be normalized to 128 as "1"; default=-4
//Bit 23:16, reg_sr2_y_bic_vcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_y_bic_vcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_y_bic_vcoef10            the same as above; default=-4
#define SHARP_SR2_CBIC_VCOEF0                      ((0x505e  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_c_bic_vcoef03            Horizontal bi-cubic filter of 1.0 phase of luma channel, Filter will be normalized to 128 as "1"; default=0
//Bit 23:16, reg_sr2_c_bic_vcoef02            the same as above; default=21
//Bit 15: 8, reg_sr2_c_bic_vcoef01            the same as above; default=22
//Bit  7: 0, reg_sr2_c_bic_vcoef00            the same as above; default=21
#define SHARP_SR2_CBIC_VCOEF1                      ((0x505f  << 2) + 0xff000000)
//Bit 31:24, reg_sr2_c_bic_vcoef13            Horizontal bi-cubic filter of 0.5 phase of luma channel,Filter will be normalized to 128 as "1"; default=-4
//Bit 23:16, reg_sr2_c_bic_vcoef12            the same as above; default=36
//Bit 15: 8, reg_sr2_c_bic_vcoef11            the same as above; default=36
//Bit  7: 0, reg_sr2_c_bic_vcoef10            the same as above; default=-4
#define SHARP_SR2_MISC                             ((0x5060  << 2) + 0xff000000)
//Bit 31:2,   reserved
//Bit 1,      reg_sr2_cmpmux_bef                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for RGB->GBR;
//Bit 0,      reg_sr2_cmpmux_aft                 :     . unsigned  , default = 0,0 no swap anf for YUV->YUV; 1, swapped and for GBR-RGB;
#define SHARP_SR3_SAD_CTRL                         ((0x5061  << 2) + 0xff000000)
//Bit 31:30 reserved
//Bit 29:24 reg_sr3_pk_sad_core_rate         // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
//Bit 23:22 reserved
//Bit 21:16 reg_sr3_lti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
//Bit 15:14 reserved
//Bit 13:8  reg_sr3_cti_sad_core_rate        // u6: rate of coring for sad(theta) - sad(theta+pi/2)*rate/64 , default= 6
//Bit 7,    reg_sr3_lti_hsad_mode            // u1: mode for hsad of lti calculation; 0: block based; 1:other shape; default= 1
//Bit 6,    reg_sr3_cti_hsad_mode            // u1: mode for hsad of cti calculation; 0: block based; 1:other shape; default= 1
//Bit 5,    reg_sr3_lti_dsad_mode            // u1: mode for dsad of lti calculation, 0: block based; 1:other shape; default= 1
//Bit 4,    reg_sr3_cti_dsad_mode            // u1: mode for dsad of cti calculation, 0: block based; 1:other shape; default= 1
//Bit 3,    reg_sr3_lti_vsad_mode            // u1: mode for vsad of lti calculation, 0: block based; 1:other shape; default= 1
//Bit 2,    reg_sr3_cti_vsad_mode            // u1: mode for vsad of cti calculation, 0: block based; 1:other shape; default= 1
//Bit 1,    reg_sr3_lti_hsad_hlpf            // u1: hlpf for hsad of lti calculation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
//Bit 0,    reg_sr3_cti_hsad_hlpf            // u1: hlpf for hsad of cti calculation, 0: no hlpf; 1: with [1 2 1] hlpf; default= 1
#define SHARP_SR3_PK_CTRL0                         ((0x5062  << 2) + 0xff000000)
//Bit 31:12 reserved
//Bit 11,   reg_sr3_pk_sad_mode              // u1: mode for sad of peaking and noise reduction, 0: block based; 1:other shape; default= 1
//Bit 10,   reg_sr3_pk_hsad_hlpf             // u1: hlpf for hsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 9,    reg_sr3_pk_vsad_hlpf             // u1: hlpf for vsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 8,    reg_sr3_pk_dsad_hlpf             // u1: hlpf for dsad for peaking calculation, 0: no hlpf; 1: with [1 2 2 2 1] hlpf; default= 1
//Bit 7:6,  reg_sr3_pk_hpdrt_mode            // u2: mode for HPdrt filter:  default= 3
//Bit 5:4,  reg_sr3_pk_bpdrt_mode            // u2: mode for BPdrt filter:  default= 3
//Bit 3:2,  reg_sr3_pk_drtbld_range          // u2: range of the min2 and min direction distance; default =1
//Bit 1,    reserved
//Bit 0,    reg_sr3_pk_ti_blend_mode         // u1: blend mode of the TI and PK results: default = 0;
#define SHARP_SR3_PK_CTRL1                         ((0x5063  << 2) + 0xff000000)
//Bit 31,     reserved
//Bit 30:28,  reg_sr3_pk_hp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
//Bit 27,     reserved
//Bit 26:24,  reg_sr3_pk_bp_hvcon_replace8_maxsad     //u3: replace HP hvcon by maxsad, default =1
//Bit 23:16,  reg_sr3_pk_hp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
//Bit 15:8,   reg_sr3_pk_bp_hvcon_replace8lv_gain     //u8: gain to local variant before calculating the hv gain for peaking, normalized to 32 as "1" default = 32;
//Bit 7,      reg_sr3_sad_intlev_mode                 //u1: interleave detection xerr mode: 0 max; 1:sum default=1
//Bit 6,      reg_sr3_sad_intlev_mode1                //u1: mode 1 of using diagonal protection: 0: no digonal protection; 1: with diagonal protection default=1
//Bit 5:0,    reg_sr3_sad_intlev_gain                 //u6: interleave detection for sad gain applied, normalized to 8 as 1  default=12
#define SHARP_DEJ_CTRL                             ((0x5064  << 2) + 0xff000000)
//Bit 31:4    reserved
//Bit 15:8,   reg_sr3_dejaggy_hblank           // u8
//Bit 7:4     reserved
//Bit 3:2,    reg_sr3_dejaggy_sameside_prtct   // u2:  enable of sr3 dejaggy same side curve protect from filter, [0] for proc, [1] for ctrl path,  default=3
//Bit 1,      reg_sr3_dejaggy_sameside_mode    // u1: mode of the sameside flag decision: default =1
//Bit 0,      reg_sr3_dejaggy_enable           // u1: enable of sr3 dejaggy: default =0
#define SHARP_DEJ_ALPHA                            ((0x5065  << 2) + 0xff000000)
//Bit 31:28,  reg_sr3_dejaggy_ctrlchrm_alpha_1  //u4: alpha for LR video LPF,  default = 0
//Bit 27:24,  reg_sr3_dejaggy_ctrlchrm_alpha_0  //u4: alpha for LR video LPF,  default = 15
//Bit 23:20,  reg_sr3_dejaggy_ctrlluma_alpha_1  //u4: alpha for LR video LPF,  default = 0
//Bit 19:16,  reg_sr3_dejaggy_ctrlluma_alpha_0  //u4: alpha for LR video LPF,  default = 15
//Bit 15:12,  reg_sr3_dejaggy_procchrm_alpha_1  //u4: alpha for LR video LPF,  default = 4
//Bit 11:8,   reg_sr3_dejaggy_procchrm_alpha_0  //u4: alpha for LR video LPF,  default = 6
//Bit 7:4,    reg_sr3_dejaggy_procluma_alpha_1  //u4: alpha for LR video LPF,  default = 4
//Bit 3:0,    reg_sr3_dejaggy_procluma_alpha_0  //u4: alpha for LR video LPF,  default = 6
#define SHARP_SR3_DRTLPF_EN                        ((0x5066  << 2) + 0xff000000)
//Bit 31:15   reserved
//Bit 14:8,   reg_pk_debug_edge                . unsigned  , default = 0
//Bit  7,     reserved
//Bit  6:4,   reg_sr3_drtlpf_theta_en           //u1x3 theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  3,     reserved
//Bit  2:0    reg_sr3_drtlpf_enable             //u1x3 directional lpf on luma U and V channels, default = 7
#define SHARP_SR3_DRTLPF_ALPHA_0                   ((0x5067  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha3             //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 9
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha2             //u6: default =10
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha1             //u6: default = 11
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha0             //u6: default = 12
#define SHARP_SR3_DRTLPF_ALPHA_1                   ((0x5068  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha7             //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 1
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha6             //u6: default = 4
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha5             //u6: default = 7
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha4             //u6: default = 8
#define SHARP_SR3_DRTLPF_ALPHA_2                   ((0x5069  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:24   reg_sr3_drtlpf_alpha11            //u6: directional lpf alpha coef for min_sad/max_sad compared, default = 0
//Bit 23:22   reserved
//Bit 21:16   reg_sr3_drtlpf_alpha10            //u6: default = 0
//Bit 15:14   reserved
//Bit 13:8    reg_sr3_drtlpf_alpha9             //u6: default = 0
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_drtlpf_alpha8             //u6: default = 0
#define SHARP_SR3_DRTLPF_ALPHA_OFST                ((0x506a  << 2) + 0xff000000)
//Bit 31:28   reg_sr3_drtlpf_alpha_ofst7        //s4: directional lpf alpha coef ofset of each directions, default = -8
//Bit 27:24   reg_sr3_drtlpf_alpha_ofst6        //s4: default = -8
//Bit 23:20   reg_sr3_drtlpf_alpha_ofst5        //s4: default = -8
//Bit 19:16   reg_sr3_drtlpf_alpha_ofst4        //s4: default = -8
//Bit 15:12   reg_sr3_drtlpf_alpha_ofst3        //s4: default = -8
//Bit 11:8    reg_sr3_drtlpf_alpha_ofst2        //s4: default = -8
//Bit 7:4     reg_sr3_drtlpf_alpha_ofst1        //s4: default = -8
//Bit 3:0     reg_sr3_drtlpf_alpha_ofst0        //s4: default = -8
#define SHARP_SR3_DERING_CTRL                      ((0x506b  << 2) + 0xff000000)
//Bit 31      reserved
//Bit 30:28   reg_sr3_dering_enable                  // u3: dering enable bits; default = 1
//Bit 27      reserved
//Bit 26:24   reg_sr3_dering_varlpf_mode             // u3: local variant LPF mode: 0 no filter, 1, erosion 3x3; 2: 3x3 lpf; 3 and up: 3x3 erosion + lpf default = 3
//Bit 23:20   reg_sr3_dering_maxrange                // u4: maximum:range of dering in LR resolution, max to 12;  default = 9
//Bit 19:18   reserved
//Bit 17:16   reg_sr3_dering_lcvar_blend_mode        // u2: mode for lcvar calculation: 0: HVblend; 1: diagblend; 2: HVblend+V (for hring); 3: HVblend+ DiagBlend default = 2
//Bit 15:8    reg_sr3_dering_lcvar_gain              // u8: gain to local variant and normalized to 32 as "1"  default = 64
//Bit 7:0     reg_sr3_dering_lcvar_nearby_maxsad_th  // u8: threshold to use nearer side maxsad if that side sad is larger than this threshold, otherwise, use the max one default = 28
#define SHARP_SR3_DERING_LUMA2PKGAIN_0TO3          ((0x506c  << 2) + 0xff000000)
//Bit 31:24   reg_sr3_dering_luma2pkgain3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkgain based on LPF luma level. default=255
//Bit 23:16   reg_sr3_dering_luma2pkgain2             // u8: level limit(for bpcon<th0) of curve for dering pkgain based on LPF luma level. default=255
//Bit 15:8    reg_sr3_dering_luma2pkgain1             // u8: threshold1 of curve for dering pkgain based on LPF luma level  default =200
//Bit 7:0     reg_sr3_dering_luma2pkgain0             // u8: threshold0 of curve for dering pkgain based on LPF luma level. default =30
#define SHARP_SR3_DERING_LUMA2PKGAIN_4TO6          ((0x506d  << 2) + 0xff000000)
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_luma2pkgain6             // u8: rate1 (for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =24
//Bit 15:8    reg_sr3_dering_luma2pkgain5             // u8: rate0 (for bpcon<th0) of curve for dering pkgain based on LPF luma level. dfault =50
//Bit 7:0     reg_sr3_dering_luma2pkgain4             // u8: level limit(for bpcon>th1) of curve for dering pkgain based on LPF luma level. default =255
#define SHARP_SR3_DERING_LUMA2PKOS_0TO3            ((0x506e  << 2) + 0xff000000)
//Bit 31:24   reg_sr3_dering_luma2pkos3             // u8: level limit(for th0<bpcon<th1) of curve for dering pkOS based on LPF luma level. default=255
//Bit 23:16   reg_sr3_dering_luma2pkos2             // u8: level limit(for bpcon<th0) of curve for dering pkOS based on LPF luma level. default=255
//Bit 15:8    reg_sr3_dering_luma2pkos1             // u8: threshold1 of curve for dering pkOS based on LPF luma level  default =200
//Bit 7:0     reg_sr3_dering_luma2pkos0             // u8: threshold0 of curve for dering pkOS based on LPF luma leve. default =30
#define SHARP_SR3_DERING_LUMA2PKOS_4TO6            ((0x506f  << 2) + 0xff000000)
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_luma2pkos6             // u8: rate1 (for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =24
//Bit 15:8    reg_sr3_dering_luma2pkos5             // u8: rate0 (for bpcon<th0) of curve for dering pkOS based on LPF luma level. dfault =50
//Bit 7:0     reg_sr3_dering_luma2pkos4             // u8: level limit(for bpcon>th1) of curve for dering pkOS based on LPF luma level. default =255
#define SHARP_SR3_DERING_GAINVS_MADSAD             ((0x5070  << 2) + 0xff000000)
//Bit 31:28   reg_sr3_dering_gainvs_maxsad7        //u4: pkgain vs maxsad value, 8 node interpolations, default = 0
//Bit 27:24   reg_sr3_dering_gainvs_maxsad6        //u4: default = 0
//Bit 23:20   reg_sr3_dering_gainvs_maxsad5        //u4: default = 0
//Bit 19:16   reg_sr3_dering_gainvs_maxsad4        //u4: default = 0
//Bit 15:12   reg_sr3_dering_gainvs_maxsad3        //u4: default = 0
//Bit 11:8    reg_sr3_dering_gainvs_maxsad2        //u4: default = 0
//Bit 7:4     reg_sr3_dering_gainvs_maxsad1        //u4: default = 4
//Bit 3:0     reg_sr3_dering_gainvs_maxsad0        //u4: default = 8
#define SHARP_SR3_DERING_GAINVS_VR2MAX             ((0x5071  << 2) + 0xff000000)
//Bit 31:28   reg_sr3_dering_gainvs_vr2max7        //u4: pkgain vs ratio = max(local_var, floor)/maxsad nearby, default = 15
//Bit 27:24   reg_sr3_dering_gainvs_vr2max6        //u4: default = 15
//Bit 23:20   reg_sr3_dering_gainvs_vr2max5        //u4: default = 15
//Bit 19:16   reg_sr3_dering_gainvs_vr2max4        //u4: default = 15
//Bit 15:12   reg_sr3_dering_gainvs_vr2max3        //u4: default = 14
//Bit 11:8    reg_sr3_dering_gainvs_vr2max2        //u4: default = 12
//Bit 7:4     reg_sr3_dering_gainvs_vr2max1        //u4: default = 2
//Bit 3:0     reg_sr3_dering_gainvs_vr2max0        //u4: default = 0
#define SHARP_SR3_DERING_PARAM0                    ((0x5072  << 2) + 0xff000000)
//Bit 31:24   reserved
//Bit 23:16   reg_sr3_dering_lcvar_floor        //u8: local variant no smaller than this value to calculate dgain max(localvar,x)/maxsad. default = 10
//Bit 15:8    reg_sr3_dering_vr2max_gain        //u8: gain to max(local_var, floor)/maxsad  before feeding to LUT. default = 32
//Bit 7:6     reserved
//Bit 5:0     reg_sr3_dering_vr2max_limt        //u6: limit of maxsad to max(local_var, floor)*(max(maxsad, lmit))/maxsad.  default = 16
#define SHARP_SR3_DRTLPF_THETA                     ((0x5073  << 2) + 0xff000000)
//Bit 31:0    reg_sr3_drtlpf_theta              //u4x8: directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
#define SHARP_SATPRT_CTRL                          ((0x5074  << 2) + 0xff000000)
//Bit 31:28   reserved
//Bit 27:16   reg_satprt_sat_core      //u8: 4x will be coring to cor(irgb_max-irgb_min) to calculate the oy_delt, the smaller the more protection to color, the larger only the rich color will be protected;
//Bit 15:8    reg_satprt_sat_rate      //u8: rate to cor(irgb_max-irgb_min) to calculate the oy_delt, the larger the more protection to rich color; norm 16 as 1
//Bit 7:4     reserved
//Bit 3:2     reg_satprt_csc_mode      //u2: csc mode of current yuv input: 0:601, 1:709, 2:BT2020 NCL, 3:reserved
//Bit 1       reg_satprt_is_lmt        //u1: flag telling the YUV is limited range data or full range data, 0 full range, 1: limited range
//Bit 0       reg_satprt_enable        //u1: enable of saturation protection for dnlp adjustments
#define SHARP_SATPRT_DIVM                          ((0x5075  << 2) + 0xff000000)
//Bit 31:24   reserved
//Bit 23:0    reg_satprt_div_m        //u8x3, 1/m, normalized to 128 as 1, default=1
#define SHARP_DB_FLT_CTRL                          ((0x5077  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1
//Bit 25           reg_nrdeband_reset0
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  0:yuv 1:RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 1  debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 1  debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 1   debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 1   debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define SHARP_DB_FLT_RANDLUT                       ((0x5079  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdebandslut7         // unsigned , default = 1   lut0
//Bit 20:18        reg_nrdebandslut6         // unsigned , default = 1   lut0
//Bit 17:15        reg_nrdebandslut5         // unsigned , default = 1   lut0
//Bit 14:12        reg_nrdebandslut4         // unsigned , default = 1   lut0
//Bit 11: 9        reg_nrdebandslut3         // unsigned , default = 1   lut0
//Bit  8: 6        reg_nrdebandslut2         // unsigned , default = 1   lut0
//Bit  5: 3        reg_nrdebandslut1         // unsigned , default = 1   lut0
//Bit  2: 0        reg_nrdebandslut0         // unsigned , default = 1   lut0
#define SHARP_DB_FLT_PXI_THRD                      ((0x507a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   to luma/|u/v| for using the denoise
#define SHARP_DB_FLT_SEED_Y                        ((0x507b  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define SHARP_DB_FLT_SEED_U                        ((0x507c  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  noise adding seed for U. seed[0]= 0x60a52f27; as default
#define SHARP_DB_FLT_SEED_V                        ((0x507d  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  noise adding seed for V. seed[0]= 0x60a52f22; as default
#define SHARP_PKGAIN_VSLUMA_LUT_L                  ((0x507e  << 2) + 0xff000000)
//Bit 31:28       reg_pkgain_vsluma_lut7;
//Bit 27:24       reg_pkgain_vsluma_lut6;
//Bit 23:20       reg_pkgain_vsluma_lut5;
//Bit 19:16       reg_pkgain_vsluma_lut4;
//Bit 15:12       reg_pkgain_vsluma_lut3;
//Bit 11: 8       reg_pkgain_vsluma_lut2;
//Bit  7: 4       reg_pkgain_vsluma_lut1;
//Bit  3: 0       reg_pkgain_vsluma_lut0;
#define SHARP_PKGAIN_VSLUMA_LUT_H                  ((0x507f  << 2) + 0xff000000)
//Bit 31: 4       reserved;
//Bit  3: 0       reg_pkgain_vsluma_lut8;
#define SHARP_PKOSHT_VSLUMA_LUT_L                  ((0x5080  << 2) + 0xff000000)
//Bit 31:28       reg_pkosht_vsluma_lut7;
//Bit 27:24       reg_pkosht_vsluma_lut6;
//Bit 23:20       reg_pkosht_vsluma_lut5;
//Bit 19:16       reg_pkosht_vsluma_lut4;
//Bit 15:12       reg_pkosht_vsluma_lut3;
//Bit 11: 8       reg_pkosht_vsluma_lut2;
//Bit  7: 4       reg_pkosht_vsluma_lut1;
//Bit  3: 0       reg_pkosht_vsluma_lut0;
#define SHARP_PKOSHT_VSLUMA_LUT_H                  ((0x5081  << 2) + 0xff000000)
//Bit 31: 4       reserved;
//Bit  3: 0       reg_pkosht_vsluma_lut8;
#define SHARP_SATPRT_LMT_RGB1                      ((0x5082  << 2) + 0xff000000)
//Bit 31:28       reserved
//Bit 27:16       reg_satprt_lmt_g      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
//Bit 15:12       reserved
//Bit 11:0        reg_satprt_lmt_r      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
#define SHARP_SATPRT_LMT_RGB2                      ((0x5083  << 2) + 0xff000000)
//Bit 31:12       reserved
//Bit 11:0        reg_satprt_lmt_b      //u12x3, limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023
#define SHARP_GATE_CLK_CTRL_0                      ((0x5084  << 2) + 0xff000000)
//Bit  31: 0     reg_gate_clk_ctrl_0
#define SHARP_GATE_CLK_CTRL_1                      ((0x5085  << 2) + 0xff000000)
//Bit  31: 0     reg_gate_clk_ctrl_1
#define SHARP_GATE_CLK_CTRL_2                      ((0x5086  << 2) + 0xff000000)
//Bit  31: 0     reg_gate_clk_ctrl_2
#define SHARP_GATE_CLK_CTRL_3                      ((0x5087  << 2) + 0xff000000)
//Bit  31: 0     reg_gate_clk_ctrl_3
#define SHARP_DPS_CTRL                             ((0x5088  << 2) + 0xff000000)
//Bit  31: 0     reg_sharp_dps_ctrl
#define DNLP_00                                    ((0x5090  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid0                          : dnlp00                                                                        . unsigned  , default = 32'h00008060
#define DNLP_01                                    ((0x5091  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid1                          : dnlp01                                                                        . unsigned  , default = 32'h100e0c0a
#define DNLP_02                                    ((0x5092  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid2                          : dnlp02                                                                        . unsigned  , default = 32'h1a171412
#define DNLP_03                                    ((0x5093  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid3                          : dnlp03                                                                        . unsigned  , default = 32'h2824201d
#define DNLP_04                                    ((0x5094  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid4                          : dnlp04                                                                        . unsigned  , default = 32'h3834302c
#define DNLP_05                                    ((0x5095  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid5                          : dnlp05                                                                        . unsigned  , default = 32'h4b45403c
#define DNLP_06                                    ((0x5096  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid6                          : dnlp06                                                                        . unsigned  , default = 32'h605b5550
#define DNLP_07                                    ((0x5097  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid7                          : dnlp07                                                                        . unsigned  , default = 32'h80787068
#define DNLP_08                                    ((0x5098  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid8                          : dnlp08                                                                        . unsigned  , default = 32'ha0989088
#define DNLP_09                                    ((0x5099  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid9                          : dnlp09                                                                        . unsigned  , default = 32'hb8b2aca6
#define DNLP_10                                    ((0x509a  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid10                         : dnlp10                                                                        . unsigned  , default = 32'hc8c4c0bc
#define DNLP_11                                    ((0x509b  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid11                         : dnlp11                                                                        . unsigned  , default = 32'hd4d2cecb
#define DNLP_12                                    ((0x509c  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid12                         : dnlp12                                                                        . unsigned  , default = 32'hdad8d7d6
#define DNLP_13                                    ((0x509d  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid13                         : dnlp13                                                                        . unsigned  , default = 32'he2e0dedc
#define DNLP_14                                    ((0x509e  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid14                         : dnlp14                                                                        . unsigned  , default = 32'hf0ece8e4
#define DNLP_15                                    ((0x509f  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid15                         : dnlp15                                                                        . unsigned  , default = 32'hfffcf8f4
#define DNLP_16                                    ((0x50a0  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid16                         : dnlp16                                                                        . unsigned  , default = 32'h08060402
#define DNLP_17                                    ((0x50a1  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid17                         : dnlp17                                                                        . unsigned  , default = 32'h100e0c0a
#define DNLP_18                                    ((0x50a2  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid18                         : dnlp18                                                                        . unsigned  , default = 32'h1a171412
#define DNLP_19                                    ((0x50a3  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid19                         : dnlp19                                                                        . unsigned  , default = 32'h2824201d
#define DNLP_20                                    ((0x50a4  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid20                         : dnlp20                                                                        . unsigned  , default = 32'h3834302c
#define DNLP_21                                    ((0x50a5  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid21                         : dnlp21                                                                        . unsigned  , default = 32'h4b45403c
#define DNLP_22                                    ((0x50a6  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid22                         : dnlp22                                                                        . unsigned  , default = 32'h605b5550
#define DNLP_23                                    ((0x50a7  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid23                         : dnlp23                                                                        . unsigned  , default = 32'h80787068
#define DNLP_24                                    ((0x50a8  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid24                         : dnlp24                                                                        . unsigned  , default = 32'ha0989088
#define DNLP_25                                    ((0x50a9  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid25                         : dnlp25                                                                        . unsigned  , default = 32'hb8b2aca6
#define DNLP_26                                    ((0x50aa  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid26                         : dnlp26                                                                        . unsigned  , default = 32'hc8c4c0bc
#define DNLP_27                                    ((0x50ab  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid27                         : dnlp27                                                                        . unsigned  , default = 32'hd4d2cecb
#define DNLP_28                                    ((0x50ac  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid28                         : dnlp28                                                                        . unsigned  , default = 32'hdad8d7d6
#define DNLP_29                                    ((0x50ad  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid29                         : dnlp29                                                                        . unsigned  , default = 32'he2e0dedc
#define DNLP_30                                    ((0x50ae  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid30                         : dnlp30                                                                        . unsigned  , default = 32'hf0ece8e4
#define DNLP_31                                    ((0x50af  << 2) + 0xff000000)
//Bit 31: 0,      reg_dnlp_ygrid31                         : dnlp31                                                                        . unsigned  , default = 32'hfffcf8f4
#define SHARP_SYNC_CTRL                            ((0x50b0  << 2) + 0xff000000)
//Bit 15: 0,      reg_sync_ctrl                            //reg_sync_ctrl: shadow register control                                       . unsigned  , default = 0
#define LC_INPUT_MUX                               ((0x50b1  << 2) + 0xff000000)
//Bit 31:7   reserved
//Bit 6:4    reg_lcinput_ysel               //u3, local contrast luma input options 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os) . unsigned  , default = 5
//Bit 3      reserved
//Bit 2:0    reg_lcinput_csel               //u3, local contrast chroma input options 0: org_c; 1: gau_c; 2: gauadp_c; 3: edgadplpf_c; 4: nr_c;5: cti_c; 6: pk_c . unsigned  , default = 5
#define NR_GAU_YH_COEF02                           ((0x50b2  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_yhcoef_0          //s10, luma's horizontal adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_yhcoef_1          //s10, luma's horizontal adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_yhcoef_2          //s10, luma's horizontal adaptive coef2   . signed  , default = 16
#define NR_GAU_YH_COEF34                           ((0x50b3  << 2) + 0xff000000)
//Bit 31:20   reserved
//Bit 19:10   reg_nr_gau_yhcoef_3          //s10, luma's horizontal adaptive coef3   . signed  , default = 0
//Bit  9: 0   reg_nr_gau_yhcoef_4          //s10, luma's horizontal adaptive coef4   . signed  , default = 0
#define NR_GAU_YV_COEF1                            ((0x50b4  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_yvcoef_0          //s10, luma's vertical adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_yvcoef_1          //s10, luma's vertical adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_yvcoef_2          //s10, luma's vertical adaptive coef2   . signed  , default = 16
#define NR_GAU_CH_COEF02                           ((0x50b5  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_chcoef_0          //s10, chroma's horizontal adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_chcoef_1          //s10, chroma's horizontal adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_chcoef_2          //s10, chroma's horizontal adaptive coef2   . signed  , default = 16
#define NR_GAU_CH_COEF34                           ((0x50b6  << 2) + 0xff000000)
//Bit 31:20   reserved
//Bit 19:10   reg_nr_gau_chcoef_3          //s10, chroma's horizontal adaptive coef3   . signed  , default = 0
//Bit  9: 0   reg_nr_gau_chcoef_4          //s10, chroma's horizontal adaptive coef4   . signed  , default = 0
#define NR_GAU_CV_COEF1                            ((0x50b7  << 2) + 0xff000000)
//Bit 31:30   reserved
//Bit 29:20   reg_nr_gau_cvcoef_0          //s10, chroma's vertical adaptive coef0   . signed  , default = 32
//Bit 19:10   reg_nr_gau_cvcoef_1          //s10, chroma's vertical adaptive coef1   . signed  , default = 32
//Bit  9: 0   reg_nr_gau_cvcoef_2          //s10, chroma's vertical adaptive coef2   . signed  , default = 16
#define SHARP_DB_FLT_CTRL1                         ((0x50b8  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11           reserved
//Bit 10: 8        reserved
//Bit  7           reserved
//Bit  6: 4        reserved
//Bit  3           reserved
//Bit  2: 0        reserved
#define SHARP_DB_FLT_LUMA_THRD                     ((0x50b9  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define SHARP_DB_FLT_CHRM_THRD                     ((0x50ba  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define LC_TOP_CTRL                                ((0x50c0  << 2) + 0xff000000)
    //Bit 31  :8      reg_lc_misc                        U     RW        default = 'h0
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4           reg_lc_enable                      U     RW        default = 'h1      enable signal for local contrast enhancement, 1-enable; 0 disable
    //Bit 3   :1      reserved                           U     RW        default = 'h0     None
    //Bit 0           reg_lc_blkblend_mode               U     RW        default = 'h1      use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
#define LC_HV_NUM                                  ((0x50c1  << 2) + 0xff000000)
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :8      reg_lc_blk_hnum                    U     RW        default = 'hc      lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8)
    //Bit 7   :5      reserved                           U     RW        default = 'h0     None
    //Bit 4   :0      reg_lc_blk_vnum                    U     RW        default = 'h8      lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12)
#define LC_SAT_LUT_0_1                             ((0x50c2  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_0                 U     RW        default = 'hc      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_1                 U     RW        default = 'h20      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_2_3                             ((0x50c3  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_2                 U     RW        default = 'h38      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_3                 U     RW        default = 'h54      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_4_5                             ((0x50c4  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_4                 U     RW        default = 'h73      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_5                 U     RW        default = 'h95      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_6_7                             ((0x50c5  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_6                 U     RW        default = 'hb9      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_7                 U     RW        default = 'hdf      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_8_9                             ((0x50c6  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_8                 U     RW        default = 'h107      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_9                 U     RW        default = 'h131      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_10_11                           ((0x50c7  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_10                U     RW        default = 'h15c      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_11                U     RW        default = 'h189      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_12_13                           ((0x50c8  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_12                U     RW        default = 'h1b8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_13                U     RW        default = 'h1e8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_14_15                           ((0x50c9  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_14                U     RW        default = 'h219      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_15                U     RW        default = 'h24c      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_16_17                           ((0x50ca  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_16                U     RW        default = 'h280      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_17                U     RW        default = 'h2b6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_18_19                           ((0x50cb  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_18                U     RW        default = 'h2ec      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_19                U     RW        default = 'h324      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_20_21                           ((0x50cc  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_20                U     RW        default = 'h35d      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_21                U     RW        default = 'h397      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_22_23                           ((0x50cd  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_22                U     RW        default = 'h3d2      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_23                U     RW        default = 'h40e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_24_25                           ((0x50ce  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_24                U     RW        default = 'h44b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_25                U     RW        default = 'h489      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_26_27                           ((0x50cf  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_26                U     RW        default = 'h4c8      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_27                U     RW        default = 'h507      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_28_29                           ((0x50d0  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_28                U     RW        default = 'h548      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_29                U     RW        default = 'h58a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_30_31                           ((0x50d1  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_30                U     RW        default = 'h5cd      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_31                U     RW        default = 'h610      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_32_33                           ((0x50d2  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_32                U     RW        default = 'h654      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_33                U     RW        default = 'h69a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_34_35                           ((0x50d3  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_34                U     RW        default = 'h6e0      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_35                U     RW        default = 'h726      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_36_37                           ((0x50d4  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_36                U     RW        default = 'h76e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_37                U     RW        default = 'h7b6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_38_39                           ((0x50d5  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_38                U     RW        default = 'h7ff      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_39                U     RW        default = 'h849      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_40_41                           ((0x50d6  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_40                U     RW        default = 'h894      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_41                U     RW        default = 'h8df      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_42_43                           ((0x50d7  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_42                U     RW        default = 'h92b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_43                U     RW        default = 'h978      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_44_45                           ((0x50d8  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_44                U     RW        default = 'h9c6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_45                U     RW        default = 'ha14      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_46_47                           ((0x50d9  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_46                U     RW        default = 'ha63      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_47                U     RW        default = 'hab2      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_48_49                           ((0x50da  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_48                U     RW        default = 'hb02      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_49                U     RW        default = 'hb53      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_50_51                           ((0x50db  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_50                U     RW        default = 'hba5      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_51                U     RW        default = 'hbf7      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_52_53                           ((0x50dc  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_52                U     RW        default = 'hc4a      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_53                U     RW        default = 'hc9d      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_54_55                           ((0x50dd  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_54                U     RW        default = 'hcf1      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_55                U     RW        default = 'hd46      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_56_57                           ((0x50de  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_56                U     RW        default = 'hd9b      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_57                U     RW        default = 'hdf1      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_58_59                           ((0x50df  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_58                U     RW        default = 'he47      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_59                U     RW        default = 'he9e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_60_61                           ((0x50e0  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_satur_lut_60                U     RW        default = 'hef6      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_61                U     RW        default = 'hf4e      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_SAT_LUT_62                              ((0x50e1  << 2) + 0xff000000)
    //Bit 31  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_satur_lut_62                U     RW        default = 'hfa7      saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define LC_CURVE_BLK_HIDX_0_1                      ((0x50e2  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_0                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_1                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_2_3                      ((0x50e3  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_2                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_3                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_4_5                      ((0x50e4  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_4                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_5                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_6_7                      ((0x50e5  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_6                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_7                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_8_9                      ((0x50e6  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_8                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_9                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_10_11                    ((0x50e7  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_hidx_10                 U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_11                 U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_HIDX_12                       ((0x50e8  << 2) + 0xff000000)
    //Bit 31  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_hidx_12                 U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_VIDX_0_1                      ((0x50e9  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_0                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_1                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_VIDX_2_3                      ((0x50ea  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_2                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_3                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_VIDX_4_5                      ((0x50eb  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_4                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_5                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_VIDX_6_7                      ((0x50ec  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :16     reg_lc_blk_vidx_6                  U     RW        default = 'h0      block boundary x-index
    //Bit 15  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_7                  U     RW        default = 'h0      block boundary x-index
#define LC_CURVE_BLK_VIDX_8                        ((0x50ed  << 2) + 0xff000000)
    //Bit 31  :14     reserved                           U     RW        default = 'h0     None
    //Bit 13  :0      reg_lc_blk_vidx_8                  U     RW        default = 'h0      block boundary x-index
#define LC_YUV2RGB_MAT_0_1                         ((0x50ee  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_0            S     RW        default =  1192      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_1            S     RW        default = 'h0        yuv2rgb 3x3 matrix
#define LC_YUV2RGB_MAT_2_3                         ((0x50ef  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_2            S     RW        default =  1836      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_3            S     RW        default =  1192       yuv2rgb 3x3 matrix
#define LC_YUV2RGB_MAT_4_5                         ((0x50f0  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_4            S     RW        default = -218      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_5            S     RW        default = -547      yuv2rgb 3x3 matrix
#define LC_YUV2RGB_MAT_6_7                         ((0x50f1  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_yuv2rgb_mat3x3_6            S     RW        default = 1192      yuv2rgb 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_7            S     RW        default = '2166      yuv2rgb 3x3 matrix
#define LC_YUV2RGB_MAT_8                           ((0x50f2  << 2) + 0xff000000)
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_yuv2rgb_mat3x3_8            S     RW        default = 'h0      yuv2rgb 3x3 matrix
#define LC_RGB2YUV_MAT_0_1                         ((0x50f3  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_0            S     RW        default =  187      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_1            S     RW        default =  629      rgb2yuv 3x3 matrix
#define LC_RGB2YUV_MAT_2_3                         ((0x50f4  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_2            S     RW        default = 63      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_3            S     RW        default = -103      rgb2yuv 3x3 matrix
#define LC_RGB2YUV_MAT_4_5                         ((0x50f5  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_4            S     RW        default = -346      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_5            S     RW        default = 450      rgb2yuv 3x3 matrix
#define LC_RGB2YUV_MAT_6_7                         ((0x50f6  << 2) + 0xff000000)
    //Bit 31  :29     reserved                           U     RW        default = 'h0     None
    //Bit 28  :16     reg_lc_rgb2yuv_mat3x3_6            S     RW        default = 450      rgb2yuv 3x3 matrix
    //Bit 15  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_7            S     RW        default = -409      rgb2yuv 3x3 matrix
#define LC_RGB2YUV_MAT_8                           ((0x50f7  << 2) + 0xff000000)
    //Bit 31  :13     reserved                           U     RW        default = 'h0     None
    //Bit 12  :0      reg_lc_rgb2yuv_mat3x3_8            S     RW        default =  41     rgb2yuv 3x3 matrix
#define LC_YUV2RGB_OFST                            ((0x50f8  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_yuv2rgb_ofset_0             U     RW        default = 'h40      yuv2rgb pre-offset to yuv,
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_yuv2rgb_ofset_1             U     RW        default = 'h200      yuv2rgb pre-offset to yuv,
#define LC_YUV2RGB_CLIP                            ((0x50f9  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :28     reg_lc_yuv2rgb_rs                  U     RW        default = 'h0       matrix normalization right shift extra bits, norm= (1<<(8+rs))
    //Bit 27  :16     reg_lc_yuv2rgb_clip_0              U     RW        default = 'h0      yuv2rgb converted RGB clipping range
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_yuv2rgb_clip_1              U     RW        default = 'h3ff      yuv2rgb converted RGB clipping range
#define LC_RGB2YUV_OFST                            ((0x50fa  << 2) + 0xff000000)
    //Bit 31  :28     reserved                           U     RW        default = 'h0     None
    //Bit 27  :16     reg_lc_rgb2yuv_ofset_0             U     RW        default = 'h40      rgb2yuv post-offset to yuv,
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_rgb2yuv_ofset_1             U     RW        default = 'h200      rgb2yuv post-offset to yuv,
#define LC_RGB2YUV_CLIP                            ((0x50fb  << 2) + 0xff000000)
    //Bit 31  :30     reserved                           U     RW        default = 'h0     None
    //Bit 29  :28     reg_lc_rgb2yuv_rs                  U     RW        default = 'h0       matrix normalization right shift extra bits, norm= (1<<(10+rs))
    //Bit 27  :16     reg_lc_rgb2yuv_clip_0              U     RW        default = 'h0      rgb2yuv converted YUV clipping range
    //Bit 15  :12     reserved                           U     RW        default = 'h0     None
    //Bit 11  :0      reg_lc_rgb2yuv_clip_1              U     RW        default = 'h3ff      rgb2yuv converted YUV clipping range
#define LC_MAP_RAM_CTRL                            ((0x50fc  << 2) + 0xff000000)
#define LC_MAP_RAM_ADDR                            ((0x50fd  << 2) + 0xff000000)
#define LC_MAP_RAM_DATA                            ((0x50fe  << 2) + 0xff000000)
#define SHARP_FMETER_CTRL                          ((0x5089  << 2) + 0xff000000)
//Bit 31:12   reserved
//Bit 11:10   reg_fmeter_vwin_mm     //u2, vertical window size, 0:1 cloumn, 1:3cloumn, 2or3: 5cloumn .unsigned  , default = 0
//Bit 9 : 8   reg_fmeter_hwin_mm     //u2, horizontal window size, 0:1x7, 1:1x9, 2or3: 1x11 .unsigned  , default = 0
//Bit 7       reg_fmeter_d2_mode     //u1, selectino filter D2, 0: [0 -2 0 0 2], 1: [-2 0 0 0 2] .unsigned  , default = 0
//Bit 6       reg_fmeter_v2_mode     //u1, selectino filter V2, 0: [0 -2 0 0 2], 1: [-2 0 0 0 2] .unsigned  , default = 0
//Bit 5: 4    reg_fmeter_h2_mode     //u2, selection filter H2, 0: [0 0 0 -2 0 0 2 0 0], 1: [-2 0 0 0 2], 2or3: [0-2 0 0 0 0 0 2 0] .unsigned  , default = 0
//Bit 3: 1    reserved
//Bit 0       reg_freq_meter_en      //u1, freq meter enable  .unsigned  , default = 0
#define SHARP_FMETER_WIN_HOR                       ((0x508a  << 2) + 0xff000000)
//Bit 31:29   reserved
//Bit 28:16   reg_fmeter_xwin_ed     //u13, window location: hend      .unsigned  , default = 1920
//Bit 15:13   reserved
//Bit 12: 0   reg_fmeter_xwin_st      //u13, window location: hstart   .unsigned  , default = 0
#define SHARP_FMETER_WIN_VER                       ((0x508b  << 2) + 0xff000000)
//Bit 31:29   reserved
//Bit 28:16   reg_fmeter_ywin_ed      //u14, window location: vend      .unsigned  , default = 1080
//Bit 15:13   reserved
//Bit 12: 0   reg_fmeter_ywin_st      //u14, window location: vstart   .unsigned  , default = 0
#define SHARP_FMETER_CORING                        ((0x508c  << 2) + 0xff000000)
//Bit 31:24  reg_fmeter_low_bound //u8, low bound for threshold  .unsigned  , default = 4
//Bit 23:16  reg_fmeter_coring_d  //u8, coring of diff before compare with threshold for diagonal frequency .unsigned  , default = 4
//Bit 15:8   reg_fmeter_coring_v  //u8, coring of diff before compare with threshold for vertical frequency .unsigned  , default = 4
//Bit 7: 0   reg_fmeter_coring_h  //u8, coring of diff before compare with threshold for horizontal frequency .unsigned  , default = 4
#define SHARP_FMETER_RATIO_H                       ((0x508d  << 2) + 0xff000000)
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_h2     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_h1     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_h0     //u6, ratio for threshold calc. for horizontal frequency, 16 is normalized as "1" .unsigned  , default = 16
#define SHARP_FMETER_RATIO_V                       ((0x508e  << 2) + 0xff000000)
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_v2     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_v1     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_v0     //u6, ratio for threshold calc. for vertical frequency, 16 is normalized as "1" .unsigned  , default = 16
#define SHARP_FMETER_RATIO_D                       ((0x508f  << 2) + 0xff000000)
//Bit 31:22   reserved
//Bit 21:16   reg_fmeter_ratio_d2     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 15:14   reserved
//Bit 13: 8   reg_fmeter_ratio_d1     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
//Bit 7 : 6   reserved
//Bit 5 : 0   reg_fmeter_ratio_d0     //u6, ratio for threshold calc. for diagonal frequency, 16 is normalized as "1" .unsigned  , default = 16
#define SHARP_RO_FMETER_HCNT_TYPE0                 ((0x5046  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_hcnt_type0     //u32, count for horizontal frequency
#define SHARP_RO_FMETER_HCNT_TYPE1                 ((0x5047  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_hcnt_type1     //u32, count for horizontal frequency
#define SHARP_RO_FMETER_HCNT_TYPE2                 ((0x5048  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_hcnt_type2     //u32, count for horizontal frequency
#define SHARP_RO_FMETER_HCNT_TYPE3                 ((0x5049  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_hcnt_type3     //u32, count for horizontal frequency
#define SHARP_RO_FMETER_VCNT_TYPE0                 ((0x504a  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_vcnt_type0     //u32, count for vertical frequency
#define SHARP_RO_FMETER_VCNT_TYPE1                 ((0x504b  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_vcnt_type1     //u32, count for vertical frequency
#define SHARP_RO_FMETER_VCNT_TYPE2                 ((0x504c  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_vcnt_type2     //u32, count for vertical frequency
#define SHARP_RO_FMETER_VCNT_TYPE3                 ((0x504d  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_vcnt_type3     //u32, count for vertical frequency
#define SHARP_RO_FMETER_PDCNT_TYPE0                ((0x504e  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_pdcnt_type0     //u32, count for positive diagonal frequency
#define SHARP_RO_FMETER_PDCNT_TYPE1                ((0x504f  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_pdcnt_type1     //u32, count for positive diagonal frequency
#define SHARP_RO_FMETER_PDCNT_TYPE2                ((0x5050  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_pdcnt_type2     //u32, count for positive diagonal frequency
#define SHARP_RO_FMETER_PDCNT_TYPE3                ((0x5051  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_pdcnt_type3     //u32, count for positive diagonal frequency
#define SHARP_RO_FMETER_NDCNT_TYPE0                ((0x5052  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_ndcnt_type0     //u32, count for negative diagonal frequency
#define SHARP_RO_FMETER_NDCNT_TYPE1                ((0x5053  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_ndcnt_type1     //u32, count for negative diagonal frequency
#define SHARP_RO_FMETER_NDCNT_TYPE2                ((0x5054  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_ndcnt_type2     //u32, count for negative diagonal frequency
#define SHARP_RO_FMETER_NDCNT_TYPE3                ((0x5055  << 2) + 0xff000000)
//Bit 31:0 ro_fmeter_ndcnt_type3     //u32, count for negative diagonal frequency
//
// Closing file:  ./sharp_regs.h
//

#define SRSHARP0_SHARP_HVSIZE                      (SRSHARP0_OFFSET + SHARP_HVSIZE                 )  //0x00  //
#define SRSHARP0_SHARP_HVBLANK_NUM                 (SRSHARP0_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
#define SRSHARP0_NR_GAUSSIAN_MODE                  (SRSHARP0_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
//`define SRSHARP0_PK_HVCON_LPF_MODE                 (`SRSHARP0_OFFSET + `PK_HVCON_LPF_MODE            )  //8'h03  //
//`define SRSHARP0_PK_CON_BLEND_GAIN                 (`SRSHARP0_OFFSET + `PK_CON_BLEND_GAIN            )  //8'h04  //
#define SRSHARP0_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
#define SRSHARP0_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
#define SRSHARP0_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
#define SRSHARP0_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
#define SRSHARP0_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
#define SRSHARP0_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
#define SRSHARP0_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
#define SRSHARP0_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP0_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
#define SRSHARP0_PK_CIRFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
#define SRSHARP0_PK_DRTFB_LPF_MODE                 (SRSHARP0_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
#define SRSHARP0_PK_CIRFB_HP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
#define SRSHARP0_PK_CIRFB_BP_CORING                (SRSHARP0_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
#define SRSHARP0_PK_DRTFB_HP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
#define SRSHARP0_PK_DRTFB_BP_CORING                (SRSHARP0_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
#define SRSHARP0_PK_CIRFB_BLEND_GAIN               (SRSHARP0_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
#define SRSHARP0_NR_ALPY_SSD_GAIN_OFST             (SRSHARP0_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
#define SRSHARP0_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
#define SRSHARP0_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
#define SRSHARP0_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
#define SRSHARP0_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP0_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
#define SRSHARP0_NR_ALP0_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
#define SRSHARP0_NR_ALP1_MIERR_CORING              (SRSHARP0_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
#define SRSHARP0_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
#define SRSHARP0_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
#define SRSHARP0_NR_ALP1_MIN_MAX                   (SRSHARP0_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
#define SRSHARP0_PK_ALP2_MIERR_CORING              (SRSHARP0_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
#define SRSHARP0_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
#define SRSHARP0_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP0_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
#define SRSHARP0_PK_ALP2_MIN_MAX                   (SRSHARP0_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
#define SRSHARP0_PK_FINALGAIN_HP_BP                (SRSHARP0_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
#define SRSHARP0_PK_OS_HORZ_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
#define SRSHARP0_PK_OS_VERT_CORE_GAIN              (SRSHARP0_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
#define SRSHARP0_PK_OS_ADPT_MISC                   (SRSHARP0_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
#define SRSHARP0_PK_OS_STATIC                      (SRSHARP0_OFFSET + PK_OS_STATIC                 )  //0x26  //
#define SRSHARP0_PK_NR_ENABLE                      (SRSHARP0_OFFSET + PK_NR_ENABLE                 )  //0x27  //
#define SRSHARP0_PK_DRT_SAD_MISC                   (SRSHARP0_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
#define SRSHARP0_NR_TI_DNLP_BLEND                  (SRSHARP0_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
#define SRSHARP0_LTI_DIR_CORE_ALPHA                (SRSHARP0_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
#define SRSHARP0_CTI_DIR_ALPHA                     (SRSHARP0_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
#define SRSHARP0_LTI_CTI_DF_GAIN                   (SRSHARP0_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
#define SRSHARP0_LTI_CTI_DIR_AC_DBG                (SRSHARP0_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
#define SRSHARP0_HCTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
#define SRSHARP0_HCTI_BST_GAIN                     (SRSHARP0_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
#define SRSHARP0_HCTI_BST_CORE                     (SRSHARP0_OFFSET + HCTI_BST_CORE                )  //0x30  //
#define SRSHARP0_HCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
#define SRSHARP0_HCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
#define SRSHARP0_HCTI_OS_MARGIN                    (SRSHARP0_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
#define SRSHARP0_HLTI_FLT_CLP_DC                   (SRSHARP0_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
#define SRSHARP0_HLTI_BST_GAIN                     (SRSHARP0_OFFSET + HLTI_BST_GAIN                )  //0x35  //
#define SRSHARP0_HLTI_BST_CORE                     (SRSHARP0_OFFSET + HLTI_BST_CORE                )  //0x36  //
#define SRSHARP0_HLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
#define SRSHARP0_HLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
#define SRSHARP0_HLTI_OS_MARGIN                    (SRSHARP0_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
#define SRSHARP0_VLTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
#define SRSHARP0_VLTI_BST_GAIN                     (SRSHARP0_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
#define SRSHARP0_VLTI_BST_CORE                     (SRSHARP0_OFFSET + VLTI_BST_CORE                )  //0x3c  //
#define SRSHARP0_VLTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
#define SRSHARP0_VLTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
#define SRSHARP0_VCTI_FLT_CON_CLP                  (SRSHARP0_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
#define SRSHARP0_VCTI_BST_GAIN                     (SRSHARP0_OFFSET + VCTI_BST_GAIN                )  //0x40  //
#define SRSHARP0_VCTI_BST_CORE                     (SRSHARP0_OFFSET + VCTI_BST_CORE                )  //0x41  //
#define SRSHARP0_VCTI_CON_2_GAIN_0                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
#define SRSHARP0_VCTI_CON_2_GAIN_1                 (SRSHARP0_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
#define SRSHARP0_SHARP_3DLIMIT                     (SRSHARP0_OFFSET + SHARP_3DLIMIT                )  //0x44  //
#define SRSHARP0_DNLP_EN                           (SRSHARP0_OFFSET + DNLP_EN                      )  //0x45  //
//`define SRSHARP0_DNLP_00                           (`SRSHARP0_OFFSET + `DNLP_00                      )  //8'h46  //
//`define SRSHARP0_DNLP_01                           (`SRSHARP0_OFFSET + `DNLP_01                      )  //8'h47  //
//`define SRSHARP0_DNLP_02                           (`SRSHARP0_OFFSET + `DNLP_02                      )  //8'h48  //
//`define SRSHARP0_DNLP_03                           (`SRSHARP0_OFFSET + `DNLP_03                      )  //8'h49  //
//`define SRSHARP0_DNLP_04                           (`SRSHARP0_OFFSET + `DNLP_04                      )  //8'h4a  //
//`define SRSHARP0_DNLP_05                           (`SRSHARP0_OFFSET + `DNLP_05                      )  //8'h4b  //
//`define SRSHARP0_DNLP_06                           (`SRSHARP0_OFFSET + `DNLP_06                      )  //8'h4c  //
//`define SRSHARP0_DNLP_07                           (`SRSHARP0_OFFSET + `DNLP_07                      )  //8'h4d  //
//`define SRSHARP0_DNLP_08                           (`SRSHARP0_OFFSET + `DNLP_08                      )  //8'h4e  //
//`define SRSHARP0_DNLP_09                           (`SRSHARP0_OFFSET + `DNLP_09                      )  //8'h4f  //
//`define SRSHARP0_DNLP_10                           (`SRSHARP0_OFFSET + `DNLP_10                      )  //8'h50  //
//`define SRSHARP0_DNLP_11                           (`SRSHARP0_OFFSET + `DNLP_11                      )  //8'h51  //
//`define SRSHARP0_DNLP_12                           (`SRSHARP0_OFFSET + `DNLP_12                      )  //8'h52  //
//`define SRSHARP0_DNLP_13                           (`SRSHARP0_OFFSET + `DNLP_13                      )  //8'h53  //
//`define SRSHARP0_DNLP_14                           (`SRSHARP0_OFFSET + `DNLP_14                      )  //8'h54  //
//`define SRSHARP0_DNLP_15                           (`SRSHARP0_OFFSET + `DNLP_15                      )  //8'h55  //
#define SRSHARP0_DEMO_CRTL                         (SRSHARP0_OFFSET + DEMO_CRTL                    )  //0x56  //
#define SRSHARP0_SHARP_SR2_CTRL                    (SRSHARP0_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
#define SRSHARP0_SHARP_SR2_YBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
#define SRSHARP0_SHARP_SR2_YBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
#define SRSHARP0_SHARP_SR2_CBIC_HCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
#define SRSHARP0_SHARP_SR2_CBIC_HCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
#define SRSHARP0_SHARP_SR2_YBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
#define SRSHARP0_SHARP_SR2_YBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
#define SRSHARP0_SHARP_SR2_CBIC_VCOEF0             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
#define SRSHARP0_SHARP_SR2_CBIC_VCOEF1             (SRSHARP0_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
#define SRSHARP0_SHARP_SR2_MISC                    (SRSHARP0_OFFSET + SHARP_SR2_MISC               )  //0x60  //
#define SRSHARP0_SR3_SAD_CTRL                   (SRSHARP0_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
#define SRSHARP0_SR3_PK_CTRL0                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
#define SRSHARP0_SR3_PK_CTRL1                   (SRSHARP0_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
#define SRSHARP0_DEJ_CTRL                       (SRSHARP0_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
#define SRSHARP0_DEJ_ALPHA                      (SRSHARP0_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
#define SRSHARP0_SR3_DRTLPF_EN                  (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
#define SRSHARP0_SR3_DRTLPF_ALPHA_0             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
#define SRSHARP0_SR3_DRTLPF_ALPHA_1             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
#define SRSHARP0_SR3_DRTLPF_ALPHA_2             (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
#define SRSHARP0_SR3_DRTLPF_ALPHA_OFST          (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
#define SRSHARP0_SR3_DERING_CTRL                (SRSHARP0_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
#define SRSHARP0_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
#define SRSHARP0_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
#define SRSHARP0_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP0_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
#define SRSHARP0_SR3_DERING_GAINVS_MADSAD       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
#define SRSHARP0_SR3_DERING_GAINVS_VR2MAX       (SRSHARP0_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
#define SRSHARP0_SR3_DERING_PARAM0              (SRSHARP0_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
#define SRSHARP0_SR3_DRTLPF_THETA               (SRSHARP0_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
#define SRSHARP0_SATPRT_CTRL                    (SRSHARP0_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
#define SRSHARP0_SATPRT_DIVM                    (SRSHARP0_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
#define SRSHARP0_DB_FLT_CTRL                    (SRSHARP0_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
//`define SRSHARP0_DB_FLT_YC_THRD                 (`SRSHARP0_OFFSET + `SHARP_DB_FLT_YC_THRD             ) // 8'h78
#define SRSHARP0_DB_FLT_CTRL1                   (SRSHARP0_OFFSET + SHARP_DB_FLT_CTRL1                 ) // 0xb8
#define SRSHARP0_DB_FLT_LUMA_THRD               (SRSHARP0_OFFSET + SHARP_DB_FLT_LUMA_THRD             ) // 0xb9
#define SRSHARP0_DB_FLT_CHRM_THRD               (SRSHARP0_OFFSET + SHARP_DB_FLT_CHRM_THRD             ) // 0xba
#define SRSHARP0_DB_FLT_RANDLUT                 (SRSHARP0_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
#define SRSHARP0_DB_FLT_PXI_THRD                (SRSHARP0_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
#define SRSHARP0_DB_FLT_SEED_Y                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
#define SRSHARP0_DB_FLT_SEED_U                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
#define SRSHARP0_DB_FLT_SEED_V                  (SRSHARP0_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
#define SRSHARP0_PKGAIN_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x7e
#define SRSHARP0_PKGAIN_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x7f
#define SRSHARP0_PKOSHT_VSLUMA_LUT_L            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x80
#define SRSHARP0_PKOSHT_VSLUMA_LUT_H            (SRSHARP0_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x81
#define SRSHARP0_SATPRT_LMT_RGB1                (SRSHARP0_OFFSET + SHARP_SATPRT_LMT_RGB1              ) // 0x82
#define SRSHARP0_SATPRT_LMT_RGB2                (SRSHARP0_OFFSET + SHARP_SATPRT_LMT_RGB2              ) // 0x83
#define SRSHARP0_SHARP_GATE_CLK_CTRL_0          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_0              ) // 0x84
#define SRSHARP0_SHARP_GATE_CLK_CTRL_1          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_1              ) // 0x85
#define SRSHARP0_SHARP_GATE_CLK_CTRL_2          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_2              ) // 0x86
#define SRSHARP0_SHARP_GATE_CLK_CTRL_3          (SRSHARP0_OFFSET + SHARP_GATE_CLK_CTRL_3              ) // 0x87
#define SRSHARP0_SHARP_DPS_CTRL                 (SRSHARP0_OFFSET + SHARP_DPS_CTRL                     ) // 0x88
#define SRSHARP0_DNLP_00                        (SRSHARP0_OFFSET + DNLP_00) // 0x90  //
#define SRSHARP0_DNLP_01                        (SRSHARP0_OFFSET + DNLP_01) // 0x91  //
#define SRSHARP0_DNLP_02                        (SRSHARP0_OFFSET + DNLP_02) // 0x92  //
#define SRSHARP0_DNLP_03                        (SRSHARP0_OFFSET + DNLP_03) // 0x93  //
#define SRSHARP0_DNLP_04                        (SRSHARP0_OFFSET + DNLP_04) // 0x94  //
#define SRSHARP0_DNLP_05                        (SRSHARP0_OFFSET + DNLP_05) // 0x95  //
#define SRSHARP0_DNLP_06                        (SRSHARP0_OFFSET + DNLP_06) // 0x96  //
#define SRSHARP0_DNLP_07                        (SRSHARP0_OFFSET + DNLP_07) // 0x97  //
#define SRSHARP0_DNLP_08                        (SRSHARP0_OFFSET + DNLP_08) // 0x98  //
#define SRSHARP0_DNLP_09                        (SRSHARP0_OFFSET + DNLP_09) // 0x99  //
#define SRSHARP0_DNLP_10                        (SRSHARP0_OFFSET + DNLP_10) // 0x9a  //
#define SRSHARP0_DNLP_11                        (SRSHARP0_OFFSET + DNLP_11) // 0x9b  //
#define SRSHARP0_DNLP_12                        (SRSHARP0_OFFSET + DNLP_12) // 0x9c  //
#define SRSHARP0_DNLP_13                        (SRSHARP0_OFFSET + DNLP_13) // 0x9d  //
#define SRSHARP0_DNLP_14                        (SRSHARP0_OFFSET + DNLP_14) // 0x9e  //
#define SRSHARP0_DNLP_15                        (SRSHARP0_OFFSET + DNLP_15) // 0x9f  //
#define SRSHARP0_DNLP_16                        (SRSHARP0_OFFSET + DNLP_16) // 0xa0  //
#define SRSHARP0_DNLP_17                        (SRSHARP0_OFFSET + DNLP_17) // 0xa1  //
#define SRSHARP0_DNLP_18                        (SRSHARP0_OFFSET + DNLP_18) // 0xa2  //
#define SRSHARP0_DNLP_19                        (SRSHARP0_OFFSET + DNLP_19) // 0xa3  //
#define SRSHARP0_DNLP_20                        (SRSHARP0_OFFSET + DNLP_20) // 0xa4  //
#define SRSHARP0_DNLP_21                        (SRSHARP0_OFFSET + DNLP_21) // 0xa5  //
#define SRSHARP0_DNLP_22                        (SRSHARP0_OFFSET + DNLP_22) // 0xa6  //
#define SRSHARP0_DNLP_23                        (SRSHARP0_OFFSET + DNLP_23) // 0xa7  //
#define SRSHARP0_DNLP_24                        (SRSHARP0_OFFSET + DNLP_24) // 0xa8  //
#define SRSHARP0_DNLP_25                        (SRSHARP0_OFFSET + DNLP_25) // 0xa9  //
#define SRSHARP0_DNLP_26                        (SRSHARP0_OFFSET + DNLP_26) // 0xaa  //
#define SRSHARP0_DNLP_27                        (SRSHARP0_OFFSET + DNLP_27) // 0xab  //
#define SRSHARP0_DNLP_28                        (SRSHARP0_OFFSET + DNLP_28) // 0xac  //
#define SRSHARP0_DNLP_29                        (SRSHARP0_OFFSET + DNLP_29) // 0xad  //
#define SRSHARP0_DNLP_30                        (SRSHARP0_OFFSET + DNLP_30) // 0xae  //
#define SRSHARP0_DNLP_31                        (SRSHARP0_OFFSET + DNLP_31) // 0xaf  //
#define SRSHARP0_SHARP_SYNC_CTRL                (SRSHARP0_OFFSET + SHARP_SYNC_CTRL                    ) // 0xb0  //
#define SRSHARP0_LC_INPUT_MUX                   (SRSHARP0_OFFSET + LC_INPUT_MUX                       ) // 0xb1  //
#define SRSHARP0_NR_GAU_YH_COEF02               (SRSHARP0_OFFSET + NR_GAU_YH_COEF02                   ) // 0xb2  //
#define SRSHARP0_NR_GAU_YH_COEF34               (SRSHARP0_OFFSET + NR_GAU_YH_COEF34                   ) // 0xb3  //
#define SRSHARP0_NR_GAU_YV_COEF1                (SRSHARP0_OFFSET + NR_GAU_YV_COEF1                    ) // 0xb4  //
#define SRSHARP0_NR_GAU_CH_COEF02               (SRSHARP0_OFFSET + NR_GAU_CH_COEF02                   ) // 0xb5  //
#define SRSHARP0_NR_GAU_CH_COEF34               (SRSHARP0_OFFSET + NR_GAU_CH_COEF34                   ) // 0xb6  //
#define SRSHARP0_NR_GAU_CV_COEF1                (SRSHARP0_OFFSET + NR_GAU_CV_COEF1                    ) // 0xb7  //
#define SRSHARP0_LC_TOP_CTRL                    (SRSHARP0_OFFSET + LC_TOP_CTRL                        ) // 0xc0  //
#define SRSHARP0_LC_HV_NUM                      (SRSHARP0_OFFSET + LC_HV_NUM                          ) // 0xc1
#define SRSHARP0_LC_SAT_LUT_0_1                 (SRSHARP0_OFFSET + LC_SAT_LUT_0_1                     ) // 0xc2
#define SRSHARP0_LC_SAT_LUT_2_3                 (SRSHARP0_OFFSET + LC_SAT_LUT_2_3                     ) // 0xc3
#define SRSHARP0_LC_SAT_LUT_4_5                 (SRSHARP0_OFFSET + LC_SAT_LUT_4_5                     ) // 0xc4
#define SRSHARP0_LC_SAT_LUT_6_7                 (SRSHARP0_OFFSET + LC_SAT_LUT_6_7                     ) // 0xc5
#define SRSHARP0_LC_SAT_LUT_8_9                 (SRSHARP0_OFFSET + LC_SAT_LUT_8_9                     ) // 0xc6
#define SRSHARP0_LC_SAT_LUT_10_11               (SRSHARP0_OFFSET + LC_SAT_LUT_10_11                   ) // 0xc7
#define SRSHARP0_LC_SAT_LUT_12_13               (SRSHARP0_OFFSET + LC_SAT_LUT_12_13                   ) // 0xc8
#define SRSHARP0_LC_SAT_LUT_14_15               (SRSHARP0_OFFSET + LC_SAT_LUT_14_15                   ) // 0xc9
#define SRSHARP0_LC_SAT_LUT_16_17               (SRSHARP0_OFFSET + LC_SAT_LUT_16_17                   ) // 0xca
#define SRSHARP0_LC_SAT_LUT_18_19               (SRSHARP0_OFFSET + LC_SAT_LUT_18_19                   ) // 0xcb
#define SRSHARP0_LC_SAT_LUT_20_21               (SRSHARP0_OFFSET + LC_SAT_LUT_20_21                   ) // 0xcc
#define SRSHARP0_LC_SAT_LUT_22_23               (SRSHARP0_OFFSET + LC_SAT_LUT_22_23                   ) // 0xcd
#define SRSHARP0_LC_SAT_LUT_24_25               (SRSHARP0_OFFSET + LC_SAT_LUT_24_25                   ) // 0xce
#define SRSHARP0_LC_SAT_LUT_26_27               (SRSHARP0_OFFSET + LC_SAT_LUT_26_27                   ) // 0xcf
#define SRSHARP0_LC_SAT_LUT_28_29               (SRSHARP0_OFFSET + LC_SAT_LUT_28_29                   ) // 0xd0
#define SRSHARP0_LC_SAT_LUT_30_31               (SRSHARP0_OFFSET + LC_SAT_LUT_30_31                   ) // 0xd1
#define SRSHARP0_LC_SAT_LUT_32_33               (SRSHARP0_OFFSET + LC_SAT_LUT_32_33                   ) // 0xd2
#define SRSHARP0_LC_SAT_LUT_34_35               (SRSHARP0_OFFSET + LC_SAT_LUT_34_35                   ) // 0xd3
#define SRSHARP0_LC_SAT_LUT_36_37               (SRSHARP0_OFFSET + LC_SAT_LUT_36_37                   ) // 0xd4
#define SRSHARP0_LC_SAT_LUT_38_39               (SRSHARP0_OFFSET + LC_SAT_LUT_38_39                   ) // 0xd5
#define SRSHARP0_LC_SAT_LUT_40_41               (SRSHARP0_OFFSET + LC_SAT_LUT_40_41                   ) // 0xd6
#define SRSHARP0_LC_SAT_LUT_42_43               (SRSHARP0_OFFSET + LC_SAT_LUT_42_43                   ) // 0xd7
#define SRSHARP0_LC_SAT_LUT_44_45               (SRSHARP0_OFFSET + LC_SAT_LUT_44_45                   ) // 0xd8
#define SRSHARP0_LC_SAT_LUT_46_47               (SRSHARP0_OFFSET + LC_SAT_LUT_46_47                   ) // 0xd9
#define SRSHARP0_LC_SAT_LUT_48_49               (SRSHARP0_OFFSET + LC_SAT_LUT_48_49                   ) // 0xda
#define SRSHARP0_LC_SAT_LUT_50_51               (SRSHARP0_OFFSET + LC_SAT_LUT_50_51                   ) // 0xdb
#define SRSHARP0_LC_SAT_LUT_52_53               (SRSHARP0_OFFSET + LC_SAT_LUT_52_53                   ) // 0xdc
#define SRSHARP0_LC_SAT_LUT_54_55               (SRSHARP0_OFFSET + LC_SAT_LUT_54_55                   ) // 0xdd
#define SRSHARP0_LC_SAT_LUT_56_57               (SRSHARP0_OFFSET + LC_SAT_LUT_56_57                   ) // 0xde
#define SRSHARP0_LC_SAT_LUT_58_59               (SRSHARP0_OFFSET + LC_SAT_LUT_58_59                   ) // 0xdf
#define SRSHARP0_LC_SAT_LUT_60_61               (SRSHARP0_OFFSET + LC_SAT_LUT_60_61                   ) // 0xe0
#define SRSHARP0_LC_SAT_LUT_62                  (SRSHARP0_OFFSET + LC_SAT_LUT_62                      ) // 0xe1
#define SRSHARP0_LC_CURVE_BLK_HIDX_0_1          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_0_1              ) // 0xe2
#define SRSHARP0_LC_CURVE_BLK_HIDX_2_3          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_2_3              ) // 0xe3
#define SRSHARP0_LC_CURVE_BLK_HIDX_4_5          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_4_5              ) // 0xe4
#define SRSHARP0_LC_CURVE_BLK_HIDX_6_7          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_6_7              ) // 0xe5
#define SRSHARP0_LC_CURVE_BLK_HIDX_8_9          (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_8_9              ) // 0xe6
#define SRSHARP0_LC_CURVE_BLK_HIDX_10_11        (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_10_11            ) // 0xe7
#define SRSHARP0_LC_CURVE_BLK_HIDX_12           (SRSHARP0_OFFSET + LC_CURVE_BLK_HIDX_12               ) // 0xe8
#define SRSHARP0_LC_CURVE_BLK_VIDX_0_1          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_0_1              ) // 0xe9
#define SRSHARP0_LC_CURVE_BLK_VIDX_2_3          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_2_3              ) // 0xea
#define SRSHARP0_LC_CURVE_BLK_VIDX_4_5          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_4_5              ) // 0xeb
#define SRSHARP0_LC_CURVE_BLK_VIDX_6_7          (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_6_7              ) // 0xec
#define SRSHARP0_LC_CURVE_BLK_VIDX_8            (SRSHARP0_OFFSET + LC_CURVE_BLK_VIDX_8                ) // 0xed
#define SRSHARP0_LC_YUV2RGB_MAT_0_1             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_0_1                 ) // 0xee
#define SRSHARP0_LC_YUV2RGB_MAT_2_3             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_2_3                 ) // 0xef
#define SRSHARP0_LC_YUV2RGB_MAT_4_5             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_4_5                 ) // 0xf0
#define SRSHARP0_LC_YUV2RGB_MAT_6_7             (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_6_7                 ) // 0xf1
#define SRSHARP0_LC_YUV2RGB_MAT_8               (SRSHARP0_OFFSET + LC_YUV2RGB_MAT_8                   ) // 0xf2
#define SRSHARP0_LC_RGB2YUV_MAT_0_1             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_0_1                 ) // 0xf3
#define SRSHARP0_LC_RGB2YUV_MAT_2_3             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_2_3                 ) // 0xf4
#define SRSHARP0_LC_RGB2YUV_MAT_4_5             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_4_5                 ) // 0xf5
#define SRSHARP0_LC_RGB2YUV_MAT_6_7             (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_6_7                 ) // 0xf6
#define SRSHARP0_LC_RGB2YUV_MAT_8               (SRSHARP0_OFFSET + LC_RGB2YUV_MAT_8                   ) // 0xf7
#define SRSHARP0_LC_YUV2RGB_OFST                (SRSHARP0_OFFSET + LC_YUV2RGB_OFST                    ) // 0xf8
#define SRSHARP0_LC_YUV2RGB_CLIP                (SRSHARP0_OFFSET + LC_YUV2RGB_CLIP                    ) // 0xf9
#define SRSHARP0_LC_RGB2YUV_OFST                (SRSHARP0_OFFSET + LC_RGB2YUV_OFST                    ) // 0xfa
#define SRSHARP0_LC_RGB2YUV_CLIP                (SRSHARP0_OFFSET + LC_RGB2YUV_CLIP                    ) // 0xfb
#define SRSHARP0_LC_MAP_RAM_CTRL                (SRSHARP0_OFFSET + LC_MAP_RAM_CTRL                    ) // 0xfc
#define SRSHARP0_LC_MAP_RAM_ADDR                (SRSHARP0_OFFSET + LC_MAP_RAM_ADDR                    ) // 0xfd
#define SRSHARP0_LC_MAP_RAM_DATA                (SRSHARP0_OFFSET + LC_MAP_RAM_DATA                    ) // 0xfe

#define SRSHARP0_FMETER_CTRL                    (SRSHARP0_OFFSET +  SHARP_FMETER_CTRL                 ) // 0x89
#define SRSHARP0_FMETER_WIN_HOR                 (SRSHARP0_OFFSET +  SHARP_FMETER_WIN_HOR              ) // 0x8a
#define SRSHARP0_FMETER_WIN_VER                 (SRSHARP0_OFFSET +  SHARP_FMETER_WIN_VER              ) // 0x8b
#define SRSHARP0_FMETER_CORING                  (SRSHARP0_OFFSET +  SHARP_FMETER_CORING               ) // 0x8c
#define SRSHARP0_FMETER_RATIO_H                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_H              ) // 0x8d
#define SRSHARP0_FMETER_RATIO_V                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_V              ) // 0x8e
#define SRSHARP0_FMETER_RATIO_D                 (SRSHARP0_OFFSET +  SHARP_FMETER_RATIO_D              ) // 0x8f
#define SRSHARP0_RO_FMETER_HCNT_TYPE0           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE0        ) // 0x46
#define SRSHARP0_RO_FMETER_HCNT_TYPE1           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE1        ) // 0x47
#define SRSHARP0_RO_FMETER_HCNT_TYPE2           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE2        ) // 0x48
#define SRSHARP0_RO_FMETER_HCNT_TYPE3           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE3        ) // 0x49
#define SRSHARP0_RO_FMETER_VCNT_TYPE0           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE0        ) // 0x4a
#define SRSHARP0_RO_FMETER_VCNT_TYPE1           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE1        ) // 0x4b
#define SRSHARP0_RO_FMETER_VCNT_TYPE2           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE2        ) // 0x4c
#define SRSHARP0_RO_FMETER_VCNT_TYPE3           (SRSHARP0_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE3        ) // 0x4d
#define SRSHARP0_RO_FMETER_PDCNT_TYPE0          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE0       ) // 0x4e
#define SRSHARP0_RO_FMETER_PDCNT_TYPE1          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE1       ) // 0x4f
#define SRSHARP0_RO_FMETER_PDCNT_TYPE2          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE2       ) // 0x50
#define SRSHARP0_RO_FMETER_PDCNT_TYPE3          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE3       ) // 0x51
#define SRSHARP0_RO_FMETER_NDCNT_TYPE0          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE0       ) // 0x52
#define SRSHARP0_RO_FMETER_NDCNT_TYPE1          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE1       ) // 0x53
#define SRSHARP0_RO_FMETER_NDCNT_TYPE2          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE2       ) // 0x54
#define SRSHARP0_RO_FMETER_NDCNT_TYPE3          (SRSHARP0_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE3       ) // 0x55





//// srsharp1 reg define

#define SRSHARP1_SHARP_HVSIZE                      (SRSHARP1_OFFSET + SHARP_HVSIZE                 )  //0x00  //
#define SRSHARP1_SHARP_HVBLANK_NUM                 (SRSHARP1_OFFSET + SHARP_HVBLANK_NUM            )  //0x01  //
#define SRSHARP1_NR_GAUSSIAN_MODE                  (SRSHARP1_OFFSET + NR_GAUSSIAN_MODE             )  //0x02  //
#define SRSHARP1_PK_CON_2CIRHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_TH_RATE    )  //0x05  //
#define SRSHARP1_PK_CON_2CIRHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRHPGAIN_LIMIT      )  //0x06  //
#define SRSHARP1_PK_CON_2CIRBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_TH_RATE    )  //0x07  //
#define SRSHARP1_PK_CON_2CIRBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2CIRBPGAIN_LIMIT      )  //0x08  //
#define SRSHARP1_PK_CON_2DRTHPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_TH_RATE    )  //0x09  //
#define SRSHARP1_PK_CON_2DRTHPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTHPGAIN_LIMIT      )  //0x0a  //
#define SRSHARP1_PK_CON_2DRTBPGAIN_TH_RATE         (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_TH_RATE    )  //0x0b  //
#define SRSHARP1_PK_CON_2DRTBPGAIN_LIMIT           (SRSHARP1_OFFSET + PK_CON_2DRTBPGAIN_LIMIT      )  //0x0c  //
#define SRSHARP1_PK_CIRFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_CIRFB_LPF_MODE            )  //0x0d  //
#define SRSHARP1_PK_DRTFB_LPF_MODE                 (SRSHARP1_OFFSET + PK_DRTFB_LPF_MODE            )  //0x0e  //
#define SRSHARP1_PK_CIRFB_HP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_HP_CORING           )  //0x0f  //
#define SRSHARP1_PK_CIRFB_BP_CORING                (SRSHARP1_OFFSET + PK_CIRFB_BP_CORING           )  //0x10  //
#define SRSHARP1_PK_DRTFB_HP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_HP_CORING           )  //0x11  //
#define SRSHARP1_PK_DRTFB_BP_CORING                (SRSHARP1_OFFSET + PK_DRTFB_BP_CORING           )  //0x12  //
#define SRSHARP1_PK_CIRFB_BLEND_GAIN               (SRSHARP1_OFFSET + PK_CIRFB_BLEND_GAIN          )  //0x13  //
#define SRSHARP1_NR_ALPY_SSD_GAIN_OFST             (SRSHARP1_OFFSET + NR_ALPY_SSD_GAIN_OFST        )  //0x14  //
#define SRSHARP1_NR_ALP0Y_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_TH_RATE    )  //0x15  //
#define SRSHARP1_NR_ALP0Y_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0Y_ERR2CURV_LIMIT      )  //0x16  //
#define SRSHARP1_NR_ALP0C_ERR2CURV_TH_RATE         (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_TH_RATE    )  //0x17  //
#define SRSHARP1_NR_ALP0C_ERR2CURV_LIMIT           (SRSHARP1_OFFSET + NR_ALP0C_ERR2CURV_LIMIT      )  //0x18  //
#define SRSHARP1_NR_ALP0_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP0_MIN_MAX              )  //0x19  //
#define SRSHARP1_NR_ALP1_MIERR_CORING              (SRSHARP1_OFFSET + NR_ALP1_MIERR_CORING         )  //0x1a  //
#define SRSHARP1_NR_ALP1_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_TH_RATE     )  //0x1b  //
#define SRSHARP1_NR_ALP1_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + NR_ALP1_ERR2CURV_LIMIT       )  //0x1c  //
#define SRSHARP1_NR_ALP1_MIN_MAX                   (SRSHARP1_OFFSET + NR_ALP1_MIN_MAX              )  //0x1d  //
#define SRSHARP1_PK_ALP2_MIERR_CORING              (SRSHARP1_OFFSET + PK_ALP2_MIERR_CORING         )  //0x1e  //
#define SRSHARP1_PK_ALP2_ERR2CURV_TH_RATE          (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_TH_RATE     )  //0x1f  //
#define SRSHARP1_PK_ALP2_ERR2CURV_LIMIT            (SRSHARP1_OFFSET + PK_ALP2_ERR2CURV_LIMIT       )  //0x20  //
#define SRSHARP1_PK_ALP2_MIN_MAX                   (SRSHARP1_OFFSET + PK_ALP2_MIN_MAX              )  //0x21  //
#define SRSHARP1_PK_FINALGAIN_HP_BP                (SRSHARP1_OFFSET + PK_FINALGAIN_HP_BP           )  //0x22  //
#define SRSHARP1_PK_OS_HORZ_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_HORZ_CORE_GAIN         )  //0x23  //
#define SRSHARP1_PK_OS_VERT_CORE_GAIN              (SRSHARP1_OFFSET + PK_OS_VERT_CORE_GAIN         )  //0x24  //
#define SRSHARP1_PK_OS_ADPT_MISC                   (SRSHARP1_OFFSET + PK_OS_ADPT_MISC              )  //0x25  //
#define SRSHARP1_PK_OS_STATIC                      (SRSHARP1_OFFSET + PK_OS_STATIC                 )  //0x26  //
#define SRSHARP1_PK_NR_ENABLE                      (SRSHARP1_OFFSET + PK_NR_ENABLE                 )  //0x27  //
#define SRSHARP1_PK_DRT_SAD_MISC                   (SRSHARP1_OFFSET + PK_DRT_SAD_MISC              )  //0x28  //
#define SRSHARP1_NR_TI_DNLP_BLEND                  (SRSHARP1_OFFSET + NR_TI_DNLP_BLEND             )  //0x29  //
#define SRSHARP1_LTI_DIR_CORE_ALPHA                (SRSHARP1_OFFSET + LTI_DIR_CORE_ALPHA           )  //0x2a  //
#define SRSHARP1_CTI_DIR_ALPHA                     (SRSHARP1_OFFSET + CTI_DIR_ALPHA                )  //0x2b  //
#define SRSHARP1_LTI_CTI_DF_GAIN                   (SRSHARP1_OFFSET + LTI_CTI_DF_GAIN              )  //0x2c  //
#define SRSHARP1_LTI_CTI_DIR_AC_DBG                (SRSHARP1_OFFSET + LTI_CTI_DIR_AC_DBG           )  //0x2d  //
#define SRSHARP1_HCTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HCTI_FLT_CLP_DC              )  //0x2e  //
#define SRSHARP1_HCTI_BST_GAIN                     (SRSHARP1_OFFSET + HCTI_BST_GAIN                )  //0x2f  //
#define SRSHARP1_HCTI_BST_CORE                     (SRSHARP1_OFFSET + HCTI_BST_CORE                )  //0x30  //
#define SRSHARP1_HCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_0            )  //0x31  //
#define SRSHARP1_HCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HCTI_CON_2_GAIN_1            )  //0x32  //
#define SRSHARP1_HCTI_OS_MARGIN                    (SRSHARP1_OFFSET + HCTI_OS_MARGIN               )  //0x33  //
#define SRSHARP1_HLTI_FLT_CLP_DC                   (SRSHARP1_OFFSET + HLTI_FLT_CLP_DC              )  //0x34  //
#define SRSHARP1_HLTI_BST_GAIN                     (SRSHARP1_OFFSET + HLTI_BST_GAIN                )  //0x35  //
#define SRSHARP1_HLTI_BST_CORE                     (SRSHARP1_OFFSET + HLTI_BST_CORE                )  //0x36  //
#define SRSHARP1_HLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_0            )  //0x37  //
#define SRSHARP1_HLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + HLTI_CON_2_GAIN_1            )  //0x38  //
#define SRSHARP1_HLTI_OS_MARGIN                    (SRSHARP1_OFFSET + HLTI_OS_MARGIN               )  //0x39  //
#define SRSHARP1_VLTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VLTI_FLT_CON_CLP             )  //0x3a  //
#define SRSHARP1_VLTI_BST_GAIN                     (SRSHARP1_OFFSET + VLTI_BST_GAIN                )  //0x3b  //
#define SRSHARP1_VLTI_BST_CORE                     (SRSHARP1_OFFSET + VLTI_BST_CORE                )  //0x3c  //
#define SRSHARP1_VLTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_0            )  //0x3d  //
#define SRSHARP1_VLTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VLTI_CON_2_GAIN_1            )  //0x3e  //
#define SRSHARP1_VCTI_FLT_CON_CLP                  (SRSHARP1_OFFSET + VCTI_FLT_CON_CLP             )  //0x3f  //
#define SRSHARP1_VCTI_BST_GAIN                     (SRSHARP1_OFFSET + VCTI_BST_GAIN                )  //0x40  //
#define SRSHARP1_VCTI_BST_CORE                     (SRSHARP1_OFFSET + VCTI_BST_CORE                )  //0x41  //
#define SRSHARP1_VCTI_CON_2_GAIN_0                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_0            )  //0x42  //
#define SRSHARP1_VCTI_CON_2_GAIN_1                 (SRSHARP1_OFFSET + VCTI_CON_2_GAIN_1            )  //0x43  //
#define SRSHARP1_SHARP_3DLIMIT                     (SRSHARP1_OFFSET + SHARP_3DLIMIT                )  //0x44  //
#define SRSHARP1_DNLP_EN                           (SRSHARP1_OFFSET + DNLP_EN                      )  //0x45  //
//`define SRSHARP1_DNLP_00                           (`SRSHARP1_OFFSET + `DNLP_00                      )  //8'h46  //
//`define SRSHARP1_DNLP_01                           (`SRSHARP1_OFFSET + `DNLP_01                      )  //8'h47  //
//`define SRSHARP1_DNLP_02                           (`SRSHARP1_OFFSET + `DNLP_02                      )  //8'h48  //
//`define SRSHARP1_DNLP_03                           (`SRSHARP1_OFFSET + `DNLP_03                      )  //8'h49  //
//`define SRSHARP1_DNLP_04                           (`SRSHARP1_OFFSET + `DNLP_04                      )  //8'h4a  //
//`define SRSHARP1_DNLP_05                           (`SRSHARP1_OFFSET + `DNLP_05                      )  //8'h4b  //
//`define SRSHARP1_DNLP_06                           (`SRSHARP1_OFFSET + `DNLP_06                      )  //8'h4c  //
//`define SRSHARP1_DNLP_07                           (`SRSHARP1_OFFSET + `DNLP_07                      )  //8'h4d  //
//`define SRSHARP1_DNLP_08                           (`SRSHARP1_OFFSET + `DNLP_08                      )  //8'h4e  //
//`define SRSHARP1_DNLP_09                           (`SRSHARP1_OFFSET + `DNLP_09                      )  //8'h4f  //
//`define SRSHARP1_DNLP_10                           (`SRSHARP1_OFFSET + `DNLP_10                      )  //8'h50  //
//`define SRSHARP1_DNLP_11                           (`SRSHARP1_OFFSET + `DNLP_11                      )  //8'h51  //
//`define SRSHARP1_DNLP_12                           (`SRSHARP1_OFFSET + `DNLP_12                      )  //8'h52  //
//`define SRSHARP1_DNLP_13                           (`SRSHARP1_OFFSET + `DNLP_13                      )  //8'h53  //
//`define SRSHARP1_DNLP_14                           (`SRSHARP1_OFFSET + `DNLP_14                      )  //8'h54  //
//`define SRSHARP1_DNLP_15                           (`SRSHARP1_OFFSET + `DNLP_15                      )  //8'h55  //
#define SRSHARP1_DEMO_CRTL                         (SRSHARP1_OFFSET + DEMO_CRTL                    )  //0x56  //
#define SRSHARP1_SHARP_SR2_CTRL                    (SRSHARP1_OFFSET + SHARP_SR2_CTRL               )  //0x57  //
#define SRSHARP1_SHARP_SR2_YBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF0        )  //0x58
#define SRSHARP1_SHARP_SR2_YBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_HCOEF1        )  //0x59  //
#define SRSHARP1_SHARP_SR2_CBIC_HCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF0        )  //0x5a  //
#define SRSHARP1_SHARP_SR2_CBIC_HCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_HCOEF1        )  //0x5b  //
#define SRSHARP1_SHARP_SR2_YBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF0        )  //0x5c  //
#define SRSHARP1_SHARP_SR2_YBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_YBIC_VCOEF1        )  //0x5d  //
#define SRSHARP1_SHARP_SR2_CBIC_VCOEF0             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF0        )  //0x5e  //
#define SRSHARP1_SHARP_SR2_CBIC_VCOEF1             (SRSHARP1_OFFSET + SHARP_SR2_CBIC_VCOEF1        )  //0x5f  //
#define SRSHARP1_SHARP_SR2_MISC                    (SRSHARP1_OFFSET + SHARP_SR2_MISC               )  //0x60  //
#define SRSHARP1_SR3_SAD_CTRL                   (SRSHARP1_OFFSET + SHARP_SR3_SAD_CTRL                 ) // 0x61  //
#define SRSHARP1_SR3_PK_CTRL0                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL0                 ) // 0x62
#define SRSHARP1_SR3_PK_CTRL1                   (SRSHARP1_OFFSET + SHARP_SR3_PK_CTRL1                 ) // 0x63
#define SRSHARP1_DEJ_CTRL                       (SRSHARP1_OFFSET + SHARP_DEJ_CTRL                     ) // 0x64
#define SRSHARP1_DEJ_ALPHA                      (SRSHARP1_OFFSET + SHARP_DEJ_ALPHA                    ) // 0x65
#define SRSHARP1_SR3_DRTLPF_EN                  (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_EN                ) // 0x66
#define SRSHARP1_SR3_DRTLPF_ALPHA_0             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_0           ) // 0x67
#define SRSHARP1_SR3_DRTLPF_ALPHA_1             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_1           ) // 0x68
#define SRSHARP1_SR3_DRTLPF_ALPHA_2             (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_2           ) // 0x69
#define SRSHARP1_SR3_DRTLPF_ALPHA_OFST          (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_ALPHA_OFST        ) // 0x6a
#define SRSHARP1_SR3_DERING_CTRL                (SRSHARP1_OFFSET + SHARP_SR3_DERING_CTRL              ) // 0x6b
#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_0TO3    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_0TO3  ) // 0x6c
#define SRSHARP1_SR3_DERING_LUMA2PKGAIN_4TO6    (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKGAIN_4TO6  ) // 0x6d
#define SRSHARP1_SR3_DERING_LUMA2PKOS_0TO3      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_0TO3    ) // 0x6e
#define SRSHARP1_SR3_DERING_LUMA2PKOS_4TO6      (SRSHARP1_OFFSET + SHARP_SR3_DERING_LUMA2PKOS_4TO6    ) // 0x6f
#define SRSHARP1_SR3_DERING_GAINVS_MADSAD       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_MADSAD     ) // 0x70
#define SRSHARP1_SR3_DERING_GAINVS_VR2MAX       (SRSHARP1_OFFSET + SHARP_SR3_DERING_GAINVS_VR2MAX     ) // 0x71
#define SRSHARP1_SR3_DERING_PARAM0              (SRSHARP1_OFFSET + SHARP_SR3_DERING_PARAM0            ) // 0x72
#define SRSHARP1_SR3_DRTLPF_THETA               (SRSHARP1_OFFSET + SHARP_SR3_DRTLPF_THETA             ) // 0x73
#define SRSHARP1_SATPRT_CTRL                    (SRSHARP1_OFFSET + SHARP_SATPRT_CTRL                  ) // 0x74
#define SRSHARP1_SATPRT_DIVM                    (SRSHARP1_OFFSET + SHARP_SATPRT_DIVM                  ) // 0x75
#define SRSHARP1_DB_FLT_CTRL                    (SRSHARP1_OFFSET + SHARP_DB_FLT_CTRL                  ) // 0x77
//`define SRSHARP1_DB_FLT_YC_THRD               (`SRSHARP1_OFFSET + `SHARP_DB_FLT_YC_THRD               ) // 8'h78
#define SRSHARP1_DB_FLT_CTRL1                   (SRSHARP1_OFFSET + SHARP_DB_FLT_CTRL1                 ) // 0xb8
#define SRSHARP1_DB_FLT_LUMA_THRD               (SRSHARP1_OFFSET + SHARP_DB_FLT_LUMA_THRD             ) // 0xb9
#define SRSHARP1_DB_FLT_CHRM_THRD               (SRSHARP1_OFFSET + SHARP_DB_FLT_CHRM_THRD             ) // 0xba
#define SRSHARP1_DB_FLT_RANDLUT                 (SRSHARP1_OFFSET + SHARP_DB_FLT_RANDLUT               ) // 0x79
#define SRSHARP1_DB_FLT_PXI_THRD                (SRSHARP1_OFFSET + SHARP_DB_FLT_PXI_THRD              ) // 0x7a
#define SRSHARP1_DB_FLT_SEED_Y                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_Y                ) // 0x7b
#define SRSHARP1_DB_FLT_SEED_U                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_U                ) // 0x7c
#define SRSHARP1_DB_FLT_SEED_V                  (SRSHARP1_OFFSET + SHARP_DB_FLT_SEED_V                ) // 0x7d
#define SRSHARP1_PKGAIN_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_L          ) // 0x7e
#define SRSHARP1_PKGAIN_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKGAIN_VSLUMA_LUT_H          ) // 0x7f
#define SRSHARP1_PKOSHT_VSLUMA_LUT_L            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_L          ) // 0x80
#define SRSHARP1_PKOSHT_VSLUMA_LUT_H            (SRSHARP1_OFFSET + SHARP_PKOSHT_VSLUMA_LUT_H          ) // 0x81
#define SRSHARP1_SATPRT_LMT_RGB1                (SRSHARP1_OFFSET + SHARP_SATPRT_LMT_RGB1              ) // 0x82
#define SRSHARP1_SATPRT_LMT_RGB2                (SRSHARP1_OFFSET + SHARP_SATPRT_LMT_RGB2              ) // 0x83
#define SRSHARP1_SHARP_GATE_CLK_CTRL_0          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_0              ) // 0x84
#define SRSHARP1_SHARP_GATE_CLK_CTRL_1          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_1              ) // 0x85
#define SRSHARP1_SHARP_GATE_CLK_CTRL_2          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_2              ) // 0x86
#define SRSHARP1_SHARP_GATE_CLK_CTRL_3          (SRSHARP1_OFFSET + SHARP_GATE_CLK_CTRL_3              ) // 0x87
#define SRSHARP1_SHARP_DPS_CTRL                 (SRSHARP1_OFFSET + SHARP_DPS_CTRL                     ) // 0x88
#define SRSHARP1_DNLP_00                        (SRSHARP1_OFFSET + DNLP_00) // 0x90  //
#define SRSHARP1_DNLP_01                        (SRSHARP1_OFFSET + DNLP_01) // 0x91  //
#define SRSHARP1_DNLP_02                        (SRSHARP1_OFFSET + DNLP_02) // 0x92  //
#define SRSHARP1_DNLP_03                        (SRSHARP1_OFFSET + DNLP_03) // 0x93  //
#define SRSHARP1_DNLP_04                        (SRSHARP1_OFFSET + DNLP_04) // 0x94  //
#define SRSHARP1_DNLP_05                        (SRSHARP1_OFFSET + DNLP_05) // 0x95  //
#define SRSHARP1_DNLP_06                        (SRSHARP1_OFFSET + DNLP_06) // 0x96  //
#define SRSHARP1_DNLP_07                        (SRSHARP1_OFFSET + DNLP_07) // 0x97  //
#define SRSHARP1_DNLP_08                        (SRSHARP1_OFFSET + DNLP_08) // 0x98  //
#define SRSHARP1_DNLP_09                        (SRSHARP1_OFFSET + DNLP_09) // 0x99  //
#define SRSHARP1_DNLP_10                        (SRSHARP1_OFFSET + DNLP_10) // 0x9a  //
#define SRSHARP1_DNLP_11                        (SRSHARP1_OFFSET + DNLP_11) // 0x9b  //
#define SRSHARP1_DNLP_12                        (SRSHARP1_OFFSET + DNLP_12) // 0x9c  //
#define SRSHARP1_DNLP_13                        (SRSHARP1_OFFSET + DNLP_13) // 0x9d  //
#define SRSHARP1_DNLP_14                        (SRSHARP1_OFFSET + DNLP_14) // 0x9e  //
#define SRSHARP1_DNLP_15                        (SRSHARP1_OFFSET + DNLP_15) // 0x9f  //
#define SRSHARP1_DNLP_16                        (SRSHARP1_OFFSET + DNLP_16) // 0xa0  //
#define SRSHARP1_DNLP_17                        (SRSHARP1_OFFSET + DNLP_17) // 0xa1  //
#define SRSHARP1_DNLP_18                        (SRSHARP1_OFFSET + DNLP_18) // 0xa2  //
#define SRSHARP1_DNLP_19                        (SRSHARP1_OFFSET + DNLP_19) // 0xa3  //
#define SRSHARP1_DNLP_20                        (SRSHARP1_OFFSET + DNLP_20) // 0xa4  //
#define SRSHARP1_DNLP_21                        (SRSHARP1_OFFSET + DNLP_21) // 0xa5  //
#define SRSHARP1_DNLP_22                        (SRSHARP1_OFFSET + DNLP_22) // 0xa6  //
#define SRSHARP1_DNLP_23                        (SRSHARP1_OFFSET + DNLP_23) // 0xa7  //
#define SRSHARP1_DNLP_24                        (SRSHARP1_OFFSET + DNLP_24) // 0xa8  //
#define SRSHARP1_DNLP_25                        (SRSHARP1_OFFSET + DNLP_25) // 0xa9  //
#define SRSHARP1_DNLP_26                        (SRSHARP1_OFFSET + DNLP_26) // 0xaa  //
#define SRSHARP1_DNLP_27                        (SRSHARP1_OFFSET + DNLP_27) // 0xab  //
#define SRSHARP1_DNLP_28                        (SRSHARP1_OFFSET + DNLP_28) // 0xac  //
#define SRSHARP1_DNLP_29                        (SRSHARP1_OFFSET + DNLP_29) // 0xad  //
#define SRSHARP1_DNLP_30                        (SRSHARP1_OFFSET + DNLP_30) // 0xae  //
#define SRSHARP1_DNLP_31                        (SRSHARP1_OFFSET + DNLP_31) // 0xaf  //
#define SRSHARP1_SHARP_SYNC_CTRL                (SRSHARP1_OFFSET + SHARP_SYNC_CTRL                    ) // 0xb0  //
#define SRSHARP1_LC_INPUT_MUX                   (SRSHARP1_OFFSET + LC_INPUT_MUX                       ) // 0xb1  //
#define SRSHARP1_NR_GAU_YH_COEF02               (SRSHARP1_OFFSET + NR_GAU_YH_COEF02                   ) // 0xb2  //
#define SRSHARP1_NR_GAU_YH_COEF34               (SRSHARP1_OFFSET + NR_GAU_YH_COEF34                   ) // 0xb3  //
#define SRSHARP1_NR_GAU_YV_COEF1                (SRSHARP1_OFFSET + NR_GAU_YV_COEF1                    ) // 0xb4  //
#define SRSHARP1_NR_GAU_CH_COEF02               (SRSHARP1_OFFSET + NR_GAU_CH_COEF02                   ) // 0xb5  //
#define SRSHARP1_NR_GAU_CH_COEF34               (SRSHARP1_OFFSET + NR_GAU_CH_COEF34                   ) // 0xb6  //
#define SRSHARP1_NR_GAU_CV_COEF1                (SRSHARP1_OFFSET + NR_GAU_CV_COEF1                    ) // 0xb7  //
#define SRSHARP1_LC_TOP_CTRL                    (SRSHARP1_OFFSET + LC_TOP_CTRL                        ) // 0xc0  //
#define SRSHARP1_LC_HV_NUM                      (SRSHARP1_OFFSET + LC_HV_NUM                          ) // 0xc1
#define SRSHARP1_LC_SAT_LUT_0_1                 (SRSHARP1_OFFSET + LC_SAT_LUT_0_1                     ) // 0xc2
#define SRSHARP1_LC_SAT_LUT_2_3                 (SRSHARP1_OFFSET + LC_SAT_LUT_2_3                     ) // 0xc3
#define SRSHARP1_LC_SAT_LUT_4_5                 (SRSHARP1_OFFSET + LC_SAT_LUT_4_5                     ) // 0xc4
#define SRSHARP1_LC_SAT_LUT_6_7                 (SRSHARP1_OFFSET + LC_SAT_LUT_6_7                     ) // 0xc5
#define SRSHARP1_LC_SAT_LUT_8_9                 (SRSHARP1_OFFSET + LC_SAT_LUT_8_9                     ) // 0xc6
#define SRSHARP1_LC_SAT_LUT_10_11               (SRSHARP1_OFFSET + LC_SAT_LUT_10_11                   ) // 0xc7
#define SRSHARP1_LC_SAT_LUT_12_13               (SRSHARP1_OFFSET + LC_SAT_LUT_12_13                   ) // 0xc8
#define SRSHARP1_LC_SAT_LUT_14_15               (SRSHARP1_OFFSET + LC_SAT_LUT_14_15                   ) // 0xc9
#define SRSHARP1_LC_SAT_LUT_16_17               (SRSHARP1_OFFSET + LC_SAT_LUT_16_17                   ) // 0xca
#define SRSHARP1_LC_SAT_LUT_18_19               (SRSHARP1_OFFSET + LC_SAT_LUT_18_19                   ) // 0xcb
#define SRSHARP1_LC_SAT_LUT_20_21               (SRSHARP1_OFFSET + LC_SAT_LUT_20_21                   ) // 0xcc
#define SRSHARP1_LC_SAT_LUT_22_23               (SRSHARP1_OFFSET + LC_SAT_LUT_22_23                   ) // 0xcd
#define SRSHARP1_LC_SAT_LUT_24_25               (SRSHARP1_OFFSET + LC_SAT_LUT_24_25                   ) // 0xce
#define SRSHARP1_LC_SAT_LUT_26_27               (SRSHARP1_OFFSET + LC_SAT_LUT_26_27                   ) // 0xcf
#define SRSHARP1_LC_SAT_LUT_28_29               (SRSHARP1_OFFSET + LC_SAT_LUT_28_29                   ) // 0xd0
#define SRSHARP1_LC_SAT_LUT_30_31               (SRSHARP1_OFFSET + LC_SAT_LUT_30_31                   ) // 0xd1
#define SRSHARP1_LC_SAT_LUT_32_33               (SRSHARP1_OFFSET + LC_SAT_LUT_32_33                   ) // 0xd2
#define SRSHARP1_LC_SAT_LUT_34_35               (SRSHARP1_OFFSET + LC_SAT_LUT_34_35                   ) // 0xd3
#define SRSHARP1_LC_SAT_LUT_36_37               (SRSHARP1_OFFSET + LC_SAT_LUT_36_37                   ) // 0xd4
#define SRSHARP1_LC_SAT_LUT_38_39               (SRSHARP1_OFFSET + LC_SAT_LUT_38_39                   ) // 0xd5
#define SRSHARP1_LC_SAT_LUT_40_41               (SRSHARP1_OFFSET + LC_SAT_LUT_40_41                   ) // 0xd6
#define SRSHARP1_LC_SAT_LUT_42_43               (SRSHARP1_OFFSET + LC_SAT_LUT_42_43                   ) // 0xd7
#define SRSHARP1_LC_SAT_LUT_44_45               (SRSHARP1_OFFSET + LC_SAT_LUT_44_45                   ) // 0xd8
#define SRSHARP1_LC_SAT_LUT_46_47               (SRSHARP1_OFFSET + LC_SAT_LUT_46_47                   ) // 0xd9
#define SRSHARP1_LC_SAT_LUT_48_49               (SRSHARP1_OFFSET + LC_SAT_LUT_48_49                   ) // 0xda
#define SRSHARP1_LC_SAT_LUT_50_51               (SRSHARP1_OFFSET + LC_SAT_LUT_50_51                   ) // 0xdb
#define SRSHARP1_LC_SAT_LUT_52_53               (SRSHARP1_OFFSET + LC_SAT_LUT_52_53                   ) // 0xdc
#define SRSHARP1_LC_SAT_LUT_54_55               (SRSHARP1_OFFSET + LC_SAT_LUT_54_55                   ) // 0xdd
#define SRSHARP1_LC_SAT_LUT_56_57               (SRSHARP1_OFFSET + LC_SAT_LUT_56_57                   ) // 0xde
#define SRSHARP1_LC_SAT_LUT_58_59               (SRSHARP1_OFFSET + LC_SAT_LUT_58_59                   ) // 0xdf
#define SRSHARP1_LC_SAT_LUT_60_61               (SRSHARP1_OFFSET + LC_SAT_LUT_60_61                   ) // 0xe0
#define SRSHARP1_LC_SAT_LUT_62                  (SRSHARP1_OFFSET + LC_SAT_LUT_62                      ) // 0xe1
#define SRSHARP1_LC_CURVE_BLK_HIDX_0_1          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_0_1              ) // 0xe2
#define SRSHARP1_LC_CURVE_BLK_HIDX_2_3          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_2_3              ) // 0xe3
#define SRSHARP1_LC_CURVE_BLK_HIDX_4_5          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_4_5              ) // 0xe4
#define SRSHARP1_LC_CURVE_BLK_HIDX_6_7          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_6_7              ) // 0xe5
#define SRSHARP1_LC_CURVE_BLK_HIDX_8_9          (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_8_9              ) // 0xe6
#define SRSHARP1_LC_CURVE_BLK_HIDX_10_11        (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_10_11            ) // 0xe7
#define SRSHARP1_LC_CURVE_BLK_HIDX_12           (SRSHARP1_OFFSET + LC_CURVE_BLK_HIDX_12               ) // 0xe8
#define SRSHARP1_LC_CURVE_BLK_VIDX_0_1          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_0_1              ) // 0xe9
#define SRSHARP1_LC_CURVE_BLK_VIDX_2_3          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_2_3              ) // 0xea
#define SRSHARP1_LC_CURVE_BLK_VIDX_4_5          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_4_5              ) // 0xeb
#define SRSHARP1_LC_CURVE_BLK_VIDX_6_7          (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_6_7              ) // 0xec
#define SRSHARP1_LC_CURVE_BLK_VIDX_8            (SRSHARP1_OFFSET + LC_CURVE_BLK_VIDX_8                ) // 0xed
#define SRSHARP1_LC_YUV2RGB_MAT_0_1             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_0_1                 ) // 0xee
#define SRSHARP1_LC_YUV2RGB_MAT_2_3             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_2_3                 ) // 0xef
#define SRSHARP1_LC_YUV2RGB_MAT_4_5             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_4_5                 ) // 0xf0
#define SRSHARP1_LC_YUV2RGB_MAT_6_7             (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_6_7                 ) // 0xf1
#define SRSHARP1_LC_YUV2RGB_MAT_8               (SRSHARP1_OFFSET + LC_YUV2RGB_MAT_8                   ) // 0xf2
#define SRSHARP1_LC_RGB2YUV_MAT_0_1             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_0_1                 ) // 0xf3
#define SRSHARP1_LC_RGB2YUV_MAT_2_3             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_2_3                 ) // 0xf4
#define SRSHARP1_LC_RGB2YUV_MAT_4_5             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_4_5                 ) // 0xf5
#define SRSHARP1_LC_RGB2YUV_MAT_6_7             (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_6_7                 ) // 0xf6
#define SRSHARP1_LC_RGB2YUV_MAT_8               (SRSHARP1_OFFSET + LC_RGB2YUV_MAT_8                   ) // 0xf7
#define SRSHARP1_LC_YUV2RGB_OFST                (SRSHARP1_OFFSET + LC_YUV2RGB_OFST                    ) // 0xf8
#define SRSHARP1_LC_YUV2RGB_CLIP                (SRSHARP1_OFFSET + LC_YUV2RGB_CLIP                    ) // 0xf9
#define SRSHARP1_LC_RGB2YUV_OFST                (SRSHARP1_OFFSET + LC_RGB2YUV_OFST                    ) // 0xfa
#define SRSHARP1_LC_RGB2YUV_CLIP                (SRSHARP1_OFFSET + LC_RGB2YUV_CLIP                    ) // 0xfb
#define SRSHARP1_LC_MAP_RAM_CTRL                (SRSHARP1_OFFSET + LC_MAP_RAM_CTRL                    ) // 0xfc
#define SRSHARP1_LC_MAP_RAM_ADDR                (SRSHARP1_OFFSET + LC_MAP_RAM_ADDR                    ) // 0xfd
#define SRSHARP1_LC_MAP_RAM_DATA                (SRSHARP1_OFFSET + LC_MAP_RAM_DATA                    ) // 0xfe

#define SRSHARP1_FMETER_CTRL                    (SRSHARP1_OFFSET +  SHARP_FMETER_CTRL                 ) // 0x89
#define SRSHARP1_FMETER_WIN_HOR                 (SRSHARP1_OFFSET +  SHARP_FMETER_WIN_HOR              ) // 0x8a
#define SRSHARP1_FMETER_WIN_VER                 (SRSHARP1_OFFSET +  SHARP_FMETER_WIN_VER              ) // 0x8b
#define SRSHARP1_FMETER_CORING                  (SRSHARP1_OFFSET +  SHARP_FMETER_CORING               ) // 0x8c
#define SRSHARP1_FMETER_RATIO_H                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_H              ) // 0x8d
#define SRSHARP1_FMETER_RATIO_V                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_V              ) // 0x8e
#define SRSHARP1_FMETER_RATIO_D                 (SRSHARP1_OFFSET +  SHARP_FMETER_RATIO_D              ) // 0x8f
#define SRSHARP1_RO_FMETER_HCNT_TYPE0           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE0        ) // 0x46
#define SRSHARP1_RO_FMETER_HCNT_TYPE1           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE1        ) // 0x47
#define SRSHARP1_RO_FMETER_HCNT_TYPE2           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE2        ) // 0x48
#define SRSHARP1_RO_FMETER_HCNT_TYPE3           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_HCNT_TYPE3        ) // 0x49
#define SRSHARP1_RO_FMETER_VCNT_TYPE0           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE0        ) // 0x4a
#define SRSHARP1_RO_FMETER_VCNT_TYPE1           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE1        ) // 0x4b
#define SRSHARP1_RO_FMETER_VCNT_TYPE2           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE2        ) // 0x4c
#define SRSHARP1_RO_FMETER_VCNT_TYPE3           (SRSHARP1_OFFSET +  SHARP_RO_FMETER_VCNT_TYPE3        ) // 0x4d
#define SRSHARP1_RO_FMETER_PDCNT_TYPE0          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE0       ) // 0x4e
#define SRSHARP1_RO_FMETER_PDCNT_TYPE1          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE1       ) // 0x4f
#define SRSHARP1_RO_FMETER_PDCNT_TYPE2          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE2       ) // 0x50
#define SRSHARP1_RO_FMETER_PDCNT_TYPE3          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_PDCNT_TYPE3       ) // 0x51
#define SRSHARP1_RO_FMETER_NDCNT_TYPE0          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE0       ) // 0x52
#define SRSHARP1_RO_FMETER_NDCNT_TYPE1          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE1       ) // 0x53
#define SRSHARP1_RO_FMETER_NDCNT_TYPE2          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE2       ) // 0x54
#define SRSHARP1_RO_FMETER_NDCNT_TYPE3          (SRSHARP1_OFFSET +  SHARP_RO_FMETER_NDCNT_TYPE3       ) // 0x55



// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./srsharp_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPE_VCBUS_BASE = 0x51
// -----------------------------------------------
// 8'h50/51/52/53  have used  for srsharp_regs
//===========================================================================
//
// Reading file:  ./srsharp_regs2.h
//
// synopsys translate_off
// synopsys translate_on
//SRSHARP0        8'h00  - 8'hff
//SRSHARP1        8'h100 - 8'1ff
#define  SRSHARP0_OFFSET   (0x000<<2)
#define  SRSHARP1_OFFSET   (0x200<<2)

//
// Reading file:  ./sharp_regs2.h
//
// synopsys translate_off
// synopsys translate_on
#define SR7_DRTLPF_EN                              ((0x5100  << 2) + 0xff000000)
//Bit 31:11,        reserved
//Bit 10,            reg_sr7_drtlpf_beta_en2                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  9,            reg_sr7_drtlpf_beta_en1                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  8,            reg_sr7_drtlpf_beta_en0                     : enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
//Bit  7: 6,        reserved
//Bit  5,            reg_sr7_drtlpf_edge_en2                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  4,            reg_sr7_drtlpf_edge_en1                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  3,            reg_sr7_drtlpf_edge_en0                     : enable of direction lpf based on edge strength. unsigned  , default = 0
//Bit  2,            reg_sr7_drtlpf_sdfd_en2                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
//Bit  1,            reg_sr7_drtlpf_sdfd_en1                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
//Bit  0,            reg_sr7_drtlpf_sdfd_en0                     : sdfd gamma (HF burst compare to real edge protection) enable. 0: not enable, 1:enable protection. unsigned  , default = 1
#define SR7_DRTLPF_BETA                            ((0x5101  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_drtlpf_beta3                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_drtlpf_beta2                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_drtlpf_beta1                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_drtlpf_beta0                        : beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf. unsigned  , default = 15
#define SR7_PKBLD_BETA                             ((0x5102  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pkdrtbld_beta3                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_pkdrtbld_beta2                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pkdrtbld_beta1                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_pkdrtbld_beta0                      : beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt. unsigned  , default = 15
#define SR7_XLTIBLD_BETA                           ((0x5103  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_xlti_dcbld_beta3                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_xlti_dcbld_beta2                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_xlti_dcbld_beta1                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_xlti_dcbld_beta0                    : beta for denoise and org dc blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 15
#define SR7_DRTLPF_EDGE0                           ((0x5104  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drtlpf_edge7                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_edge6                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_edge5                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_edge4                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_edge3                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_edge2                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_edge1                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_edge0                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
#define SR7_DRTLPF_EDGE1                           ((0x5105  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drtlpf_edge15                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_edge14                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_edge13                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_edge12                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_edge11                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_edge10                       : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_edge9                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_edge8                        : edge lamda for drt lpf base on max_sad [0:16:128~255];. unsigned  , default = 15
#define SR7_DRTLPF_SDCOR0                          ((0x5106  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drtlpf_sdcor7                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_sdcor6                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_sdcor5                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_sdcor4                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_sdcor3                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_sdcor2                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_sdcor1                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_sdcor0                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_DRTLPF_SDCOR1                          ((0x5107  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drtlpf_sdcor15                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtlpf_sdcor14                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtlpf_sdcor13                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtlpf_sdcor12                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtlpf_sdcor11                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtlpf_sdcor10                      : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtlpf_sdcor9                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtlpf_sdcor8                       : gamma for drt lpf base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_CTIGAIN_SDCOR0                         ((0x5108  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_ctigain_sdcor7                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ctigain_sdcor6                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ctigain_sdcor5                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ctigain_sdcor4                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ctigain_sdcor3                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ctigain_sdcor2                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ctigain_sdcor1                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ctigain_sdcor0                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_CTIGAIN_SDCOR1                         ((0x5109  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_ctigain_sdcor15                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ctigain_sdcor14                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ctigain_sdcor13                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ctigain_sdcor12                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ctigain_sdcor11                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ctigain_sdcor10                     : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ctigain_sdcor9                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ctigain_sdcor8                      : adaptive gamma for cti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_LTIGAIN_SDCOR0                         ((0x510a  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_ltigain_sdcor7                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ltigain_sdcor6                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ltigain_sdcor5                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ltigain_sdcor4                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ltigain_sdcor3                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ltigain_sdcor2                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ltigain_sdcor1                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ltigain_sdcor0                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_LTIGAIN_SDCOR1                         ((0x510b  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_ltigain_sdcor15                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 27:24,        reg_sr7_ltigain_sdcor14                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 23:20,        reg_sr7_ltigain_sdcor13                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 19:16,        reg_sr7_ltigain_sdcor12                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 15:12,        reg_sr7_ltigain_sdcor11                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_ltigain_sdcor10                     : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_ltigain_sdcor9                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_ltigain_sdcor8                      : adaptive gamma for lti boost gain base on SD'[0:16:128~255];. unsigned  , default = 15
#define SR7_HLTIBPF_TAP0                           ((0x510c  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_hlti_bpf_tap153                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_hlti_bpf_tap152                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -34
//Bit 15: 8,        reg_sr7_hlti_bpf_tap151                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_hlti_bpf_tap150                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 120
#define SR7_HLTIBPF_TAP1                           ((0x510d  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_hlti_bpf_tap157                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 2
//Bit 23:16,        reg_sr7_hlti_bpf_tap156                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -7
//Bit 15: 8,        reg_sr7_hlti_bpf_tap155                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 1
//Bit  7: 0,        reg_sr7_hlti_bpf_tap154                     : tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -21
#define SR7_HCTIBPF_TAP0                           ((0x510e  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_hcti_bpf_tap153                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_hcti_bpf_tap152                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -34
//Bit 15: 8,        reg_sr7_hcti_bpf_tap151                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_hcti_bpf_tap150                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 120
#define SR7_HCTIBPF_TAP1                           ((0x510f  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_hcti_bpf_tap157                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 2
//Bit 23:16,        reg_sr7_hcti_bpf_tap156                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -7
//Bit 15: 8,        reg_sr7_hcti_bpf_tap155                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 1
//Bit  7: 0,        reg_sr7_hcti_bpf_tap154                     : tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -21
#define SR7_PKLONGBPF_HTAP0                        ((0x5110  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_bpf_hztap153                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -24
//Bit 23:16,        reg_sr7_pk_long_bpf_hztap152                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -19
//Bit 15: 8,        reg_sr7_pk_long_bpf_hztap151                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 31
//Bit  7: 0,        reg_sr7_pk_long_bpf_hztap150                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 66
#define SR7_PKLONGBPF_HTAP1                        ((0x5111  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_bpf_hztap157                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -6
//Bit 23:16,        reg_sr7_pk_long_bpf_hztap156                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -10
//Bit 15: 8,        reg_sr7_pk_long_bpf_hztap155                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_pk_long_bpf_hztap154                : tap15 BPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -4
#define SR7_PKLONGHPF_HTAP0                        ((0x5112  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_hpf_hztap153                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 27
//Bit 23:16,        reg_sr7_pk_long_hpf_hztap152                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -15
//Bit 15: 8,        reg_sr7_pk_long_hpf_hztap151                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -32
//Bit  7: 0,        reg_sr7_pk_long_hpf_hztap150                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 58
#define SR7_PKLONGHPF_HTAP1                        ((0x5113  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_hpf_hztap157                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 8
//Bit 23:16,        reg_sr7_pk_long_hpf_hztap156                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -6
//Bit 15: 8,        reg_sr7_pk_long_hpf_hztap155                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -1
//Bit  7: 0,        reg_sr7_pk_long_hpf_hztap154                : tap15 HPF for horizontal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -10
#define SR7_VLTIBPF_TAP0                           ((0x5114  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_vlti_bpf_tap093                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_vlti_bpf_tap092                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -41
//Bit 15: 8,        reg_sr7_vlti_bpf_tap091                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit  7: 0,        reg_sr7_vlti_bpf_tap090                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 126
#define SR7_VLTIBPF_TAP1                           ((0x5115  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_vlti_bpf_tap094                     : tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -22
#define SR7_VCTIBPF_TAP0                           ((0x5116  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_vcti_bpf_tap093                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit 23:16,        reg_sr7_vcti_bpf_tap092                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -41
//Bit 15: 8,        reg_sr7_vcti_bpf_tap091                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 0
//Bit  7: 0,        reg_sr7_vcti_bpf_tap090                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = 126
#define SR7_VCTIBPF_TAP1                           ((0x5117  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_vcti_bpf_tap094                     : tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0. signed    , default = -22
#define SR7_PKLONGBPF_VTAP0                        ((0x5118  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_bpf_vdtap093                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -32
//Bit 23:16,        reg_sr7_pk_long_bpf_vdtap092                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -28
//Bit 15: 8,        reg_sr7_pk_long_bpf_vdtap091                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 30
//Bit  7: 0,        reg_sr7_pk_long_bpf_vdtap090                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 68
#define SR7_PKLONGBPF_VTAP1                        ((0x5119  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_pk_long_bpf_vdtap094                : tap09 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -4
#define SR7_PKLONGHPF_VTAP0                        ((0x511a  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_hpf_vdtap093                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 30
//Bit 23:16,        reg_sr7_pk_long_hpf_vdtap092                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -28
//Bit 15: 8,        reg_sr7_pk_long_hpf_vdtap091                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -31
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdtap090                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = 68
#define SR7_PKLONGHPF_VTAP1                        ((0x511b  << 2) + 0xff000000)
//Bit 31: 8,        reserved
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdtap094                : tap09 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 258 as 1.0. signed    , default = -5
#define SR7_CIRBPLONG_ALP                          ((0x511c  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_cirbp_long_alpha3                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_cirbp_long_alpha2                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cirbp_long_alpha1                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cirbp_long_alpha0                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
#define SR7_CIRHPLONG_ALP                          ((0x511d  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_cirhp_long_alpha3                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_cirhp_long_alpha2                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cirhp_long_alpha1                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cirhp_long_alpha0                   : alpha to blend bp_long to the cirpk filter corresponding angle (0/45/90/135), norm to 16 as 1.0; default = 15, ==0 means same as s6-;. unsigned  , default = 15
#define SR7_DRTBPLONG_ALP                          ((0x511e  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drtbp_long_alpha7                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drtbp_long_alpha6                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drtbp_long_alpha5                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drtbp_long_alpha4                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drtbp_long_alpha3                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drtbp_long_alpha2                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drtbp_long_alpha1                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drtbp_long_alpha0                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
#define SR7_DRTHPLONG_ALP                          ((0x511f  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_drthp_long_alpha7                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 27:24,        reg_sr7_drthp_long_alpha6                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 23:20,        reg_sr7_drthp_long_alpha5                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 19:16,        reg_sr7_drthp_long_alpha4                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 15:12,        reg_sr7_drthp_long_alpha3                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit 11: 8,        reg_sr7_drthp_long_alpha2                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_drthp_long_alpha1                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_drthp_long_alpha0                   : alpha to blend bp_long to the drtpk filter corresponding angle (8 angles), norm to 16 as 1.0; default = 0, ==0 means same as s6-;. unsigned  , default = 15
#define SR7_PKMINMAXCIR_BLD_LUT2D0                 ((0x5120  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d7          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d6          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d5          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d4          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d3          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d2          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d1          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d0          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define SR7_PKMINMAXCIR_BLD_LUT2D1                 ((0x5121  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d15          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d14          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d13          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d12          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d11          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d10          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d9           : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d8           : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define SR7_PKMINMAXCIR_BLD_LUT2D2                 ((0x5122  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d23          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d22          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d21          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d20          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d19          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d18          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d17          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d16          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define SR7_PKMINMAXCIR_BLD_LUT2D3                 ((0x5123  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_cirbld_lut2d31          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 14
//Bit 27:24,        reg_sr7_pk_mimaxerr2_cirbld_lut2d30          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 23:20,        reg_sr7_pk_mimaxerr2_cirbld_lut2d29          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 19:16,        reg_sr7_pk_mimaxerr2_cirbld_lut2d28          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 8
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d27          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d26          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d25          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d24          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
#define SR7_PKMINMAXCIR_BLD_LUT2D4                 ((0x5124  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pk_mimaxerr2_cirbld_lut2d35          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_cirbld_lut2d34          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_cirbld_lut2d33          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_cirbld_lut2d32          : 2D-LUT for alpha2 for cir-PK blender,larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define SR7_PKMINMAXLPF_BLD_LUT2D0                 ((0x5125  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d7          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d6          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d5          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d4          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d3          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d2          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d1          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d0          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define SR7_PKMINMAXLPF_BLD_LUT2D1                 ((0x5126  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d15          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d14          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 0
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d13          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d12          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d11          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d10          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d9           : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d8           : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
#define SR7_PKMINMAXLPF_BLD_LUT2D2                 ((0x5127  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d23          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d22          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d21          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d20          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d19          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d18          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d17          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 6
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d16          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define SR7_PKMINMAXLPF_BLD_LUT2D3                 ((0x5128  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d31          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 14
//Bit 27:24,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d30          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 23:20,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d29          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
//Bit 19:16,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d28          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 8
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d27          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 10
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d26          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d25          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 2
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d24          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 4
#define SR7_PKMINMAXLPF_BLD_LUT2D4                 ((0x5129  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d35          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit 11: 8,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d34          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  7: 4,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d33          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 15
//Bit  3: 0,        reg_sr7_pk_mimaxerr2_lpfbld_lut2d32          : 2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, .... unsigned  , default = 12
#define SR7_PKDRT_BLD_EN                           ((0x512a  << 2) + 0xff000000)
//Bit 31: 1,        reserved
//Bit  0,            reg_sr7_pkdrtbld_beta_en                       : enable of direction ambiguity protection for drt and cir blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 0
#define SR7_DRTDIF_TH                              ((0x512b  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15: 8,        reg_sr7_drtdif_min2sad_th1                   : for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;. unsigned  , default = 128
//Bit  7: 0,        reg_sr7_drtdif_min2sad_th0                   : for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;. unsigned  , default = 128
#define SR7_TIBLD_PRT                              ((0x512c  << 2) + 0xff000000)
//Bit 31:14,        reserved
//Bit 13,            reg_sr7_hlti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit 12,            reg_sr7_vlti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit 11: 8,        reg_sr7_xcti_dcbld_beta1                     : beta for denoise and org dc blend base on the x=cal_drt_dif4(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_xcti_dcbld_beta0                     : beta for denoise and org dc blend base on the x=cal_drt_dif4(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo denoise. unsigned  , default = 15
//Bit  3,            reg_sr7_hcti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit  2,            reg_sr7_vcti_dcbld_beta_en                     : enable of denoise protection for dc org and denoise blend, beta for , 0, equivalent beta[i]=15, 1, enable. unsigned  , default = 1
//Bit  1,            reg_sr7_hcti_dcbld_use_ybeta                   : enable to use beta from hlti, 0, use c-beta, 1, use y-beta. unsigned  , default = 0
//Bit  0,            reg_sr7_vcti_dcbld_use_ybeta                   : enable to use beta from vlti, 0, use c-beta, 1, use y-beta. unsigned  , default = 0
#define SR7_HTI_OPT_FORCE                          ((0x512d  << 2) + 0xff000000)
//Bit 31: 6,        reserved
//Bit  5,            reg_sr7_diag_force_hti1                      :   force hti for diagonal edges luma/chroma, 0: diagonal use vti, 1: diagonal use hti, default=1. unsigned  , default = 1
//Bit  4,            reg_sr7_diag_force_hti0                      :   force hti for diagonal edges luma/chroma, 0: diagonal use vti, 1: diagonal use hti, default=1. unsigned  , default = 1
//Bit  3,            reg_sr7_horz_force_vti1                      :   force vti for horizontal edges luma/chroma, 0: bias hti, 1: horizontal edge force 100% vti,  default=1. unsigned  , default = 1
//Bit  2,            reg_sr7_horz_force_vti0                      :   force vti for horizontal edges luma/chroma, 0: bias hti, 1: horizontal edge force 100% vti,  default=1. unsigned  , default = 1
//Bit  1,            reg_sr7_alph_force_hvsad1                    :   alpha = minsad*64/maxsad, force minsad=sad_h, maxsad=sad_v for alpha calculation, [0]for luma, [1] for chroma. if sad_h>sad_v alpha will be large,  default=1. unsigned  , default = 1
//Bit  0,            reg_sr7_alph_force_hvsad0                    :   alpha = minsad*64/maxsad, force minsad=sad_h, maxsad=sad_v for alpha calculation, [0]for luma, [1] for chroma. if sad_h>sad_v alpha will be large,  default=1. unsigned  , default = 1
#define SR7_HVTI_FINALGAIN                         ((0x512e  << 2) + 0xff000000)
//Bit 31:28,        reserved
//Bit 27:16,        reg_sr7_hvti_finalgain1                      :   final gain for HVTI boost, for easier level tunning for application, normalized to 256 as 1.0 default = 256. unsigned  , default = 256
//Bit 15:12,        reserved
//Bit 11: 0,        reg_sr7_hvti_finalgain0                      :   final gain for HVTI boost, for easier level tunning for application, normalized to 256 as 1.0 default = 256. unsigned  , default = 256
#define SR7_TIOS_SDRATIO                           ((0x512f  << 2) + 0xff000000)
//Bit 31:30,        reserved
//Bit 29:24,        reg_sr7_hti_osmargin_sdratio1                :  ratio for HTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit 23:22,        reserved
//Bit 21:16,        reg_sr7_hti_osmargin_sdratio0                :  ratio for HTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit 15:14,        reserved
//Bit 13: 8,        reg_sr7_vti_osmargin_sdratio1                :  ratio for VTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_sr7_vti_osmargin_sdratio0                :  ratio for VTI OS margin adaptive to sd. osmargin= (sd*ratio)>>6; default=3. unsigned  , default = 3
#define SR7_XTI_SDFDEN                             ((0x5130  << 2) + 0xff000000)
//Bit 31: 2,        reserved
//Bit  1,            reg_sr7_xtigain_sdfd_en1                     :  adaptive gamma for cti boost gain enable.[0]for luma, [1] for chroma. 0: not enable, 1:enable, default = 1. unsigned  , default = 1
//Bit  0,            reg_sr7_xtigain_sdfd_en0                     :  adaptive gamma for cti boost gain enable.[0]for luma, [1] for chroma. 0: not enable, 1:enable, default = 1. unsigned  , default = 1
#define SR7_FDSD_PARAM                             ((0x5131  << 2) + 0xff000000)
//Bit 31:26,        reserved
//Bit 25,            reg_fdsd_vlpf_en                               : use vertical [1 2 1] lpf filter for the fd and sd derivativecalculations. unsigned  , default = 1
//Bit 24,            reg_fdsd_hlpf_en                               : use horizontal [1 2 1] lpf filter for the fd and sd derivativecalculations. unsigned  , default = 1
//Bit 23:20,        reg_sd_coring_th1                            : coring to SD'= MAX(SD - FD*ratio - coring,0); default = 0. unsigned  , default = 0
//Bit 19:16,        reg_sd_coring_th0                            : coring to SD'= MAX(SD - FD*ratio - coring,0); default = 0. unsigned  , default = 0
//Bit 15:14,        reserved
//Bit 13: 8,        reg_sd_coring_ratio2fd1                      : ratio to FD for adaptive coring to SD'= MAX(SD - FD*ratio - coring,0); normalized 64 as 1.0  default = 4. unsigned  , default = 4
//Bit  7: 6,        reserved
//Bit  5: 0,        reg_sd_coring_ratio2fd0                      : ratio to FD for adaptive coring to SD'= MAX(SD - FD*ratio - coring,0); normalized 64 as 1.0  default = 4. unsigned  , default = 4
#define SR7_TI_BPF_EN                              ((0x5132  << 2) + 0xff000000)
//Bit 31: 4,        reserved
//Bit  3,            reg_sr7_hlti_bpf_en                            :   enable of tap15 BPF for hlti (gain3), only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  2,            reg_sr7_hcti_bpf_en                            :   enable of tap15 BPF for hcti (gain3), only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  1,            reg_sr7_vlti_bpf_en                            :   enable of tap09 BPF for vlti (gain3), only store half of the filter normalized to 258 as 1.0, mainly for 2x2 UP case. unsigned  , default = 1
//Bit  0,            reg_sr7_vcti_bpf_en                            :   enable of tap09 BPF for vcti (gain3), only store half of the filter normalized to 258 as 1.0, mainly for 2x2 UP case. unsigned  , default = 1
#define SR7_PKLONG_PF_EN                           ((0x5133  << 2) + 0xff000000)
//Bit 31: 2,        reserved
//Bit  1,            reg_sr7_pk_long_bpf_en                         :   enable of long BPF for peaking only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
//Bit  0,            reg_sr7_pk_long_hpf_en                         :   enable of long HPF for peaking only store half of the filter normalized to 258 as 1.0. unsigned  , default = 1
#define SR7_PKLONG_PF_GAIN                         ((0x5134  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_pk_long_bpf_hzgain                     :   gain to long horizontal BPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit 23:16,        reg_sr7_pk_long_bpf_vdgain                     :   gain to long vertical and diagonal BPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit 15: 8,        reg_sr7_pk_long_hpf_hzgain                     :   gain to long horizontal HPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_pk_long_hpf_vdgain                     :   gain to long vertical and diagonal HPF for peaking, normalized to 64 as 1.0. unsigned  , default = 64
#define SR7_PKMINMAX_BLD                           ((0x5135  << 2) + 0xff000000)
//Bit 31: 4,        reserved
//Bit  3,            reg_sr7_pk_mimaxerr2_cirbld_on_bp              : enable to use adaptive blender of drtBP vs cirBP alpha2, the larger of cell, the more cirPK results, 0: alp2=lut2d(minerr, maxerr),1:alp2=min_err/maxerr,default = 1. unsigned  , default = 1
//Bit  2,            reg_sr7_pk_mimaxerr2_cirbld_on_hp              : enable to use adaptive blender of drtHP vs cirHP alpha2, the larger of cell, the more cirPK results, 0: alp2=lut2d(minerr, maxerr),1:alp2=min_err/maxerr,default = 1. unsigned  , default = 1
//Bit  1,            reg_sr7_pk_mimaxerr2_lpfbld_on_bp              : enable to use adaptive blender of BP result lpf along edge based on the mimaxsad relationship, default = 1. unsigned  , default = 1
//Bit  0,            reg_sr7_pk_mimaxerr2_lpfbld_on_hp              : enable to use adaptive blender of HP result lpf along edge based on the mimaxsad relationship, default = 1. unsigned  , default = 1
#define SR7_TI_CONMAXERR_GAIN                      ((0x5136  << 2) + 0xff000000)
//Bit 31:16,        reserved
//Bit 15:12,        reg_sr7_hti_conmaxerr_gain1                  : con=max(con, maxerr) for the horizontal transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit 11: 8,        reg_sr7_hti_conmaxerr_gain0                  : con=max(con, maxerr) for the horizontal transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit  7: 4,        reg_sr7_vti_conmaxerr_gain1                  : con=max(con, maxerr) for the vertical transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_vti_conmaxerr_gain0                  : con=max(con, maxerr) for the vertical transition calculation, gain=0, same as s6 and prev, [0] for y and [1] for uv. unsigned  , default = 8
#define SR7_CC_PK_ADJ                              ((0x5137  << 2) + 0xff000000)
//Bit 31:25,        reserved
//Bit 24,            reg_sr7_cc_enable                              : color compensation enable, 0: no CC, 1: with CC, default = 1. unsigned  , default = 1
//Bit 23:22,        reserved
//Bit 21:20,        reg_sr7_cc_yinp_sel                            : color compensation input luma selection, 0: org_y; 1: gau_y ; 2:gauadp_y; 3:edgeadp_y (same as dnlp input sel), default= 0. unsigned  , default = 0
//Bit 19:18,        reg_sr7_cc_ydlt_sel                            : color compensation output luma selection, 0: peaking+lti output; 1: dnlp output; 2/3: peaking+lti+dnlp, default = 2. unsigned  , default = 2
//Bit 17:16,        reg_sr7_cc_sat_norm                            : normalization of lut cell to saturation. 0: norm to 8 as 1.0, sat[0:23/8]; 1: norm to 16 as 1.0, sat[1/16:31/16]; 2: norm to 32 as 1.0, sat[17/32:47/32]; 3:norm to 64 as 1.0, sat[49/64:79/64]. unsigned  , default = 1
//Bit 15: 8,        reg_sr7_cc_ydlt_pscl                           : prescale to the y-delta (if >0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_cc_ydlt_nscl                           : prescale to the y-delta (if <0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.. unsigned  , default = 64
#define SR7_CC_LUT0                                ((0x5138  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_cc_lut003                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 27:24,        reg_sr7_cc_lut002                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 23:20,        reg_sr7_cc_lut001                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 19:16,        reg_sr7_cc_lut000                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 15:12,        reg_sr7_cc_lut103                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 8
//Bit 11: 8,        reg_sr7_cc_lut102                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 4
//Bit  7: 4,        reg_sr7_cc_lut101                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 2
//Bit  3: 0,        reg_sr7_cc_lut100                           : valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}. unsigned  , default = 1
#define SR7_CC_LUT1                                ((0x5139  << 2) + 0xff000000)
//Bit 31:28,        reserved
//Bit 27:24,        reg_sr7_cc_lut202                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 12
//Bit 23:20,        reg_sr7_cc_lut201                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 8
//Bit 19:16,        reg_sr7_cc_lut200                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}. unsigned  , default = 4
//Bit 15:12,        reserved
//Bit 11: 8,        reg_sr7_cc_lut302                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 15
//Bit  7: 4,        reg_sr7_cc_lut301                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 10
//Bit  3: 0,        reg_sr7_cc_lut300                           : valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}. unsigned  , default = 5
#define SR7_CC_LUT2                                ((0x513a  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut401                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 15
//Bit 19:16,        reg_sr7_cc_lut400                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 8
//Bit 15:12,        reg_sr7_cc_lut501                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}. unsigned  , default = 13
//Bit 11: 8,        reg_sr7_cc_lut500                           : valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}. unsigned  , default = 6
//Bit  7: 4,        reg_sr7_cc_lut600                           : valid for y-lumadlt=  1/4,              ; of x-lumainput=6/8   dft={5}. unsigned  , default = 5
//Bit  3: 0,        reg_sr7_cc_lut700                           : valid for y-lumadlt=  1/4,              ; of x-lumainput=7/8   dft={4}. unsigned  , default = 4
#define SR7_CC_LUT3                                ((0x513b  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut710                           : valid for y-lumadlt= -1/4,              ; of x-lumainput=1/8   dft={4}. unsigned  , default = 4
//Bit 19:16,        reg_sr7_cc_lut610                           : valid for y-lumadlt= -1/4,              ; of x-lumainput=2/8   dft={5}. unsigned  , default = 5
//Bit 15:12,        reg_sr7_cc_lut511                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}. unsigned  , default = 13
//Bit 11: 8,        reg_sr7_cc_lut510                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}. unsigned  , default = 6
//Bit  7: 4,        reg_sr7_cc_lut411                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_cc_lut410                           : valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}. unsigned  , default = 8
#define SR7_CC_LUT4                                ((0x513c  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:20,        reg_sr7_cc_lut312                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 15
//Bit 19:16,        reg_sr7_cc_lut311                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 10
//Bit 15:12,        reg_sr7_cc_lut310                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}. unsigned  , default = 5
//Bit 11: 8,        reg_sr7_cc_lut212                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 12
//Bit  7: 4,        reg_sr7_cc_lut211                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 8
//Bit  3: 0,        reg_sr7_cc_lut210                           : valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}. unsigned  , default = 4
#define SR7_CC_LUT5                                ((0x513d  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_cc_lut113                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 8
//Bit 27:24,        reg_sr7_cc_lut112                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 4
//Bit 23:20,        reg_sr7_cc_lut111                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 2
//Bit 19:16,        reg_sr7_cc_lut110                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}. unsigned  , default = 1
//Bit 15:12,        reg_sr7_cc_lut013                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_cc_lut012                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_cc_lut011                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_cc_lut010                           : valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}. unsigned  , default = 0
#define SR7_GRAPHIC_CTRL                           ((0x513e  << 2) + 0xff000000)
//Bit 31:11,        reserved
//Bit 10,            reg_sr7_grph_en                                : enable graphic statistic    . unsigned  , default = 1
//Bit  9,            reg_sr7_grph_hflt                              : horizontal filter, 0: [0 1 -1], 1: [-1 2 -1]. unsigned  , default = 1
//Bit  8,            reg_sr7_grph_vflt                              : vertical filter, 0: [0 1 -1], 1: [-1 2 -1]. unsigned  , default = 1
//Bit  7: 0,        reg_sr7_grph_dif_cor                           : coring for dif while count for graphic. unsigned  , default = 0
#define SR7_GRAPHIC_THD_GAIN                       ((0x513f  << 2) + 0xff000000)
//Bit 31:24,        reg_sr7_grph_flt_thd                           : flat threshold for dif while count for graphic. unsigned  , default = 2
//Bit 23:16,        reg_sr7_grph_dtl_thd                           : detail threshold for dif while count for graphic. unsigned  , default = 40
//Bit 15: 8,        reg_sr7_grph_hgain                             : horizontal gain for fast squart of hp. unsigned  , default = 32
//Bit  7: 0,        reg_sr7_grph_vgain                             : vertical gain for fast squart of hp. unsigned  , default = 32
#define SR7_RO_GRAPHIC_FLT_CNT                     ((0x5140  << 2) + 0xff000000)
//Bit 31: 0,        ro_sr7_grph_flt_cnt                            : flat count numbers for graphic. unsigned  , default = 0
#define SR7_RO_GRAPHIC_DTL_CNT                     ((0x5141  << 2) + 0xff000000)
//Bit 31: 0,        ro_sr7_grph_dtl_cnt                            : detail count numbers for graphic. unsigned  , default = 0
#define SR7_CLR_PRT_PARAM                          ((0x5142  << 2) + 0xff000000)
//Bit 31:18,        reserved
//Bit 17:16,        reg_sr7_clr_prct_inpsel                        : input UV selection for color protection, 0: org; 1: NRout; 2: CTIout; 3: (NR+TIout)/2. unsigned  , default = 3
//Bit 15: 8,        reg_sr7_clr_prct_dnlp_gain                     : gain to de-boost of dnlp_dlt base on color region, norm to 64 as 1.0. set to 0 as disable. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_clr_prct_peak_gain                     : gain to de-boost of peak_dlt base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
#define SR7_CLR_PRT_LC_GAIN                        ((0x5143  << 2) + 0xff000000)
//Bit 31:24,        reserved
//Bit 23:16,        reg_sr7_clr_prct_lc_gain2                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
//Bit 15: 8,        reg_sr7_clr_prct_lc_gain1                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
//Bit  7: 0,        reg_sr7_clr_prct_lc_gain0                    : gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable. unsigned  , default = 64
#define SR7_CLR_PRT_LUT0                           ((0x5144  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut7                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut6                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut5                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut4                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut3                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut2                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut1                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut0                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT1                           ((0x5145  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut15                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut14                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut13                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut12                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut11                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut10                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut9                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut8                        : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT2                           ((0x5146  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut23                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut22                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut21                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut20                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut19                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut18                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut17                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut16                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT3                           ((0x5147  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut31                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut30                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut29                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut28                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut27                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut26                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut25                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut24                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT4                           ((0x5148  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut39                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut38                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut37                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut36                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut35                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut34                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut33                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut32                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT5                           ((0x5149  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut47                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut46                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut45                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut44                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut43                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut42                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut41                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut40                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT6                           ((0x514a  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut55                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut54                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut53                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut52                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut51                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut50                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut49                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut48                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT7                           ((0x514b  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut63                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut62                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut61                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut60                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut59                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut58                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut57                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut56                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT8                           ((0x514c  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut71                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut70                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut69                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut68                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut67                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut66                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut65                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut64                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT9                           ((0x514d  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut79                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut78                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut77                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut76                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut75                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut74                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut73                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut72                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT10                          ((0x514e  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut87                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut86                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut85                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut84                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut83                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut82                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut81                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut80                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT11                          ((0x514f  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut95                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut94                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut93                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut92                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut91                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut90                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut89                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut88                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT12                          ((0x5150  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut103                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut102                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut101                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut100                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut99                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut98                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut97                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut96                       : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT13                          ((0x5151  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut111                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut110                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut109                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut108                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut107                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut106                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut105                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut104                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT14                          ((0x5152  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut119                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut118                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut117                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut116                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut115                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut114                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut113                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut112                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT15                          ((0x5153  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut127                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut126                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut125                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut124                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut123                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut122                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut121                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut120                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT16                          ((0x5154  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut135                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut134                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut133                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut132                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut131                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut130                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut129                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut128                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT17                          ((0x5155  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut143                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut142                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut141                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut140                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut139                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut138                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut137                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut136                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT18                          ((0x5156  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut151                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut150                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut149                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut148                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut147                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut146                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut145                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut144                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT19                          ((0x5157  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut159                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut158                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut157                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut156                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut155                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut154                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut153                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut152                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT20                          ((0x5158  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut167                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut166                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut165                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut164                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut163                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut162                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut161                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut160                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT21                          ((0x5159  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut175                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut174                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut173                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut172                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut171                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut170                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut169                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut168                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT22                          ((0x515a  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut183                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut182                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut181                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut180                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut179                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut178                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut177                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut176                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT23                          ((0x515b  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut191                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut190                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut189                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut188                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut187                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut186                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut185                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut184                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT24                          ((0x515c  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut199                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut198                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut197                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut196                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut195                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut194                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut193                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut192                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT25                          ((0x515d  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut207                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut206                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut205                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut204                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut203                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut202                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut201                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut200                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT26                          ((0x515e  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut215                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut214                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut213                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut212                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut211                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut210                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut209                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut208                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT27                          ((0x515f  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut223                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut222                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut221                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut220                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut219                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut218                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut217                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut216                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT28                          ((0x5160  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut231                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 27:24,        reg_sr7_clr_prct_lut230                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 23:20,        reg_sr7_clr_prct_lut229                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit 19:16,        reg_sr7_clr_prct_lut228                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut227                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut226                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut225                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut224                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT29                          ((0x5161  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut239                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut238                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut237                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut236                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut235                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut234                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut233                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
//Bit  3: 0,        reg_sr7_clr_prct_lut232                      : color protection lut, 16 is normalized to 1. unsigned  , default = 15
#define SR7_CLR_PRT_LUT30                          ((0x5162  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut247                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut246                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut245                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut244                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut243                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut242                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut241                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut240                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
#define SR7_CLR_PRT_LUT31                          ((0x5163  << 2) + 0xff000000)
//Bit 31:28,        reg_sr7_clr_prct_lut255                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 27:24,        reg_sr7_clr_prct_lut254                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 23:20,        reg_sr7_clr_prct_lut253                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 19:16,        reg_sr7_clr_prct_lut252                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 15:12,        reg_sr7_clr_prct_lut251                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit 11: 8,        reg_sr7_clr_prct_lut250                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  7: 4,        reg_sr7_clr_prct_lut249                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
//Bit  3: 0,        reg_sr7_clr_prct_lut248                      : color protection lut, 16 is normalized to 1. unsigned  , default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./sharp_regs2.h
//

#define SRSHARP0_SR7_DRTLPF_EN                     (SRSHARP0_OFFSET + SR7_DRTLPF_EN             )//
#define SRSHARP0_SR7_DRTLPF_BETA                   (SRSHARP0_OFFSET + SR7_DRTLPF_BETA           )//
#define SRSHARP0_SR7_PKBLD_BETA                    (SRSHARP0_OFFSET + SR7_PKBLD_BETA            )//
#define SRSHARP0_SR7_XLTIBLD_BETA                  (SRSHARP0_OFFSET + SR7_XLTIBLD_BETA          )//
#define SRSHARP0_SR7_DRTLPF_EDGE0                  (SRSHARP0_OFFSET + SR7_DRTLPF_EDGE0          )//
#define SRSHARP0_SR7_DRTLPF_EDGE1                  (SRSHARP0_OFFSET + SR7_DRTLPF_EDGE1          )//
#define SRSHARP0_SR7_DRTLPF_SDCOR0                 (SRSHARP0_OFFSET + SR7_DRTLPF_SDCOR0         )//
#define SRSHARP0_SR7_DRTLPF_SDCOR1                 (SRSHARP0_OFFSET + SR7_DRTLPF_SDCOR1         )//
#define SRSHARP0_SR7_CTIGAIN_SDCOR0                (SRSHARP0_OFFSET + SR7_CTIGAIN_SDCOR0        )//
#define SRSHARP0_SR7_CTIGAIN_SDCOR1                (SRSHARP0_OFFSET + SR7_CTIGAIN_SDCOR1        )//
#define SRSHARP0_SR7_LTIGAIN_SDCOR0                (SRSHARP0_OFFSET + SR7_LTIGAIN_SDCOR0        )//
#define SRSHARP0_SR7_LTIGAIN_SDCOR1                (SRSHARP0_OFFSET + SR7_LTIGAIN_SDCOR1        )//
#define SRSHARP0_SR7_HLTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_HLTIBPF_TAP0          )//
#define SRSHARP0_SR7_HLTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_HLTIBPF_TAP1          )//
#define SRSHARP0_SR7_HCTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_HCTIBPF_TAP0          )//
#define SRSHARP0_SR7_HCTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_HCTIBPF_TAP1          )//
#define SRSHARP0_SR7_PKLONGBPF_HTAP0               (SRSHARP0_OFFSET + SR7_PKLONGBPF_HTAP0       ) //
#define SRSHARP0_SR7_PKLONGBPF_HTAP1               (SRSHARP0_OFFSET + SR7_PKLONGBPF_HTAP1       ) //
#define SRSHARP0_SR7_PKLONGHPF_HTAP0               (SRSHARP0_OFFSET + SR7_PKLONGHPF_HTAP0       ) //
#define SRSHARP0_SR7_PKLONGHPF_HTAP1               (SRSHARP0_OFFSET + SR7_PKLONGHPF_HTAP1       ) //
#define SRSHARP0_SR7_VLTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_VLTIBPF_TAP0          ) //
#define SRSHARP0_SR7_VLTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_VLTIBPF_TAP1          ) //
#define SRSHARP0_SR7_VCTIBPF_TAP0                  (SRSHARP0_OFFSET + SR7_VCTIBPF_TAP0          ) //
#define SRSHARP0_SR7_VCTIBPF_TAP1                  (SRSHARP0_OFFSET + SR7_VCTIBPF_TAP1          ) //
#define SRSHARP0_SR7_PKLONGBPF_VTAP0               (SRSHARP0_OFFSET + SR7_PKLONGBPF_VTAP0       ) //
#define SRSHARP0_SR7_PKLONGBPF_VTAP1               (SRSHARP0_OFFSET + SR7_PKLONGBPF_VTAP1       ) //
#define SRSHARP0_SR7_PKLONGHPF_VTAP0               (SRSHARP0_OFFSET + SR7_PKLONGHPF_VTAP0       ) //
#define SRSHARP0_SR7_PKLONGHPF_VTAP1               (SRSHARP0_OFFSET + SR7_PKLONGHPF_VTAP1       ) //
#define SRSHARP0_SR7_CIRBPLONG_ALP                 (SRSHARP0_OFFSET + SR7_CIRBPLONG_ALP         ) //
#define SRSHARP0_SR7_CIRHPLONG_ALP                 (SRSHARP0_OFFSET + SR7_CIRHPLONG_ALP         ) //
#define SRSHARP0_SR7_DRTBPLONG_ALP                 (SRSHARP0_OFFSET + SR7_DRTBPLONG_ALP         ) //
#define SRSHARP0_SR7_DRTHPLONG_ALP                 (SRSHARP0_OFFSET + SR7_DRTHPLONG_ALP         ) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D0        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D0) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D1        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D1) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D2        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D2) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D3        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D3) //
#define SRSHARP0_SR7_PKMINMAXCIR_BLD_LUT2D4        (SRSHARP0_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D4) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D0        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D0) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D1        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D1) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D2        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D2) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D3        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D3) //
#define SRSHARP0_SR7_PKMINMAXLPF_BLD_LUT2D4        (SRSHARP0_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D4) //
#define SRSHARP0_SR7_PKDRT_BLD_EN                  (SRSHARP0_OFFSET + SR7_PKDRT_BLD_EN          ) //
#define SRSHARP0_SR7_DRTDIF_TH                     (SRSHARP0_OFFSET + SR7_DRTDIF_TH             ) //
#define SRSHARP0_SR7_TIBLD_PRT                     (SRSHARP0_OFFSET + SR7_TIBLD_PRT             ) //
#define SRSHARP0_SR7_HTI_OPT_FORCE                 (SRSHARP0_OFFSET + SR7_HTI_OPT_FORCE         ) //
#define SRSHARP0_SR7_HVTI_FINALGAIN                (SRSHARP0_OFFSET + SR7_HVTI_FINALGAIN        ) //
#define SRSHARP0_SR7_TIOS_SDRATIO                  (SRSHARP0_OFFSET + SR7_TIOS_SDRATIO          ) //
#define SRSHARP0_SR7_XTI_SDFDEN                    (SRSHARP0_OFFSET + SR7_XTI_SDFDEN            ) //
#define SRSHARP0_SR7_FDSD_PARAM                    (SRSHARP0_OFFSET + SR7_FDSD_PARAM            ) //
#define SRSHARP0_SR7_TI_BPF_EN                     (SRSHARP0_OFFSET + SR7_TI_BPF_EN             ) //
#define SRSHARP0_SR7_PKLONG_PF_EN                  (SRSHARP0_OFFSET + SR7_PKLONG_PF_EN          ) //
#define SRSHARP0_SR7_PKLONG_PF_GAIN                (SRSHARP0_OFFSET + SR7_PKLONG_PF_GAIN        ) //
#define SRSHARP0_SR7_PKMINMAX_BLD                  (SRSHARP0_OFFSET + SR7_PKMINMAX_BLD          ) //
#define SRSHARP0_SR7_TI_CONMAXERR_GAIN             (SRSHARP0_OFFSET + SR7_TI_CONMAXERR_GAIN     ) //
#define SRSHARP0_SR7_CC_PK_ADJ                     (SRSHARP0_OFFSET + SR7_CC_PK_ADJ             ) //
#define SRSHARP0_SR7_CC_LUT0                       (SRSHARP0_OFFSET + SR7_CC_LUT0               ) //
#define SRSHARP0_SR7_CC_LUT1                       (SRSHARP0_OFFSET + SR7_CC_LUT1               ) //
#define SRSHARP0_SR7_CC_LUT2                       (SRSHARP0_OFFSET + SR7_CC_LUT2               ) //
#define SRSHARP0_SR7_CC_LUT3                       (SRSHARP0_OFFSET + SR7_CC_LUT3               ) //
#define SRSHARP0_SR7_CC_LUT4                       (SRSHARP0_OFFSET + SR7_CC_LUT4               ) //
#define SRSHARP0_SR7_CC_LUT5                       (SRSHARP0_OFFSET + SR7_CC_LUT5               ) //
#define SRSHARP0_SR7_GRAPHIC_CTRL                  (SRSHARP0_OFFSET + SR7_GRAPHIC_CTRL          ) //
#define SRSHARP0_SR7_GRAPHIC_THD_GAIN              (SRSHARP0_OFFSET + SR7_GRAPHIC_THD_GAIN      ) //
#define SRSHARP0_SR7_RO_GRAPHIC_FLT_CNT            (SRSHARP0_OFFSET + SR7_RO_GRAPHIC_FLT_CNT    ) //
#define SRSHARP0_SR7_RO_GRAPHIC_DTL_CNT            (SRSHARP0_OFFSET + SR7_RO_GRAPHIC_DTL_CNT    ) //
#define SRSHARP0_SR7_CLR_PRT_PARAM                 (SRSHARP0_OFFSET + SR7_CLR_PRT_PARAM         ) //
#define SRSHARP0_SR7_CLR_PRT_LC_GAIN               (SRSHARP0_OFFSET + SR7_CLR_PRT_LC_GAIN       ) //
#define SRSHARP0_SR7_CLR_PRT_LUT0                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT0          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT1                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT1          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT2                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT2          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT3                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT3          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT4                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT4          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT5                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT5          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT6                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT6          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT7                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT7          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT8                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT8          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT9                  (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT9          ) //
#define SRSHARP0_SR7_CLR_PRT_LUT10                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT10         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT11                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT11         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT12                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT12         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT13                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT13         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT14                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT14         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT15                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT15         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT16                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT16         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT17                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT17         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT18                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT18         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT19                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT19         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT20                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT20         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT21                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT21         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT22                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT22         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT23                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT23         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT24                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT24         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT25                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT25         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT26                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT26         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT27                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT27         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT28                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT28         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT29                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT29         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT30                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT30         ) //
#define SRSHARP0_SR7_CLR_PRT_LUT31                 (SRSHARP0_OFFSET + SR7_CLR_PRT_LUT31         ) //


//// srsharp1 reg define
#define SRSHARP1_SR7_DRTLPF_EN                     (SRSHARP1_OFFSET + SR7_DRTLPF_EN             )//
#define SRSHARP1_SR7_DRTLPF_BETA                   (SRSHARP1_OFFSET + SR7_DRTLPF_BETA           )//
#define SRSHARP1_SR7_PKBLD_BETA                    (SRSHARP1_OFFSET + SR7_PKBLD_BETA            )//
#define SRSHARP1_SR7_XLTIBLD_BETA                  (SRSHARP1_OFFSET + SR7_XLTIBLD_BETA          )//
#define SRSHARP1_SR7_DRTLPF_EDGE0                  (SRSHARP1_OFFSET + SR7_DRTLPF_EDGE0          )//
#define SRSHARP1_SR7_DRTLPF_EDGE1                  (SRSHARP1_OFFSET + SR7_DRTLPF_EDGE1          )//
#define SRSHARP1_SR7_DRTLPF_SDCOR0                 (SRSHARP1_OFFSET + SR7_DRTLPF_SDCOR0         )//
#define SRSHARP1_SR7_DRTLPF_SDCOR1                 (SRSHARP1_OFFSET + SR7_DRTLPF_SDCOR1         )//
#define SRSHARP1_SR7_CTIGAIN_SDCOR0                (SRSHARP1_OFFSET + SR7_CTIGAIN_SDCOR0        )//
#define SRSHARP1_SR7_CTIGAIN_SDCOR1                (SRSHARP1_OFFSET + SR7_CTIGAIN_SDCOR1        )//
#define SRSHARP1_SR7_LTIGAIN_SDCOR0                (SRSHARP1_OFFSET + SR7_LTIGAIN_SDCOR0        )//
#define SRSHARP1_SR7_LTIGAIN_SDCOR1                (SRSHARP1_OFFSET + SR7_LTIGAIN_SDCOR1        )//
#define SRSHARP1_SR7_HLTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_HLTIBPF_TAP0          )//
#define SRSHARP1_SR7_HLTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_HLTIBPF_TAP1          )//
#define SRSHARP1_SR7_HCTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_HCTIBPF_TAP0          )//
#define SRSHARP1_SR7_HCTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_HCTIBPF_TAP1          )//
#define SRSHARP1_SR7_PKLONGBPF_HTAP0               (SRSHARP1_OFFSET + SR7_PKLONGBPF_HTAP0       ) //
#define SRSHARP1_SR7_PKLONGBPF_HTAP1               (SRSHARP1_OFFSET + SR7_PKLONGBPF_HTAP1       ) //
#define SRSHARP1_SR7_PKLONGHPF_HTAP0               (SRSHARP1_OFFSET + SR7_PKLONGHPF_HTAP0       ) //
#define SRSHARP1_SR7_PKLONGHPF_HTAP1               (SRSHARP1_OFFSET + SR7_PKLONGHPF_HTAP1       ) //
#define SRSHARP1_SR7_VLTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_VLTIBPF_TAP0          ) //
#define SRSHARP1_SR7_VLTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_VLTIBPF_TAP1          ) //
#define SRSHARP1_SR7_VCTIBPF_TAP0                  (SRSHARP1_OFFSET + SR7_VCTIBPF_TAP0          ) //
#define SRSHARP1_SR7_VCTIBPF_TAP1                  (SRSHARP1_OFFSET + SR7_VCTIBPF_TAP1          ) //
#define SRSHARP1_SR7_PKLONGBPF_VTAP0               (SRSHARP1_OFFSET + SR7_PKLONGBPF_VTAP0       ) //
#define SRSHARP1_SR7_PKLONGBPF_VTAP1               (SRSHARP1_OFFSET + SR7_PKLONGBPF_VTAP1       ) //
#define SRSHARP1_SR7_PKLONGHPF_VTAP0               (SRSHARP1_OFFSET + SR7_PKLONGHPF_VTAP0       ) //
#define SRSHARP1_SR7_PKLONGHPF_VTAP1               (SRSHARP1_OFFSET + SR7_PKLONGHPF_VTAP1       ) //
#define SRSHARP1_SR7_CIRBPLONG_ALP                 (SRSHARP1_OFFSET + SR7_CIRBPLONG_ALP         ) //
#define SRSHARP1_SR7_CIRHPLONG_ALP                 (SRSHARP1_OFFSET + SR7_CIRHPLONG_ALP         ) //
#define SRSHARP1_SR7_DRTBPLONG_ALP                 (SRSHARP1_OFFSET + SR7_DRTBPLONG_ALP         ) //
#define SRSHARP1_SR7_DRTHPLONG_ALP                 (SRSHARP1_OFFSET + SR7_DRTHPLONG_ALP         ) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D0        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D0) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D1        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D1) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D2        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D2) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D3        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D3) //
#define SRSHARP1_SR7_PKMINMAXCIR_BLD_LUT2D4        (SRSHARP1_OFFSET + SR7_PKMINMAXCIR_BLD_LUT2D4) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D0        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D0) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D1        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D1) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D2        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D2) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D3        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D3) //
#define SRSHARP1_SR7_PKMINMAXLPF_BLD_LUT2D4        (SRSHARP1_OFFSET + SR7_PKMINMAXLPF_BLD_LUT2D4) //
#define SRSHARP1_SR7_PKDRT_BLD_EN                  (SRSHARP1_OFFSET + SR7_PKDRT_BLD_EN          ) //
#define SRSHARP1_SR7_DRTDIF_TH                     (SRSHARP1_OFFSET + SR7_DRTDIF_TH             ) //
#define SRSHARP1_SR7_TIBLD_PRT                     (SRSHARP1_OFFSET + SR7_TIBLD_PRT             ) //
#define SRSHARP1_SR7_HTI_OPT_FORCE                 (SRSHARP1_OFFSET + SR7_HTI_OPT_FORCE         ) //
#define SRSHARP1_SR7_HVTI_FINALGAIN                (SRSHARP1_OFFSET + SR7_HVTI_FINALGAIN        ) //
#define SRSHARP1_SR7_TIOS_SDRATIO                  (SRSHARP1_OFFSET + SR7_TIOS_SDRATIO          ) //
#define SRSHARP1_SR7_XTI_SDFDEN                    (SRSHARP1_OFFSET + SR7_XTI_SDFDEN            ) //
#define SRSHARP1_SR7_FDSD_PARAM                    (SRSHARP1_OFFSET + SR7_FDSD_PARAM            ) //
#define SRSHARP1_SR7_TI_BPF_EN                     (SRSHARP1_OFFSET + SR7_TI_BPF_EN             ) //
#define SRSHARP1_SR7_PKLONG_PF_EN                  (SRSHARP1_OFFSET + SR7_PKLONG_PF_EN          ) //
#define SRSHARP1_SR7_PKLONG_PF_GAIN                (SRSHARP1_OFFSET + SR7_PKLONG_PF_GAIN        ) //
#define SRSHARP1_SR7_PKMINMAX_BLD                  (SRSHARP1_OFFSET + SR7_PKMINMAX_BLD          ) //
#define SRSHARP1_SR7_TI_CONMAXERR_GAIN             (SRSHARP1_OFFSET + SR7_TI_CONMAXERR_GAIN     ) //
#define SRSHARP1_SR7_CC_PK_ADJ                     (SRSHARP1_OFFSET + SR7_CC_PK_ADJ             ) //
#define SRSHARP1_SR7_CC_LUT0                       (SRSHARP1_OFFSET + SR7_CC_LUT0               ) //
#define SRSHARP1_SR7_CC_LUT1                       (SRSHARP1_OFFSET + SR7_CC_LUT1               ) //
#define SRSHARP1_SR7_CC_LUT2                       (SRSHARP1_OFFSET + SR7_CC_LUT2               ) //
#define SRSHARP1_SR7_CC_LUT3                       (SRSHARP1_OFFSET + SR7_CC_LUT3               ) //
#define SRSHARP1_SR7_CC_LUT4                       (SRSHARP1_OFFSET + SR7_CC_LUT4               ) //
#define SRSHARP1_SR7_CC_LUT5                       (SRSHARP1_OFFSET + SR7_CC_LUT5               ) //
#define SRSHARP1_SR7_GRAPHIC_CTRL                  (SRSHARP1_OFFSET + SR7_GRAPHIC_CTRL          ) //
#define SRSHARP1_SR7_GRAPHIC_THD_GAIN              (SRSHARP1_OFFSET + SR7_GRAPHIC_THD_GAIN      ) //
#define SRSHARP1_SR7_RO_GRAPHIC_FLT_CNT            (SRSHARP1_OFFSET + SR7_RO_GRAPHIC_FLT_CNT    ) //
#define SRSHARP1_SR7_RO_GRAPHIC_DTL_CNT            (SRSHARP1_OFFSET + SR7_RO_GRAPHIC_DTL_CNT    ) //
#define SRSHARP1_SR7_CLR_PRT_PARAM                 (SRSHARP1_OFFSET + SR7_CLR_PRT_PARAM         ) //
#define SRSHARP1_SR7_CLR_PRT_LC_GAIN               (SRSHARP1_OFFSET + SR7_CLR_PRT_LC_GAIN       ) //
#define SRSHARP1_SR7_CLR_PRT_LUT0                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT0          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT1                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT1          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT2                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT2          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT3                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT3          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT4                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT4          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT5                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT5          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT6                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT6          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT7                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT7          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT8                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT8          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT9                  (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT9          ) //
#define SRSHARP1_SR7_CLR_PRT_LUT10                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT10         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT11                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT11         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT12                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT12         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT13                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT13         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT14                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT14         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT15                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT15         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT16                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT16         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT17                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT17         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT18                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT18         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT19                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT19         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT20                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT20         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT21                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT21         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT22                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT22         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT23                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT23         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT24                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT24         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT25                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT25         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT26                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT26         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT27                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT27         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT28                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT28         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT29                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT29         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT30                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT30         ) //
#define SRSHARP1_SR7_CLR_PRT_LUT31                 (SRSHARP1_OFFSET + SR7_CLR_PRT_LUT31         ) //

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./srsharp_regs2.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPG_VCBUS_BASE = 0x52
// -----------------------------------------------
//===========================================================================
// 8'h50/51/52/53  have used  for srsharp_regs
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPH_VCBUS_BASE = 0x53
// -----------------------------------------------
//===========================================================================
// 8'h50/51/52/53  have used  for srsharp_regs
//===========================================================================
// -----------------------------------------------
// REG_BASE:  MADE_VCBUS_BASE = 0x54
// -----------------------------------------------
//afbcd_multx6 use 3 reg_pages
//===========================================================================
//
// Reading file:  ./afbcd_mult_regs.h
//
// synopsys translate_off
// synopsys translate_on
////===============================////
//   reg addr map
//   8'h0  - 8'h37 :  rdmif
//   8'h38 - 8'h3f :  vd_top
//   8'h40 - 8'h6f :  afbcd
//   8'h70 - 8'h7f :  fgrain
////===============================////
//==========================================================================
// NOR_RD_MIF
//==========================================================================
#define RDMIFXN_GEN_REG                            ((0x5400  << 2) + 0xff000000)
//Bit 31        cntl_enable_free_clk                //unsigned, RW, default = 0
//Bit 30        reserved                            //unsigned, pulse cntl_sw_reset
//Bit 29        cntl_reset_on_go_field              //unsigned, RW, default = 0
//Bit 28        cntl_urgent_chroma                  //unsigned, RW, default = 0
//Bit 27        cntl_urgent_luma                    //unsigned, RW, default = 0
//Bit 26        cntl_chroma_end_at_last_line        //unsigned, RW, default = 0
//Bit 25        cntl_luma_end_at_last_line          //unsigned, RW, default = 0
//Bit 24:19     cntl_hold_lines[5:0]                //unsigned, RW, default = 0
//Bit 18        cntl_last_line_mode                 //unsigned, RW, default = 1
//Bit 17        ro_busy                             //unsigned, RO, default = 0//used as busy readback, ro ?
//Bit 16        cntl_demux_mode                     //unsigned, RW, default = 0
//Bit 15:14     cntl_bytes_per_pixel                //unsigned, RW, default = 0
//Bit 13:12     cntl_ddr_burst_size_cr              //unsigned, RW, default = 0
//Bit 11:10     cntl_ddr_burst_size_cb              //unsigned, RW, default = 0
//Bit 9:8       cntl_ddr_burst_size_y               //unsigned, RW, default = 0
//Bit 7         reserved                            //unsigned, pulse cntl_start_frame_man
//Bit 6         cntl_chro_rpt_lastl                 //unsigned, RW, default = 0
//Bit 5         reserved                            //unsigned,
//Bit 4         cntl_little_endian                  //unsigned, RW, default = 0
//Bit 3         cntl_chroma_hz_avg                  //unsigned, RW, default = 0
//Bit 2         cntl_luma_hz_avg                    //unsigned, RW, default = 0
//Bit 1         cntl_st_separate_en                 //unsigned, RW, default = 0
//Bit 0         cntl_enable                         //unsigned, RW, default = 0
#define RDMIFXN_CANVAS0                            ((0x5401  << 2) + 0xff000000)
//Bit 31        cntl_canvas0_addr_syncen            //unsigned, RW, default = 0
//Bit 30:24     reserved
//Bit 23:16     cntl_canvas0_addr2                  //unsigned, RW, default = 0
//Bit 15:8      cntl_canvas0_addr1                  //unsigned, RW, default = 0
//Bit 7:0       cntl_canvas0_addr0                  //unsigned, RW, default = 0
#define RDMIFXN_CANVAS1                            ((0x5402  << 2) + 0xff000000)
//Bit 31        cntl_canvas1_addr_syncen            //unsigned, RW, default = 0
//Bit 30:24     reserved
//Bit 23:16     cntl_canvas1_addr2                  //unsigned, RW, default = 0
//Bit 15:8      cntl_canvas1_addr1                  //unsigned, RW, default = 0
//Bit 7:0       cntl_canvas1_addr0                  //unsigned, RW, default = 0
#define RDMIFXN_LUMA_X0                            ((0x5403  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     cntl_luma_x_end0                    //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      cntl_luma_x_start0                  //unsigned, RW, default = 0
#define RDMIFXN_LUMA_Y0                            ((0x5404  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_luma_y_end0                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_luma_y_start0                  //unsigned, RW, default = 0
#define RDMIFXN_CHROMA_X0                          ((0x5405  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     cntl_chroma_x_end0                  //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      cntl_chroma_x_start0                //unsigned, RW, default = 0
#define RDMIFXN_CHROMA_Y0                          ((0x5406  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_chroma_y_end0                  //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_chroma_y_start0                //unsigned, RW, default = 0
#define RDMIFXN_LUMA_X1                            ((0x5407  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     cntl_luma_x_end1                    //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      cntl_luma_x_start1                  //unsigned, RW, default = 0
#define RDMIFXN_LUMA_Y1                            ((0x5408  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_luma_y_end1                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_luma_y_start1                  //unsigned, RW, default = 0
#define RDMIFXN_CHROMA_X1                          ((0x5409  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     cntl_chroma_x_end1                  //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      cntl_chroma_x_start1                //unsigned, RW, default = 0
#define RDMIFXN_CHROMA_Y1                          ((0x540a  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_chroma_y_end1                  //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_chroma_y_start1                //unsigned, RW, default = 0
#define RDMIFXN_RPT_LOOP                           ((0x540b  << 2) + 0xff000000)
//Bit 31:24     cntl_chroma_rpt_loop1               //unsigned, RW, default = 0
//Bit 23:16     cntl_luma_rpt_loop1                 //unsigned, RW, default = 0
//Bit 15:8      cntl_chroma_rpt_loop0               //unsigned, RW, default = 0
//Bit 7:0       cntl_luma_rpt_loop0                 //unsigned, RW, default = 0
#define RDMIFXN_LUMA0_RPT_PAT                      ((0x540c  << 2) + 0xff000000)
//Bit 31:0      cntl_luma_rpt_pat0                  //unsigned, RW, default = 0
#define RDMIFXN_CHROMA0_RPT_PAT                    ((0x540d  << 2) + 0xff000000)
//Bit 31:0      cntl_chroma_rpt_pat0                //unsigned, RW, default = 0
#define RDMIFXN_LUMA1_RPT_PAT                      ((0x540e  << 2) + 0xff000000)
//Bit 31:0      cntl_luma_rpt_pat1                  //unsigned, RW, default = 0
#define RDMIFXN_CHROMA1_RPT_PAT                    ((0x540f  << 2) + 0xff000000)
//Bit 31:0      cntl_chroma_rpt_pat1                //unsigned, RW, default = 0
#define RDMIFXN_LUMA_PSEL                          ((0x5410  << 2) + 0xff000000)
//Bit 31:28     reserved
//Bit 27:26     cntl_luma_psel_mode                 //unsigned, RW, default = 0
//Bit 25:24     cntl_luma_psel_last_line            //unsigned, RW, default = 0
//Bit 23:8      cntl_luma_psel_pat                  //unsigned, RW, default = 0
//Bit 7:0       cntl_luma_psel_loop                 //unsigned, RW, default = 0
#define RDMIFXN_CHROMA_PSEL                        ((0x5411  << 2) + 0xff000000)
//Bit 31:28     reserved
//Bit 27:26     cntl_chroma_psel_mode               //unsigned, RW, default = 0
//Bit 25:24     cntl_chroma_psel_last_line          //unsigned, RW, default = 0
//Bit 23:8      cntl_chroma_psel_pat                //unsigned, RW, default = 0
//Bit 7:0       cntl_chroma_psel_loop               //unsigned, RW, default = 0
#define RDMIFXN_DUMMY_PIXEL                        ((0x5412  << 2) + 0xff000000)
//Bit 31:0      cntl_dummy_pixel_val                //unsigned, RW, default = 32'h00808000
#define RDMIFXN_LUMA_FIFO_SIZE                     ((0x5413  << 2) + 0xff000000)
//Bit 31:13     reserved
//Bit 12:0      cntl_luma_fifo_size                 //unsigned, RW, default = 128
#define RDMIFXN_AXI_CMD_CNT                        ((0x5414  << 2) + 0xff000000)
//Bit 31:0      ro_axi_cmd_cnt_sel                  //unsigned, RO, default = 0
#define RDMIFXN_AXI_RDAT_CNT                       ((0x5415  << 2) + 0xff000000)
//Bit 31:0      ro_axi_rdat_cnt_sel                 //unsigned, RO, default = 0
#define RDMIFXN_RANGE_MAP_Y                        ((0x5416  << 2) + 0xff000000)
//Bit 31:23     cntl_din_offset_y                   //unsigned, RW, default = 0
//Bit 22:15     cntl_range_map_coef_y               //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     cntl_range_map_sr_y                 //unsigned, RW, default = 0
//Bit 9:1       cntl_dout_offset_y                  //unsigned, RW, default = 0
//Bit 0         cntl_range_map_en_y                 //unsigned, RW, default = 0
#define RDMIFXN_RANGE_MAP_CB                       ((0x5417  << 2) + 0xff000000)
//Bit 31:23     cntl_din_offset_cb                  //unsigned, RW, default = 0
//Bit 22:15     cntl_range_map_coef_cb              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     cntl_range_map_sr_cb                //unsigned, RW, default = 0
//Bit 9:1       cntl_dout_offset_cb                 //unsigned, RW, default = 0
//Bit 0         cntl_range_map_en_cb                //unsigned, RW, default = 0
#define RDMIFXN_RANGE_MAP_CR                       ((0x5418  << 2) + 0xff000000)
//Bit 31:23     cntl_din_offset_cr                  //unsigned, RW, default = 0
//Bit 22:15     cntl_range_map_coef_cr              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     cntl_range_map_sr_cr                //unsigned, RW, default = 0
//Bit 9:1       cntl_dout_offset_cr                 //unsigned, RW, default = 0
//Bit 0         cntl_range_map_en_cr                //unsigned, RW, default = 0
#define RDMIFXN_GEN_REG2                           ((0x5419  << 2) + 0xff000000)
//Bit 31:30     reserved
//Bit 29        cntl_chroma_line_read_sel           //unsigned, RW, default = 0
//Bit 28        cntl_luma_line_read_sel             //unsigned, RW, default = 0
//Bit 27:24     cntl_shift_pat_cr                   //unsigned, RW, default = 0
//Bit 23:20     reserved
//Bit 19:16     cntl_shift_pat_cb                   //unsigned, RW, default = 0
//Bit 15:12     reserved
//Bit 11:8      cntl_shift_pat_y                    //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6         cntl_hold_lines[6]                  //unsigned, RW, default = 0
//Bit 5         cntl_y_rev1                         //unsigned, RW, default = 0
//Bit 4         cntl_x_rev1                         //unsigned, RW, default = 0
//Bit 3         cntl_y_rev0                         //unsigned, RW, default = 0
//Bit 2         cntl_x_rev0                         //unsigned, RW, default = 0
//Bit 1:0       cntl_color_map                      //unsigned, RW, default = 0
#define RDMIFXN_PROT                               ((0x541a  << 2) + 0xff000000)
//Bit 31        cntl_prot_en                        //unsigned, RW, default = 0
//Bit 30:29     reserved
//Bit 28:16     cntl_prot_chroma_fifo_size          //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_prot_luma_fifo_size            //unsigned, RW, default = 0
#define RDMIFXN_URGENT_CTRL                        ((0x541b  << 2) + 0xff000000)
//Bit 31:16     cntl_urgent_ctrl_luma               //unsigned, RW, default = 0
//Bit 15:0      cntl_urgent_ctrl_chroma             //unsigned, RW, default = 0
#define RDMIFXN_GEN_REG3                           ((0x541c  << 2) + 0xff000000)
//Bit 31:27     reserved
//Bit 26        cntl_f0_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        cntl_f0_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        cntl_f0_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     cntl_f0_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     cntl_f0_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     cntl_f0_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17:16     cntl_abort_mode                     //unsigned, RW, default = 0
//Bit 15:12     reserved
//Bit 11:10     cntl_dbg_mode                       //unsigned, RW, default = 0
//Bit 9:8       cntl_bits_mode                      //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6:4       cntl_blk_len                        //unsigned, RW, default = 0
//Bit 3         reserved
//Bit 2:1       cntl_burst_len                      //unsigned, RW, default = 0
//Bit 0         cntl_64bit_rev                      //unsigned, RW, default = 0
#define RDMIFXN_CFMT_CTRL                          ((0x541d  << 2) + 0xff000000)
//Bit 31        cntl_cfmt_gclk_bit_dis              //unsigned, RW, default = 0;
//Bit 30        cntl_cfmt_soft_rst_bit              //unsigned, RW, default = 0;
//Bit 29        reserved
//Bit 28        cntl_chfmt_rpt_pix                  //unsigned, RW, default = 0;
//Bit 27:24     cntl_chfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 23        cntl_chfmt_rpt_p0_en                //unsigned, RW, default = 0;
//Bit 22:21     cntl_chfmt_yc_ratio                 //unsigned, RW, default = 0;
//Bit 20        cntl_chfmt_en                       //unsigned, RW, default = 0;
//Bit 19        cntl_cvfmt_phase0_always_en         //unsigned, RW, default = 0;
//Bit 18        cntl_cvfmt_rpt_last_dis             //unsigned, RW, default = 0;
//Bit 17        cntl_cvfmt_phase0_nrpt_en           //unsigned, RW, default = 0;
//Bit 16        cntl_cvfmt_rpt_line0_en             //unsigned, RW, default = 0;
//Bit 15:12     cntl_cvfmt_skip_line_num            //unsigned, RW, default = 0;
//Bit 11:8      cntl_cvfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 7:1       cntl_cvfmt_phase_step               //unsigned, RW, default = 0;
//Bit 0         cntl_cvfmt_en                       //unsigned, RW, default = 0;
#define RDMIFXN_CFMT_W                             ((0x541e  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_chfmt_w                        //unsigned, RW, default = 0;
//Bit 15:13     reserved
//Bit 12:0      cntl_cvfmt_w                        //unsigned, RW, default = 0;
#define RDMIFXN_BADDR_Y                            ((0x5420  << 2) + 0xff000000)
//Bit 31:0      cntl_f0_baddr_y                        //unsigned, RW, default = 0
#define RDMIFXN_BADDR_CB                           ((0x5421  << 2) + 0xff000000)
//Bit 31:0      cntl_f0_baddr_cb                       //unsigned, RW, default = 0
#define RDMIFXN_BADDR_CR                           ((0x5422  << 2) + 0xff000000)
//Bit 31:0      cntl_f0_baddr_cr                       //unsigned, RW, default = 0
#define RDMIFXN_STRIDE_0                           ((0x5423  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_y                       //unsigned, RW, default = 256
#define RDMIFXN_STRIDE_1                           ((0x5424  << 2) + 0xff000000)
//Bit 31:17     reserved
//Bit 16        cntl_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f0_stride_cr                      //unsigned, RW, default = 256
#define RDMIFXN_BADDR_Y_F1                         ((0x5425  << 2) + 0xff000000)
//Bit 31:0      cntl_f1_baddr_y                     //unsigned, RW, default = 0
#define RDMIFXN_BADDR_CB_F1                        ((0x5426  << 2) + 0xff000000)
//Bit 31:0      cntl_f1_baddr_cb                    //unsigned, RW, default = 0
#define RDMIFXN_BADDR_CR_F1                        ((0x5427  << 2) + 0xff000000)
//Bit 31:0      cntl_f1_baddr_cr                    //unsigned, RW, default = 0
#define RDMIFXN_STRIDE_0_F1                        ((0x5428  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     cntl_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_y                    //unsigned, RW, default = 256
#define RDMIFXN_STRIDE_1_F1                        ((0x5429  << 2) + 0xff000000)
//Bit 31:27     reserved
//Bit 26        cntl_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        cntl_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        cntl_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     cntl_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     cntl_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     cntl_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17        reserved
//Bit 16        cntl_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      cntl_f1_stride_cr                   //unsigned, RW, default = 256
//==========================================================================
// VD_TOP
//==========================================================================
#define AFBCDM_VDTOP_CTRL0                         ((0x5438  << 2) + 0xff000000)
//Bit  31:22       reserved              //
//Bit  21:16       reg_afbc_gclk_ctrl    // unsigned, RW, default = 0
//Bit  15          reg_frm_start_sel     // unsigned, RW, default = 0
//Bit  14          reg_use_4kram         // unsigned, RW, default = 0
//Bit  13          reg_afbc_vd_sel       // unsigned, RW, default = 0, 0:nor_rdmif 1:afbc_dec
//Bit  12          reg_rdmif_lbuf_bypas  // unsigned, RW, default = 1, 1:rdmif lbuf bypass
//Bit  11:0        reg_rdmif_lbuf_depth  // unsigned, RW, default = 512
//==========================================================================
// AFBC_DEC
//==========================================================================
#define AFBCDM_ENABLE                              ((0x5440  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:23     reg_gclk_ctrl_core     unsigned, default = 0
//Bit   22        reg_fmt_size_sw_mode   unsigned, default = 0, 0:hw mode 1:sw mode for format size
//Bit   21        reg_addr_link_en  unsigned, default = 1, 1:enable
//Bit   20        reg_fmt444_comb   unsigned, default = 0, 0: 444 8bit uncomb
//Bit   19        reg_dos_uncomp_mode   unsigned  , default = 0
//Bit   18:16     soft_rst          unsigned  , default = 4
//Bit   15:14     reserved
//Bit   13:12     ddr_blk_size      unsigned  , default = 1
//Bit   11:9      cmd_blk_size      unsigned  , default = 3
//Bit   8         dec_enable        unsigned  , default = 0
//Bit   7:2       reserved
//Bit   1         head_len_sel      unsigned  , default = 1
//Bit   0         reserved          unsigned  , pulse dec_frm_start
#define AFBCDM_MODE                                ((0x5441  << 2) + 0xff000000)
//Bit   31:30     reserved
//Bit   29        ddr_sz_mode       unsigned, default = 0 , 0: fixed block ddr size 1 : unfixed block ddr size;
//Bit   28        blk_mem_mode      unsigned, default = 0 , 0: fixed 16x128 size; 1 : fixed 12x128 size
//Bit   27:26     rev_mode          unsigned, default = 0 , reverse mode
//Bit   25:24     mif_urgent        unsigned, default = 3 , info mif and data mif urgent
//Bit   23        reserved
//Bit   22:16     hold_line_num     unsigned, default = 0 ,
//Bit   15:14     burst_len         unsigned, default = 2, 0: burst1 1:burst2 2:burst4
//Bit   13:8      compbits_yuv      unsigned, default = 0 ,
//                                  bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//                                  bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit 11-12bit
//Bit   7:6       vert_skip_y       unsigned, default = 0 , luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   5:4       horz_skip_y       unsigned, default = 0 , luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   3:2       vert_skip_uv      unsigned, default = 0 , chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
//Bit   1:0       horz_skip_uv      unsigned, default = 0 , chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2
#define AFBCDM_SIZE_IN                             ((0x5442  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     hsize_in          unsigned, default = 1920 , pic horz size in  unit: pixel
//Bit   15:13     reserved
//Bit   12:0      vsize_in          unsigned, default = 1080 , pic vert size in  unit: pixel
#define AFBCDM_DEC_DEF_COLOR                       ((0x5443  << 2) + 0xff000000)
//Bit   31:30    reserved
//Bit   29:20    def_color_y        unsigned, default = 255, afbc dec y default setting value
//Bit   19:10    def_color_u        unsigned, default = 128, afbc dec u default setting value
//Bit    9: 0    def_color_v        unsigned, default = 128, afbc dec v default setting value
#define AFBCDM_CONV_CTRL                           ((0x5444  << 2) + 0xff000000)
//Bit   31:14    reserved
//Bit   13:12    fmt_mode            unsigned, default = 2, 0:yuv444 1:yuv422 2:yuv420
//Bit   11: 0    conv_lbuf_len       unsigned, default = 256, unit=16 pixel need to set = 2^n
#define AFBCDM_LBUF_DEPTH                          ((0x5445  << 2) + 0xff000000)
//Bit   31:28    reserved
//Bit   27:16    dec_lbuf_depth      unsigned, default = 128; // unit= 8 pixel
//Bit   15:12    reserved
//Bit   11:0     mif_lbuf_depth      unsigned, default = 128;
#define AFBCDM_HEAD_BADDR                          ((0x5446  << 2) + 0xff000000)
//Bit   31:0    mif_info_baddr      unsigned, default = 32'h0;
#define AFBCDM_BODY_BADDR                          ((0x5447  << 2) + 0xff000000)
//Bit   31:0    mif_data_baddr      unsigned, default = 32'h00010000;
#define AFBCDM_SIZE_OUT                            ((0x5448  << 2) + 0xff000000)
//Bit   31:29    reserved
//Bit   28:16    hsize_out           unsigned, default = 1920 ; // unit: 1 pixel
//Bit   15:13    reserved
//Bit    12:0    vsize_out           unsigned, default = 1080 ; // unit: 1 pixel
#define AFBCDM_OUT_YSCOPE                          ((0x5449  << 2) + 0xff000000)
//Bit   31:29    reserved
//Bit   28:16    out_vert_bgn        unsigned, default = 0 ; // unit: 1 pixel
//Bit   15:13    reserved
//Bit    12:0    out_vert_end        unsigned, default = 1079 ; // unit: 1 pixel
#define AFBCDM_STAT                                ((0x544a  << 2) + 0xff000000)
//Bit   31:18   ro_dbg_axi_cnt_d8    unsigned,RO, default = 0
//Bit   17:16   ro_dbg_axi_idel      unsigned,RO, default = 0
//Bit   15:14   reserved
//Bit   13:8    ro_dbg_frm_cnt       unsigned,RO, default = 0
//Bit   7 :1    ro_dbg_go_line_cnt   unsigned,RO, default = 0
//Bit      0    frm_end_stat         unsigned, default = 0 frame end status
#define AFBCDM_VD_CFMT_CTRL                        ((0x544b  << 2) + 0xff000000)
//Bit 31    cfmt_gclk_bit_dis      unsigned, default = 0 ; //  it true, disable clock, otherwise enable clock
//Bit 30    cfmt_soft_rst_bit      unsigned, default = 0 ; //  soft rst bit
//Bit 29    reserved
//Bit 28    chfmt_rpt_pix          unsigned, default = 0 ; //  if true, horizontal formatter use repeating to generate pixel, otherwise use bilinear interpolation
//Bit 27:24 chfmt_ini_phase        unsigned, default = 0 ; //  horizontal formatter initial phase
//Bit 23    chfmt_rpt_p0_en        unsigned, default = 0 ; //  horizontal formatter repeat pixel 0 enable
//Bit 22:21 chfmt_yc_ratio         unsigned, default = 0 ; //  horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    chfmt_en               unsigned, default = 0 ; //  horizontal formatter enable
//Bit 19    cvfmt_phase0_always_en unsigned, default = 0 ; //if true, always use phase0 while vertical formater, meaning always //repeat data, no interpolation
//Bit 18    cvfmt_rpt_last_dis     unsigned, default = 0 ; //if true, disable vertical formatter chroma repeat last line
//Bit 17    cvfmt_phase0_nrpt_en   unsigned, default = 0 ; //vertical formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    cvfmt_rpt_line0_en     unsigned, default = 0 ; //vertical formatter repeat line 0 enable
//Bit 15:12 cvfmt_skip_line_num    unsigned, default = 0 ; //vertical formatter skip line num at the beginning
//Bit 11:8  cvfmt_ini_phase        unsigned, default = 0 ; //vertical formatter initial phase
//Bit 7:1   cvfmt_phase_step       unsigned, default = 0 ; //vertical formatter phase step (3.4)
//Bit 0     cvfmt_en               unsigned, default = 0 ; //vertical formatter enable
#define AFBCDM_VD_CFMT_W                           ((0x544c  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 chfmt_w                unsigned, default = 0 ;horizontal formatter width
//Bit 15:13 reserved
//Bit 12:0  cvfmt_w                unsigned, default = 0 ;vertical formatter width
#define AFBCDM_MIF_HOR_SCOPE                       ((0x544d  << 2) + 0xff000000)
//Bit   31:26   reserved
//Bit   25:16   mif_blk_bgn_h        unsigned, default = 0  ; // unit: 32 pixel/block hor
//Bit   15:10   reserved
//Bit    9: 0   mif_blk_end_h        unsigned, default = 59 ; // unit: 32 pixel/block hor
#define AFBCDM_MIF_VER_SCOPE                       ((0x544e  << 2) + 0xff000000)
//Bit   31:28   reserved
//Bit   27:16   mif_blk_bgn_v          unsigned, default = 0  ; // unit: 32 pixel/block ver
//Bit   15:12   reserved
//Bit   11: 0   mif_blk_end_v          unsigned, default = 269; // unit: 32 pixel/block ver
#define AFBCDM_PIXEL_HOR_SCOPE                     ((0x544f  << 2) + 0xff000000)
//Bit   31:29   reserved
//Bit   28:16   dec_pixel_bgn_h        unsigned, default = 0  ; // unit: pixel
//Bit   15:13   reserved
//Bit   12: 0   dec_pixel_end_h        unsigned, default = 1919 ; // unit: pixel
#define AFBCDM_PIXEL_VER_SCOPE                     ((0x5450  << 2) + 0xff000000)
//Bit   31:29   reserved
//Bit   28:16   dec_pixel_bgn_v        unsigned, default = 0  ; // unit: pixel
//Bit   15:13   reserved
//Bit   12: 0   dec_pixel_end_v        unsigned, default = 1079 ; // unit: pixel
#define AFBCDM_VD_CFMT_H                           ((0x5451  << 2) + 0xff000000)
//Bit 31:13     reserved
//Bit 12:0      cfmt_h                 unsigned, default = 142  ; //vertical formatter height
#define AFBCDM_IQUANT_ENABLE                       ((0x5452  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit  11          reg_quant_expand_en_1     //unsigned,      RW, default = 0  enable for quantization value expansion
//Bit  10          reg_quant_expand_en_0     //unsigned,      RW, default = 0  enable for quantization value expansion
//Bit  9: 8        reg_bcleav_ofst           //signed ,       RW, default = 0  bcleave ofset to get lower range, especially under lossy, for v1/v2, x=0 is equivalent, default = -1;
//Bit  7: 5        reserved
//Bit  4           reg_quant_enable_1        // unsigned ,    RW, default = 0  enable for quant to get some lossy
//Bit  3: 1        reserved
//Bit  0           reg_quant_enable_0        // unsigned ,    RW, default = 0  enable for quant to get some lossy
#define AFBCDM_IQUANT_LUT_1                        ((0x5453  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_0_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_0_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_0_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_0_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDM_IQUANT_LUT_2                        ((0x5454  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_0_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_0_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_0_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_0_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDM_IQUANT_LUT_3                        ((0x5455  << 2) + 0xff000000)
//Bit 31           reserved
//Bit 30:28        reg_iquant_yclut_1_11     // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 27           reserved
//Bit 26:24        reg_iquant_yclut_1_10     // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 23           reserved
//Bit 22:20        reg_iquant_yclut_1_9      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 19           reserved
//Bit 18:16        reg_iquant_yclut_1_8      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_7      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_6      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_5      // unsigned ,    RW, default = 5  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_4      // unsigned ,    RW, default = 4  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDM_IQUANT_LUT_4                        ((0x5456  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reserved
//Bit 14:12        reg_iquant_yclut_1_3      // unsigned ,    RW, default = 3  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit 11           reserved
//Bit 10: 8        reg_iquant_yclut_1_2      // unsigned ,    RW, default = 2  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  7           reserved
//Bit  6: 4        reg_iquant_yclut_1_1      // unsigned ,    RW, default = 1  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
//Bit  3           reserved
//Bit  2: 0        reg_iquant_yclut_1_0      // unsigned ,    RW, default = 0  quantization lut for mintree leavs, iquant=2^lut(bc_leav_q+1)
#define AFBCDM_ROT_CTRL                            ((0x5460  << 2) + 0xff000000)
//Bit   31:30   reg_rot_ohds2_mode                  //unsigned, RW, default = 0 , rot output format down hor drop mode,0:average 1:use 0 2:use 1
//Bit   29:28   reg_rot_ovds2_mode                  //unsigned, RW, default = 0 , rot output format down ver drop mode,0:average 1:use 0 2:use 1
//Bit   27      reg_pip_mode                        //unsigned, RW, default = 0 , 0:dec_src from vdin/dos  1:dec_src from pip
//Bit   26:24   reg_rot_uv_vshrk_drop_mode          //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   23      reserved
//Bit   22:20   reg_rot_uv_hshrk_drop_mode          //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   19:18   reg_rot_uv_vshrk_ratio              //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   17:16   reg_rot_uv_hshrk_ratio              //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   15      reserved
//Bit   14:12   reg_rot_y_vshrk_drop_mode           //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   11      reserved
//Bit   10:8    reg_rot_y_hshrk_drop_mode           //unsigned, RW, default = 0 , 0:average (1/2: 1:left 2:right) (1/4: 1:[0] 2:[1] 3:[2] 4:[3], 5:left_121 6:right_121)
//Bit   7:6     reg_rot_y_vshrk_ratio               //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   5:4     reg_rot_y_hshrk_ratio               //unsigned, RW, default = 0 , 0:no shrink  1:1/2 shrink  2:1/4 shrink
//Bit   3:2     reg_rot_uv422_drop_mode             //unsigned, RW, default = 0 , 0:average 1:left 2:right
//Bit   1       reg_rot_uv422_omode                 //unsigned, RW, default = 0 , when rot input fmt422, 0:output_uv422  1:output_uv420
//Bit   0       reg_rot_enable                      //unsigned, RW, default = 0 , rotation enable
#define AFBCDM_ROT_SCOPE                           ((0x5461  << 2) + 0xff000000)
//Bit   31:26   reserved
//Bit   25:20   reg_rot_debug_probe      //unsigned, RW , default = 0, y:[2:0] uv:[5:3]; 0:iblk_size 1:oblk_size 2:iblk_cnt 3:oblk_cnt 4:hsize_in 5:vsize_in 6:vstep
//Bit   19      reg_rot_dout_ds_mode_sw  //unsigned, RW , default = 0, 0:use hardware mode 1:use software mode
//Bit   18:17   reg_rot_dout_ds_mode     //unsigned, RW , default = 0, rot output fmt_down mode: [0]:h_downscale [1]:v_downscale
//Bit   16      reg_rot_ifmt_force444    //unsigned, RW , default = 1, 1: rot input fmt force as 444
//Bit   15:14   reg_rot_ofmt_mode        //unsigned, RW , default = 0, rot output fmt mode
//Bit   13:12   reg_rot_compbits_out_y   //unsigned, RW , default = 0, rot output compbit y
//Bit   11:10   reg_rot_compbits_out_uv  //unsigned, RW , default = 0, rot output compbit uv
//Bit   9:8     reg_rot_wrbgn_v          //unsigned, RW , default = 0, rot pic vert size window begin pixel
//Bit   7:5     reserved
//Bit   4:0     reg_rot_wrbgn_h          //unsigned, RW , default = 0, rot pic hori size window begin pixel
#define AFBCDM_RPLC_CTRL                           ((0x5462  << 2) + 0xff000000)
//Bit   31        reg_rplc_inter_corr_en //unsigned, RW , default = 0   , //pip replace inte-frame edge correct enable
//Bit   30        reg_rplc_dummy_corr_en //unsigned, RW , default = 0   , //pip replace outsize of real-pipframe edge correct enable
//Bit   29        reg_rplc_byps          //unsigned, RW , default = 1   , //pip replace module bypass
//Bit   28:16     reg_rplc_vsize_in      //unsigned, RW , default = 1080, //
//Bit   15:13     reserved
//Bit   12:0      reg_rplc_hsize_in      //unsigned, RW , default = 1920,
#define AFBCDM_RPLC_PICEN                          ((0x5463  << 2) + 0xff000000)
//Bit  31:28      reserved
//Bit  27:16      reg_rplc_def_color_y    //unsigned, RW , default =0        , //pip replace def_color_y
//Bit  15:0       reg_rplc_pic_enable     //unsigned, RW , default =16'hffff , //pip replace pip_picure enbale
#define AFBCDM_RPLC_DEFCOL                         ((0x5464  << 2) + 0xff000000)
//Bit  31:24     reserved
//Bit  23:12     reg_rplc_def_color_v    //unsigned, RW , default =0        , //pip replace def_color_v
//Bit  11:0      reg_rplc_def_color_u    //unsigned, RW , default =0        , //pip replace def_color_u
#define AFBCDM_RPLC_SCPXN_ADDR                     ((0x5465  << 2) + 0xff000000)
//Bit  31:5      reserved
//Bit  4:0       reg_rplc_scpxn_addr     //unsigned, RW , default =0        , //pip replace scopex16 addr
#define AFBCDM_RPLC_SCPXN_DATA                     ((0x5466  << 2) + 0xff000000)
//Bit  31:26     reserved
//Bit  25:0      reg_rplc_scpxn_data     //unsigned, RW , default =0        , //pip replace scopex16 data
#define AFBCDM_ROT_RO_STAT                         ((0x5467  << 2) + 0xff000000)
//Bit   31:0     ro_rot_debug           //unsigned, RO , default = 0, rot some status
//==========================================================================
// FGRAIN
//==========================================================================
#define AFBCDM_FGRAIN_CTRL                         ((0x5470  << 2) + 0xff000000)
//Bit 31:26     reserved
//Bit 25:24     reg_sync_ctrl              // unsigned , RW, default = 0
//Bit 23        reserved
//Bit 22        reg_dma_st_clr             // unsigned , RW, default = 0 clear DMA error status
//Bit 21        reg_hold4dma_scale         // unsigned , RW, default = 0 1 to wait DMA scale data ready before accept input data        default = 0
//Bit 20        reg_hold4dma_tbl           // unsigned , RW, default = 0 1 to wait DMA grain table data ready before accept input data  default = 0
//Bit 19        reg_cin_uv_swap            // unsigned , RW, default = 0 1 to swap U/V input
//Bit 18        reg_cin_rev                // unsigned , RW, default = 0 1 to reverse the U/V input order
//Bit 17        reg_yin_rev                // unsigned , RW, default = 0 1 to reverse the Y input order
//Bit 16        reg_fgrain_ext_imode       // unsigned , RW, default = 1 0 to indicate the input data is *4 in 8bit mode
//Bit 15        reg_use_par_apply_fgrain   // unsigned , RW, default = 0 1 to use apply_fgrain from DMA table
//Bit 14        reg_fgrain_last_ln_mode    // unsigned , RW, default = 0 1 to keep fgrain noise generator though the input is finished for rdmif.
//Bit 13        reg_fgrain_use_sat4bp      // unsigned , RW, default = 0 1 to use fgain_max/min for sat not {DW{1'b1}}/0
//Bit 12        reg_apply_c_mode           // unsigned , RW, default = 1 0 to following C
//Bit 11        reg_fgrain_tbl_sign_mode   // unsigned , RW, default = 1 0 to indicate signed bit is not extended in 8bit mode
//Bit 10        reg_fgrain_tbl_ext_mode    // unsigned , RW, default = 1 0 to indicate the grain table is *4 in 8bit mode
//Bit  9: 8     reg_fmt_mode               // unsigned , RW, default = 2 0:444; 1:422; 2:420; 3:reserved
//Bit  7: 6     reg_comp_bits              // unsigned , RW, default = 1 0:8bits; 1:10bits, else 12 bits
//Bit  5: 4     reg_rev_mode               // unsigned . RW, default = 0 0:h_rev; 1:v_rev;
//Bit  3        reserved
//Bit  2        reg_block_mode             // unsigned , RW, default = 1
//Bit  1        reg_fgrain_loc_en          // unsigned , RW, default = 0 frame-based  fgrain enable
//Bit  0        reg_fgrain_glb_en          // unsigned , RW, default = 0 global-based fgrain enable
#define AFBCDM_FGRAIN_WIN_H                        ((0x5471  << 2) + 0xff000000)
//Bit  31:16     reg_win_end_h      .unsigned , default = 3812
//Bit  15: 0     reg_win_bgn_h      .unsigned , default = 0
#define AFBCDM_FGRAIN_WIN_V                        ((0x5472  << 2) + 0xff000000)
//Bit  31:16     reg_win_end_v      .unsigned , default = 2156
//Bit  15: 0     reg_win_bgn_v      .unsigned , default = 0
#define AFBCDM_FGRAIN_SW_Y_RANGE                  ((0x5473  << 2) + 0xff000000)
//Bit 31        reg_fgrain_sw_yrange   .unsigned , default = 0
//Bit 30:26     reserved
//Bit 25:16     reg_fgrain_ymax        .unsigned , default = 1023
//Bit 15:10     reserved
//Bit  9: 0     reg_fgrain_ymin        .unsigned , default = 0
#define AFBCDM_FGRAIN_SW_C_RANGE                  ((0x5474  << 2) + 0xff000000)
//Bit 31        reg_fgrain_sw_crange   .unsigned , default = 0
//Bit 30:26     reserved
//Bit 25:16     reg_fgrain_cmax        .unsigned , default = 1023
//Bit 15:10     reserved
//Bit  9: 0     reg_fgrain_cmin        .unsigned , default = 0
#define AFBCDM_FGRAIN_GCLK_CTRL_0                  ((0x5475  << 2) + 0xff000000)
//Bit 31:0      reg_fgrain_gclk_ctrl0  .unsigned , default = 0
#define AFBCDM_FGRAIN_GCLK_CTRL_1                  ((0x5476  << 2) + 0xff000000)
//Bit 31:0      reg_fgrain_gclk_ctrl1  .unsigned , default = 0
#define AFBCDM_FGRAIN_GCLK_CTRL_2                  ((0x5477  << 2) + 0xff000000)
//Bit 31:0      reg_fgrain_gclk_ctrl2  .unsigned , default = 0
#define AFBCDM_FGRAIN_PARAM_ADDR                   ((0x5478  << 2) + 0xff000000)
#define AFBCDM_FGRAIN_PARAM_DATA                   ((0x5479  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./afbcd_mult_regs.h
//
//afbcd_multx6 use 3 reg_pages
// -----------------------------------------------
// REG_BASE:  MADF_VCBUS_BASE = 0x55
// -----------------------------------------------
//`include "afbcd_mult_regs.h"
//afbcd_multx6 use 3 reg_pages
// -----------------------------------------------
// REG_BASE:  MADG_VCBUS_BASE = 0x56
// -----------------------------------------------
//`include "afbcd_mult_regs.h"
//===========================================================================
// -----------------------------------------------
// REG_BASE:  MADH_VCBUS_BASE = 0x57
// -----------------------------------------------
//===========================================================================
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPI_VCBUS_BASE = 0x58
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./pip_alph_gen_regs.h
//
//
// Reading file:  ./vd3_pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
////===================================////
////reg
////===================================////
#define VD3_PIP_ALPH_CTRL                          ((0x5850  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28        reg_alph_gen_dbg     unsigned,default = 0     1 bit  dbg_mode: output pic with alph_256 to check function
//Bit   27:12     reg_pic_en           unsigned,default = 16'h0 16bits decide which pics are enable
//Bit   11:3      reg_alph0            unsigned,default = 0     9 bits alph0: alph value of those points which are out of the windows range
//Bit   2:1       reg_alph_gen_mode    unsigned, default = 0    2 bits out of window/border/inside of window: 0:original, 1:  0/0.5/1 alpha 2: 0/0.25/0.5/0.75/1 alph
//Bit   0         reg_alph_gen_byps    unsigned, default = 1    1 bit  bypass mode
#define VD3_PIP_ALPH_SCP_H_0                       ((0x5851  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h0     unsigned,default = 0     13bits pic_0 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h0     unsigned,default = 0     13bits pic_0 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_1                       ((0x5852  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h1     unsigned,default = 0     13bits pic_1 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h1     unsigned,default = 0     13bits pic_1 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_2                       ((0x5853  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h2     unsigned,default = 0     13bits pic_2 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h2     unsigned,default = 0     13bits pic_2 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_3                       ((0x5854  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h3     unsigned,default = 0     13bits pic_3 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h3     unsigned,default = 0     13bits pic_3 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_4                       ((0x5855  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h4     unsigned,default = 0     13bits pic_4 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h4     unsigned,default = 0     13bits pic_4 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_5                       ((0x5856  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h5     unsigned,default = 0     13bits pic_5 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h5     unsigned,default = 0     13bits pic_5 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_6                       ((0x5857  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h6     unsigned,default = 0     13bits pic_6 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h6     unsigned,default = 0     13bits pic_6 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_7                       ((0x5858  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h7     unsigned,default = 0     13bits pic_7 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h7     unsigned,default = 0     13bits pic_7 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_8                       ((0x5859  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h8     unsigned,default = 0     13bits pic_8 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h8     unsigned,default = 0     13bits pic_8 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_9                       ((0x585a  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h9     unsigned,default = 0     13bits pic_9 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h9     unsigned,default = 0     13bits pic_9 window horizontal begin
#define VD3_PIP_ALPH_SCP_H_10                      ((0x585b  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h10     unsigned,default = 0    13bits pic_10 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h10     unsigned,default = 0    13bits pic_10 window horizontal begi
#define VD3_PIP_ALPH_SCP_H_11                      ((0x585c  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h11     unsigned,default = 0    13bits pic_11 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h11     unsigned,default = 0    13bits pic_11 window horizontal begi
#define VD3_PIP_ALPH_SCP_H_12                      ((0x585d  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h12     unsigned,default = 0    13bits pic_12 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h12     unsigned,default = 0    13bits pic_12 window horizontal begi
#define VD3_PIP_ALPH_SCP_H_13                      ((0x585e  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h13     unsigned,default = 0    13bits pic_13 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h13     unsigned,default = 0    13bits pic_13 window horizontal begi
#define VD3_PIP_ALPH_SCP_H_14                      ((0x585f  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h14     unsigned,default = 0    13bits pic_14 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h14     unsigned,default = 0    13bits pic_14 window horizontal begi
#define VD3_PIP_ALPH_SCP_H_15                      ((0x5860  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h15     unsigned,default = 0    13bits pic_15 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h15     unsigned,default = 0    13bits pic_15 window horizontal begi
#define VD3_PIP_ALPH_SCP_V_0                       ((0x5861  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v0     unsigned,default = 0     13bits pic_0 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v0     unsigned,default = 0     13bits pic_0 window vertical begin
#define VD3_PIP_ALPH_SCP_V_1                       ((0x5862  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v1     unsigned,default = 0     13bits pic_1 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v1     unsigned,default = 0     13bits pic_1 window vertical begin
#define VD3_PIP_ALPH_SCP_V_2                       ((0x5863  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v2     unsigned,default = 0     13bits pic_2 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v2     unsigned,default = 0     13bits pic_2 window vertical begin
#define VD3_PIP_ALPH_SCP_V_3                       ((0x5864  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v3     unsigned,default = 0     13bits pic_3 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v3     unsigned,default = 0     13bits pic_3 window vertical begin
#define VD3_PIP_ALPH_SCP_V_4                       ((0x5865  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v4     unsigned,default = 0     13bits pic_4 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v4     unsigned,default = 0     13bits pic_4 window vertical begin
#define VD3_PIP_ALPH_SCP_V_5                       ((0x5866  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v5     unsigned,default = 0     13bits pic_5 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v5     unsigned,default = 0     13bits pic_5 window vertical begin
#define VD3_PIP_ALPH_SCP_V_6                       ((0x5867  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v6     unsigned,default = 0     13bits pic_6 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v6     unsigned,default = 0     13bits pic_6 window vertical begin
#define VD3_PIP_ALPH_SCP_V_7                       ((0x5868  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v7     unsigned,default = 0     13bits pic_7 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v7     unsigned,default = 0     13bits pic_7 window vertical begin
#define VD3_PIP_ALPH_SCP_V_8                       ((0x5869  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v8     unsigned,default = 0     13bits pic_8 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v8     unsigned,default = 0     13bits pic_8 window vertical begin
#define VD3_PIP_ALPH_SCP_V_9                       ((0x586a  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v9     unsigned,default = 0     13bits pic_9 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v9     unsigned,default = 0     13bits pic_9 window vertical begin
#define VD3_PIP_ALPH_SCP_V_10                      ((0x586b  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v10     unsigned,default = 0    13bits pic_10 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v10     unsigned,default = 0    13bits pic_10 window vertical begin
#define VD3_PIP_ALPH_SCP_V_11                      ((0x586c  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v11     unsigned,default = 0    13bits pic_11 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v11     unsigned,default = 0    13bits pic_11 window vertical begin
#define VD3_PIP_ALPH_SCP_V_12                      ((0x586d  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v12     unsigned,default = 0    13bits pic_12 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v12     unsigned,default = 0    13bits pic_12 window vertical begin
#define VD3_PIP_ALPH_SCP_V_13                      ((0x586e  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v13     unsigned,default = 0    13bits pic_13 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v13     unsigned,default = 0    13bits pic_13 window vertical begin
#define VD3_PIP_ALPH_SCP_V_14                      ((0x586f  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v14     unsigned,default = 0    13bits pic_14 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v14     unsigned,default = 0    13bits pic_14 window vertical begin
#define VD3_PIP_ALPH_SCP_V_15                      ((0x5870  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v15     unsigned,default = 0    13bits pic_15 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v15     unsigned,default = 0    13bits pic_15 window vertical begin
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vd3_pip_alph_gen_regs.h
//
//
// Reading file:  ./vd1_pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
////===================================////
////reg
////===================================////
#define VD1_PIP_ALPH_CTRL                          ((0x5880  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28        reg_alph_gen_dbg     unsigned,default = 0     1 bit  dbg_mode: output pic with alph_256 to check function
//Bit   27:12     reg_pic_en           unsigned,default = 16'h0 16bits decide which pics are enable
//Bit   11:3      reg_alph0            unsigned,default = 0     9 bits alph0: alph value of those points which are out of the windows range
//Bit   2:1       reg_alph_gen_mode    unsigned, default = 0    2 bits out of window/border/inside of window: 0:original, 1:  0/0.5/1 alpha 2: 0/0.25/0.5/0.75/1 alph
//Bit   0         reg_alph_gen_byps    unsigned, default = 1    1 bit  bypass mode
#define VD1_PIP_ALPH_SCP_H_0                       ((0x5881  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h0     unsigned,default = 0     13bits pic_0 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h0     unsigned,default = 0     13bits pic_0 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_1                       ((0x5882  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h1     unsigned,default = 0     13bits pic_1 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h1     unsigned,default = 0     13bits pic_1 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_2                       ((0x5883  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h2     unsigned,default = 0     13bits pic_2 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h2     unsigned,default = 0     13bits pic_2 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_3                       ((0x5884  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h3     unsigned,default = 0     13bits pic_3 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h3     unsigned,default = 0     13bits pic_3 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_4                       ((0x5885  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h4     unsigned,default = 0     13bits pic_4 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h4     unsigned,default = 0     13bits pic_4 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_5                       ((0x5886  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h5     unsigned,default = 0     13bits pic_5 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h5     unsigned,default = 0     13bits pic_5 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_6                       ((0x5887  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h6     unsigned,default = 0     13bits pic_6 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h6     unsigned,default = 0     13bits pic_6 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_7                       ((0x5888  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h7     unsigned,default = 0     13bits pic_7 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h7     unsigned,default = 0     13bits pic_7 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_8                       ((0x5889  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h8     unsigned,default = 0     13bits pic_8 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h8     unsigned,default = 0     13bits pic_8 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_9                       ((0x588a  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h9     unsigned,default = 0     13bits pic_9 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h9     unsigned,default = 0     13bits pic_9 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_10                      ((0x588b  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h10     unsigned,default = 0    13bits pic_10 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h10     unsigned,default = 0    13bits pic_10 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_11                      ((0x588c  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h11     unsigned,default = 0    13bits pic_11 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h11     unsigned,default = 0    13bits pic_11 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_12                      ((0x588d  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h12     unsigned,default = 0    13bits pic_12 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h12     unsigned,default = 0    13bits pic_12 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_13                      ((0x588e  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h13     unsigned,default = 0    13bits pic_13 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h13     unsigned,default = 0    13bits pic_13 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_14                      ((0x588f  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h14     unsigned,default = 0    13bits pic_14 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h14     unsigned,default = 0    13bits pic_14 window horizontal begin
#define VD1_PIP_ALPH_SCP_H_15                      ((0x5890  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h15     unsigned,default = 0    13bits pic_15 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h15     unsigned,default = 0    13bits pic_15 window horizontal begin
#define VD1_PIP_ALPH_SCP_V_0                       ((0x5891  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v0     unsigned,default = 0     13bits pic_0 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v0     unsigned,default = 0     13bits pic_0 window vertical begin
#define VD1_PIP_ALPH_SCP_V_1                       ((0x5892  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v1     unsigned,default = 0     13bits pic_1 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v1     unsigned,default = 0     13bits pic_1 window vertical begin
#define VD1_PIP_ALPH_SCP_V_2                       ((0x5893  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v2     unsigned,default = 0     13bits pic_2 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v2     unsigned,default = 0     13bits pic_2 window vertical begin
#define VD1_PIP_ALPH_SCP_V_3                       ((0x5894  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v3     unsigned,default = 0     13bits pic_3 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v3     unsigned,default = 0     13bits pic_3 window vertical begin
#define VD1_PIP_ALPH_SCP_V_4                       ((0x5895  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v4     unsigned,default = 0     13bits pic_4 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v4     unsigned,default = 0     13bits pic_4 window vertical begin
#define VD1_PIP_ALPH_SCP_V_5                       ((0x5896  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v5     unsigned,default = 0     13bits pic_5 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v5     unsigned,default = 0     13bits pic_5 window vertical begin
#define VD1_PIP_ALPH_SCP_V_6                       ((0x5897  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v6     unsigned,default = 0     13bits pic_6 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v6     unsigned,default = 0     13bits pic_6 window vertical begin
#define VD1_PIP_ALPH_SCP_V_7                       ((0x5898  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v7     unsigned,default = 0     13bits pic_7 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v7     unsigned,default = 0     13bits pic_7 window vertical begin
#define VD1_PIP_ALPH_SCP_V_8                       ((0x5899  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v8     unsigned,default = 0     13bits pic_8 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v8     unsigned,default = 0     13bits pic_8 window vertical begin
#define VD1_PIP_ALPH_SCP_V_9                       ((0x589a  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v9     unsigned,default = 0     13bits pic_9 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v9     unsigned,default = 0     13bits pic_9 window vertical begin
#define VD1_PIP_ALPH_SCP_V_10                      ((0x589b  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v10     unsigned,default = 0    13bits pic_10 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v10     unsigned,default = 0    13bits pic_10 window vertical begin
#define VD1_PIP_ALPH_SCP_V_11                      ((0x589c  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v11     unsigned,default = 0    13bits pic_11 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v11     unsigned,default = 0    13bits pic_11 window vertical begin
#define VD1_PIP_ALPH_SCP_V_12                      ((0x589d  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v12     unsigned,default = 0    13bits pic_12 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v12     unsigned,default = 0    13bits pic_12 window vertical begin
#define VD1_PIP_ALPH_SCP_V_13                      ((0x589e  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v13     unsigned,default = 0    13bits pic_13 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v13     unsigned,default = 0    13bits pic_13 window vertical begin
#define VD1_PIP_ALPH_SCP_V_14                      ((0x589f  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v14     unsigned,default = 0    13bits pic_14 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v14     unsigned,default = 0    13bits pic_14 window vertical begin
#define VD1_PIP_ALPH_SCP_V_15                      ((0x58a0  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v15     unsigned,default = 0    13bits pic_15 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v15     unsigned,default = 0    13bits pic_15 window vertical begin
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vd1_pip_alph_gen_regs.h
//
//
// Reading file:  ./vd2_pip_alph_gen_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
////===================================////
////reg
////===================================////
#define VD2_PIP_ALPH_CTRL                          ((0x58b0  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28        reg_alph_gen_dbg     unsigned,default = 0     1 bit  dbg_mode: output pic with alph_256 to check function
//Bit   27:12     reg_pic_en           unsigned,default = 16'h0 16bits decide which pics are enable
//Bit   11:3      reg_alph0            unsigned,default = 0     9 bits alph0: alph value of those points which are out of the windows range
//Bit   2:1       reg_alph_gen_mode    unsigned, default = 0    2 bits out of window/border/inside of window: 0:original, 1:  0/0.5/1 alpha 2: 0/0.25/0.5/0.75/1 alph
//Bit   0         reg_alph_gen_byps    unsigned, default = 1    1 bit  bypass mode
#define VD2_PIP_ALPH_SCP_H_0                       ((0x58b1  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h0     unsigned,default = 0     13bits pic_0 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h0     unsigned,default = 0     13bits pic_0 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_1                       ((0x58b2  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h1     unsigned,default = 0     13bits pic_1 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h1     unsigned,default = 0     13bits pic_1 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_2                       ((0x58b3  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h2     unsigned,default = 0     13bits pic_2 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h2     unsigned,default = 0     13bits pic_2 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_3                       ((0x58b4  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h3     unsigned,default = 0     13bits pic_3 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h3     unsigned,default = 0     13bits pic_3 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_4                       ((0x58b5  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h4     unsigned,default = 0     13bits pic_4 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h4     unsigned,default = 0     13bits pic_4 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_5                       ((0x58b6  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h5     unsigned,default = 0     13bits pic_5 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h5     unsigned,default = 0     13bits pic_5 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_6                       ((0x58b7  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h6     unsigned,default = 0     13bits pic_6 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h6     unsigned,default = 0     13bits pic_6 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_7                       ((0x58b8  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h7     unsigned,default = 0     13bits pic_7 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h7     unsigned,default = 0     13bits pic_7 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_8                       ((0x58b9  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h8     unsigned,default = 0     13bits pic_8 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h8     unsigned,default = 0     13bits pic_8 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_9                       ((0x58ba  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h9     unsigned,default = 0     13bits pic_9 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h9     unsigned,default = 0     13bits pic_9 window horizontal begin
#define VD2_PIP_ALPH_SCP_H_10                      ((0x58bb  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h10     unsigned,default = 0    13bits pic_10 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h10     unsigned,default = 0    13bits pic_10 window horizontal begi
#define VD2_PIP_ALPH_SCP_H_11                      ((0x58bc  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h11     unsigned,default = 0    13bits pic_11 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h11     unsigned,default = 0    13bits pic_11 window horizontal begi
#define VD2_PIP_ALPH_SCP_H_12                      ((0x58bd  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h12     unsigned,default = 0    13bits pic_12 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h12     unsigned,default = 0    13bits pic_12 window horizontal begi
#define VD2_PIP_ALPH_SCP_H_13                      ((0x58be  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h13     unsigned,default = 0    13bits pic_13 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h13     unsigned,default = 0    13bits pic_13 window horizontal begi
#define VD2_PIP_ALPH_SCP_H_14                      ((0x58bf  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h14     unsigned,default = 0    13bits pic_14 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h14     unsigned,default = 0    13bits pic_14 window horizontal begi
#define VD2_PIP_ALPH_SCP_H_15                      ((0x58c0  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_h15     unsigned,default = 0    13bits pic_15 window horizontal end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_h15     unsigned,default = 0    13bits pic_15 window horizontal begi
#define VD2_PIP_ALPH_SCP_V_0                       ((0x58c1  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v0     unsigned,default = 0     13bits pic_0 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v0     unsigned,default = 0     13bits pic_0 window vertical begin
#define VD2_PIP_ALPH_SCP_V_1                       ((0x58c2  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v1     unsigned,default = 0     13bits pic_1 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v1     unsigned,default = 0     13bits pic_1 window vertical begin
#define VD2_PIP_ALPH_SCP_V_2                       ((0x58c3  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v2     unsigned,default = 0     13bits pic_2 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v2     unsigned,default = 0     13bits pic_2 window vertical begin
#define VD2_PIP_ALPH_SCP_V_3                       ((0x58c4  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v3     unsigned,default = 0     13bits pic_3 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v3     unsigned,default = 0     13bits pic_3 window vertical begin
#define VD2_PIP_ALPH_SCP_V_4                       ((0x58c5  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v4     unsigned,default = 0     13bits pic_4 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v4     unsigned,default = 0     13bits pic_4 window vertical begin
#define VD2_PIP_ALPH_SCP_V_5                       ((0x58c6  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v5     unsigned,default = 0     13bits pic_5 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v5     unsigned,default = 0     13bits pic_5 window vertical begin
#define VD2_PIP_ALPH_SCP_V_6                       ((0x58c7  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v6     unsigned,default = 0     13bits pic_6 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v6     unsigned,default = 0     13bits pic_6 window vertical begin
#define VD2_PIP_ALPH_SCP_V_7                       ((0x58c8  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v7     unsigned,default = 0     13bits pic_7 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v7     unsigned,default = 0     13bits pic_7 window vertical begin
#define VD2_PIP_ALPH_SCP_V_8                       ((0x58c9  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v8     unsigned,default = 0     13bits pic_8 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v8     unsigned,default = 0     13bits pic_8 window vertical begin
#define VD2_PIP_ALPH_SCP_V_9                       ((0x58ca  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v9     unsigned,default = 0     13bits pic_9 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v9     unsigned,default = 0     13bits pic_9 window vertical begin
#define VD2_PIP_ALPH_SCP_V_10                      ((0x58cb  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v10     unsigned,default = 0    13bits pic_10 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v10     unsigned,default = 0    13bits pic_10 window vertical begin
#define VD2_PIP_ALPH_SCP_V_11                      ((0x58cc  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v11     unsigned,default = 0    13bits pic_11 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v11     unsigned,default = 0    13bits pic_11 window vertical begin
#define VD2_PIP_ALPH_SCP_V_12                      ((0x58cd  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v12     unsigned,default = 0    13bits pic_12 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v12     unsigned,default = 0    13bits pic_12 window vertical begin
#define VD2_PIP_ALPH_SCP_V_13                      ((0x58ce  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v13     unsigned,default = 0    13bits pic_13 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v13     unsigned,default = 0    13bits pic_13 window vertical begin
#define VD2_PIP_ALPH_SCP_V_14                      ((0x58cf  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v14     unsigned,default = 0    13bits pic_14 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v14     unsigned,default = 0    13bits pic_14 window vertical begin
#define VD2_PIP_ALPH_SCP_V_15                      ((0x58d0  << 2) + 0xff000000)
//Bit   31:29     reserved
//Bit   28:16     reg_scpxn_end_v15     unsigned,default = 0    13bits pic_15 window vertical end
//Bit   15:13     reserved
//Bit   12:0      reg_scpxn_bgn_v15     unsigned,default = 0    13bits pic_15 window vertical begin
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vd2_pip_alph_gen_regs.h
//
//
// Closing file:  ./pip_alph_gen_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPJ_VCBUS_BASE = 0x59
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vppj_regs.h
//
//0x00-0x2f
//
// Reading file:  ./vpp_vd3_scale_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define VD3_SCALE_COEF_IDX                         ((0x5903  << 2) + 0xff000000)
#define VD3_SCALE_COEF                             ((0x5904  << 2) + 0xff000000)
#define VD3_VSC_REGION12_STARTP                    ((0x5905  << 2) + 0xff000000)
#define VD3_VSC_REGION34_STARTP                    ((0x5906  << 2) + 0xff000000)
#define VD3_VSC_REGION4_ENDP                       ((0x5907  << 2) + 0xff000000)
#define VD3_VSC_START_PHASE_STEP                   ((0x5908  << 2) + 0xff000000)
#define VD3_VSC_REGION0_PHASE_SLOPE                ((0x5909  << 2) + 0xff000000)
#define VD3_VSC_REGION1_PHASE_SLOPE                ((0x590a  << 2) + 0xff000000)
#define VD3_VSC_REGION3_PHASE_SLOPE                ((0x590b  << 2) + 0xff000000)
#define VD3_VSC_REGION4_PHASE_SLOPE                ((0x590c  << 2) + 0xff000000)
#define VD3_VSC_PHASE_CTRL                         ((0x590d  << 2) + 0xff000000)
#define VD3_VSC_INI_PHASE                          ((0x590e  << 2) + 0xff000000)
#define VD3_HSC_REGION12_STARTP                    ((0x590f  << 2) + 0xff000000)
#define VD3_HSC_REGION34_STARTP                    ((0x5910  << 2) + 0xff000000)
#define VD3_HSC_REGION4_ENDP                       ((0x5911  << 2) + 0xff000000)
#define VD3_HSC_START_PHASE_STEP                   ((0x5912  << 2) + 0xff000000)
#define VD3_HSC_REGION0_PHASE_SLOPE                ((0x5913  << 2) + 0xff000000)
#define VD3_HSC_REGION1_PHASE_SLOPE                ((0x5914  << 2) + 0xff000000)
#define VD3_HSC_REGION3_PHASE_SLOPE                ((0x5915  << 2) + 0xff000000)
#define VD3_HSC_REGION4_PHASE_SLOPE                ((0x5916  << 2) + 0xff000000)
#define VD3_HSC_PHASE_CTRL                         ((0x5917  << 2) + 0xff000000)
#define VD3_SC_MISC                                ((0x5918  << 2) + 0xff000000)
#define VD3_SCO_FIFO_CTRL                          ((0x5919  << 2) + 0xff000000)
#define VD3_HSC_PHASE_CTRL1                        ((0x591a  << 2) + 0xff000000)
#define VD3_HSC_INI_PAT_CTRL                       ((0x591b  << 2) + 0xff000000)
#define VD3_SC_GCLK_CTRL                           ((0x591c  << 2) + 0xff000000)
#define VD3_PREHSC_COEF                            ((0x591d  << 2) + 0xff000000)
#define VD3_PRE_SCALE_CTRL                         ((0x591e  << 2) + 0xff000000)
#define VD3_PREVSC_COEF                            ((0x591f  << 2) + 0xff000000)
#define VD3_PREHSC_COEF1                           ((0x5920  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp_vd3_scale_regs.h
//
//0x30-0x7f
//
// Reading file:  ./vd3_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//`include "hdr2_top_reg.h"
//VD3 0x00 - -x35
#define VD3_HDR2_CTRL                              ((0x5930  << 2) + 0xff000000)
#define VD3_HDR2_CLK_GATE                          ((0x5931  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF00_01                 ((0x5932  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF02_10                 ((0x5933  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF11_12                 ((0x5934  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF20_21                 ((0x5935  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF22                    ((0x5936  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF30_31                 ((0x5937  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF32_40                 ((0x5938  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_COEF41_42                 ((0x5939  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_OFFSET0_1                 ((0x593a  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_OFFSET2                   ((0x593b  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_PRE_OFFSET0_1             ((0x593c  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_PRE_OFFSET2               ((0x593d  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF00_01                 ((0x593e  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF02_10                 ((0x593f  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF11_12                 ((0x5940  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF20_21                 ((0x5941  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF22                    ((0x5942  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF30_31                 ((0x5943  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF32_40                 ((0x5944  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_COEF41_42                 ((0x5945  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_OFFSET0_1                 ((0x5946  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_OFFSET2                   ((0x5947  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_PRE_OFFSET0_1             ((0x5948  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_PRE_OFFSET2               ((0x5949  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_CLIP                      ((0x594a  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_CLIP                      ((0x594b  << 2) + 0xff000000)
#define VD3_HDR2_CGAIN_OFFT                        ((0x594c  << 2) + 0xff000000)
#define VD3_HDR2_HIST_RD                           ((0x594d  << 2) + 0xff000000)
#define VD3_EOTF_LUT_ADDR_PORT                     ((0x594e  << 2) + 0xff000000)
#define VD3_EOTF_LUT_DATA_PORT                     ((0x594f  << 2) + 0xff000000)
#define VD3_OETF_LUT_ADDR_PORT                     ((0x5950  << 2) + 0xff000000)
#define VD3_OETF_LUT_DATA_PORT                     ((0x5951  << 2) + 0xff000000)
#define VD3_CGAIN_LUT_ADDR_PORT                    ((0x5952  << 2) + 0xff000000)
#define VD3_CGAIN_LUT_DATA_PORT                    ((0x5953  << 2) + 0xff000000)
#define VD3_HDR2_CGAIN_COEF0                       ((0x5954  << 2) + 0xff000000)
#define VD3_HDR2_CGAIN_COEF1                       ((0x5955  << 2) + 0xff000000)
#define VD3_OGAIN_LUT_ADDR_PORT                    ((0x5956  << 2) + 0xff000000)
#define VD3_OGAIN_LUT_DATA_PORT                    ((0x5957  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_CTRL                         ((0x5958  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_ALPHA0                       ((0x5959  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_ALPHA1                       ((0x595a  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_BETA0                        ((0x595b  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_BETA1                        ((0x595c  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_BETA2                        ((0x595d  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_COEF0                        ((0x595e  << 2) + 0xff000000)
#define VD3_HDR2_ADPS_COEF1                        ((0x595f  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_CTRL                         ((0x5960  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_COEF0                        ((0x5961  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_COEF1                        ((0x5962  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_COEF2                        ((0x5963  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_COEF3                        ((0x5964  << 2) + 0xff000000)
#define VD3_HDR2_GMUT_COEF4                        ((0x5965  << 2) + 0xff000000)
#define VD3_HDR2_PIPE_CTRL1                        ((0x5966  << 2) + 0xff000000)
#define VD3_HDR2_PIPE_CTRL2                        ((0x5967  << 2) + 0xff000000)
#define VD3_HDR2_PIPE_CTRL3                        ((0x5968  << 2) + 0xff000000)
#define VD3_HDR2_PROC_WIN1                         ((0x5969  << 2) + 0xff000000)
#define VD3_HDR2_PROC_WIN2                         ((0x596a  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXI_EN_CTRL                   ((0x596b  << 2) + 0xff000000)
#define VD3_HDR2_MATRIXO_EN_CTRL                   ((0x596c  << 2) + 0xff000000)
#define VD3_HDR2_HIST_CTRL                         ((0x596d  << 2) + 0xff000000)
#define VD3_HDR2_HIST_H_START_END                  ((0x596e  << 2) + 0xff000000)
#define VD3_HDR2_HIST_V_START_END                  ((0x596f  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vd3_hdr2_regs.h
//
//0x80-0xff
//
// Reading file:  ./vpp1_regs.h
//
// synopsys translate_off
// synopsys translate_on
//ox80-0xbf
#define VPP1_TOP_CTRL                              ((0x5980  << 2) + 0xff000000)
#define VPP1_WRBAK_CTRL                            ((0x5981  << 2) + 0xff000000)
#define VPP1_LFIFO_CTRL                            ((0x5982  << 2) + 0xff000000)
#define VPP1_CRC_RO                                ((0x5983  << 2) + 0xff000000)
#define VPP1_RO_STATUS                             ((0x5984  << 2) + 0xff000000)
#define VPP1_BLD_CTRL                              ((0x5985  << 2) + 0xff000000)
#define VPP1_BLD_OUT_SIZE                          ((0x5986  << 2) + 0xff000000)
#define VPP1_BLD_DIN0_HSCOPE                       ((0x5987  << 2) + 0xff000000)
#define VPP1_BLD_DIN0_VSCOPE                       ((0x5988  << 2) + 0xff000000)
#define VPP1_BLD_DIN1_HSCOPE                       ((0x5989  << 2) + 0xff000000)
#define VPP1_BLD_DIN1_VSCOPE                       ((0x598a  << 2) + 0xff000000)
#define VPP1_BLD_DIN2_HSCOPE                       ((0x598b  << 2) + 0xff000000)
#define VPP1_BLD_DIN2_VSCOPE                       ((0x598c  << 2) + 0xff000000)
#define VPP1_MISC                                  ((0x598d  << 2) + 0xff000000)
#define VPP1_URGENT_CTRL                           ((0x598e  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF00_01                      ((0x5990  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF02_10                      ((0x5991  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF11_12                      ((0x5992  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF20_21                      ((0x5993  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF22                         ((0x5994  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF13_14                      ((0x5995  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF23_24                      ((0x5996  << 2) + 0xff000000)
#define VPP1_MATRIX_COEF15_25                      ((0x5997  << 2) + 0xff000000)
#define VPP1_MATRIX_CLIP                           ((0x5998  << 2) + 0xff000000)
#define VPP1_MATRIX_OFFSET0_1                      ((0x5999  << 2) + 0xff000000)
#define VPP1_MATRIX_OFFSET2                        ((0x599a  << 2) + 0xff000000)
#define VPP1_MATRIX_PRE_OFFSET0_1                  ((0x599b  << 2) + 0xff000000)
#define VPP1_MATRIX_PRE_OFFSET2                    ((0x599c  << 2) + 0xff000000)
#define VPP1_MATRIX_EN_CTRL                        ((0x599d  << 2) + 0xff000000)
#define VPP1_GAINOFF_GCLK_CTRL                     ((0x59a0  << 2) + 0xff000000)
#define VPP1_GAINOFF_CTRL0                         ((0x59a1  << 2) + 0xff000000)
#define VPP1_GAINOFF_CTRL1                         ((0x59a2  << 2) + 0xff000000)
#define VPP1_GAINOFF_CTRL2                         ((0x59a3  << 2) + 0xff000000)
#define VPP1_GAINOFF_CTRL3                         ((0x59a4  << 2) + 0xff000000)
#define VPP1_GAINOFF_CTRL4                         ((0x59a5  << 2) + 0xff000000)
#define VPP1_BLEND_CTRL                            ((0x59a8  << 2) + 0xff000000)
#define VPP1_BLEND_BLEND_DUMMY_DATA                ((0x59a9  << 2) + 0xff000000)
#define VPP1_BLEND_DUMMY_ALPHA                     ((0x59aa  << 2) + 0xff000000)
#define VPP1_BLEND2_RO_CURRENT_XY                  ((0x59ab  << 2) + 0xff000000)
//oxc0-0xff
#define VPP2_TOP_CTRL                              ((0x59c0  << 2) + 0xff000000)
#define VPP2_WRBAK_CTRL                            ((0x59c1  << 2) + 0xff000000)
#define VPP2_LFIFO_CTRL                            ((0x59c2  << 2) + 0xff000000)
#define VPP2_CRC_RO                                ((0x59c3  << 2) + 0xff000000)
#define VPP2_RO_STATUS                             ((0x59c4  << 2) + 0xff000000)
#define VPP2_BLD_CTRL                              ((0x59c5  << 2) + 0xff000000)
#define VPP2_BLD_OUT_SIZE                          ((0x59c6  << 2) + 0xff000000)
#define VPP2_BLD_DIN0_HSCOPE                       ((0x59c7  << 2) + 0xff000000)
#define VPP2_BLD_DIN0_VSCOPE                       ((0x59c8  << 2) + 0xff000000)
#define VPP2_BLD_DIN1_HSCOPE                       ((0x59c9  << 2) + 0xff000000)
#define VPP2_BLD_DIN1_VSCOPE                       ((0x59ca  << 2) + 0xff000000)
#define VPP2_BLD_DIN2_HSCOPE                       ((0x59cb  << 2) + 0xff000000)
#define VPP2_BLD_DIN2_VSCOPE                       ((0x59cc  << 2) + 0xff000000)
#define VPP2_MISC                                  ((0x59cd  << 2) + 0xff000000)
#define VPP2_URGENT_CTRL                           ((0x59ce  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF00_01                      ((0x59d0  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF02_10                      ((0x59d1  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF11_12                      ((0x59d2  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF20_21                      ((0x59d3  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF22                         ((0x59d4  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF13_14                      ((0x59d5  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF23_24                      ((0x59d6  << 2) + 0xff000000)
#define VPP2_MATRIX_COEF15_25                      ((0x59d7  << 2) + 0xff000000)
#define VPP2_MATRIX_CLIP                           ((0x59d8  << 2) + 0xff000000)
#define VPP2_MATRIX_OFFSET0_1                      ((0x59d9  << 2) + 0xff000000)
#define VPP2_MATRIX_OFFSET2                        ((0x59da  << 2) + 0xff000000)
#define VPP2_MATRIX_PRE_OFFSET0_1                  ((0x59db  << 2) + 0xff000000)
#define VPP2_MATRIX_PRE_OFFSET2                    ((0x59dc  << 2) + 0xff000000)
#define VPP2_MATRIX_EN_CTRL                        ((0x59dd  << 2) + 0xff000000)
#define VPP2_GAINOFF_GCLK_CTRL                     ((0x59e0  << 2) + 0xff000000)
#define VPP2_GAINOFF_CTRL0                         ((0x59e1  << 2) + 0xff000000)
#define VPP2_GAINOFF_CTRL1                         ((0x59e2  << 2) + 0xff000000)
#define VPP2_GAINOFF_CTRL2                         ((0x59e3  << 2) + 0xff000000)
#define VPP2_GAINOFF_CTRL3                         ((0x59e4  << 2) + 0xff000000)
#define VPP2_GAINOFF_CTRL4                         ((0x59e5  << 2) + 0xff000000)
#define VPP2_BLEND_CTRL                            ((0x59e8  << 2) + 0xff000000)
#define VPP2_BLEND_BLEND_DUMMY_DATA                ((0x59e9  << 2) + 0xff000000)
#define VPP2_BLEND_DUMMY_ALPHA                     ((0x59ea  << 2) + 0xff000000)
#define VPP2_BLEND2_RO_CURRENT_XY                  ((0x59eb  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpp1_regs.h
//
//
// Closing file:  ./vppj_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPK_VCBUS_BASE = 0x5a
// -----------------------------------------------
//osd_scale
//===========================================================================
//
// Reading file:  ./vppk_regs.h
//
//0x00-0x3f
//
// Reading file:  ./vpu_osd1_scale.h
//
// synopsys translate_off
// synopsys translate_on
#define VPP_OSD_VSC_PHASE_STEP                     ((0x5a00  << 2) + 0xff000000)
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define VPP_OSD_VSC_INI_PHASE                      ((0x5a01  << 2) + 0xff000000)
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define VPP_OSD_VSC_CTRL0                          ((0x5a02  << 2) + 0xff000000)
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define VPP_OSD_HSC_PHASE_STEP                     ((0x5a03  << 2) + 0xff000000)
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define VPP_OSD_HSC_INI_PHASE                      ((0x5a04  << 2) + 0xff000000)
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define VPP_OSD_HSC_CTRL0                          ((0x5a05  << 2) + 0xff000000)
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define VPP_OSD_HSC_INI_PAT_CTRL                   ((0x5a06  << 2) + 0xff000000)
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define VPP_OSD_SC_DUMMY_DATA                      ((0x5a07  << 2) + 0xff000000)
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define VPP_OSD_SC_CTRL0                           ((0x5a08  << 2) + 0xff000000)
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define VPP_OSD_SCI_WH_M1                          ((0x5a09  << 2) + 0xff000000)
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define VPP_OSD_SCO_H_START_END                    ((0x5a0a  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define VPP_OSD_SCO_V_START_END                    ((0x5a0b  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define VPP_OSD_SCALE_COEF_IDX                     ((0x5a0c  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define VPP_OSD_SCALE_COEF                         ((0x5a0d  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd1_scale.h
//
//
// Reading file:  ./osdsc_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD_DB_FLT_CTRL                            ((0x5a20  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define OSD_DB_FLT_CTRL1                           ((0x5a21  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define OSD_DB_FLT_LUMA_THRD                       ((0x5a22  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define OSD_DB_FLT_CHRM_THRD                       ((0x5a23  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define OSD_DB_FLT_RANDLUT                         ((0x5a24  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define OSD_DB_FLT_PXI_THRD                        ((0x5a25  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define OSD_DB_FLT_SEED_Y                          ((0x5a26  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define OSD_DB_FLT_SEED_U                          ((0x5a27  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define OSD_DB_FLT_SEED_V                          ((0x5a28  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD_DB_FLT_SEED3                           ((0x5a29  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD_DB_FLT_SEED4                           ((0x5a2a  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD_DB_FLT_SEED5                           ((0x5a2b  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osdsc_deband_regs.h
//
//0x40-0x7f
//
// Reading file:  ./vpu_osd2_scale.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD2_VSC_PHASE_STEP                        ((0x5a40  << 2) + 0xff000000)
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define OSD2_VSC_INI_PHASE                         ((0x5a41  << 2) + 0xff000000)
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define OSD2_VSC_CTRL0                             ((0x5a42  << 2) + 0xff000000)
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define OSD2_HSC_PHASE_STEP                        ((0x5a43  << 2) + 0xff000000)
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define OSD2_HSC_INI_PHASE                         ((0x5a44  << 2) + 0xff000000)
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define OSD2_HSC_CTRL0                             ((0x5a45  << 2) + 0xff000000)
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define OSD2_HSC_INI_PAT_CTRL                      ((0x5a46  << 2) + 0xff000000)
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define OSD2_SC_DUMMY_DATA                         ((0x5a47  << 2) + 0xff000000)
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define OSD2_SC_CTRL0                              ((0x5a48  << 2) + 0xff000000)
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define OSD2_SCI_WH_M1                             ((0x5a49  << 2) + 0xff000000)
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define OSD2_SCO_H_START_END                       ((0x5a4a  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define OSD2_SCO_V_START_END                       ((0x5a4b  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define OSD2_SCALE_COEF_IDX                        ((0x5a4c  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define OSD2_SCALE_COEF                            ((0x5a4d  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd2_scale.h
//
//
// Reading file:  ./vpu_osd2_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD2_DB_FLT_CTRL                           ((0x5a60  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define OSD2_DB_FLT_CTRL1                          ((0x5a61  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define OSD2_DB_FLT_LUMA_THRD                      ((0x5a62  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define OSD2_DB_FLT_CHRM_THRD                      ((0x5a63  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define OSD2_DB_FLT_RANDLUT                        ((0x5a64  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define OSD2_DB_FLT_PXI_THRD                       ((0x5a65  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define OSD2_DB_FLT_SEED_Y                         ((0x5a66  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define OSD2_DB_FLT_SEED_U                         ((0x5a67  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define OSD2_DB_FLT_SEED_V                         ((0x5a68  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD2_DB_FLT_SEED3                          ((0x5a69  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD2_DB_FLT_SEED4                          ((0x5a6a  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD2_DB_FLT_SEED5                          ((0x5a6b  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd2_deband_regs.h
//
//0x80-0xbf
//
// Reading file:  ./vpu_osd3_scale.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD34_VSC_PHASE_STEP                       ((0x5a80  << 2) + 0xff000000)
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define OSD34_VSC_INI_PHASE                        ((0x5a81  << 2) + 0xff000000)
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define OSD34_VSC_CTRL0                            ((0x5a82  << 2) + 0xff000000)
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define OSD34_HSC_PHASE_STEP                       ((0x5a83  << 2) + 0xff000000)
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define OSD34_HSC_INI_PHASE                        ((0x5a84  << 2) + 0xff000000)
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define OSD34_HSC_CTRL0                            ((0x5a85  << 2) + 0xff000000)
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define OSD34_HSC_INI_PAT_CTRL                     ((0x5a86  << 2) + 0xff000000)
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define OSD34_SC_DUMMY_DATA                        ((0x5a87  << 2) + 0xff000000)
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define OSD34_SC_CTRL0                             ((0x5a88  << 2) + 0xff000000)
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define OSD34_SCI_WH_M1                            ((0x5a89  << 2) + 0xff000000)
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define OSD34_SCO_H_START_END                      ((0x5a8a  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define OSD34_SCO_V_START_END                      ((0x5a8b  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define OSD34_SCALE_COEF_IDX                       ((0x5a8c  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define OSD34_SCALE_COEF                           ((0x5a8d  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd3_scale.h
//
//
// Reading file:  ./vpu_osd3_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD34_DB_FLT_CTRL                          ((0x5aa0  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define OSD34_DB_FLT_CTRL1                         ((0x5aa1  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define OSD34_DB_FLT_LUMA_THRD                     ((0x5aa2  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define OSD34_DB_FLT_CHRM_THRD                     ((0x5aa3  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define OSD34_DB_FLT_RANDLUT                       ((0x5aa4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define OSD34_DB_FLT_PXI_THRD                      ((0x5aa5  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define OSD34_DB_FLT_SEED_Y                        ((0x5aa6  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define OSD34_DB_FLT_SEED_U                        ((0x5aa7  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define OSD34_DB_FLT_SEED_V                        ((0x5aa8  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD34_DB_FLT_SEED3                         ((0x5aa9  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD34_DB_FLT_SEED4                         ((0x5aaa  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD34_DB_FLT_SEED5                         ((0x5aab  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd3_deband_regs.h
//
//0xc0-0xff
//
// Reading file:  ./vpu_osd4_scale.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD4_VSC_PHASE_STEP                        ((0x5ac0  << 2) + 0xff000000)
//vertical scaler phase step
//Bit 27:0,  4.24 format
#define OSD4_VSC_INI_PHASE                         ((0x5ac1  << 2) + 0xff000000)
//Bit 31:16, bottom vertical scaler initial phase
//Bit 15:0, top vertical scaler initial phase
#define OSD4_VSC_CTRL0                             ((0x5ac2  << 2) + 0xff000000)
//Bit 24    osd vertical Scaler enable
//Bit 23    osd_prog_interlace 0: current field is progressive, 1: current field is interlace
//Bit 22:21 osd_vsc_double_line_mode, bit1, double input width and half input height, bit0, change line buffer becomes 2 lines
//Bit 20    osd_vsc_phase0_always_en
//Bit 19    osd_vsc_nearest_en
//Bit 17:16 osd_vsc_bot_rpt_l0_num
//Bit 14:11 osd_vsc_bot_ini_rcv_num
//Bit 9:8   osd_vsc_top_rpt_l0_num
//Bit 6:3   osd_vsc_top_ini_rcv_num
//Bit 2:0   osd_vsc_bank_length
#define OSD4_HSC_PHASE_STEP                        ((0x5ac3  << 2) + 0xff000000)
//horizontal scaler phase step
//Bit 27:0,  4.24 format
#define OSD4_HSC_INI_PHASE                         ((0x5ac4  << 2) + 0xff000000)
//Bit 31:16, horizontal scaler initial phase1
//Bit 15:0, horizontal scaler initial phase0
#define OSD4_HSC_CTRL0                             ((0x5ac5  << 2) + 0xff000000)
//Bit 22   osd horizontal scaler enable
//Bit 21   osd_hsc_double_pix_mode
//Bit 20   osd_hsc_phase0_always_en
//Bit 19   osd_hsc_nearest_en
//Bit 17:16 osd_hsc_rpt_p0_num1
//Bit 14:11 osd_hsc_ini_rcv_num1
//Bit 9:8   osd_hsc_rpt_p0_num0
//Bit 6:3   osd_hsc_ini_rcv_num0
//Bit 2:0   osd_hsc_bank_length
#define OSD4_HSC_INI_PAT_CTRL                      ((0x5ac6  << 2) + 0xff000000)
//for 3D quincunx sub-sampling
//bit 15:8 pattern, each patten 1 bit, from lsb -> msb
//bit 6:4  pattern start
//bit 2:0  pattern end
#define OSD4_SC_DUMMY_DATA                         ((0x5ac7  << 2) + 0xff000000)
//bit 31:24, componet 0
//bit 23:16, component 1
//bit 15:8, component 2
//bit 7:0 component 3, alpha
#define OSD4_SC_CTRL0                              ((0x5ac8  << 2) + 0xff000000)
//Bit 14 osc_sc_din_osd1_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 13 osc_sc_din_osd2_alpha_mode, 1: (alpha >= 128) ? alpha -1: alpha,  0: (alpha >=1) ? alpha - 1: alpha.
//Bit 12 osc_sc_dout_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 12 osc_sc_alpha_mode, 1: (alpha >= 128) ? alpha + 1: alpha, 0: (alpha >=1) ? alpha + 1: alpha.
//Bit 11:4 default alpha for vd1 or vd2 if they are selected as the source
//Bit 3 osd scaler path enable
//Bit 1:0 osd_sc_sel, 00: select osd1 input, 01: select osd2 input, 10: select vd1 input, 11: select vd2 input after matrix
#define OSD4_SCI_WH_M1                             ((0x5ac9  << 2) + 0xff000000)
//Bit 28:16 OSD scaler input width minus 1
//Bit 12:0 OSD scaler input height minus 1
#define OSD4_SCO_H_START_END                       ((0x5aca  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output horizontal start
//Bit 12:0 OSD scaler output horizontal end
#define OSD4_SCO_V_START_END                       ((0x5acb  << 2) + 0xff000000)
//Bit 28:16 OSD scaler output vertical start
//Bit 12:0 OSD scaler output vertical end
#define OSD4_SCALE_COEF_IDX                        ((0x5acc  << 2) + 0xff000000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8   type of index, 0: vertical coef,  1: horizontal coef
//Bit 6:0 	coef index
#define OSD4_SCALE_COEF                            ((0x5acd  << 2) + 0xff000000)
//coefficients for vertical filter and horizontal filter
 // synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd4_scale.h
//
//
// Reading file:  ./vpu_osd4_deband_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define OSD4_DB_FLT_CTRL                           ((0x5ae0  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_nrdeband_reset1       // unsigned , default = 1  , 0 : no reload chrm seed 1: reload chrm seed
//Bit 25           reg_nrdeband_reset0       // unsigned , default = 1  , 0 : no reload luma seed 1: reload luma seed
//Bit 24           reg_nrdeband_rgb          // unsigned , default = 0  , 0 : yuv 1: RGB
//Bit 23           reg_nrdeband_en11         // unsigned , default = 0  , debanding registers of side lines, [0] for luma,   same for below
//Bit 22           reg_nrdeband_en10         // unsigned , default = 0  , debanding registers of side lines, [1] for chroma, same for below
//Bit 21           reg_nrdeband_siderand     // unsigned , default = 1  , options to use side two lines use the rand, instead of use for the YUV three component of middle line, 0: seed[3]/bandrand[3] for middle line yuv; 1: seed[3]/bandrand[3] for nearby three lines Y;
//Bit 20           reg_nrdeband_randmode     // unsigned , default = 0  , mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs, MIN((pPKReg->reg_nrdeband_bandrand[m]), noise[m])
//Bit 19:17        reg_nrdeband_bandrand2    // unsigned , default = 6
//Bit 16            reserved
//Bit 15:13        reg_nrdeband_bandrand1    // unsigned , default = 6
//Bit 12            reserved
//Bit 11: 9        reg_nrdeband_bandrand0    // unsigned , default = 6
//Bit  8            reserved
//Bit  7           reg_nrdeband_hpxor1       // unsigned , default = 1   , debanding random hp portion xor, [0] for luma
//Bit  6           reg_nrdeband_hpxor0       // unsigned , default = 1   , debanding random hp portion xor, [1] for chroma
//Bit  5           reg_nrdeband_en1          // unsigned , default = 0   , debanding registers,  for luma
//Bit  4           reg_nrdeband_en0          // unsigned , default = 0   , debanding registers,  for chroma
//Bit  3: 2        reg_nrdeband_lpf_mode1    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
//Bit  1: 0        reg_nrdeband_lpf_mode0    // unsigned , default = 2   , lpf mode, 0: 3x3, 1:3x5; 2: 5x5; 3:5x7
#define OSD4_DB_FLT_CTRL1                          ((0x5ae1  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_nrdeband_noise_rs     // unsigned , default = 2
//Bit 15:12        reg_nrdeband_randgain     // unsigned , default = 8
//Bit 11            reserved
//Bit 10: 8        reg_nrdeband_bandrand5    // unsigned , default = 6
//Bit  7            reserved
//Bit  6: 4        reg_nrdeband_bandrand4    // unsigned , default = 6
//Bit  3            reserved
//Bit  2: 0        reg_nrdeband_bandrand3    // unsigned , default = 6
#define OSD4_DB_FLT_LUMA_THRD                      ((0x5ae2  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_luma_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_luma_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_luma_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_luma_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif <th[3] (lpf*1 + 3*y)/4; else
#define OSD4_DB_FLT_CHRM_THRD                      ((0x5ae3  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nrdeband_chrm_th3     // unsigned , default = 36   , threshold to |Y-Ylpf|, if < th[0] use lpf
//Bit 23:22        reserved
//Bit 21:16        reg_nrdeband_chrm_th2     // unsigned , default = 28   , elseif <th[1] use (lpf*3 + y)/4
//Bit 15:14        reserved
//Bit 13: 8        reg_nrdeband_chrm_th1     // unsigned , default = 24   , elseif <th[1] use (lpf*3 + y)/4elseif <th[2] (lpf*1 + y)/2
//Bit  7: 6        reserved
//Bit  5: 0        reg_nrdeband_chrm_th0     // unsigned , default = 20   , elseif <th[1] use (lpf*3 + y)/4elseif elseif
#define OSD4_DB_FLT_RANDLUT                        ((0x5ae4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:21        reg_nrdeband_randslut7    // unsigned , default = 1   rand lut7
//Bit 20:18        reg_nrdeband_randslut6    // unsigned , default = 1   rand lut6
//Bit 17:15        reg_nrdeband_randslut5    // unsigned , default = 1   rand lut5
//Bit 14:12        reg_nrdeband_randslut4    // unsigned , default = 1   rand lut4
//Bit 11: 9        reg_nrdeband_randslut3    // unsigned , default = 1   rand lut3
//Bit  8: 6        reg_nrdeband_randslut2    // unsigned , default = 1   rand lut2
//Bit  5: 3        reg_nrdeband_randslut1    // unsigned , default = 1   rand lut1
//Bit  2: 0        reg_nrdeband_randslut0    // unsigned , default = 1   rand lut0
#define OSD4_DB_FLT_PXI_THRD                       ((0x5ae5  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_nrdeband_yc_th1       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
//Bit 15:10        reserved
//Bit  9: 0        reg_nrdeband_yc_th0       // unsigned , default = 0   ,threshold to luma/|u/v| for using the denoise
#define OSD4_DB_FLT_SEED_Y                         ((0x5ae6  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed0        // unsigned , default = 1621438240  ,debanding noise adding seed for Y. seed[0]= 0x60a52f20; as default
#define OSD4_DB_FLT_SEED_U                         ((0x5ae7  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed1        // unsigned , default = 1621438247  ,debanding noise adding seed for U. seed[0]= 0x60a52f27; as default
#define OSD4_DB_FLT_SEED_V                         ((0x5ae8  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed2        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD4_DB_FLT_SEED3                          ((0x5ae9  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed3        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD4_DB_FLT_SEED4                          ((0x5aea  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed4        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
#define OSD4_DB_FLT_SEED5                          ((0x5aeb  << 2) + 0xff000000)
//Bit 31: 0        reg_nrdeband_seed5        // unsigned , default = 1621438242  ,debanding noise adding seed for V. seed[0]= 0x60a52f22; as default
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vpu_osd4_deband_regs.h
//
//
// Closing file:  ./vppk_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPPL_VCBUS_BASE = 0x5b
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./vppl_regs.h
//
//0x00-0x4f
//
// Reading file:  ./osd2_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//osd1 0x40 - 0x7f
#define OSD2_HDR2_CTRL                             ((0x5b00  << 2) + 0xff000000)
#define OSD2_HDR2_CLK_GATE                         ((0x5b01  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF00_01                ((0x5b02  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF02_10                ((0x5b03  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF11_12                ((0x5b04  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF20_21                ((0x5b05  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF22                   ((0x5b06  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF30_31                ((0x5b07  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF32_40                ((0x5b08  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_COEF41_42                ((0x5b09  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_OFFSET0_1                ((0x5b0a  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_OFFSET2                  ((0x5b0b  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_PRE_OFFSET0_1            ((0x5b0c  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_PRE_OFFSET2              ((0x5b0d  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF00_01                ((0x5b0e  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF02_10                ((0x5b0f  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF11_12                ((0x5b10  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF20_21                ((0x5b11  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF22                   ((0x5b12  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF30_31                ((0x5b13  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF32_40                ((0x5b14  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_COEF41_42                ((0x5b15  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_OFFSET0_1                ((0x5b16  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_OFFSET2                  ((0x5b17  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_PRE_OFFSET0_1            ((0x5b18  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_PRE_OFFSET2              ((0x5b19  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_CLIP                     ((0x5b1a  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_CLIP                     ((0x5b1b  << 2) + 0xff000000)
#define OSD2_HDR2_CGAIN_OFFT                       ((0x5b1c  << 2) + 0xff000000)
#define OSD2_HDR2_HIST_RD                          ((0x5b1d  << 2) + 0xff000000)
#define OSD2_EOTF_LUT_ADDR_PORT                    ((0x5b1e  << 2) + 0xff000000)
#define OSD2_EOTF_LUT_DATA_PORT                    ((0x5b1f  << 2) + 0xff000000)
#define OSD2_OETF_LUT_ADDR_PORT                    ((0x5b20  << 2) + 0xff000000)
#define OSD2_OETF_LUT_DATA_PORT                    ((0x5b21  << 2) + 0xff000000)
#define OSD2_CGAIN_LUT_ADDR_PORT                   ((0x5b22  << 2) + 0xff000000)
#define OSD2_CGAIN_LUT_DATA_PORT                   ((0x5b23  << 2) + 0xff000000)
#define OSD2_HDR2_CGAIN_COEF0                      ((0x5b24  << 2) + 0xff000000)
#define OSD2_HDR2_CGAIN_COEF1                      ((0x5b25  << 2) + 0xff000000)
#define OSD2_OGAIN_LUT_ADDR_PORT                   ((0x5b26  << 2) + 0xff000000)
#define OSD2_OGAIN_LUT_DATA_PORT                   ((0x5b27  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_CTRL                        ((0x5b28  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_ALPHA0                      ((0x5b29  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_ALPHA1                      ((0x5b2a  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_BETA0                       ((0x5b2b  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_BETA1                       ((0x5b2c  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_BETA2                       ((0x5b2d  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_COEF0                       ((0x5b2e  << 2) + 0xff000000)
#define OSD2_HDR2_ADPS_COEF1                       ((0x5b2f  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_CTRL                        ((0x5b30  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_COEF0                       ((0x5b31  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_COEF1                       ((0x5b32  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_COEF2                       ((0x5b33  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_COEF3                       ((0x5b34  << 2) + 0xff000000)
#define OSD2_HDR2_GMUT_COEF4                       ((0x5b35  << 2) + 0xff000000)
#define OSD2_HDR2_PIPE_CTRL1                       ((0x5b36  << 2) + 0xff000000)
#define OSD2_HDR2_PIPE_CTRL2                       ((0x5b37  << 2) + 0xff000000)
#define OSD2_HDR2_PIPE_CTRL3                       ((0x5b38  << 2) + 0xff000000)
#define OSD2_HDR2_PROC_WIN1                        ((0x5b39  << 2) + 0xff000000)
#define OSD2_HDR2_PROC_WIN2                        ((0x5b3a  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXI_EN_CTRL                  ((0x5b3b  << 2) + 0xff000000)
#define OSD2_HDR2_MATRIXO_EN_CTRL                  ((0x5b3c  << 2) + 0xff000000)
#define OSD2_HDR2_HIST_CTRL                        ((0x5b3d  << 2) + 0xff000000)
#define OSD2_HDR2_HIST_H_START_END                 ((0x5b3e  << 2) + 0xff000000)
#define OSD2_HDR2_HIST_V_START_END                 ((0x5b3f  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osd2_hdr2_regs.h
//
//0x50-0x9f
//
// Reading file:  ./osd3_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//osd1 0x40 - 0x7f
#define OSD3_HDR2_CTRL                             ((0x5b50  << 2) + 0xff000000)
#define OSD3_HDR2_CLK_GATE                         ((0x5b51  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF00_01                ((0x5b52  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF02_10                ((0x5b53  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF11_12                ((0x5b54  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF20_21                ((0x5b55  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF22                   ((0x5b56  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF30_31                ((0x5b57  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF32_40                ((0x5b58  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_COEF41_42                ((0x5b59  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_OFFSET0_1                ((0x5b5a  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_OFFSET2                  ((0x5b5b  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_PRE_OFFSET0_1            ((0x5b5c  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_PRE_OFFSET2              ((0x5b5d  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF00_01                ((0x5b5e  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF02_10                ((0x5b5f  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF11_12                ((0x5b60  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF20_21                ((0x5b61  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF22                   ((0x5b62  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF30_31                ((0x5b63  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF32_40                ((0x5b64  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_COEF41_42                ((0x5b65  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_OFFSET0_1                ((0x5b66  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_OFFSET2                  ((0x5b67  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_PRE_OFFSET0_1            ((0x5b68  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_PRE_OFFSET2              ((0x5b69  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_CLIP                     ((0x5b6a  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_CLIP                     ((0x5b6b  << 2) + 0xff000000)
#define OSD3_HDR2_CGAIN_OFFT                       ((0x5b6c  << 2) + 0xff000000)
#define OSD3_HDR2_HIST_RD                          ((0x5b6d  << 2) + 0xff000000)
#define OSD3_EOTF_LUT_ADDR_PORT                    ((0x5b6e  << 2) + 0xff000000)
#define OSD3_EOTF_LUT_DATA_PORT                    ((0x5b6f  << 2) + 0xff000000)
#define OSD3_OETF_LUT_ADDR_PORT                    ((0x5b70  << 2) + 0xff000000)
#define OSD3_OETF_LUT_DATA_PORT                    ((0x5b71  << 2) + 0xff000000)
#define OSD3_CGAIN_LUT_ADDR_PORT                   ((0x5b72  << 2) + 0xff000000)
#define OSD3_CGAIN_LUT_DATA_PORT                   ((0x5b73  << 2) + 0xff000000)
#define OSD3_HDR2_CGAIN_COEF0                      ((0x5b74  << 2) + 0xff000000)
#define OSD3_HDR2_CGAIN_COEF1                      ((0x5b75  << 2) + 0xff000000)
#define OSD3_OGAIN_LUT_ADDR_PORT                   ((0x5b76  << 2) + 0xff000000)
#define OSD3_OGAIN_LUT_DATA_PORT                   ((0x5b77  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_CTRL                        ((0x5b78  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_ALPHA0                      ((0x5b79  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_ALPHA1                      ((0x5b7a  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_BETA0                       ((0x5b7b  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_BETA1                       ((0x5b7c  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_BETA2                       ((0x5b7d  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_COEF0                       ((0x5b7e  << 2) + 0xff000000)
#define OSD3_HDR2_ADPS_COEF1                       ((0x5b7f  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_CTRL                        ((0x5b80  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_COEF0                       ((0x5b81  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_COEF1                       ((0x5b82  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_COEF2                       ((0x5b83  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_COEF3                       ((0x5b84  << 2) + 0xff000000)
#define OSD3_HDR2_GMUT_COEF4                       ((0x5b85  << 2) + 0xff000000)
#define OSD3_HDR2_PIPE_CTRL1                       ((0x5b86  << 2) + 0xff000000)
#define OSD3_HDR2_PIPE_CTRL2                       ((0x5b87  << 2) + 0xff000000)
#define OSD3_HDR2_PIPE_CTRL3                       ((0x5b88  << 2) + 0xff000000)
#define OSD3_HDR2_PROC_WIN1                        ((0x5b89  << 2) + 0xff000000)
#define OSD3_HDR2_PROC_WIN2                        ((0x5b8a  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXI_EN_CTRL                  ((0x5b8b  << 2) + 0xff000000)
#define OSD3_HDR2_MATRIXO_EN_CTRL                  ((0x5b8c  << 2) + 0xff000000)
#define OSD3_HDR2_HIST_CTRL                        ((0x5b8d  << 2) + 0xff000000)
#define OSD3_HDR2_HIST_H_START_END                 ((0x5b8e  << 2) + 0xff000000)
#define OSD3_HDR2_HIST_V_START_END                 ((0x5b8f  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osd3_hdr2_regs.h
//
//0xa0-0xef
//
// Reading file:  ./osd4_hdr2_regs.h
//
// synopsys translate_off
// synopsys translate_on
//osd1 0x40 - 0x7f
#define OSD4_HDR2_CTRL                             ((0x5ba0  << 2) + 0xff000000)
#define OSD4_HDR2_CLK_GATE                         ((0x5ba1  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF00_01                ((0x5ba2  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF02_10                ((0x5ba3  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF11_12                ((0x5ba4  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF20_21                ((0x5ba5  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF22                   ((0x5ba6  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF30_31                ((0x5ba7  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF32_40                ((0x5ba8  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_COEF41_42                ((0x5ba9  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_OFFSET0_1                ((0x5baa  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_OFFSET2                  ((0x5bab  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_PRE_OFFSET0_1            ((0x5bac  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_PRE_OFFSET2              ((0x5bad  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF00_01                ((0x5bae  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF02_10                ((0x5baf  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF11_12                ((0x5bb0  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF20_21                ((0x5bb1  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF22                   ((0x5bb2  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF30_31                ((0x5bb3  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF32_40                ((0x5bb4  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_COEF41_42                ((0x5bb5  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_OFFSET0_1                ((0x5bb6  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_OFFSET2                  ((0x5bb7  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_PRE_OFFSET0_1            ((0x5bb8  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_PRE_OFFSET2              ((0x5bb9  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_CLIP                     ((0x5bba  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_CLIP                     ((0x5bbb  << 2) + 0xff000000)
#define OSD4_HDR2_CGAIN_OFFT                       ((0x5bbc  << 2) + 0xff000000)
#define OSD4_HDR2_HIST_RD                          ((0x5bbd  << 2) + 0xff000000)
#define OSD4_EOTF_LUT_ADDR_PORT                    ((0x5bbe  << 2) + 0xff000000)
#define OSD4_EOTF_LUT_DATA_PORT                    ((0x5bbf  << 2) + 0xff000000)
#define OSD4_OETF_LUT_ADDR_PORT                    ((0x5bc0  << 2) + 0xff000000)
#define OSD4_OETF_LUT_DATA_PORT                    ((0x5bc1  << 2) + 0xff000000)
#define OSD4_CGAIN_LUT_ADDR_PORT                   ((0x5bc2  << 2) + 0xff000000)
#define OSD4_CGAIN_LUT_DATA_PORT                   ((0x5bc3  << 2) + 0xff000000)
#define OSD4_HDR2_CGAIN_COEF0                      ((0x5bc4  << 2) + 0xff000000)
#define OSD4_HDR2_CGAIN_COEF1                      ((0x5bc5  << 2) + 0xff000000)
#define OSD4_OGAIN_LUT_ADDR_PORT                   ((0x5bc6  << 2) + 0xff000000)
#define OSD4_OGAIN_LUT_DATA_PORT                   ((0x5bc7  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_CTRL                        ((0x5bc8  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_ALPHA0                      ((0x5bc9  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_ALPHA1                      ((0x5bca  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_BETA0                       ((0x5bcb  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_BETA1                       ((0x5bcc  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_BETA2                       ((0x5bcd  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_COEF0                       ((0x5bce  << 2) + 0xff000000)
#define OSD4_HDR2_ADPS_COEF1                       ((0x5bcf  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_CTRL                        ((0x5bd0  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_COEF0                       ((0x5bd1  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_COEF1                       ((0x5bd2  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_COEF2                       ((0x5bd3  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_COEF3                       ((0x5bd4  << 2) + 0xff000000)
#define OSD4_HDR2_GMUT_COEF4                       ((0x5bd5  << 2) + 0xff000000)
#define OSD4_HDR2_PIPE_CTRL1                       ((0x5bd6  << 2) + 0xff000000)
#define OSD4_HDR2_PIPE_CTRL2                       ((0x5bd7  << 2) + 0xff000000)
#define OSD4_HDR2_PIPE_CTRL3                       ((0x5bd8  << 2) + 0xff000000)
#define OSD4_HDR2_PROC_WIN1                        ((0x5bd9  << 2) + 0xff000000)
#define OSD4_HDR2_PROC_WIN2                        ((0x5bda  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXI_EN_CTRL                  ((0x5bdb  << 2) + 0xff000000)
#define OSD4_HDR2_MATRIXO_EN_CTRL                  ((0x5bdc  << 2) + 0xff000000)
#define OSD4_HDR2_HIST_CTRL                        ((0x5bdd  << 2) + 0xff000000)
#define OSD4_HDR2_HIST_H_START_END                 ((0x5bde  << 2) + 0xff000000)
#define OSD4_HDR2_HIST_V_START_END                 ((0x5bdf  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./osd4_hdr2_regs.h
//
//
// Closing file:  ./vppl_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY1C_VCBUS_BASE = 0x60
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby1c_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE1C_REG_START                     ((0x6000  << 2) + 0xff000000)
#define DOLBY_CORE1C_CLKGATE_CTRL                  ((0x60f2  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL0                    ((0x60f3  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL1                    ((0x60f4  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL2                    ((0x60f5  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL3                    ((0x60f6  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL4                    ((0x60f7  << 2) + 0xff000000)
#define DOLBY_CORE1C_SWAP_CTRL5                    ((0x60f8  << 2) + 0xff000000)
#define DOLBY_CORE1C_DMA_CTRL                      ((0x60f9  << 2) + 0xff000000)
#define DOLBY_CORE1C_DMA_STATUS                    ((0x60fa  << 2) + 0xff000000)
#define DOLBY_CORE1C_STATUS0                       ((0x60fb  << 2) + 0xff000000)
#define DOLBY_CORE1C_STATUS1                       ((0x60fc  << 2) + 0xff000000)
#define DOLBY_CORE1C_STATUS2                       ((0x60fd  << 2) + 0xff000000)
#define DOLBY_CORE1C_STATUS3                       ((0x60fe  << 2) + 0xff000000)
#define DOLBY_CORE1C_DMA_PORT                      ((0x60ff  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby1c_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  DOLBY2C_VCBUS_BASE = 0x61
// -----------------------------------------------
//===========================================================================
//
// Reading file:  ./dolby2c_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define DOLBY_CORE2C_REG_START                     ((0x6100  << 2) + 0xff000000)
#define DOLBY_CORE2C_CLKGATE_CTRL                  ((0x6132  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL0                    ((0x6133  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL1                    ((0x6134  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL2                    ((0x6135  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL3                    ((0x6136  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL4                    ((0x6137  << 2) + 0xff000000)
#define DOLBY_CORE2C_SWAP_CTRL5                    ((0x6138  << 2) + 0xff000000)
#define DOLBY_CORE2C_DMA_CTRL                      ((0x6139  << 2) + 0xff000000)
#define DOLBY_CORE2C_DMA_STATUS                    ((0x613a  << 2) + 0xff000000)
#define DOLBY_CORE2C_STATUS0                       ((0x613b  << 2) + 0xff000000)
#define DOLBY_CORE2C_STATUS1                       ((0x613c  << 2) + 0xff000000)
#define DOLBY_CORE2C_STATUS2                       ((0x613d  << 2) + 0xff000000)
#define DOLBY_CORE2C_STATUS3                       ((0x613e  << 2) + 0xff000000)
#define DOLBY_CORE2C_DMA_PORT                      ((0x613f  << 2) + 0xff000000)
#define DOLBY_CORE2C_AXI2DMA_CTRL0                 ((0x6140  << 2) + 0xff000000)
#define DOLBY_CORE2C_AXI2DMA_CTRL1                 ((0x6141  << 2) + 0xff000000)
#define DOLBY_CORE2C_AXI2DMA_CTRL2                 ((0x6142  << 2) + 0xff000000)
#define DOLBY_CORE2C_AXI2DMA_CTRL3                 ((0x6143  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dolby2c_regs.h
//
//===========================================================================
// -----------------------------------------------
// REG_BASE:  VPP2_VCBUS_BASE = 0x70
// -----------------------------------------------
// -----------------------------------------------
// REG_BASE:  VIU2_VCBUS_BASE = 0x71
// -----------------------------------------------
//===========================================================================
//`include "v2regs.h"
//`include "viu2_regs.h"
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./vcbus_regs.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_regs_base.h
//
// -----------------------------------------------
// REG_BASE:  ISP_TOP_APB0_APB_BASE = 0x00
// -----------------------------------------------
#if 0
//below register for t7_revc
//
// Reading file:  ./isp_inc/inc_sw/isp_top_hw_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_TOP_INPUT_SIZE                         ((0x0000  << 2) + 0xfe3b4000)
//Bit 31:16         reg_input_hsize                // unsigned ,    RW, default = 720
//Bit 15: 0         reg_input_vsize                // unsigned ,    RW, default = 480
#define ISP_TOP_FRM_SIZE                           ((0x0001  << 2) + 0xfe3b4000)
//Bit 31:16         reg_core_ihsize                // unsigned ,    RW, default = 720
//Bit 15: 0         reg_core_ivsize                // unsigned ,    RW, default = 480
#define ISP_TOP_HOLD_SIZE                          ((0x0002  << 2) + 0xfe3b4000)
//Bit 31:16         reg_hold_hsize                 // unsigned ,    RW, default = 720
//Bit 15: 0         reg_hold_vsize                 // unsigned ,    RW, default = 20
#define ISP_TOP_CTRL0                              ((0x0003  << 2) + 0xfe3b4000)
//Bit 31:19         reserved
//Bit 18            pls_din_vsync                 // unsigned ,    RW, default = 0,  //
//Bit 17:16         reg_din_vsync_sel             // unsigned ,    RW, default = 0,  //0: mipi/tmg vsync,  1:pls 2:1'b1  3:1'b0
//Bit 15:13         reserved
//Bit 12:11         reg_frm_latch_sel             // unsigned ,    RW, default = 0,  //latch use 0:frm_start 1:frm_end 2:1'b1 3:1'b0
//Bit 10            pls_frm_st_clr                // unsigned ,    W1T, default = 0, //pluse to clr frm_start_flg
//Bit 9:8           reg_frm_start_sel             // unsigned ,    RW, default = 0, //0:din_vsync 1:pls 2:fst_din
//Bit 7:6           reg_frm_rst_sel               // unsigned ,    RW, default = 2, //0:auto 1:pls 2:start_din
//Bit 5:2           reg_sw_rst_ctrl               // unsigned ,    RW, default = 0,
//Bit 1             pls_frm_start                 // unsigned ,    W1T, default = 0,
//Bit 0             pls_frm_rst                   // unsigned ,    W1T, default = 0,
#define ISP_TOP_PATH_EN                            ((0x0004  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28         reg_pnrmif_en                 // unsigned ,    RW, default = 0, {pnr_wrmif_y,pnr_rdmif_meta,pnr_rdmif_y}
//Bit 27:20         reg_nrmif_en                  // unsigned ,    RW, default = 0, {nr_rdmif_x4,nr_wrmif_x4},{meta,mv,mix,raw}
//Bit 19:18         reserved
//Bit 17:16         reg_rdmif_en                  // unsigned ,    RW, default = 0,
//Bit 15:13         reserved
//Bit 12:8          reg_wrmif_en                  // unsigned ,    RW, default = 0,
//Bit 7:4           reg_disp_2out_en              // unsigned ,    RW, default = 4'h3, //disp2out_enable
//Bit 3:0           reg_disp_en                   // unsigned ,    RW, default = 4'h1, //disp_en
#define ISP_TOP_PATH_SEL                           ((0x0005  << 2) + 0xfe3b4000)
//Bit 31:20         reserved
//Bit 19            reg_dpth_hs_en_post           // unsigned ,    RW, default = 0, 0: raw_in->ofe->dms->post, 1:yuv_in->post
//Bit 18:16         reg_dpth_hs_en_core           // unsigned ,    RW, default = 1, 'b000:core disable, 'b001:mipi->core 'b010:rd0->core 'b100:rd1->core
//Bit 15:6          reserved
//Bit 5:4           reg_dpth_hs_en_rd1            // unsigned ,    RW, default = 2, [0]:rd1 to post hs en   [1]:rd1 to disp hs en
//Bit 3:2           reg_dpth_hs_en_rd0            // unsigned ,    RW, default = 3, [0]:rd0  to core hs en  [1]:rd0  to disp hs en
//Bit 1:0           reg_dpth_hs_en_mipi           // unsigned ,    RW, default = 3, [0]:mipi to core hs en  [1]:mipi to disp hs en
#define ISP_TOP_DISPIN_SEL                         ((0x0006  << 2) + 0xfe3b4000)
//Bit 31:30         reserved
//Bit 29:20         reg_dispin_dat_sel            // unsigned ,    RW, default = 10'h6,disp0[1:0] ,01:cmpn1 02:cmpn2 else:cmpn0
//Bit 19:0          reg_dispin_path_sel           // unsigned ,    RW, default = 20'h0,6:close 5:rdmif1 4:dbgpath 3:rd02disp, 2:mipi2disp, 1:core_ir_dout, 0:core_dout
#define ISP_TOP_LS_INV                             ((0x0009  << 2) + 0xfe3b4000)
//Bit 31:24         reg_rd1_reo_sel               // unsigned ,    RW, default = 8'h24
//Bit 23:16         reg_din_reo_sel               // unsigned ,    RW, default = 8'h24
//Bit 15:0          reg_ls_flag_inv               // unsigned ,    RW, default = 0  0:reg0 1:reg1 2:i_ls_flg 3:i_ls_flg_inv for long/short expos
#define ISP_TOP_MEAS                               ((0x000a  << 2) + 0xfe3b4000)
//Bit 31:19         reserved
//Bit 18            pls_tmg_rst                    // unsigned ,   W1T, default = 0, //pluse to clr tmg_cnt
//Bit 17            reg_tmg_phase                  // unsigned ,    RW, default = 1, timing_gen enable
//Bit 16            reg_tmg_vsyn_sel               // unsigned ,    RW, default = 0, 0:din_vsyn_dly 1:tim_vsyn
//Bit 15            reg_tmg_hsyn_sel               // unsigned ,    RW, default = 1, 0:din_hsyn     1:ref_hend
//Bit 14            reserved
//Bit 13:12         reg_meas_ref_sel               // unsigned ,    RW, default = 0, for measure line dly
//Bit 11:8          reg_meas_din_sel               // unsigned ,    RW, default = 1
//Bit 7:4           reg_meas_dout_sel              // unsigned ,    RW, default = 7
//Bit 3:0           reserved
#define ISP_TOP_SYN_CTRL                           ((0x000b  << 2) + 0xfe3b4000)
//Bit 31:23         reserved
//Bit 22            reg_din_secure                 // unsigned ,    RW, default = 0
//Bit 21            reg_rdmif1_secure              // unsigned ,    RW, default = 0
//Bit 20            reg_rdmif0_secure              // unsigned ,    RW, default = 0
//Bit 19:18         reserved
//Bit 17:16         reg_din_syn_mode               // unsigned ,    RW, default = 0  sel between din_h/vsyn from mipi & dly bit0 for vsyn bit1 for hsyn
//Bit 15:0          reserved
#define ISP_TOP_TIMGEN                             ((0x000c  << 2) + 0xfe3b4000)
//Bit 31:16         reg_tmg_vtotal                 // unsigned ,    RW, default = 16'hffff
//Bit 15:0          reg_tmg_htotal                 // unsigned ,    RW, default = 1920
#define ISP_TOP_TIMGEN_REF                         ((0x000d  << 2) + 0xfe3b4000)
//Bit 31:16         reg_tmg_ref_vcnt               // unsigned ,    RW, default = 0
//Bit 15:0          reg_tmg_ref_hcnt               // unsigned ,    RW, default = 2
#define ISP_TOP_TIMEGEN_RO_DBG                     ((0x000e  << 2) + 0xfe3b4000)
//Bit 31:16         reserved
//Bit 15:0          ro_ref_vcnt                    // unsigned ,    RO, default = 0
#define ISP_TOP_DBGPATH                            ((0x000f  << 2) + 0xfe3b4000)
//Bit 31:5          reserved
//Bit 4             reg_dbgpath_enable             // unsigned ,    RW, default = 0
//Bit 3:0           reg_dbgpath_src_sel            // unsigned ,    RW, default = 0  source sel for dbgpath 0: dfe 1:obe
#define ISP_TOP_SYN_VS                             ((0x0010  << 2) + 0xfe3b4000)
//Bit 31:0          reg_vs_dly_num                 // unsigned ,    RW, default = 32
#define ISP_PROB_CTRL                              ((0x0011  << 2) + 0xfe3b4000)
//Bit 31:19         reserved
//Bit 18:17         reg_hilight_mode               // unsigned ,    RW, default = 0
//Bit 16            reg_hilight_en                 // unsigned ,    RW, default = 0
//Bit 15:10          reserved
//Bit 9:4           reg_prob_sel                   // unsigned ,    RW, default = 1 0:ofe_din 1:ofe_dout 2:dfe_dout 3: obe_dout 4: dms_dout 5: post_dout
//Bit 3             reserved
//Bit 2             reg_checksum_en                // unsigned ,    RW, default = 0
//Bit 1             reg_prob_clr                   // unsigned ,    RW, default = 0
//Bit 0             reg_prob_en                    // unsigned ,    RW, default = 0
#define ISP_HILT_COLOR                             ((0x0012  << 2) + 0xfe3b4000)
//Bit 31:24         reserved
//Bit 23:0          reg_hilight_color              // unsigned ,    RW, default = 0
#define ISP_PROB_POS                               ((0x0013  << 2) + 0xfe3b4000)
//Bit 31:16         reg_prob_ypos                  // unsigned ,    RW, default = 50
//Bit 15:0          reg_prob_xpos                  // unsigned ,    RW, default = 50
#define ISP_PROB_RO_DAT_0                          ((0x0014  << 2) + 0xfe3b4000)
//Bit 31:0          ro_prob_dat_0                  // unsigned ,    RO, default = 0
#define ISP_PROB_RO_DAT_1                          ((0x0015  << 2) + 0xfe3b4000)
//Bit 31:0          ro_prob_dat_1                  // unsigned ,    RO, default = 0
#define ISP_TOP_IRQ_ABN_EN                         ((0x001f  << 2) + 0xfe3b4000)
//Bit 31:16         reserved
//Bit 15:0          reg_irq_abn_en                 // unsigned ,    RW, default = 1
#define ISP_TOP_IRQ_EN                             ((0x0020  << 2) + 0xfe3b4000)
//Bit 31:0          reg_irq_en                    // unsigned ,    RW, default = 1  //{6'h0, irq_intf,6'h0,din_vsyn_dly,din_vsyn,2'h0,irq_3a_dma_err,irq_abnorm_end,irq_line,frm_en,frm_rst,frm_end}
#define ISP_TOP_IRQ_CLR                            ((0x0021  << 2) + 0xfe3b4000)
//Bit 31:0          pls_irq_clr                   // unsigned ,    W1T, default = 0
#define ISP_TOP_IRQ_LINE_THRD                      ((0x0022  << 2) + 0xfe3b4000)
//Bit 31:20         reserved
//Bit 19:18         reg_irq_pos_flg_rev           // unsigned ,    RW, default = 0, [0]o_irq_flg 0:use flg 1:use pos  [1]:o_irq_pos 0:use pos 1:use flg
//Bit 17:16         reg_irq_line_sel              // unsigned ,    RW, default = 0, irq_line_sel from din_hsyn or core_dout_vcnt
//Bit 15:0          reg_irq_line_thrd             // unsigned ,    RW, default = 16'h100
#define ISP_TOP_RAW_MODE_SEL                       ((0x0023  << 2) + 0xfe3b4000)
//Bit 31:4          reserved
//Bit 3:2           reg_bdryext_mode_ofe          // unsigned ,    RW, default = 0 ,hw_bdryext 0:1x1 repeat else 2x2 repeat
//Bit 1:0           reg_bdryext_mode_dms          // unsigned ,    RW, default = 0 ,hw_bdryext 0:1x1 repeat else 2x2 repeat
#define ISP_TOP_ABN_RDMA                           ((0x0024  << 2) + 0xfe3b4000)
//Bit 31:16         pls_undone_clr                // unsigned ,    W1T, default = 0, frm_undone_clr
//Bit 15:0          reg_undone_en                 // unsigned ,    RW, default = 0, rdma_abnorm_frm_end_en
#define ISP_TOP_RDMA_CTRL                          ((0x0025  << 2) + 0xfe3b4000)
//Bit 31:24         reserved
//Bit 23:16         pls_rdma_start                // unsigned ,    W1T, default= 0,
//Bit 15:8          reg_rdma_abn_en               // unsigned ,    RW, default = 0,
//Bit 7:0           reg_rdma_start_sel            // unsigned ,    RW, default = 0,
#define ISP_TOP_GCLK_CTRL                          ((0x0026  << 2) + 0xfe3b4000)
//Bit 31:24         reserved
//Bit 23:8          reg_core_gclk_ctrl            // unsigned ,    RW, default = 0,
//Bit 7:6           reg_intf_gclk_wr              // unsigned ,    RW, default = 0,
//Bit 5:4           reg_intf_gclk_rd              // unsigned ,    RW, default = 0,
//Bit 3:2           reg_top_gclk_ctrl             // unsigned ,    RW, default = 0,
//Bit 1:0           reg_rgb2y_gclk_ctrl           // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_CTRL                        ((0x0027  << 2) + 0xfe3b4000)
//Bit 31:19         reserved
//Bit 18:3          reg_srcdif_dbg_thrd           // unsigned ,    RW, default = 800, thrd for diff between same pixel from rdmif frame & mipi_din frame
//Bit 2             pls_srcdif_dbg_clr            // unsigned ,    W1T,default = 0, clr pls for ro_dbg_cnt
//Bit 1             reg_srcdif_dbg_mode           // unsigned ,    RW, default = 0, 0: output dbg_cnt 1: output dbg_cnt_max for several frames
//Bit 0             reg_srcdif_dbg_en             // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_START                       ((0x0028  << 2) + 0xfe3b4000)
//Bit 31:16         reg_srcdif_dbg_hstart         // unsigned ,    RW, default = 0,
//Bit 15:0          reg_srcdif_dbg_vstart         // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_SIZE                        ((0x0029  << 2) + 0xfe3b4000)
//Bit 31:16         reg_srcdif_dbg_hsize          // unsigned ,    RW, default = 200,
//Bit 15:0          reg_srcdif_dbg_vsize          // unsigned ,    RW, default = 200,
#define ISP_TOP_SRCDIF_RO_CNT                      ((0x002a  << 2) + 0xfe3b4000)
//Bit 31:0          ro_srcdif_dbg_cnt             // unsigned ,    RO, default = 0,
#define ISP_TOP_IRQ_LINE_THRD1                     ((0x002b  << 2) + 0xfe3b4000)
//Bit 31:16         reserved
//Bit 15:0          reg_irq_line_thrd1             // unsigned ,    RW, default = 16'h200
#define ISP_DMA_CHN_EN                             ((0x002c  << 2) + 0xfe3b4000)
//Bit 31:5          reserved
//Bit 4:0           reg_dma_chn_en                 // unsigned ,    RW, default = 5'h1f
#define ISP_FRM_CNT_CTRL                           ((0x002d  << 2) + 0xfe3b4000)
//Bit 31:28         reg_frm_cnt_sel                      //unsigned,  RW, default = 0, ro_frm_cnt vld src sel
//Bit 27            reserved
//Bit 26            reg_frm_cnt_en                       //unsigned,  RW, default = 0, ro_frm_cnt_enable
//Bit 25            reg_frm_end_cnt_en                   //unsigned,  RW, default = 0, frm_end dly cnt enable
//Bit 24            reg_frm_end_cnt_sel                  //unsigned,  RW, default = 0, rdma_frm_end sel 0:frm_end, 1:frm_end_dly
//Bit 23:0          reg_frm_end_cnt_thrd                 //unsigned,  RW, default = 0, frm_end dly cnt thrd
#define ISP_TOP_CORE_CTRL0                         ((0x0030  << 2) + 0xfe3b4000)
//Bit 31:0          reg_isp_core_ctrl0                   // unsigned ,    RW, default = 0
#define ISP_TOP_CORE_CTRL1                         ((0x0031  << 2) + 0xfe3b4000)
//Bit 31:0          reg_isp_core_ctrl1                   // unsigned ,    RW, default = 0
#define ISP_TOP_FRM_END_MASK                       ((0x0035  << 2) + 0xfe3b4000)
//Bit 31:0          reg_frm_end_mask          // unsigned ,    RW, default = 0  disable frm_end_chn
#define ISP_TOP_AXI_CNT_ID                         ((0x0036  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_axi_cnt_all                  // unsigned ,    RW, default = 0 axi_ro_cnt en
//Bit 19:16        reg_axi_cnt_en                   // unsigned ,    RW, default = 0 axi_ro_cnt en
//Bit 15:12        reg_axi_cnt_id_wr1               // unsigned ,    RW, default = 0 axi_ro_cnt id
//Bit 11:8         reg_axi_cnt_id_wr0               // unsigned ,    RW, default = 0 axi_ro_cnt id
//Bit 7:0          reg_axi_cnt_id_rd0               // unsigned ,    RW, default = 0 axi_ro_cnt id
#define ISP_TOP_OFFLINE_CTRL                       ((0x0038  << 2) + 0xfe3b4000)
//Bit 31:17       reserved
//Bit 16          reg_slice_splt_en             // unsigned ,    RW, default = 0, two slice mode en
//Bit 15:3        reserved
//Bit 2           reg_offline_ena               // unsigned ,    RW, default = 0, offline mode enable
//Bit 1           pls_offline_frm_start         // unsigned ,    W1T, default = 0, offline sw frm_start
//Bit 0           pls_offline_frm_rst           // unsigned ,    W1T, default = 0, offline sw frm_rst
#define ISP_TOP_SLICE_TOTAL_SIZE                   ((0x0039  << 2) + 0xfe3b4000)
//Bit 31:16       reg_slice_tvsize            // unsigned ,    RW, default = 1080  2slice mode,total size
//Bit 15:0        reg_slice_thsize            // unsigned ,    RW, default = 1920  2slice mode,total size
#define ISP_TOP_SLICE_HSCOPE0                      ((0x003a  << 2) + 0xfe3b4000)
//Bit 31:16       reg_slice_hend0            // unsigned ,    RW, default = 1920  2slice mode,slice0 hend
//Bit 15:0        reg_slice_hbgn0            // unsigned ,    RW, default = 0     2slice mode,slice0 hbgn
#define ISP_TOP_SLICE_VSCOPE0                      ((0x003b  << 2) + 0xfe3b4000)
//Bit 31:16       reg_slice_vend0            // unsigned ,    RW, default = 1080  2slice mode,slice0 vend
//Bit 15:0        reg_slice_vbgn0            // unsigned ,    RW, default = 0     2slice mode,slice0 vbgn
#define ISP_TOP_SLICE_HSCOPE1                      ((0x003c  << 2) + 0xfe3b4000)
//Bit 31:16       reg_slice_hend1            // unsigned ,    RW, default = 1920  2slice mode,slice1 hend
//Bit 15:0        reg_slice_hbgn1            // unsigned ,    RW, default = 0     2slice mode,slice1 hbgn
#define ISP_TOP_SLICE_VSCOPE1                      ((0x003d  << 2) + 0xfe3b4000)
//Bit 31:16       reg_slice_vend1            // unsigned ,    RW, default = 1080  2slice mode,slice1 vend
//Bit 15:0        reg_slice_vbgn1            // unsigned ,    RW, default = 0     2slice mode,slice1 vbgn
#define ISP_CHECKSUM_RO_DAT_0                      ((0x0040  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_0                // unsigned ,   RO, default = 0 checksum for ofe_din
#define ISP_CHECKSUM_RO_DAT_1                      ((0x0041  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_1                // unsigned ,   RO, default = 0 checksum for ofe_dout
#define ISP_CHECKSUM_RO_DAT_2                      ((0x0042  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_2                // unsigned ,   RO, default = 0 checksum for dfe_dout
#define ISP_CHECKSUM_RO_DAT_3                      ((0x0043  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_3                // unsigned ,   RO, default = 0 checksum for obe_dout
#define ISP_CHECKSUM_RO_DAT_4                      ((0x0044  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_4                // unsigned ,   RO, default = 0 checksum for dms_dout
#define ISP_CHECKSUM_RO_DAT_5                      ((0x0045  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_5                // unsigned ,   RO, default = 0 checksum for post_dout
#define ISP_CHECKSUM_RO_DAT_6                      ((0x0046  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_6                // unsigned ,   RO, default = 0 checksum for post_ir
#define ISP_CHECKSUM_RO_DAT_7                      ((0x0047  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_7                // unsigned ,   RO, default = 0 checksum for disp_0
#define ISP_CHECKSUM_RO_DAT_8                      ((0x0048  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_8                // unsigned ,   RO, default = 0 checksum for disp_1
#define ISP_CHECKSUM_RO_DAT_9                      ((0x0049  << 2) + 0xfe3b4000)
//Bit 31:0         ro_checksum_dat_9                // unsigned ,   RO, default = 0 checksum for disp_2
#define ISP_TOP_RO_DBG_STAT0                       ((0x0070  << 2) + 0xfe3b4000)
//Bit 31:0          ro_debug_stat0                  // unsigned ,    RO, default = 0 ,[15:0]:isp_undone_vcnt,[31:16]:{corein,ofe,dfe,obe,  dms,post,3a,core,  disp,line,intf,all_end},
#define ISP_TOP_RO_IRQ_STAT                        ((0x0071  << 2) + 0xfe3b4000)
//Bit 31:0          ro_irq_status                   // unsigned ,    RO, default = 0 , {frm_end_dly,irq_line_out1,din_vsyn_dly,din_vsyn_mipi,offline_frm_end,post_int,intf_err_int,irq_3a_dma_err ,irq_abnorm_end,irq_line,frm_en,frm_rst,frm_end}
#define ISP_TOP_RO_MEAS                            ((0x0072  << 2) + 0xfe3b4000)
//Bit 31:16         ro_isp_frm_cnt                  // unsigned ,    RO, default = 0 ,
//Bit 15:0          ro_meas_dly_num                 // unsigned ,    RO, default = 0 ,
#define ISP_TOP_AXI_RO_RD0_STAT                    ((0x0073  << 2) + 0xfe3b4000)
//Bit 31:0          ro_axi_rd0_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR0_STAT                    ((0x0074  << 2) + 0xfe3b4000)
//Bit 31:0          ro_axi_wr0_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR1_STAT                    ((0x0075  << 2) + 0xfe3b4000)
//Bit 31:0          ro_axi_wr1_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR0_RSP                     ((0x0076  << 2) + 0xfe3b4000)
//Bit 31:0          ro_axi_wr0_rsp_cnt              //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR1_RSP                     ((0x0077  << 2) + 0xfe3b4000)
//Bit 31:0          ro_axi_wr1_rsp_cnt              //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_top_hw_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_TOP_APB1_APB_BASE = 0x01
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_TOP_MODE_CTRL                          ((0x0100  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16:12        reg_src_bit_depth         // unsigned ,    RW, default = 14  source data bit depth from input port, support 8bit~14bit
//Bit 11:10        reserved
//Bit  9: 8        reg_src_inp_chn           // unsigned ,    RW, default = 0  the source data channels, support (1+inp_chn) as 1/2/3/4 from input port
//Bit  7: 6        reserved
//Bit  5: 4        reg_wdr_inp_chn           // unsigned ,    RW, default = 0  the input channels for wdr stitch, support (1+inp_chn) as 1/2/3/4 images as wdr stitch's input;
//Bit  3            reserved
//Bit  2: 0        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
#define ISP_TOP_RAW_PHS_0                          ((0x0101  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  phase lut for raw data
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  phase lut for raw data
#define ISP_TOP_RAW_PHS_1                          ((0x0102  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  phase lut for raw data
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  phase lut for raw data
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  phase lut for raw data
#define ISP_TOP_FEO_CTRL0                          ((0x0103  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12           reg_crop_en               // unsigned ,    RW, default = 0  enable crop mode
//Bit 11           reg_bin_en                // unsigned ,    RW, default = 0  enable binning function
//Bit 10           reg_fpnr_en               // unsigned ,    RW, default = 0  1:fpnr enable
//Bit  9           reg_bac_en                // unsigned ,    RW, default = 0  enable binning artifacts correction
//Bit  8           reg_inp_fmt_en            // unsigned ,    RW, default = 1  enable input formatter
//Bit  7           reg_decmp_en              // unsigned ,    RW, default = 0  0: disable decompander for linear src, 1: enable decompander for compander src
//Bit  6           reg_wdr_stat_en           // unsigned ,    RW, default = 0  enable wdr statistic
//Bit  5: 4        reg_expstitch_mode        // unsigned ,    RW, default = 0  0: linear mode (bypass wdr), 1: wdr mode, 2or3: combination mode
//Bit  3: 1        reg_pre_mux_mode          // unsigned ,    RW, default = 0  pre mux mode for front-end output, 4 or else: ch0 before formatter,
//Bit  0           reg_pst_mux_mode          // unsigned ,    RW, default = 0  post mux mode for front-end output, 1: wdr output, 0: no-wdr output
#define ISP_TOP_FEO_CTRL1_0                        ((0x0104  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5           reg_og_en_0               // unsigned ,    RW, default = 1  enable for wdr gain offst adjustment each channels
//Bit  4           reg_pat_en_0              // unsigned ,    RW, default = 0  enable pattern generation
//Bit  3           reg_dpc_en_0              // unsigned ,    RW, default = 1  enable defect pixel correction
//Bit  2           reg_ge_en_0               // unsigned ,    RW, default = 0  enable green equalization
//Bit  1: 0        reg_crossbar_mux_0        // unsigned ,    RW, default = 0  selection for crossbar mux
#define ISP_TOP_FEO_CTRL1_1                        ((0x0105  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5           reg_og_en_1               // unsigned ,    RW, default = 1  enable for wdr gain offst adjustment each channels
//Bit  4           reg_pat_en_1              // unsigned ,    RW, default = 0  enable pattern generation
//Bit  3           reg_dpc_en_1              // unsigned ,    RW, default = 1  enable defect pixel correction
//Bit  2           reg_ge_en_1               // unsigned ,    RW, default = 0  enable green equalization
//Bit  1: 0        reg_crossbar_mux_1        // unsigned ,    RW, default = 1  selection for crossbar mux
#define ISP_TOP_FED_CTRL                           ((0x0106  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:17        reg_flkr_sta_pos          // unsigned ,    RW, default = 1  select flicker statistic position in ISP 0:feo 1:nr 2:post
//Bit 16           reg_dgain_en              // unsigned ,    RW, default = 1  enable digital gain
//Bit 15           reg_fe_bl_en              // unsigned ,    RW, default = 0  enable front end black level
//Bit 14           reg_sqrt_en               // unsigned ,    RW, default = 1  enable for the sqrt function, 0, simple rounding from BIT_DEPTH02 to BIT_DEPTH1; 1: using sqrt lut
//Bit 13           reg_cubic_en              // unsigned ,    RW, default = 0  enable cubic
//Bit 12           reg_cubic_cs_en           // unsigned ,    RW, default = 1  default: 0(0: bayer, 1: yvuy), description: color space mode for snr1 input
//Bit 11           reg_tnr0_en               // unsigned ,    RW, default = 1  enable tnr0, default: 1, range: 0~1
//Bit 10           reg_mc_tnr_en             // unsigned ,    RW, default = 0  enable mc tnr, default: 0, range: 0~1
//Bit  9           reg_snr1_en               // unsigned ,    RW, default = 1  enable snr, default: 1, range: 0~1
//Bit  8: 7        reg_stage2_input_mode     // unsigned ,    RW, default = 2  nr model C/E, default: 2
//Bit  6: 5        reg_rawcnr_enable         // unsigned ,    RW, default = 1  enable of the rawcnr_function, 0: disable; 1: enable,5x5 window, default=1
//Bit  4           reg_flkr_det_en           // unsigned ,    RW, default = 0  enable flicker detection (HW)
//Bit  3           reg_flkr_stat_en          // unsigned ,    RW, default = 0  enable row statistic for flicker detection
//Bit  2           reg_cac_en                // unsigned ,    RW, default = 0  enable of CAC function, o: bypass CAC (power gated); 1: enable CAC
//Bit  1           reg_pdpc_enable           // unsigned ,    RW, default = 1  enable for the post dpc function
//Bit  0           reg_lcge_enable           // unsigned ,    RW, default = 0  enable of the lcge function
#define ISP_TOP_BEO_CTRL                           ((0x0107  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9           reg_eotf_en               // unsigned ,    RW, default = 1  enable for the eotf function, 0, simple rounding from BIT_DEPTH2 to BIT_DEPTH3; 1: using eotf lut
//Bit  8           reg_idgain_en             // unsigned ,    RW, default = 1  enable inv digital gain
//Bit  7           reg_blc_en                // unsigned ,    RW, default = 1  enable black level correction
//Bit  6           reg_wb_en                 // unsigned ,    RW, default = 1  enable white balance gain
//Bit  5           reg_wb_switch             // unsigned ,    RW, default = 0  0: wb before radial and mesh shading, 1: wb after radial and mesh shading
//Bit  4           reg_lns_rad_en            // unsigned ,    RW, default = 0  shading enable
//Bit  3           reg_lns_mesh_en           // unsigned ,    RW, default = 0  mesh shading enable
//Bit  2           reg_gtm_en                // unsigned ,    RW, default = 0  enable tone mapping
//Bit  1           reg_ltm_en                // unsigned ,    RW, default = 0  enable local tone mapping
//Bit  0            reserved
#define ISP_TOP_BED_CTRL                           ((0x0108  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25           reg_amcm_en               // unsigned ,    RW, default = 1  amcm enable
//Bit 24:22        reserved
//Bit 21           reg_pst_tnr_lite_en       // unsigned ,    RW, default = 1
//Bit 20           reg_mirror_en             // unsigned ,    RW, default = 0  enable horizontal flipping
//Bit 19           reg_dmsc_en               // unsigned ,    RW, default = 1  enable demosaic
//Bit 18           reg_ccm_en                // unsigned ,    RW, default = 1  enable color correction matrix, 0=off 1=on
//Bit 17           reg_lut3d_en              // unsigned ,    RW, default = 1  signal for lut3d ip
//Bit 16           reg_pst_gamma_en          // unsigned ,    RW, default = 1  enable rgb gamma lut, tuning curve gamma, default as off
//Bit 15           reg_dgamma_en             // unsigned ,    RW, default = 0  display gamma, should be enable
//Bit 14           reg_cm0_en                // unsigned ,    RW, default = 1  enable color matrix 0
//Bit 13           reg_cm1_en                // unsigned ,    RW, default = 1  enable color matrix 1
//Bit 12            reserved
//Bit 11           reg_cnr2_en               // unsigned ,    RW, default = 1  cnr2 enable
//Bit 10           reg_bsc_en                // unsigned ,    RW, default = 1  enable bsc adjust
//Bit  9           reg_ir_plus_en            // unsigned ,    RW, default = 0  enable Ir plus function
//Bit  8           reg_lc_en                 // unsigned ,    RW, default = 0  enable local contrast
//Bit  7           reg_dhz_en                // unsigned ,    RW, default = 0  enable dehaze
//Bit  6           reg_dnlp_en               // unsigned ,    RW, default = 0  enable dnlp contrast
//Bit  5           reg_pk_en                 // unsigned ,    RW, default = 0  enable peaking for sharpness
//Bit  4           reg_nr_en                 // unsigned ,    RW, default = 0  enable noise reduction for sharpness
//Bit  3           reg_fmeter_en             // unsigned ,    RW, default = 1  enable fmeter fucntion
//Bit  2           reg_grph_en               // unsigned ,    RW, default = 1  enable graphic statistic
//Bit  1: 0        reg_yhs_sta_en            // unsigned ,    RW, default = 1
#define ISP_TOP_3A_STAT_CRTL                       ((0x0109  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_awb_stat_mux          // unsigned ,    RW, default = 0  mux input data in feo for awb statistic
//Bit 19:17        reserved
//Bit 16           reg_ae_stat_mux           // unsigned ,    RW, default = 0  mux input data in feo for awb statistic
//Bit 15:14        reserved
//Bit 13:12        reg_af_stat_switch        // unsigned ,    RW, default = 1  0: from snr, 1: from dms pp, 2or3: from sharpness, switch of auto focus statistics
//Bit 11:10        reserved
//Bit  9: 8        reg_ae_stat_switch        // unsigned ,    RW, default = 2  0: from GE, 1: from MLS, 2: Before DRC, 3: After DRC, switch of ae statistic
//Bit  7            reserved
//Bit  6: 4        reg_awb_stat_switch       // unsigned ,    RW, default = 2  0: from FE, 1: from GE, 2: before WB, 3: after WB, 4: from DRC, 5 or else: from PEK, switch of awb statistic
//Bit  3            reserved
//Bit  2           reg_af_stat_en            // unsigned ,    RW, default = 1  enable af statistic
//Bit  1           reg_awb_stat_en           // unsigned ,    RW, default = 1  enable awb statistic
//Bit  0           reg_ae_stat_en            // unsigned ,    RW, default = 1  enable ae statistic
#define ISP_TOP_BYPASS                             ((0x010a  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_bypass_feo            // unsigned ,    RW, default = 0  bypass ch0~2 after TPG and the wdr stich output for md
#define ISP_TOP_STITCH_CTRL                        ((0x010b  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16: 1        reg_stch_ovlp_num         // unsigned ,    RW, default = 160  number of overlap pixels in left/right slice mode
//Bit  0           reg_two_slic_mode         // unsigned ,    RW, default = 0  stitch enable
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB0_APB_BASE = 0x02
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GE0_CTRL                               ((0x0200  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_ge_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for ge
//Bit 15:14        reserved
//Bit 13:12        reg_ge_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for ge
//Bit 11: 9        reserved
//Bit  8           reg_ge_rpt_mode           // unsigned ,    RW, default = 1  0: repeat, 1: mirror, repeat mode for green equalization
//Bit  7: 0        reg_ge_edge_rs            // unsigned ,    RW, default = 128  for edge shift
#define ISP_GE0_STAT                               ((0x0201  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ge_stat_edge_thd      // unsigned ,    RW, default = 16  edge threshold for ge statistic
#define ISP_GE0_COMM                               ((0x0202  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17: 8        reg_ge_hv_thrd            // unsigned ,    RW, default = 34  ge, if absdiff > reg_ge_hv_thrd, weight, 0, if absidff < reg_ge_hv_thrd, do filter
//Bit  7: 0        reg_ge_final_bld          // unsigned ,    RW, default = 0  heavy ge and ge blend ratio, 0 use ge_lpf, 255 use ge_dlt
#define ISP_GE0_HV_RATIO                           ((0x0203  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ge_hv_ratio_0         // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_hv_ratio_1         // unsigned ,    RW, default = 12
//Bit  7: 0        reg_ge_hv_ratio_2         // unsigned ,    RW, default = 28
#define ISP_GE0_HV_WT2                             ((0x0204  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_hv_wtlut_0         // unsigned ,    RW, default = 64  when making the weighted average, the weights need to be looked up according to the diff
//Bit 23:16        reg_ge_hv_wtlut_1         // unsigned ,    RW, default = 84  when making the weighted average, the weights need to be looked up according to the diff
//Bit 15: 8        reg_ge_hv_wtlut_2         // unsigned ,    RW, default = 96  when making the weighted average, the weights need to be looked up according to the diff
//Bit  7: 0        reg_ge_hv_wtlut_3         // unsigned ,    RW, default = 128  when making the weighted average, the weights need to be looked up according to the diff
#define ISP_GE0_GI_LUT0                            ((0x0205  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_gi_lut_0           // unsigned ,    RW, default = 24  GI_LUT
//Bit 23:16        reg_ge_gi_lut_1           // unsigned ,    RW, default = 24  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_2           // unsigned ,    RW, default = 12  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_3           // unsigned ,    RW, default = 12  GI_LUT
#define ISP_GE0_GI_LUT1                            ((0x0206  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_gi_lut_4           // unsigned ,    RW, default = 10  GI_LUT
//Bit 23:16        reg_ge_gi_lut_5           // unsigned ,    RW, default = 10  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_6           // unsigned ,    RW, default = 5  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_7           // unsigned ,    RW, default = 5  GI_LUT
#define ISP_GE0_DLT_CTRL1                          ((0x0207  << 2) + 0xfe3b4000)
//Bit 31:30        reg_ge_gi_lut_sft         // signed ,    RW, default = 0  ge_gi_lut_shift
//Bit 29:25        reg_max_ge_dlt_ratio      // unsigned ,    RW, default = 31  ge_max_delta_ratio
//Bit 24           reg_ge_dlt_real_max_en    // unsigned ,    RW, default = 1  ge_delta_real_max enable
//Bit 23:16        reg_ge_dlt_bld_th0        // unsigned ,    RW, default = 10  ge_delta_blend_th0
//Bit 15:12        reg_ge_dlt_bld_thn        // unsigned ,    RW, default = 5  ge_delta_blend_thn
//Bit 11: 6        reg_ge_dlt_bld_alph0      // unsigned ,    RW, default = 48  ge_delta_blend_alpha0
//Bit  5: 0        reg_ge_dlt_bld_alph1      // unsigned ,    RW, default = 48  ge_delta_blend_alpha1
#define ISP_GE0_DLT_CTRL2                          ((0x0208  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:17        reg_ge_lpf_blend_alp      // unsigned ,    RW, default = 0  ge_out_dlt use lpf data centered gr/gb and neighbor gbs/grs
//Bit 16           reg_ge_dlt_edge_en        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_dlt_edge_ratio_0   // unsigned ,    RW, default = 8
//Bit  7: 0        reg_ge_dlt_edge_ratio_1   // unsigned ,    RW, default = 8
#define ISP_GE0_CORE                               ((0x0209  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ge_coring             // unsigned ,    RW, default = 0  coring for ge difference and edge calc
#define ISP_OG0_OFST0                              ((0x020a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_0         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gr for wdr previous offset each color each channels
//Bit 15: 6        reserved
//Bit  5: 4        reg_og_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for offset/gain
//Bit  3: 2        reserved
//Bit  1: 0        reg_og_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for offset/gain
#define ISP_OG0_OFST12                             ((0x020b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_2         // unsigned ,    RW, default = 0  (BIT_DEPTH01), B  for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_1         // unsigned ,    RW, default = 0  (BIT_DEPTH01), R  for wdr previous offset each color each channels
#define ISP_OG0_OFST34                             ((0x020c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_4         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_3         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gb for wdr previous offset each color each channels
#define ISP_OG0_GAIN_PST                           ((0x020d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_0             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pst_ofst           // unsigned ,    RW, default = 0  (BIT_DEPTH01), for wdr post offset each channels
#define ISP_OG0_GAIN1                              ((0x020e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_1             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_2             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_OG0_GAIN2                              ((0x020f  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_3             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_4             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_FPNR0_CTRL_CORR                        ((0x0210  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_fpnr_corr_en          // unsigned ,    RW, default = 1  fpnr correction enable for each channel
#define ISP_FPNR0_CORR_GAIN_0                      ((0x0211  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_0     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_0     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_1                      ((0x0212  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_1     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_1     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_2                      ((0x0213  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_2     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_2     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_3                      ((0x0214  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_3     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_3     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_4                      ((0x0215  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_4     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_4     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_OFST_0                      ((0x0216  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_0      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_1                      ((0x0217  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_1      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_2                      ((0x0218  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_2      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_3                      ((0x0219  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_3      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_4                      ((0x021a  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_4      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_LUT_ADDR                         ((0x021e  << 2) + 0xfe3b4000)
//Bit 31:0        reg_fpnr_lut_addr         // unsigned, RW, default=0, fpnr lut addr
#define ISP_FPNR0_LUT_DATA                         ((0x021f  << 2) + 0xfe3b4000)
//Bit 31:0        reg_fpnr_lut_data         // unsigned, RW, default=0, fpnr lut data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_PAT0_CTRL                              ((0x0220  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13:12        reg_pat_xphs_ofst         // unsigned ,    RW, default = 1  x phase offset for pattern generation
//Bit 11:10        reg_pat_yphs_ofst         // unsigned ,    RW, default = 0  y phase offset for pattern generation
//Bit  9: 8        reg_pat_dft_mode          // unsigned ,    RW, default = 0  0 no dft; 1 dead pixel 2: hot pixel; 3: not dft
//Bit  7: 5        reg_pat_xmode             // unsigned ,    RW, default = 0  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along x-direction
//Bit  4: 2        reg_pat_ymode             // unsigned ,    RW, default = 3  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along y-direction
//Bit  1           reg_pat_xinvt             // unsigned ,    RW, default = 0  invert along x-direction
//Bit  0           reg_pat_yinvt             // unsigned ,    RW, default = 0  invert along y-direction
#define ISP_PAT0_IDX_SCL                           ((0x0221  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_scale        // unsigned ,    RW, default = 32  index scale, 1<<(15-reg_pat_xidx_rshft) / HSIZE
//Bit 15: 4        reg_pat_yidx_scale        // unsigned ,    RW, default = 46  index scale, 1<<(15-reg_pat_yidx_rshft) / VSIZE
//Bit  3: 2        reg_pat_xidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for x index
//Bit  1: 0        reg_pat_yidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for y index
#define ISP_PAT0_IDX_OFST                          ((0x0222  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_ofset        // unsigned ,    RW, default = 0  x index offset for pattern generation
//Bit 15:12        reserved
//Bit 11: 0        reg_pat_yidx_ofset        // unsigned ,    RW, default = 0  y index offset for pattern generation
#define ISP_PAT0_FWIN_R                            ((0x0223  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_0        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15: 2        reserved
//Bit  1           reg_pat_fwin_clr_chk      // unsigned ,    RW, default = 1  color checker for foreground window
//Bit  0           reg_pat_fwin_en           // unsigned ,    RW, default = 1  enable foreground window
#define ISP_PAT0_FWIN_GB                           ((0x0224  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_2        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_fwin_rgb_1        // unsigned ,    RW, default = 1023  rgb of foreground window
#define ISP_PAT0_FWIN_START                        ((0x0225  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hstart       // unsigned ,    RW, default = 480  horizontal start of foreground window
//Bit 15: 0        reg_pat_fwin_vstart       // unsigned ,    RW, default = 270  vertical start of foreground window
#define ISP_PAT0_FWIN_SIZE                         ((0x0226  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hsize        // unsigned ,    RW, default = 960  horizontal size of foreground window
//Bit 15: 0        reg_pat_fwin_vsize        // unsigned ,    RW, default = 540  vertical size of foreground window
#define ISP_PAT0_FWIN_BLK_SIZE                     ((0x0227  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hblk_size    // unsigned ,    RW, default = 160  horizontal block size of foreground window
//Bit 15: 0        reg_pat_fwin_vblk_size    // unsigned ,    RW, default = 135  vertical block size of foreground window
#define ISP_PAT0_IR_MODE                           ((0x0228  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 27:26        reserved
//Bit 15:10        reserved
#define ISP_PAT0_XRMP_SRGB                         ((0x0229  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_xrmp_scalergb_2   // unsigned ,    RW, default = 255  B x ramp scale for pattern generation
//Bit 15: 8        reg_pat_xrmp_scalergb_1   // unsigned ,    RW, default = 255  G x ramp scale for pattern generation
//Bit  7: 0        reg_pat_xrmp_scalergb_0   // unsigned ,    RW, default = 255  R x ramp scale for pattern generation
#define ISP_PAT0_YRMP_SRGB                         ((0x022a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_yrmp_scalergb_2   // unsigned ,    RW, default = 0  B y ramp scale for pattern generation
//Bit 15: 8        reg_pat_yrmp_scalergb_1   // unsigned ,    RW, default = 0  G y ramp scale for pattern generation
//Bit  7: 0        reg_pat_yrmp_scalergb_0   // unsigned ,    RW, default = 0  R y ramp scale for pattern generation
#define ISP_PAT0_BAR24_R01                         ((0x022b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R23                         ((0x022c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_2      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R45                         ((0x022d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_5      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_4      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R67                         ((0x022e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_6      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R89                         ((0x022f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_R1011                       ((0x0230  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_R1213                       ((0x0231  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_R1415                       ((0x0232  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_R1617                       ((0x0233  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R1819                       ((0x0234  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R2021                       ((0x0235  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R2223                       ((0x0236  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G01                         ((0x0237  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G23                         ((0x0238  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_3      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_2      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G45                         ((0x0239  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_4      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G67                         ((0x023a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_6      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G89                         ((0x023b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_G1011                       ((0x023c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_G1213                       ((0x023d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_G1415                       ((0x023e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_G1617                       ((0x023f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G1819                       ((0x0240  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G2021                       ((0x0241  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G2223                       ((0x0242  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_B01                         ((0x0243  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_1      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B23                         ((0x0244  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_2      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B45                         ((0x0245  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_4      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B67                         ((0x0246  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_6      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B89                         ((0x0247  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_B1011                       ((0x0248  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_B1213                       ((0x0249  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_B1415                       ((0x024a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_B1617                       ((0x024b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B1819                       ((0x024c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_B2021                       ((0x024d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B2223                       ((0x024e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_DFT_XIDX                          ((0x024f  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_dft_xidx          // unsigned ,    RW, default = 100  x index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_xwid          // unsigned ,    RW, default = 100  x window for defeat pixel on pattern
#define ISP_PAT0_DFT_YIDX                          ((0x0250  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_dft_yidx          // unsigned ,    RW, default = 200  y index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_ywid          // unsigned ,    RW, default = 1  y window for defeat pixel on pattern
#define ISP_PAT0_DFT_GAIN                          ((0x0251  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pat_dft_gaingrbg_3    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 23:22        reserved
//Bit 21:16        reg_pat_dft_gaingrbg_2    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 15:14        reserved
//Bit 13: 8        reg_pat_dft_gaingrbg_1    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit  7: 6        reserved
//Bit  5: 0        reg_pat_dft_gaingrbg_0    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC0_CNTL                              ((0x0260  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13:12        reg_dpc_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 11:10        reserved
//Bit  9: 8        reg_dpc_xphs_ofst         // unsigned ,    RW, default = 1
//Bit  7: 5        reserved
//Bit  4           reg_dpc_det_en            // unsigned ,    RW, default = 1  1 = enable defect pixel detection, 0 = diable
//Bit  3: 1        reserved
//Bit  0           reg_dpc_cor_en            // unsigned ,    RW, default = 1  1 = enable defect pixel correction, 0 = disable
#define ISP_DPC0_AVG_GAIN0                         ((0x0261  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h0       // unsigned ,    RW, default = 512  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l0       // unsigned ,    RW, default = 128  is used to set the gain of average
#define ISP_DPC0_AVG_GAIN1                         ((0x0262  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h1       // unsigned ,    RW, default = 435  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l1       // unsigned ,    RW, default = 150  is used to set the gain of average
#define ISP_DPC0_AVG_GAIN2                         ((0x0263  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h2       // unsigned ,    RW, default = 332  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l2       // unsigned ,    RW, default = 196  is used to set the gain of average
#define ISP_DPC0_VAR_THD                           ((0x0264  << 2) + 0xfe3b4000)
//Bit 31:24        reg_dpc_cond_en           // unsigned ,    RW, default = 0  is used to enable some condition constraint.
//Bit 23:19        reserved
//Bit 18:16        reg_dpc_cnt_thd           // unsigned ,    RW, default = 3  it is used to set the judge threshold for variance of 8 pixels at same channel
//Bit 15:11        reserved
//Bit 10: 8        reg_dpc_var2_sft0         // unsigned ,    RW, default = 4  it is used to set the judge threshold for variance of 4 pixels at same channel
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_var2_sft1         // unsigned ,    RW, default = 6  it is used to set the judge threshold for variance of 4 pixels at same channel
#define ISP_DPC0_AVG_SFT_CTRL                      ((0x0265  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:16        reg_dpc_avg_diff_sft2     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit 15            reserved
//Bit 14:12        reg_dpc_avg_thd_sft1      // unsigned ,    RW, default = 3  it is used to select the shift1 in avg thd
//Bit 11            reserved
//Bit 10: 8        reg_dpc_avg_thd_sft0      // unsigned ,    RW, default = 3  it is used to select the shift0 in avg thd
//Bit  7            reserved
//Bit  6: 4        reg_dpc_avg_diff_sft1     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit  3            reserved
//Bit  2: 0        reg_dpc_avg_diff_sft0     // unsigned ,    RW, default = 3  it is used to select the shift0 in avg diff
#define ISP_DPC0_VAR_GAIN                          ((0x0266  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_bld_auto_dis      // unsigned ,    RW, default = 0  it is used to disable the auto blending alpha
//Bit 23:21        reserved
//Bit 20           reg_dpc_avg_thd2_en       // unsigned ,    RW, default = 1  it is used to enable the avg_thd2
//Bit 19            reserved
//Bit 18:16        reg_dpc_avg_sft           // unsigned ,    RW, default = 3  it is used to set the shift of avg in avg_thd2 calculation
//Bit 15            reserved
//Bit 14:12        reg_dpc_var_gain_00       // unsigned ,    RW, default = 2  it is used to set the gain for variance
//Bit 11            reserved
//Bit 10: 8        reg_dpc_var_gain_01       // unsigned ,    RW, default = 1  it is used to set the gain for variance
//Bit  7            reserved
//Bit  6: 4        reg_dpc_var_gain_10       // unsigned ,    RW, default = 4  it is used to set the gain for variance
//Bit  3            reserved
//Bit  2: 0        reg_dpc_var_gain_11       // unsigned ,    RW, default = 2  it is used to set the gain for variance
#define ISP_DPC0_STD_GAIN                          ((0x0267  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24:20        reg_dpc_std_gain          // unsigned ,    RW, default = 12  is used to set the gain of standard bias
//Bit 19:13        reserved
//Bit 12: 8        reg_dpc_std_diff_gain     // unsigned ,    RW, default = 16  is used to set the difference gain of standard bias
//Bit  7: 0        reg_dpc_max_min_bias_thd  // unsigned ,    RW, default = 20  is used to set the threshold between maximum standard bias and minimum one
#define ISP_DPC0_AVG_MOD                           ((0x0268  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:10        reg_dpc_low_thd           // unsigned ,    RW, default = 50  is used to set the low theshold for dp_x6
//Bit  9: 8        reg_dpc_avg_mode          // unsigned ,    RW, default = 3  0 = auto selection average value between avg6 and avg4,1 = avg6, 2 = avg4, 3 = avg8
//Bit  7: 0        reg_dpc_avg_bias_thd      // unsigned ,    RW, default = 40  it is used to set theshold for selecting the average value
#define ISP_DPC0_AVG_DEV                           ((0x0269  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_dpc_avg_dev_sft       // unsigned ,    RW, default = 3  it is used to set the avg_dev shift
//Bit 27:25        reserved
//Bit 24           reg_dpc_avg_dev_mode      // unsigned ,    RW, default = 0  it is used to set the mode for calculation of average bias. 0 = variance+offset, 1 = offset
//Bit 23:16        reg_dpc_avg_dev_offset    // unsigned ,    RW, default = 20  it is used to set the offset for average bias
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_blend_alpha   // unsigned ,    RW, default = 12'h800  it used to set the blending alpha for average deviation and standard deviation
#define ISP_DPC0_DEV_DP                            ((0x026a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_dpc_dev_dp_offset     // unsigned ,    RW, default = 30  it is used to set the threshold for deviation mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_dp_slope      // unsigned ,    RW, default = 82  it is used to set the slope for deviation mapping
#define ISP_DPC0_X1_2_CTRL                         ((0x026b  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21: 8        reg_dpc_low_thd_top       // unsigned ,    RW, default = 50  is used to set the low theshold for top
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_x2_rank_lim       // unsigned ,    RW, default = 2  it is used to set the rank limit.
#define ISP_DPC0_X6_CTRL                           ((0x026c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_high_gain         // unsigned ,    RW, default = 256  it is used to set the gain
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_diff_ratio        // unsigned ,    RW, default = 213  it is used to set the diff gain
#define ISP_DPC0_COR_CTRL                          ((0x026d  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_vote_en           // unsigned ,    RW, default = 0  it is used to enable the detection vote. 1= enable, 0=disable
//Bit 23            reserved
//Bit 22:16        reg_dpc_flag_en           // unsigned ,    RW, default = 1  it is used to enbale the detection flag.
//Bit 15            reserved
//Bit 14:12        reg_dpc_vote_thd          // unsigned ,    RW, default = 3  it is used to set the vote threshold.
//Bit 11            reserved
//Bit 10: 8        reg_dpc_ud_mode           // unsigned ,    RW, default = 4  it is used to set the mode for un-diretioanal estimation.0= auto,1=median,2= avg6, 3=avg4,4=avg8,
//Bit  7: 5        reserved
//Bit  4           reg_dpc_highlight_en      // unsigned ,    RW, default = 0  it is used to enable highlighting the defect pixels. 1= enbale, 0=disable
//Bit  3: 2        reserved
//Bit  1: 0        reg_dpc_correct_mode      // unsigned ,    RW, default = 2  it is used to set the correction mode.0= disable, 1= static, 2= dynamic, 3=static or dynamic
#define ISP_DPC0_BLEND                             ((0x026e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_dpc_cor_blend_alpha   // unsigned ,    RW, default = 12'h800  it is used to set the blending alpha for directional estimation and un-directional estimation
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_org_blend_alpha   // unsigned ,    RW, default = 12'hfff  it is used to set the blending alpha for estimation and original value.
#define ISP_DPC0_LUT_CTRL                          ((0x026f  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:20        reg_dpc_lut_start         // unsigned ,    RW, default = 0  it is used to set the start position of table
//Bit 19:17        reserved
//Bit 16           reg_dpc_write_to_lut      // unsigned ,    RW, default = 0  it is used to write the defect pixel position into memory
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_writeto_lut_stline // unsigned ,    RW, default = 0  it is used to set the start line to write to memory
#define ISP_DPC0_SDP_NUM                           ((0x0270  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 0        ro_dpc_sdp_num            // unsigned ,    RO, default = 0  it is used to report the number of the static defect pixel
#define ISP_DPC0_DDP_NUM                           ((0x0271  << 2) + 0xfe3b4000)
//Bit 31:16        ro_dpc_ddp_num            // unsigned ,    RO, default = 0  it is used to report the number of the dynamic defect pixel
//Bit 15: 0        ro_dpc_defect_num         // unsigned ,    RO, default = 0  it is used to report the number of the defect pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC0_LUT1024_ADDR                      ((0x0280  << 2) + 0xfe3b4000)
//Bit 31:0      isp_dpc_lut1024_addr              // unsigned , RW, default=0
#define ISP_DPC0_LUT1024_DATA                      ((0x0281  << 2) + 0xfe3b4000)
//Bit 31:0      isp_dpc_lut1024_data              // unsigned , RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB1_APB_BASE = 0x03
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GE1_CTRL                               ((0x0300  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_ge_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for ge
//Bit 15:14        reserved
//Bit 13:12        reg_ge_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for ge
//Bit 11: 9        reserved
//Bit  8           reg_ge_rpt_mode           // unsigned ,    RW, default = 1  0: repeat, 1: mirror, repeat mode for green equalization
//Bit  7: 0        reg_ge_edge_rs            // unsigned ,    RW, default = 128  for edge shift
#define ISP_GE1_STAT                               ((0x0301  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ge_stat_edge_thd      // unsigned ,    RW, default = 16  edge threshold for ge statistic
#define ISP_GE1_COMM                               ((0x0302  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17: 8        reg_ge_hv_thrd            // unsigned ,    RW, default = 34  ge, if absdiff > reg_ge_hv_thrd, weight, 0, if absidff < reg_ge_hv_thrd, do filter
//Bit  7: 0        reg_ge_final_bld          // unsigned ,    RW, default = 0  heavy ge and ge blend ratio, 0 use ge_lpf, 255 use ge_dlt
#define ISP_GE1_HV_RATIO                           ((0x0303  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ge_hv_ratio_0         // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_hv_ratio_1         // unsigned ,    RW, default = 12
//Bit  7: 0        reg_ge_hv_ratio_2         // unsigned ,    RW, default = 28
#define ISP_GE1_HV_WT2                             ((0x0304  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_hv_wtlut_0         // unsigned ,    RW, default = 64  when making the weighted average, the weights need to be looked up according to the diff
//Bit 23:16        reg_ge_hv_wtlut_1         // unsigned ,    RW, default = 84  when making the weighted average, the weights need to be looked up according to the diff
//Bit 15: 8        reg_ge_hv_wtlut_2         // unsigned ,    RW, default = 96  when making the weighted average, the weights need to be looked up according to the diff
//Bit  7: 0        reg_ge_hv_wtlut_3         // unsigned ,    RW, default = 128  when making the weighted average, the weights need to be looked up according to the diff
#define ISP_GE1_GI_LUT0                            ((0x0305  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_gi_lut_0           // unsigned ,    RW, default = 24  GI_LUT
//Bit 23:16        reg_ge_gi_lut_1           // unsigned ,    RW, default = 24  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_2           // unsigned ,    RW, default = 12  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_3           // unsigned ,    RW, default = 12  GI_LUT
#define ISP_GE1_GI_LUT1                            ((0x0306  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ge_gi_lut_4           // unsigned ,    RW, default = 10  GI_LUT
//Bit 23:16        reg_ge_gi_lut_5           // unsigned ,    RW, default = 10  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_6           // unsigned ,    RW, default = 5  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_7           // unsigned ,    RW, default = 5  GI_LUT
#define ISP_GE1_DLT_CTRL1                          ((0x0307  << 2) + 0xfe3b4000)
//Bit 31:30        reg_ge_gi_lut_sft         // signed ,    RW, default = 0  ge_gi_lut_shift
//Bit 29:25        reg_max_ge_dlt_ratio      // unsigned ,    RW, default = 31  ge_max_delta_ratio
//Bit 24           reg_ge_dlt_real_max_en    // unsigned ,    RW, default = 1  ge_delta_real_max enable
//Bit 23:16        reg_ge_dlt_bld_th0        // unsigned ,    RW, default = 10  ge_delta_blend_th0
//Bit 15:12        reg_ge_dlt_bld_thn        // unsigned ,    RW, default = 5  ge_delta_blend_thn
//Bit 11: 6        reg_ge_dlt_bld_alph0      // unsigned ,    RW, default = 48  ge_delta_blend_alpha0
//Bit  5: 0        reg_ge_dlt_bld_alph1      // unsigned ,    RW, default = 48  ge_delta_blend_alpha1
#define ISP_GE1_DLT_CTRL2                          ((0x0308  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:17        reg_ge_lpf_blend_alp      // unsigned ,    RW, default = 0  ge_out_dlt use lpf data centered gr/gb and neighbor gbs/grs
//Bit 16           reg_ge_dlt_edge_en        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_dlt_edge_ratio_0   // unsigned ,    RW, default = 8
//Bit  7: 0        reg_ge_dlt_edge_ratio_1   // unsigned ,    RW, default = 8
#define ISP_GE1_CORE                               ((0x0309  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ge_coring             // unsigned ,    RW, default = 0  coring for ge difference and edge calc
#define ISP_OG1_OFST0                              ((0x030a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_0         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gr for wdr previous offset each color each channels
//Bit 15: 6        reserved
//Bit  5: 4        reg_og_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for offset/gain
//Bit  3: 2        reserved
//Bit  1: 0        reg_og_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for offset/gain
#define ISP_OG1_OFST12                             ((0x030b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_2         // unsigned ,    RW, default = 0  (BIT_DEPTH01), B  for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_1         // unsigned ,    RW, default = 0  (BIT_DEPTH01), R  for wdr previous offset each color each channels
#define ISP_OG1_OFST34                             ((0x030c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_4         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_3         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gb for wdr previous offset each color each channels
#define ISP_OG1_GAIN_PST                           ((0x030d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_0             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pst_ofst           // unsigned ,    RW, default = 0  (BIT_DEPTH01), for wdr post offset each channels
#define ISP_OG1_GAIN1                              ((0x030e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_1             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_2             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_OG1_GAIN2                              ((0x030f  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_3             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_4             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_FPNR1_CTRL_CORR                        ((0x0310  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_fpnr_corr_en          // unsigned ,    RW, default = 1  fpnr correction enable for each channel
#define ISP_FPNR1_CORR_GAIN_0                      ((0x0311  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_0     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_0     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_1                      ((0x0312  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_1     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_1     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_2                      ((0x0313  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_2     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_2     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_3                      ((0x0314  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_3     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_3     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_4                      ((0x0315  << 2) + 0xfe3b4000)
//Bit 31:16        reg_fpnr_corr_gain0_4     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_4     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_OFST_0                      ((0x0316  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_0      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_1                      ((0x0317  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_1      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_2                      ((0x0318  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_2      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_3                      ((0x0319  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_3      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_4                      ((0x031a  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_4      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_LUT_ADDR                         ((0x031e  << 2) + 0xfe3b4000)
//Bit 31:0        reg_fpnr_lut_addr         // unsigned, RW, default=0, fpnr lut addr
#define ISP_FPNR1_LUT_DATA                         ((0x031f  << 2) + 0xfe3b4000)
//Bit 31:0        reg_fpnr_lut_data         // unsigned, RW, default=0, fpnr lut data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_PAT1_CTRL                              ((0x0320  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13:12        reg_pat_xphs_ofst         // unsigned ,    RW, default = 1  x phase offset for pattern generation
//Bit 11:10        reg_pat_yphs_ofst         // unsigned ,    RW, default = 0  y phase offset for pattern generation
//Bit  9: 8        reg_pat_dft_mode          // unsigned ,    RW, default = 0  0 no dft; 1 dead pixel 2: hot pixel; 3: not dft
//Bit  7: 5        reg_pat_xmode             // unsigned ,    RW, default = 0  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along x-direction
//Bit  4: 2        reg_pat_ymode             // unsigned ,    RW, default = 3  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along y-direction
//Bit  1           reg_pat_xinvt             // unsigned ,    RW, default = 0  invert along x-direction
//Bit  0           reg_pat_yinvt             // unsigned ,    RW, default = 0  invert along y-direction
#define ISP_PAT1_IDX_SCL                           ((0x0321  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_scale        // unsigned ,    RW, default = 32  index scale, 1<<(15-reg_pat_xidx_rshft) / HSIZE
//Bit 15: 4        reg_pat_yidx_scale        // unsigned ,    RW, default = 46  index scale, 1<<(15-reg_pat_yidx_rshft) / VSIZE
//Bit  3: 2        reg_pat_xidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for x index
//Bit  1: 0        reg_pat_yidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for y index
#define ISP_PAT1_IDX_OFST                          ((0x0322  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_ofset        // unsigned ,    RW, default = 0  x index offset for pattern generation
//Bit 15:12        reserved
//Bit 11: 0        reg_pat_yidx_ofset        // unsigned ,    RW, default = 0  y index offset for pattern generation
#define ISP_PAT1_FWIN_R                            ((0x0323  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_0        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15: 2        reserved
//Bit  1           reg_pat_fwin_clr_chk      // unsigned ,    RW, default = 1  color checker for foreground window
//Bit  0           reg_pat_fwin_en           // unsigned ,    RW, default = 1  enable foreground window
#define ISP_PAT1_FWIN_GB                           ((0x0324  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_2        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_fwin_rgb_1        // unsigned ,    RW, default = 1023  rgb of foreground window
#define ISP_PAT1_FWIN_START                        ((0x0325  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hstart       // unsigned ,    RW, default = 480  horizontal start of foreground window
//Bit 15: 0        reg_pat_fwin_vstart       // unsigned ,    RW, default = 270  vertical start of foreground window
#define ISP_PAT1_FWIN_SIZE                         ((0x0326  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hsize        // unsigned ,    RW, default = 960  horizontal size of foreground window
//Bit 15: 0        reg_pat_fwin_vsize        // unsigned ,    RW, default = 540  vertical size of foreground window
#define ISP_PAT1_FWIN_BLK_SIZE                     ((0x0327  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_fwin_hblk_size    // unsigned ,    RW, default = 160  horizontal block size of foreground window
//Bit 15: 0        reg_pat_fwin_vblk_size    // unsigned ,    RW, default = 135  vertical block size of foreground window
#define ISP_PAT1_IR_MODE                           ((0x0328  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 27:26        reserved
//Bit 15:10        reserved
#define ISP_PAT1_XRMP_SRGB                         ((0x0329  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_xrmp_scalergb_2   // unsigned ,    RW, default = 255  B x ramp scale for pattern generation
//Bit 15: 8        reg_pat_xrmp_scalergb_1   // unsigned ,    RW, default = 255  G x ramp scale for pattern generation
//Bit  7: 0        reg_pat_xrmp_scalergb_0   // unsigned ,    RW, default = 255  R x ramp scale for pattern generation
#define ISP_PAT1_YRMP_SRGB                         ((0x032a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_yrmp_scalergb_2   // unsigned ,    RW, default = 0  B y ramp scale for pattern generation
//Bit 15: 8        reg_pat_yrmp_scalergb_1   // unsigned ,    RW, default = 0  G y ramp scale for pattern generation
//Bit  7: 0        reg_pat_yrmp_scalergb_0   // unsigned ,    RW, default = 0  R y ramp scale for pattern generation
#define ISP_PAT1_BAR24_R01                         ((0x032b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R23                         ((0x032c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_2      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R45                         ((0x032d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_5      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_4      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R67                         ((0x032e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_6      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R89                         ((0x032f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_R1011                       ((0x0330  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_R1213                       ((0x0331  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_R1415                       ((0x0332  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_R1617                       ((0x0333  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R1819                       ((0x0334  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R2021                       ((0x0335  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R2223                       ((0x0336  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G01                         ((0x0337  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G23                         ((0x0338  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_3      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_2      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G45                         ((0x0339  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_4      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G67                         ((0x033a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_6      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G89                         ((0x033b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_G1011                       ((0x033c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_G1213                       ((0x033d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_G1415                       ((0x033e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_G1617                       ((0x033f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G1819                       ((0x0340  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G2021                       ((0x0341  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G2223                       ((0x0342  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_B01                         ((0x0343  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_1      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B23                         ((0x0344  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_2      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B45                         ((0x0345  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_4      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B67                         ((0x0346  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_6      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B89                         ((0x0347  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_B1011                       ((0x0348  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_B1213                       ((0x0349  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_B1415                       ((0x034a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_B1617                       ((0x034b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B1819                       ((0x034c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_B2021                       ((0x034d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B2223                       ((0x034e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_DFT_XIDX                          ((0x034f  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_dft_xidx          // unsigned ,    RW, default = 100  x index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_xwid          // unsigned ,    RW, default = 100  x window for defeat pixel on pattern
#define ISP_PAT1_DFT_YIDX                          ((0x0350  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pat_dft_yidx          // unsigned ,    RW, default = 200  y index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_ywid          // unsigned ,    RW, default = 1  y window for defeat pixel on pattern
#define ISP_PAT1_DFT_GAIN                          ((0x0351  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pat_dft_gaingrbg_3    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 23:22        reserved
//Bit 21:16        reg_pat_dft_gaingrbg_2    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 15:14        reserved
//Bit 13: 8        reg_pat_dft_gaingrbg_1    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit  7: 6        reserved
//Bit  5: 0        reg_pat_dft_gaingrbg_0    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC1_CNTL                              ((0x0360  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13:12        reg_dpc_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 11:10        reserved
//Bit  9: 8        reg_dpc_xphs_ofst         // unsigned ,    RW, default = 1
//Bit  7: 5        reserved
//Bit  4           reg_dpc_det_en            // unsigned ,    RW, default = 1  1 = enable defect pixel detection, 0 = diable
//Bit  3: 1        reserved
//Bit  0           reg_dpc_cor_en            // unsigned ,    RW, default = 1  1 = enable defect pixel correction, 0 = disable
#define ISP_DPC1_AVG_GAIN0                         ((0x0361  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h0       // unsigned ,    RW, default = 512  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l0       // unsigned ,    RW, default = 128  is used to set the gain of average
#define ISP_DPC1_AVG_GAIN1                         ((0x0362  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h1       // unsigned ,    RW, default = 435  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l1       // unsigned ,    RW, default = 150  is used to set the gain of average
#define ISP_DPC1_AVG_GAIN2                         ((0x0363  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h2       // unsigned ,    RW, default = 332  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l2       // unsigned ,    RW, default = 196  is used to set the gain of average
#define ISP_DPC1_VAR_THD                           ((0x0364  << 2) + 0xfe3b4000)
//Bit 31:24        reg_dpc_cond_en           // unsigned ,    RW, default = 0  is used to enable some condition constraint.
//Bit 23:19        reserved
//Bit 18:16        reg_dpc_cnt_thd           // unsigned ,    RW, default = 3  it is used to set the judge threshold for variance of 8 pixels at same channel
//Bit 15:11        reserved
//Bit 10: 8        reg_dpc_var2_sft0         // unsigned ,    RW, default = 4  it is used to set the judge threshold for variance of 4 pixels at same channel
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_var2_sft1         // unsigned ,    RW, default = 6  it is used to set the judge threshold for variance of 4 pixels at same channel
#define ISP_DPC1_AVG_SFT_CTRL                      ((0x0365  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:16        reg_dpc_avg_diff_sft2     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit 15            reserved
//Bit 14:12        reg_dpc_avg_thd_sft1      // unsigned ,    RW, default = 3  it is used to select the shift1 in avg thd
//Bit 11            reserved
//Bit 10: 8        reg_dpc_avg_thd_sft0      // unsigned ,    RW, default = 3  it is used to select the shift0 in avg thd
//Bit  7            reserved
//Bit  6: 4        reg_dpc_avg_diff_sft1     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit  3            reserved
//Bit  2: 0        reg_dpc_avg_diff_sft0     // unsigned ,    RW, default = 3  it is used to select the shift0 in avg diff
#define ISP_DPC1_VAR_GAIN                          ((0x0366  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_bld_auto_dis      // unsigned ,    RW, default = 0  it is used to disable the auto blending alpha
//Bit 23:21        reserved
//Bit 20           reg_dpc_avg_thd2_en       // unsigned ,    RW, default = 1  it is used to enable the avg_thd2
//Bit 19            reserved
//Bit 18:16        reg_dpc_avg_sft           // unsigned ,    RW, default = 3  it is used to set the shift of avg in avg_thd2 calculation
//Bit 15            reserved
//Bit 14:12        reg_dpc_var_gain_00       // unsigned ,    RW, default = 2  it is used to set the gain for variance
//Bit 11            reserved
//Bit 10: 8        reg_dpc_var_gain_01       // unsigned ,    RW, default = 1  it is used to set the gain for variance
//Bit  7            reserved
//Bit  6: 4        reg_dpc_var_gain_10       // unsigned ,    RW, default = 4  it is used to set the gain for variance
//Bit  3            reserved
//Bit  2: 0        reg_dpc_var_gain_11       // unsigned ,    RW, default = 2  it is used to set the gain for variance
#define ISP_DPC1_STD_GAIN                          ((0x0367  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24:20        reg_dpc_std_gain          // unsigned ,    RW, default = 12  is used to set the gain of standard bias
//Bit 19:13        reserved
//Bit 12: 8        reg_dpc_std_diff_gain     // unsigned ,    RW, default = 16  is used to set the difference gain of standard bias
//Bit  7: 0        reg_dpc_max_min_bias_thd  // unsigned ,    RW, default = 20  is used to set the threshold between maximum standard bias and minimum one
#define ISP_DPC1_AVG_MOD                           ((0x0368  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:10        reg_dpc_low_thd           // unsigned ,    RW, default = 50  is used to set the low theshold for dp_x6
//Bit  9: 8        reg_dpc_avg_mode          // unsigned ,    RW, default = 3  0 = auto selection average value between avg6 and avg4,1 = avg6, 2 = avg4, 3 = avg8
//Bit  7: 0        reg_dpc_avg_bias_thd      // unsigned ,    RW, default = 40  it is used to set theshold for selecting the average value
#define ISP_DPC1_AVG_DEV                           ((0x0369  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_dpc_avg_dev_sft       // unsigned ,    RW, default = 3  it is used to set the avg_dev shift
//Bit 27:25        reserved
//Bit 24           reg_dpc_avg_dev_mode      // unsigned ,    RW, default = 0  it is used to set the mode for calculation of average bias. 0 = variance+offset, 1 = offset
//Bit 23:16        reg_dpc_avg_dev_offset    // unsigned ,    RW, default = 20  it is used to set the offset for average bias
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_blend_alpha   // unsigned ,    RW, default = 12'h800  it used to set the blending alpha for average deviation and standard deviation
#define ISP_DPC1_DEV_DP                            ((0x036a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_dpc_dev_dp_offset     // unsigned ,    RW, default = 30  it is used to set the threshold for deviation mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_dp_slope      // unsigned ,    RW, default = 82  it is used to set the slope for deviation mapping
#define ISP_DPC1_X1_2_CTRL                         ((0x036b  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21: 8        reg_dpc_low_thd_top       // unsigned ,    RW, default = 50  is used to set the low theshold for top
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_x2_rank_lim       // unsigned ,    RW, default = 2  it is used to set the rank limit.
#define ISP_DPC1_X6_CTRL                           ((0x036c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_high_gain         // unsigned ,    RW, default = 256  it is used to set the gain
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_diff_ratio        // unsigned ,    RW, default = 213  it is used to set the diff gain
#define ISP_DPC1_COR_CTRL                          ((0x036d  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_vote_en           // unsigned ,    RW, default = 0  it is used to enable the detection vote. 1= enable, 0=disable
//Bit 23            reserved
//Bit 22:16        reg_dpc_flag_en           // unsigned ,    RW, default = 1  it is used to enbale the detection flag.
//Bit 15            reserved
//Bit 14:12        reg_dpc_vote_thd          // unsigned ,    RW, default = 3  it is used to set the vote threshold.
//Bit 11            reserved
//Bit 10: 8        reg_dpc_ud_mode           // unsigned ,    RW, default = 4  it is used to set the mode for un-diretioanal estimation.0= auto,1=median,2= avg6, 3=avg4,4=avg8,
//Bit  7: 5        reserved
//Bit  4           reg_dpc_highlight_en      // unsigned ,    RW, default = 0  it is used to enable highlighting the defect pixels. 1= enbale, 0=disable
//Bit  3: 2        reserved
//Bit  1: 0        reg_dpc_correct_mode      // unsigned ,    RW, default = 2  it is used to set the correction mode.0= disable, 1= static, 2= dynamic, 3=static or dynamic
#define ISP_DPC1_BLEND                             ((0x036e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_dpc_cor_blend_alpha   // unsigned ,    RW, default = 12'h800  it is used to set the blending alpha for directional estimation and un-directional estimation
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_org_blend_alpha   // unsigned ,    RW, default = 12'hfff  it is used to set the blending alpha for estimation and original value.
#define ISP_DPC1_LUT_CTRL                          ((0x036f  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:20        reg_dpc_lut_start         // unsigned ,    RW, default = 0  it is used to set the start position of table
//Bit 19:17        reserved
//Bit 16           reg_dpc_write_to_lut      // unsigned ,    RW, default = 0  it is used to write the defect pixel position into memory
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_writeto_lut_stline // unsigned ,    RW, default = 0  it is used to set the start line to write to memory
#define ISP_DPC1_SDP_NUM                           ((0x0370  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 0        ro_dpc_sdp_num            // unsigned ,    RO, default = 0  it is used to report the number of the static defect pixel
#define ISP_DPC1_DDP_NUM                           ((0x0371  << 2) + 0xfe3b4000)
//Bit 31:16        ro_dpc_ddp_num            // unsigned ,    RO, default = 0  it is used to report the number of the dynamic defect pixel
//Bit 15: 0        ro_dpc_defect_num         // unsigned ,    RO, default = 0  it is used to report the number of the defect pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC1_LUT1024_ADDR                      ((0x0380  << 2) + 0xfe3b4000)
//Bit 31:0      isp_dpc_lut1024_addr              // unsigned , RW, default=0
#define ISP_DPC1_LUT1024_DATA                      ((0x0381  << 2) + 0xfe3b4000)
//Bit 31:0      isp_dpc_lut1024_data              // unsigned , RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB2_APB_BASE = 0x04
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CROP_START                             ((0x0400  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crop_hstart           // unsigned ,    RW, default = 0  horizontal start for crop
//Bit 15: 0        reg_crop_vstart           // unsigned ,    RW, default = 0  vertical start for crop
#define ISP_CROP_SIZE                              ((0x0401  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crop_hsize            // unsigned ,    RW, default = 1920  horizontal size for crop
//Bit 15: 0        reg_crop_vsize            // unsigned ,    RW, default = 1080  vertical size for crop
#define ISP_DECOMP_CTRL                            ((0x0402  << 2) + 0xfe3b4000)
//Bit 31: 3        reserved
//Bit  2           reg_decmp0_en             // unsigned ,    RW, default = 0  enable decompander0
//Bit  1           reg_decmp1_en             // unsigned ,    RW, default = 0  enable decompander1
//Bit  0           reg_decmp1_mode           // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for decompander1 lut
#define ISP_DECOMP1_STP                            ((0x0403  << 2) + 0xfe3b4000)
//Bit 31:28        reg_decmp1_stp_7          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 27:24        reg_decmp1_stp_6          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 23:20        reg_decmp1_stp_5          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 19:16        reg_decmp1_stp_4          // unsigned ,    RW, default = 13  step for each segment of decompander1 lut
//Bit 15:12        reg_decmp1_stp_3          // unsigned ,    RW, default = 12  step for each segment of decompander1 lut
//Bit 11: 8        reg_decmp1_stp_2          // unsigned ,    RW, default = 11  step for each segment of decompander1 lut
//Bit  7: 4        reg_decmp1_stp_1          // unsigned ,    RW, default = 9  step for each segment of decompander1 lut
//Bit  3: 0        reg_decmp1_stp_0          // unsigned ,    RW, default = 8  step for each segment of decompander1 lut
#define ISP_DECOMP1_NUM                            ((0x0404  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_decmp1_num_7          // unsigned ,    RW, default = 5  numbers for each segment of decompander1 lut
//Bit 27            reserved
//Bit 26:24        reg_decmp1_num_6          // unsigned ,    RW, default = 4  numbers for each segment of decompander1 lut
//Bit 23            reserved
//Bit 22:20        reg_decmp1_num_5          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 19            reserved
//Bit 18:16        reg_decmp1_num_4          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 15            reserved
//Bit 14:12        reg_decmp1_num_3          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 11            reserved
//Bit 10: 8        reg_decmp1_num_2          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit  7            reserved
//Bit  6: 4        reg_decmp1_num_1          // unsigned ,    RW, default = 4  numbers for each segment of decompander1 lut
//Bit  3            reserved
//Bit  2: 0        reg_decmp1_num_0          // unsigned ,    RW, default = 5  numbers for each segment of decompander1 lut
#define ISP_INPFMT_KPTS_01                         ((0x0405  << 2) + 0xfe3b4000)
//Bit 31:16        reg_inp_fmt_kneepts_1     // unsigned ,    RW, default = 1408  (BIT_DEPTH00), default for u12 to u20, knee point1 for decompanding
//Bit 15: 0        reg_inp_fmt_kneepts_0     // unsigned ,    RW, default = 512  (BIT_DEPTH00), default for u12 to u20, knee point0 for decompanding
#define ISP_INPFMT_KPTS2_SLP                       ((0x0406  << 2) + 0xfe3b4000)
//Bit 31:16        reg_inp_fmt_kneepts_2     // unsigned ,    RW, default = 2176  (BIT_DEPTH00), default for u12 to u20, knee point2 for decompanding
//Bit 15:12        reg_inp_fmt_slope_3       // unsigned ,    RW, default = 9  slope of knee points for decompanding, equal to 2^n
//Bit 11: 8        reg_inp_fmt_slope_2       // unsigned ,    RW, default = 6  slope of knee points for decompanding, equal to 2^n
//Bit  7: 4        reg_inp_fmt_slope_1       // unsigned ,    RW, default = 4  slope of knee points for decompanding, equal to 2^n
//Bit  3: 0        reg_inp_fmt_slope_0       // unsigned ,    RW, default = 2  slope of knee points for decompanding, equal to 2^n
#define ISP_INPFMT_SPLT                            ((0x0407  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_inp_fmt_chn           // unsigned ,    RW, default = 1  the data channels after input formatter, support (1+inp_fmt_chn) as 1/2/3/4
//Bit 15:13        reserved
//Bit 12           reg_inp_fmt_diag_mux      // unsigned ,    RW, default = 0  0: select 0 or (0,1), 1: select 1 or (1,0), ouput mux for diagonal split
//Bit 11: 8        reg_inp_fmt_split_sbit    // unsigned ,    RW, default = 4  short exp bits split for combined split
//Bit  7: 6        reserved
//Bit  5: 4        reg_inp_fmt_split_mode    // unsigned ,    RW, default = 0  0: bypass, 1: long/short split, 2or3: diag sum split for quadra, channel0 split mode for input formatter
//Bit  3: 2        reserved
//Bit  1: 0        reg_inp_fmt_32mux         // unsigned ,    RW, default = 0  0: select 0,1, 1: select 0,2, 2or3: select 1,2
#define ISP_INPFMT_MOD_BD_0                        ((0x0408  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 8        reg_inp_fmt_mod_0         // unsigned ,    RW, default = 0  input formatter mode, 0: linear data, 1: companding data with knee points, 2or3: log data
//Bit  7            reserved
//Bit  6: 4        reg_inp_fmt_ibit_depth_0  // unsigned ,    RW, default = 2  sensor data inp (compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
//Bit  3            reserved
//Bit  2: 0        reg_inp_fmt_obit_depth_0  // unsigned ,    RW, default = 2  sensor data out (de-compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
#define ISP_INPFMT_MOD_BD_1                        ((0x0409  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 8        reg_inp_fmt_mod_1         // unsigned ,    RW, default = 0  input formatter mode, 0: linear data, 1: companding data with knee points, 2or3: log data
//Bit  7            reserved
//Bit  6: 4        reg_inp_fmt_ibit_depth_1  // unsigned ,    RW, default = 2  sensor data inp (compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
//Bit  3            reserved
//Bit  2: 0        reg_inp_fmt_obit_depth_1  // unsigned ,    RW, default = 2  sensor data out (de-compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
#define ISP_BIN_BAC_CTRL                           ((0x040a  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_bin_mode              // unsigned ,    RW, default = 0  0: 2x2 binning, 1: 4x4 binning, 2: 2x2 skip, 3: 4x4 skip, binning mode
//Bit 15:14        reserved
//Bit 13:12        reg_bac_xphs_ofst         // unsigned ,    RW, default = 0  x phase ofst for bac
//Bit 11:10        reserved
//Bit  9: 8        reg_bac_yphs_ofst         // unsigned ,    RW, default = 0  y phase ofst for bac
//Bit  7: 5        reserved
//Bit  4           reg_bac_mode              // unsigned ,    RW, default = 0  0: 2x2 bac, 1: 4x4 bac, bac mode
//Bit  3: 1        reserved
//Bit  0           reg_bac_norm              // unsigned ,    RW, default = 0  0: 64, 1: 128, normalization for bac filter
#define ISP_BAC_HCOEF                              ((0x040b  << 2) + 0xfe3b4000)
//Bit 31:24        reg_bac_hcoef_3           // signed ,    RW, default = 16  phase 1 horizontal coef1. for bac filter
//Bit 23:16        reg_bac_hcoef_2           // signed ,    RW, default = 48  phase 1 horizontal coef0. for bac filter
//Bit 15: 8        reg_bac_hcoef_1           // signed ,    RW, default = 0  phase 0 horizontal coef1. for bac filter
//Bit  7: 0        reg_bac_hcoef_0           // signed ,    RW, default = 64  phase 0 horizontal coef0. for bac filter
#define ISP_BAC_VCOEF                              ((0x040c  << 2) + 0xfe3b4000)
//Bit 31:24        reg_bac_vcoef_3           // signed ,    RW, default = 16  phase 1 vertical coef1. for bac filter
//Bit 23:16        reg_bac_vcoef_2           // signed ,    RW, default = 48  phase 1 vertical coef0. for bac filter
//Bit 15: 8        reg_bac_vcoef_1           // signed ,    RW, default = 0  phase 0 vertical coef1. for bac filter
//Bit  7: 0        reg_bac_vcoef_0           // signed ,    RW, default = 64  phase 0 vertical coef0. for bac filter
#define ISP_FPNR_CTRL                              ((0x040d  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30           reg_fpnr_cali_flag        // unsigned ,    RW, default = 1  0: no fpnr cali operation; 1: more than 0 time fpnr cali operation
//Bit 29            reserved
//Bit 28           reg_fpnr_cali_corr_sel    // unsigned ,    RW, default = 1  0: calibration mode 1:correction mode, fpnr mode selection
//Bit 27:26        reserved
//Bit 25:24        reg_fpnr_xphs_ofst        // unsigned ,    RW, default = 1  xphase ofset
//Bit 23:22        reserved
//Bit 21:20        reg_fpnr_yphs_ofst        // unsigned ,    RW, default = 0  yphase ofset
//Bit 19            reserved
//Bit 18           reg_fpnr_cali_trigger     // unsigned ,    RW, default = 0  1: calibration trigger signal for fpnr, auto. reset to zero
//Bit 17:16        reserved
//Bit 15:14        reg_fpnr_corr_mode        // unsigned ,    RW, default = 0  0: correction mode 1; 1: correction mode 1; else: correction mode 2
//Bit 13: 0        reg_fpnr_ofst             // unsigned ,    RW, default = 0  fpnr ofst
#define ISP_BAC_PRCT                               ((0x040e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_bac_prct_vrat         // unsigned ,    RW, default = 16  vdifs v.s. hdifs ratio (4.2) for bac protection
//Bit 23:22        reserved
//Bit 21:16        reg_bac_prct_hrat         // unsigned ,    RW, default = 16  hdifs v.s. vdifs ratio (4.2) for bac protection
//Bit 15:14        reserved
//Bit 13: 8        reg_bac_prct_coring       // unsigned ,    RW, default = 0  coring for difs in bac protection
//Bit  7: 1        reserved
//Bit  0           reg_bac_prct_en           // unsigned ,    RW, default = 1  enable bac protection
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_top_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_OFE_DECMP0_LUT_ADDR                    ((0x04f0  << 2) + 0xfe3b4000)
//Bit 31:0  reg_decmp0_lut_addr    // unsigned, RW, default=0
//
#define ISP_OFE_DECMP0_LUT_DATA                    ((0x04f1  << 2) + 0xfe3b4000)
//Bit 31:20 reserved
//Bit 19:0  reg_decmp0_lut_data    //unsigned, RW, default=0
//
#define ISP_OFE_DECMP1_LUT_ADDR                    ((0x04f2  << 2) + 0xfe3b4000)
//Bit 31:0  reg_decmp1_lut_addr    // unsigned, RW, default=0
//
#define ISP_OFE_DECMP1_LUT_DATA                    ((0x04f3  << 2) + 0xfe3b4000)
//Bit 31:20 reserved
//Bit 19:0  reg_decmp1_lut_data    //unsigned, RW, default=0
//
#define ISP_OFE_GCLK_CTRL0                         ((0x04f4  << 2) + 0xfe3b4000)
//Bit 31:0  reg_gclk_ctrl_0           //unsigned, RW, default=0
//
#define ISP_OFE_GCLK_CTRL1                         ((0x04f5  << 2) + 0xfe3b4000)
//Bit 31:0  reg_gclk_ctrl_1           //unsigned, RW, default=0
//
#define ISP_OFE_HW_CTRL0                           ((0x04f6  << 2) + 0xfe3b4000)
//Bit 31:1  reserved
//Bit 0     reg_ofe_bypass          //unsigned, RW, default=0;
#define ISP_DPC_GCLK_CTRL                          ((0x04f7  << 2) + 0xfe3b4000)
//Bit 31:0  reg_dpc_gclk_ctrl           //unsigned, RW, default=0
//
#define ISP_OFE_SW_RST                             ((0x04f8  << 2) + 0xfe3b4000)
//Bit 31:30 reserved
//Bit 0     reg_sw_rst          //unsigned, RW, default=0, pulse, sw rst for ofe logic, especially fpnr
#define ISP_OFE_FPNR_CALI_STAT                     ((0x04f9  << 2) + 0xfe3b4000)
//Bit 31:0  ro_cali_stat        //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB3_APB_BASE = 0x05
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_wdr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_WDR_COM_BLC0                           ((0x0500  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_gr     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_gb     // unsigned ,    RW, default = 240  black level for WDR
#define ISP_WDR_COM_BLC1                           ((0x0501  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_rg     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_bg     // unsigned ,    RW, default = 240  black level for WDR
#define ISP_WDR_COM_BLC2                           ((0x0502  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_ir     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_wdr    // unsigned ,    RW, default = 240  compensation black level for WDR
#define ISP_WDR_COM_PARAM0                         ((0x0503  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:26        reg_wdr_force_exp_mode    // unsigned ,    RW, default = 0  0:long exposure output, 1:short1 exposure output, 2: short2 exposure output, 3: short3 exposure output; 4:
//Bit 25            reserved
//Bit 24           reg_wdr_force_exp_en      // unsigned ,    RW, default = 0  0: disable, 1: enable force single expsure output
//Bit 23:21        reserved
//Bit 20:16        reg_sensor_bitdepth       // unsigned ,    RW, default = 10  the bitdepth of sensor output, max support 20bit
//Bit 15: 9        reserved
//Bit  8           reg_wdr_motiondect_en     // unsigned ,    RW, default = 1  0: wdr motion detection disable,  1: enable
//Bit  7: 4        reserved
//Bit  3: 2        reg_expst_xphase_ofst     // unsigned ,    RW, default = 0  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_expst_yphase_ofst     // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_WDR_COM_AWBGAIN2                       ((0x0504  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_awb_gain_256_4        // unsigned ,    RW, default = 256  4.8, AWB gain for Ir channel
#define ISP_WDR_COM_AWBGAIN1                       ((0x0505  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_gain_256_3        // unsigned ,    RW, default = 256  4.8, AWB gain for Gb channel
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_gain_256_2        // unsigned ,    RW, default = 256  4.8, AWB gain for B channel
#define ISP_WDR_COM_AWBGAIN0                       ((0x0506  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_gain_256_1        // unsigned ,    RW, default = 256  4.8, AWB gain for R channel
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_gain_256_0        // unsigned ,    RW, default = 256  4.8, AWB gain for Gr channel
#define ISP_WDR_GEN_EXPRATIO1                      ((0x0507  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lexpratio_int64_3 // unsigned ,    RW, default = 64  exposure ratio between long and short3
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lexpratio_int64_2 // unsigned ,    RW, default = 64  exposure ratio between long and short2
#define ISP_WDR_GEN_EXPRARIO0                      ((0x0508  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lexpratio_int64_1 // unsigned ,    RW, default = 64  exposure ratio between long and short1
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lexpratio_int64_0 // unsigned ,    RW, default = 64  exposure ratio of long
#define ISP_WDR_GEN_MAPRATIO2                      ((0x0509  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_2_1 // unsigned ,    RW, default = 64  of short2 to short3, short3 x Ratio(L/S3)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_2_0 // unsigned ,    RW, default = 64  of short2 to short3, short2 x Ratio(L/S2)
#define ISP_WDR_GEN_MAPRATIO1                      ((0x050a  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_1_1 // unsigned ,    RW, default = 64  of short1 to short2, short2 x Ratio(L/S2)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_1_0 // unsigned ,    RW, default = 64  of short1 to short2, short1 x Ratio(L/S1)
#define ISP_WDR_GEN_MAPRATIO0                      ((0x050b  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_0_1 // unsigned ,    RW, default = 64  of long   to short1, short1 x Ratio(L/S1)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_0_0 // unsigned ,    RW, default = 64  of long   to short1, long x 64
#define ISP_WDR_GEN_LEXPCOMP0                      ((0x050c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_LEXPCOMP1                      ((0x050d  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_LEXPCOMP2                      ((0x050e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_LEXPCOMP3                      ((0x050f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_LEXPCOMP4                      ((0x0510  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_MEXPCOMP0                      ((0x0511  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_MEXPCOMP1                      ((0x0512  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_MEXPCOMP2                      ((0x0513  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_MEXPCOMP3                      ((0x0514  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_MEXPCOMP4                      ((0x0515  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_SEXPCOMP0                      ((0x0516  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_SEXPCOMP1                      ((0x0517  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_SEXPCOMP2                      ((0x0518  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_SEXPCOMP3                      ((0x0519  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_SEXPCOMP4                      ((0x051a  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_MDETC_MODE                         ((0x051b  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3           reg_wdr_mdetc_withblc_mode // unsigned ,    RW, default = 0  pix value w/o blc for MDthd calculation, 1: w/ blc for MDthd calculation
//Bit  2: 1        reg_wdr_mdetc_chksat_mode // unsigned ,    RW, default = 0  check G & C w/ BLC, 1: check G & C w/o BLC
//Bit  0           reg_wdr_mdetc_motionmap_mode // unsigned ,    RW, default = 0  final map determined by Gdiff, 1: determined by MAX3(Gmap, Rmap, Bmap)
#define ISP_WDR_MDETC_WEIGHT1                      ((0x051c  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_wdr_mdetc_lo_weight_2 // unsigned ,    RW, default = 64  weight for motion detection
//Bit  7: 0        reg_wdr_mdetc_hi_weight_2 // unsigned ,    RW, default = 128  weight for motion detection
#define ISP_WDR_MDETC_WEIGHT0                      ((0x051d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_wdr_mdetc_lo_weight_1 // unsigned ,    RW, default = 64  weight for motion detection
//Bit 23:16        reg_wdr_mdetc_hi_weight_1 // unsigned ,    RW, default = 128  weight for motion detection
//Bit 15: 8        reg_wdr_mdetc_lo_weight_0 // unsigned ,    RW, default = 64  weight for motion detection
//Bit  7: 0        reg_wdr_mdetc_hi_weight_0 // unsigned ,    RW, default = 128  weight for motion detection
#define ISP_WDR_MDETC_SATTHD0                      ((0x051e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdetc_sat_gr_thd  // unsigned ,    RW, default = 3853  saturation threshold for Gr channel
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_gb_thd  // unsigned ,    RW, default = 3853  saturation threshold for Gb channel
#define ISP_WDR_MDETC_SATTHD1                      ((0x051f  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdetc_sat_rg_thd  // unsigned ,    RW, default = 3853  saturation threshold for Rg channel
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_bg_thd  // unsigned ,    RW, default = 3853  saturation threshold for Bg channel
#define ISP_WDR_MDETC_SATTHD2                      ((0x0520  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_ir_thd  // unsigned ,    RW, default = 3853  saturation threshold for Ir channel
#define ISP_WDR_MDETC_SQRT_AGAIN                   ((0x0521  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_wdr_mdetc_sqrt_again_ir // unsigned ,    RW, default = 1  result of sqrt by Ir channel Again
//Bit 23:21        reserved
//Bit 20:16        reg_wdr_mdetc_sqrt_again_bg // unsigned ,    RW, default = 1  result of sqrt by B channel Again
//Bit 15:13        reserved
//Bit 12: 8        reg_wdr_mdetc_sqrt_again_rg // unsigned ,    RW, default = 1  result of sqrt by R channel Again
//Bit  7: 5        reserved
//Bit  4: 0        reg_wdr_mdetc_sqrt_again_g // unsigned ,    RW, default = 1  result of sqrt by G channel Again
#define ISP_WDR_MDETC_SQRT_DGAIN                   ((0x0522  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_wdr_mdetc_sqrt_dgain_ir // unsigned ,    RW, default = 1  result of sqrt by Ir channel Dgain
//Bit 23:21        reserved
//Bit 20:16        reg_wdr_mdetc_sqrt_dgain_bg // unsigned ,    RW, default = 1  result of sqrt by B channel Dgain
//Bit 15:13        reserved
//Bit 12: 8        reg_wdr_mdetc_sqrt_dgain_rg // unsigned ,    RW, default = 1  result of sqrt by R channel Dgain
//Bit  7: 5        reserved
//Bit  4: 0        reg_wdr_mdetc_sqrt_dgain_g // unsigned ,    RW, default = 1  result of sqrt by G channel Dgain
#define ISP_WDR_MDETC_GNOISEFLOOR                  ((0x0523  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_g_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_g_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_g_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_RNOISEFLOOR                  ((0x0524  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_rg_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_rg_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_rg_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_BNOISEFLOOR                  ((0x0525  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_bg_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_bg_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_bg_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_IRNOISEFLOOR                 ((0x0526  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_ir_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_ir_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_ir_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDECI_PARAM                        ((0x0527  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28           reg_wdr_mdeci_msk_sat_prct_en // unsigned ,    RW, default = 0  mask saturation protection disable, 1: mask saturation protection enable
//Bit 27:26        reserved
//Bit 25           reg_wdr_mdeci_chkstill_mode // unsigned ,    RW, default = 0  check G w/o BLC, 1: check G & C w/o BLC
//Bit 24           reg_wdr_mdeci_satmoving_gain_en // unsigned ,    RW, default = 0  the mask of a saturated moving pixel is set as 254; 1: the mask of a saturated moving pixel is affected by the reg_wdr_mdetc_lo/hi_weight
//Bit 23:16        reg_wdr_mdeci_addlong     // unsigned ,    RW, default = 0  reduce motion map value in order to include more long-exp data
//Bit 15: 8        reg_wdr_mdeci_still_thd   // unsigned ,    RW, default = 20  motion map value is less than this threshold, this motion map is set as 0
//Bit  7: 0        reg_wdr_mdeci_fullmot_thd // unsigned ,    RW, default = 250  motion map value is more than this threshold, this motion map will look for the next exposure's map
#define ISP_WDR_MDECI_LSTHD0                       ((0x0528  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gr_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gr_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD1                       ((0x0529  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gr_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gb_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD2                       ((0x052a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gb_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gb_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD3                       ((0x052b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_rg_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_rg_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD4                       ((0x052c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_rg_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_bg_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD5                       ((0x052d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_bg_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_bg_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD6                       ((0x052e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_ir_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_ir_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD7                       ((0x052f  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_ir_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_FLONG_PARAM                        ((0x0530  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 8        reg_wdr_forcelong_en      // unsigned ,    RW, default = 1  1:based on 32x32 long-exp data in previous frame, 2: based on mode1, increase short-exp data under specific condition to avoid discontinuity
//Bit  7: 5        reserved
//Bit  4           reg_wdr_flong2_colorcorrect_en // unsigned ,    RW, default = 1  1: enable
//Bit  3: 1        reserved
//Bit  0           reg_wdr_forcelong_thdmode // unsigned ,    RW, default = 0  thd is set by register, 1: thd is set by the background info calculation
#define ISP_WDR_FLONG_MASKTHD                      ((0x0531  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_flong2_mask_orgthd // unsigned ,    RW, default = 250  mask threshold in flong2 mode
//Bit 15: 8        reserved
//Bit  7: 0        reg_wdr_flong2_mask_afterthd // unsigned ,    RW, default = 251  mask threshold in flong2 mode
#define ISP_WDR_FLONG_THD0                         ((0x0532  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_0     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_0     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG_THD1                         ((0x0533  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_1     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_1     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG_THD2                         ((0x0534  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_2     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_2     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG1_THD                         ((0x0535  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong1_thd0       // unsigned ,    RW, default = 1000  threshold for Mask interpolation in flong1 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong1_thd1       // unsigned ,    RW, default = 1600  threshold for Mask interpolation in flong1 mode
#define ISP_WDR_EXPCOMB_PARAM                      ((0x0536  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21           reg_wdr_expcomb_maxavg_winsize // unsigned ,    RW, default = 1  5x5, 1: 5x9
//Bit 20:18        reg_wdr_expcomb_maxavg_mode // unsigned ,    RW, default = 3  original long and short data, 1: check G w/ BLC, 2: check G w/o BLC, 3: check G & C w/ BLC, 4: check G & C w/o BLC
//Bit 17:14        reg_wdr_expcomb_maxavg_ratio // unsigned ,    RW, default = 4  indx calculated by ratio of max and avg, #/16, 0->using max, 16->using avg
//Bit 13:10        reg_wdr_expcomb_slope_weight // unsigned ,    RW, default = 6  weight for exp combine
//Bit  9: 0        reg_wdr_expcomb_blend_slope // unsigned ,    RW, default = 0  slope for exp combine
#define ISP_WDR_EXPCOMB_SATTHD0                    ((0x0537  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 15:14        reserved
#define ISP_WDR_EXPCOMB_SATTHD1                    ((0x0538  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 15:14        reserved
#define ISP_WDR_EXPCOMB_SATTHD2                    ((0x0539  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
#define ISP_WDR_EXPCOMB_BLDTHD                     ((0x053a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_expcomb_blend_thd0 // unsigned ,    RW, default = 3008  precision depending on sensor bit depth, exposure combination lo_thd, when long value is less than this thd, output long data, higher than this thd, blend long and short
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_expcomb_blend_thd1 // unsigned ,    RW, default = 3900  precision depending on sensor bit depth, exposure combination hi_thd, when long vlaue is higher than this thd, output short data
#define ISP_WDR_EXPCOMB_IRBLDTHD                   ((0x053b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_expcomb_ir_blend_thd0 // unsigned ,    RW, default = 3008  precision depending on sensor bit depth, exposure combination lo_thd, when long value is less than this thd, output long data, higher than this thd, blend long and short
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_expcomb_ir_blend_thd1 // unsigned ,    RW, default = 3900  precision depending on sensor bit depth, exposure combination hi_thd, when long vlaue is higher than this thd, output short data
#define ISP_WDR_EXPCOMB_IRPARAM                    ((0x053c  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13:10        reg_wdr_expcomb_ir_slope_weight // unsigned ,    RW, default = 6
//Bit  9: 0        reg_wdr_expcomb_ir_blend_slope // unsigned ,    RW, default = 0
#define ISP_WDR_EXPCOMB_MAXRATIO                   ((0x053d  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22: 1        reg_wdr_expcomb_maxratio  // unsigned ,    RW, default = 0  ratio for exp combine
//Bit  0           reg_wdr_expcomb_irmode    // unsigned ,    RW, default = 1  0:ir channel and other channels share the blend coefficient,
#define ISP_WDR_SEXPNR_PARAM0                      ((0x053e  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6           reg_wdr_sexpnr_en         // unsigned ,    RW, default = 1  disable short-exp nr, 1: enable short-exp nr for moving areas
//Bit  5: 3        reg_wdr_sexpnr_gweight_mode // unsigned ,    RW, default = 3  control G channel filtering strength, larger number, stronger filtering effect
//Bit  2: 0        reg_wdr_sexpnr_cweight_mode // unsigned ,    RW, default = 3  control R/B channel filtering strength, larger number, stronger filtering effect
#define ISP_WDR_SEXPNR_LPWEIGHT_0                  ((0x053f  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_0_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_0_1 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_0_0 // unsigned ,    RW, default = 1  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_1                  ((0x0540  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_1_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_1_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_1_0 // unsigned ,    RW, default = 4  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_2                  ((0x0541  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_2_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_2_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_2_0 // unsigned ,    RW, default = 2  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_3                  ((0x0542  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_3_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_3_1 // unsigned ,    RW, default = 2  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_3_0 // unsigned ,    RW, default = 3  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_4                  ((0x0543  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_4_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_4_1 // unsigned ,    RW, default = 3  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_4_0 // unsigned ,    RW, default = 4  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_5                  ((0x0544  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_5_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_5_1 // unsigned ,    RW, default = 2  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_5_0 // unsigned ,    RW, default = 2  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_6                  ((0x0545  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_6_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_6_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_6_0 // unsigned ,    RW, default = 1  mode for sigma filter
#define ISP_WDR_SEXPNR_GWEIGHT                     ((0x0546  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_gsigma_weight // unsigned ,    RW, default = 16  value bigger than 16, stronger filtering effect (default: 16)
//Bit 15: 8        reg_wdr_sexpnr_gsigma_l2weight // unsigned ,    RW, default = 32  (default: 32)
//Bit  7: 0        reg_wdr_sexpnr_gsigma_l3weight // unsigned ,    RW, default = 48  (default: 48)
#define ISP_WDR_SEXPNR_CWEIGHT                     ((0x0547  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_csigma_weight // unsigned ,    RW, default = 16  value bigger than 16, stronger filtering effect (default: 16)
//Bit 15: 8        reg_wdr_sexpnr_csigma_l2weight // unsigned ,    RW, default = 32
//Bit  7: 0        reg_wdr_sexpnr_csigma_l3weight // unsigned ,    RW, default = 48
#define ISP_WDR_SEXPNR_PARAM1                      ((0x0548  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_motion_lothd // unsigned ,    RW, default = 180  the motion mask is bigger than this threshold, this pixel is marked as motion pixel for short-exp NR process
//Bit 15: 8        reg_wdr_sexpnr_blend_hithd // unsigned ,    RW, default = 50  the blend ratio is smaller than this threshold, this pixel is marked as motion pixel for short-exp NR process
//Bit  7: 6        reserved
//Bit  5: 0        reg_wdr_sexpnr_blend_bayerlocnt // unsigned ,    RW, default = 1  a bayer pixel, the number of pixel's blend ratio being smaller than blend_hithd is more than this threshold, this bayer pixel will be marked as motion bayer pixel
#define ISP_WDR_SEXPNR_PARAM2                      ((0x0549  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:14        reg_wdr_sexpnr_motion_locnt1 // unsigned ,    RW, default = 1
//Bit 13: 8        reg_wdr_sexpnr_motion_locnt2 // unsigned ,    RW, default = 0
//Bit  7: 2        reg_wdr_sexpnr_blend_locnt2 // unsigned ,    RW, default = 1
//Bit  1           reg_wdr_sexpnr_gsigma_mode // unsigned ,    RW, default = 0  0:physical theory 1:based on noise profile
//Bit  0           reg_wdr_sexpnr_csigma_mode // unsigned ,    RW, default = 0  0:physical theory 1:based on noise profile
#define ISP_WDR_STAT_SUM_0                         ((0x054a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wdr_stat_sum_0         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_CNT_0                         ((0x054b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wdr_stat_cnt_0         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_SUM_1                         ((0x054c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wdr_stat_sum_1         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_CNT_1                         ((0x054d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wdr_stat_cnt_1         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_PARAM                         ((0x054e  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_wdr_stat_bk_binsize   // unsigned ,    RW, default = 1023  1023
//Bit 15: 8        reg_wdr_stat_bk_binwidth  // unsigned ,    RW, default = 250  width of stat
//Bit  7: 1        reserved
//Bit  0           reg_wdr_stat_flt_en       // unsigned ,    RW, default = 1  wdr statistic flt en
#define ISP_COMB_PARAM                             ((0x054f  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_comb_shortexp_mode    // unsigned ,    RW, default = 3  use original short-exp data, when exposure ratio is larger than 6x
//Bit 15: 0        reg_comb_maxratio         // unsigned ,    RW, default = 0  ratio for combination mode
#define ISP_COMB_LSBARRIER0_0                      ((0x0550  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_0    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_0                      ((0x0551  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_1                      ((0x0552  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_1    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_1                      ((0x0553  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_2                      ((0x0554  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_2    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_2                      ((0x0555  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_3                      ((0x0556  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_3    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_3                      ((0x0557  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_EXPRAT_01                         ((0x0558  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:16        reg_comb_expratio_int64_1 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
//Bit 15            reserved
//Bit 14: 0        reg_comb_expratio_int64_0 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
#define ISP_COMB_EXPRAT_2                          ((0x0559  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14: 0        reg_comb_expratio_int64_2 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_0          ((0x055a  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_0 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_1          ((0x055b  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_1 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_2          ((0x055c  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_2 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_WDR_HW_CTRL                            ((0x0590  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 0            reg_wdr_mskmap_en          // unsigned ,    RW, default = 1 1:mask out enable 0:mask out disable
#define ISP_WDR_HW_STATUS                          ((0x0598  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit 9            ro_wdr_din_done           // unsigned ,    RO, default = 0
//Bit 8            ro_wdr_dout_done          // unsigned ,    RO, default = 0
//Bit 7:6          reserved
//Bit 5            ro_wdr_din_srdy           // unsigned ,    RO, default = 0
//Bit 4            ro_wdr_din_rrdy           // unsigned ,    RO, default = 0
//Bit 3            ro_wdr_dout_srdy          // unsigned ,    RO, default = 0
//Bit 2            ro_wdr_dout_rrdy          // unsigned ,    RO, default = 0
//Bit 1            ro_wdr_mmsk_srdy          // unsigned ,    RO, default = 0
//Bit 0            ro_wdr_mmsk_rrdy          // unsigned ,    RO, default = 0
#define ISP_WDR_GSIGMA_LUT_ADDR                    ((0x05a0  << 2) + 0xfe3b4000)
#define ISP_WDR_GSIGMA_LUT_DATA                    ((0x05a1  << 2) + 0xfe3b4000)
#define ISP_WDR_RSIGMA_LUT_ADDR                    ((0x05a2  << 2) + 0xfe3b4000)
#define ISP_WDR_RSIGMA_LUT_DATA                    ((0x05a3  << 2) + 0xfe3b4000)
#define ISP_WDR_BSIGMA_LUT_ADDR                    ((0x05a4  << 2) + 0xfe3b4000)
#define ISP_WDR_BSIGMA_LUT_DATA                    ((0x05a5  << 2) + 0xfe3b4000)
#define ISP_CH0_RO_WDR_STAT_FLT_ADDR               ((0x05b0  << 2) + 0xfe3b4000)
//Bit 31:0      ro_wdr_stat_flt_addr // unsigned ,    RW, default = 0
#define ISP_CH0_RO_WDR_STAT_FLT_DATA               ((0x05b1  << 2) + 0xfe3b4000)
//Bit 31:0      ro_wdr_stat_flt_data // unsigned ,    RW, default = 0
#define ISP_CH1_RO_WDR_STAT_FLT_ADDR               ((0x05b2  << 2) + 0xfe3b4000)
#define ISP_CH1_RO_WDR_STAT_FLT_DATA               ((0x05b3  << 2) + 0xfe3b4000)
#define ISP_CH2_RO_WDR_STAT_FLT_ADDR               ((0x05b4  << 2) + 0xfe3b4000)
#define ISP_CH2_RO_WDR_STAT_FLT_DATA               ((0x05b5  << 2) + 0xfe3b4000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_wdr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB4_APB_BASE = 0x06
// -----------------------------------------------
//reserved
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TOP_APB_BASE = 0x07
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_fed_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_FED_DG_PHS_OFST                        ((0x0700  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_dg_xphs_ofst          // unsigned ,    RW, default = 1
//Bit  3: 2        reserved
//Bit  1: 0        reg_dg_yphs_ofst          // unsigned ,    RW, default = 0
#define ISP_FED_DG_GAIN01                          ((0x0701  << 2) + 0xfe3b4000)
//Bit 31:16        reg_dg_gain_1             // unsigned ,    RW, default = 4096  in format 4.12, digital gain1 for linear bayer data
//Bit 15: 0        reg_dg_gain_0             // unsigned ,    RW, default = 4096  in format 4.12, digital gain0for linear bayer data
#define ISP_FED_DG_GAIN23                          ((0x0702  << 2) + 0xfe3b4000)
//Bit 31:16        reg_dg_gain_3             // unsigned ,    RW, default = 4096  in format 4.12, digital gain3 for linear bayer data
//Bit 15: 0        reg_dg_gain_2             // unsigned ,    RW, default = 4096  in format 4.12, digital gain2 for linear bayer data
#define ISP_FED_DG_GAIN4                           ((0x0703  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_dg_gain_4             // unsigned ,    RW, default = 4096  in format 4.12, digital gain4 for linear bayer data
#define ISP_FED_DG_OFST                            ((0x0704  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_dg_ofst               // unsigned ,    RW, default = 0  offset before and after digital gain for linear bayer data
#define ISP_FED_BL_PHS                             ((0x0705  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_fe_bl_xphs_ofst       // unsigned ,    RW, default = 1
//Bit  3: 2        reserved
//Bit  1: 0        reg_fe_bl_yphs_ofst       // unsigned ,    RW, default = 0
#define ISP_FED_BL_OFST_GR                         ((0x0706  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_0          // signed ,    RW, default = 0  Gr for fe_bl offset each color each channels
#define ISP_FED_BL_OFST_R                          ((0x0707  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_1          // signed ,    RW, default = 0  R for blc offset each color each channels
#define ISP_FED_BL_OFST_B                          ((0x0708  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_2          // signed ,    RW, default = 0  B  for blc offset each color each channels
#define ISP_FED_BL_OFST_GB                         ((0x0709  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_3          // signed ,    RW, default = 0  Gb for blc offset each color each channels
#define ISP_FED_BL_OFST_IR                         ((0x070a  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_4          // signed ,    RW, default = 0  Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
#define ISP_FED_SQRT_PRE_OFST                      ((0x070b  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_sqrt_pre_ofst         // signed ,    RW, default = 0  previous offset before square root
#define ISP_FED_SQRT_PST_OFST                      ((0x070c  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16: 0        reg_sqrt_pst_ofst         // signed ,    RW, default = 0  post offset after square root
#define ISP_FED_SQRT_EN_MODE                       ((0x070d  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8           reg_sqrt1_mode            // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for square root 1 lut
//Bit  7: 5        reserved
//Bit  4           reg_sqrt0_en              // unsigned ,    RW, default = 1  enable sqrt0
//Bit  3: 1        reserved
//Bit  0           reg_sqrt1_en              // unsigned ,    RW, default = 1  enable sqrt1
#define ISP_FED_SQRT_STP                           ((0x070e  << 2) + 0xfe3b4000)
//Bit 31:28        reg_sqrt1_stp_7           // unsigned ,    RW, default = 15  step for each segment of  square root 1 lut
//Bit 27:24        reg_sqrt1_stp_6           // unsigned ,    RW, default = 14  step for each segment of  square root 1 lut
//Bit 23:20        reg_sqrt1_stp_5           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 19:16        reg_sqrt1_stp_4           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 15:12        reg_sqrt1_stp_3           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 11: 8        reg_sqrt1_stp_2           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit  7: 4        reg_sqrt1_stp_1           // unsigned ,    RW, default = 12  step for each segment of  square root 1 lut
//Bit  3: 0        reg_sqrt1_stp_0           // unsigned ,    RW, default = 11  step for each segment of  square root 1 lut
#define ISP_FED_SQRT_NUM                           ((0x070f  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_sqrt1_num_7           // unsigned ,    RW, default = 3  numbers for each segment of  square root 1 lut
//Bit 27            reserved
//Bit 26:24        reg_sqrt1_num_6           // unsigned ,    RW, default = 3  numbers for each segment of  square root 1 lut
//Bit 23            reserved
//Bit 22:20        reg_sqrt1_num_5           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 19            reserved
//Bit 18:16        reg_sqrt1_num_4           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 15            reserved
//Bit 14:12        reg_sqrt1_num_3           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 11            reserved
//Bit 10: 8        reg_sqrt1_num_2           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit  7            reserved
//Bit  6: 4        reg_sqrt1_num_1           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit  3            reserved
//Bit  2: 0        reg_sqrt1_num_0           // unsigned ,    RW, default = 5  numbers for each segment of  square root 1 lut
#define ISP_FED_SQRT0_ADDR                         ((0x071a  << 2) + 0xfe3b4000)
//Bit  31:6        reserved
//Bit  5: 0        reg_prefe_lut0_addr        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT0_DATA                         ((0x071b  << 2) + 0xfe3b4000)
//Bit  31:20       reserved
//Bit  19: 0       reg_prefe_lut0_data        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT1_ADDR                         ((0x071c  << 2) + 0xfe3b4000)
//Bit  31:8        reserved
//Bit  7: 0        reg_prefe_lut1_addr        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT1_DATA                         ((0x071d  << 2) + 0xfe3b4000)
//Bit  31:20       reserved
//Bit  19: 0       reg_prefe_lut1_data        // unsigned ,    RW, default = 0
#define ISP_FED_GCLK                               ((0x071e  << 2) + 0xfe3b4000)
//Bit 31:6      reserved
//Bit 5:0       reg_pre_gclk_ctrl             // unsigned  ,   RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_fed_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_nr_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBIC_CS_COMMON                        ((0x0780  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_xphs_ofst             // unsigned ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 4        reg_yphs_ofst             // unsigned ,    RW, default = 0
//Bit  3: 2        reserved
//Bit  1: 0        reg_cubic_cs_derr_mode    // unsigned ,    RW, default = 2  diagonal G5 interpolation error mode: 0: |g1/g0-g2|, 1: 2*|g1/g0-g2|, 2: |g1/g0-g2| + (|g0-g3|or|g1-g4|)/2; 3: |g1/g0-g2| + (|g0-g3|or|g1-g4|)
#define ISP_CUBIC_CS_CRTL                          ((0x0781  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_cubic_cs_dint_alph    // unsigned ,    RW, default = 4  diagonal interpolation mode, 0: just use (G1+G2)/2 or (G0+G2)/2, 7: ((G1+G2)or(G0+G2))/4 + G0/2; default= 4
//Bit 27:24        reg_cubic_cs_G3bld_alp    // unsigned ,    RW, default = 0  blend alpha of G3(XC criteria) with G5, for iG, only for rb2uv; norm to 16 as 1; default= 0
//Bit 23:20        reg_cubic_detect_thrd_rt  // unsigned ,    RW, default = 8  detect bad point thrd ratio
//Bit 19:16        reg_cubic_dpc_avg_rt      // unsigned ,    RW, default = 14  min_err and min2_err is almost same,but dat is quite different,use min_err >= min2_err * rt ? use avg : use dat[min_err];
//Bit 15: 8        reg_cubic_cs_vint_thrd    // unsigned ,    RW, default = 25  bayer2yuv,vertical interpolation mode=err[2]>=thrd*4: just use G2, else: (G0+G1)/4 + G2/2; default= 25
//Bit  7: 4        reg_cubic_cs_diff_gain    // unsigned ,    RW, default = 1  bayer2yuv, gain to diff for error modifications, the larger of this value, the less cross color will be; default = 1;
//Bit  3: 0        reg_cubic_cs_grad_gain    // unsigned ,    RW, default = 8  bayer2yuv, gain to gradient for error modifications, the smaller of this value, the more reliable on xc-diff; norm to 8 as 1.0 default = 8;
#define ISP_CUBIC_CS_DRT                           ((0x0782  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cubic_cs_useavg_th    // unsigned ,    RW, default = 10  bayer2yuv,max_err<(th*4), use average g0~g2 as og for DbDr calculation (flat region), default =10;
//Bit 23:20        reg_cubic_cs_useavg_rt    // unsigned ,    RW, default = 12  bayer2yuv, min_err>(max_err*rate/16), use average g0~g2 as og for DbDr calculation (non good edge), default =12;
//Bit 19:16        reg_cubic_cs_usedrt_rt    // unsigned ,    RW, default = 13  bayer2yuv, min_err<(max_err*rate/16), use 100% drt g0~g2 as og for DbDr calculation (very good edge), otherwise (avg+3*drt)/4, default = 8;
//Bit 15:12        reg_cubic_cs_direct_en    // unsigned ,    RW, default = 15  enable of the four directions for the G5 calc, b[0]: horizontal, b[1]: D0(TL-BR), b[2]: Vertical; b[3]: D1(TR-BL), default=b'1111
//Bit 11: 8        reg_cubic_csi_diff_gain   // unsigned ,    RW, default = 1  yuv2bayer, gain to diff for error modifications, the larger of this value, the less cross color will be; default = 1;
//Bit  7: 0        reg_cubic_csi_vint_thrd   // unsigned ,    RW, default = 25  yuv2bayer,vertical interpolation mode=err[2]>=thrd*4: just use G2, else: (G0+G1)/4 + G2/2; default = 25
#define ISP_CUBIC_CSI_DRT                          ((0x0783  << 2) + 0xfe3b4000)
//Bit 31:28        reg_cubic_csi_grad_gain   // unsigned ,    RW, default = 8  bayer2yuv, gain to gradient for error modifications, the smaller of this value, the more reliable on xc-diff; norm to 8 as 1.0 default = 8;
//Bit 27:24        reg_cubic_csi_useavg_rt   // unsigned ,    RW, default = 12  yuv2bayer, min_err>(max_err*rate/16), use average g0~g2 as og for DbDr calculation (non good edge), default = 12;
//Bit 23:20        reg_cubic_csi_usedrt_rt   // unsigned ,    RW, default = 13  bayer2yuv, min_err<(max_err*rate/16), use 100% drt g0~g2 as og for DbDr calculation (very good edge), otherwise (avg+3*drt)/4, default = 8;
//Bit 19:16        reg_cubic_csi_direct_en   // unsigned ,    RW, default = 15  enable of the four directions for the G5 calc, b[0]: horizontal, b[1]: D0(TL-BR), b[2]: Vertical; b[3]: D1(TR-BL), default =b'1111
//Bit 15: 8        reg_cubic_csi_color_cor   // unsigned ,    RW, default = 0  yuv2bayer, color coring threshold (hard threshold), default =10;
//Bit  7: 0        reg_cubic_csi_useavg_th   // unsigned ,    RW, default = 10  yuv2bayer, max_err<(th*4), use average g0~g2 as og for DbDr calculation (flat region), default =10;
#define ISP_CUBIC_CS_POWER                         ((0x0784  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_cubic_cs_powersaving  // unsigned ,    RW, default = 2  power saving mode bayer2yuv and yuv2bayer use average; 0,adaptive, 1:use avg; 2/3: use g_avg_within_2x2, default=0
//Bit 23:18        reserved
//Bit 17:16        reg_cubic_csi_powersaving // unsigned ,    RW, default = 2  power saving mode bayer2yuv and yuv2bayer use average; 0,adaptive, 1:use avg; 2/3: use g_avg_within_2x2, default=0
//Bit 15: 0        reserved
#define ISP_CUBIC_RAD_CRTL                         ((0x0785  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26           reg_rad_tnr0_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  TNR0;
//Bit 25           reg_rad_snr1_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  SNR1;
//Bit 24           reg_rad_tnr2_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  TNR2;
//Bit 23:16        reg_rad_tnr0_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to tnr0_rad_gain, norm to 64 as 1.0, the larger, the more TNR0 on the border
//Bit 15: 8        reg_rad_snr1_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to snr1_rad_gain, norm to 64 as 1.0, the larger, the more SNR1 on the border
//Bit  7: 0        reg_rad_tnr2_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to tnr2_rad_gain, norm to 64 as 1.0, the larger, the more TNR2 on the border
#define ISP_CUBIC_RAD_SCL0                         ((0x0786  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rad_xscale            // unsigned ,    RW, default = 64  norm 512 as "1"; x scale <=65536/(ColMax)*32
//Bit 15: 0        reg_rad_yscale            // unsigned ,    RW, default = 64  norm 512 as "1"; y scale <=65536/(RowMax)*32
#define ISP_CUBIC_RAD_CENTER                       ((0x0787  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rad_centerx           // unsigned ,    RW, default = 540  the coordinates of the center of the image on the X axis
//Bit 15: 0        reg_rad_centery           // unsigned ,    RW, default = 960  the coordinates of the center of the image on the Y axis
#define ISP_CUBIC_RAD_SCL1                         ((0x0788  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_rad_scale             // unsigned ,    RW, default = 181  rad scale up to fill 65bin lut, set to 128*2/sqrt(a^2 +b^2), norm to 128 as "1", 256/1.414
#define ISP_CUBIC_LUT65_ADDR                       ((0x0790  << 2) + 0xfe3b4000)
//Bit  31:5        reserved
//Bit  4: 0        reg_rad_lut65_addr        // unsigned ,    RW, default = 0
#define ISP_CUBIC_LUT65_DATA                       ((0x0791  << 2) + 0xfe3b4000)
//Bit  31: 0       reg_rad_lut65_data        // unsigned ,    RW, default = 0
#define ISP_CUBIC_GCLK                             ((0x0792  << 2) + 0xfe3b4000)
//Bit 31:8      reserved
//Bit 7:6       reserved
//Bit 5:0       reg_gclk_ctrl_top             // unsigned  ,   RW, default = 0
#define ISP_TNR_GCLK_CTRL                          ((0x0793  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_tnr_gclk_ctrl             // unsigned ,    RW, default = 0
#define ISP_MCNR_GCLK_CTRL                         ((0x0794  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_mcnr_gclk_ctrl            // unsigned ,    RW, default = 0
#define ISP_SNR_GCLK_CTRL                          ((0x0795  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_snr_gclk_ctrl             // unsigned ,    RW, default = 0
#define ISP_RCNR_GCLK_CTRL                         ((0x0796  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_rcnr_gclk_ctrl            // unsigned ,    RW, default = 0
#define ISP_NR_TOP_GCLK_CTRL                       ((0x0797  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_nr_top_gclk_ctrl          // unsigned ,    RW, default = 0
#define ISP_NR_DBG_PATH_CTRL                       ((0x0798  << 2) + 0xfe3b4000)
//Bit  31: 16       reg_nr_dbg_path_gain          // unsigned ,    RW, default = 0
//Bit  15: 1        reg_nr_dbg_path_sel           // unsigned ,    RW, default = 0
//Bit  0            reg_nr_dbg_path_en            // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_nr_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_CAC_APB_BASE = 0x08
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_cac_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CAC_CNTL                               ((0x0800  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_cac_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset
//Bit 27:26        reserved
//Bit 25:24        reg_cac_xphs_ofst         // unsigned ,    RW, default = 1  horizontal phase offset
//Bit 23:12        reg_cac_col_step          // unsigned ,    RW, default = 12'h3e
//Bit 11: 0        reg_cac_row_step          // unsigned ,    RW, default = 12'h24
#define ISP_CAC_CNTL0                              ((0x0801  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22: 0        reg_cac_col_step_inv      // unsigned ,    RW, default = 23'h42108  the inversion of column step
#define ISP_CAC_CNTL1                              ((0x0802  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22: 0        reg_cac_row_step_inv      // unsigned ,    RW, default = 23'h71c72  inversion of row step
#define ISP_CAC_COL_OFFSET                         ((0x0803  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 8        reg_cac_col_idx_offset1   // unsigned ,    RW, default = 0  the offset of colum alpha index
//Bit  7: 5        reserved
//Bit  4: 0        reg_cac_col_idx_offset0   // unsigned ,    RW, default = 0  the offset of column index
#define ISP_CAC_FILTER_COEF0                       ((0x0804  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_0      // unsigned ,    RW, default = 32'h8000  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF1                       ((0x0805  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_1      // unsigned ,    RW, default = 32'h280fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF2                       ((0x0806  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_2      // unsigned ,    RW, default = 32'h57ffc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF3                       ((0x0807  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_3      // unsigned ,    RW, default = 32'hff087dfb  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF4                       ((0x0808  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_4      // unsigned ,    RW, default = 32'hff0c7bfa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF5                       ((0x0809  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_5      // unsigned ,    RW, default = 32'hff1079f9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF6                       ((0x080a  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_6      // unsigned ,    RW, default = 32'hfe1476f8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF7                       ((0x080b  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_7      // unsigned ,    RW, default = 32'hfe1873f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF8                       ((0x080c  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_8      // unsigned ,    RW, default = 32'hfd1d6ff7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF9                       ((0x080d  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_9      // unsigned ,    RW, default = 32'hfc226bf7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF10                      ((0x080e  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_10     // unsigned ,    RW, default = 32'hfc2767f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF11                      ((0x080f  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_11     // unsigned ,    RW, default = 32'hfb2c62f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF12                      ((0x0810  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_12     // unsigned ,    RW, default = 32'hfa325df7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF13                      ((0x0811  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_13     // unsigned ,    RW, default = 32'hfa3758f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF14                      ((0x0812  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_14     // unsigned ,    RW, default = 32'hf93d53f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF15                      ((0x0813  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_15     // unsigned ,    RW, default = 32'hf9424df8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF16                      ((0x0814  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_16     // unsigned ,    RW, default = 32'hf84848f8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF17                      ((0x0815  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_17     // unsigned ,    RW, default = 32'hf84d42f9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF18                      ((0x0816  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_18     // unsigned ,    RW, default = 32'hf7533df9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF19                      ((0x0817  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_19     // unsigned ,    RW, default = 32'hf75837fa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF20                      ((0x0818  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_20     // unsigned ,    RW, default = 32'hf75d32fa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF21                      ((0x0819  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_21     // unsigned ,    RW, default = 32'hf7622cfb  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF22                      ((0x081a  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_22     // unsigned ,    RW, default = 32'hf76727fc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF23                      ((0x081b  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_23     // unsigned ,    RW, default = 32'hf76b22fc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF24                      ((0x081c  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_24     // unsigned ,    RW, default = 32'hf76f1dfd  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF25                      ((0x081d  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_25     // unsigned ,    RW, default = 32'hf77318fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF26                      ((0x081e  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_26     // unsigned ,    RW, default = 32'hf87614fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF27                      ((0x081f  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_27     // unsigned ,    RW, default = 32'hf97910ff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF28                      ((0x0820  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_28     // unsigned ,    RW, default = 32'hfa7b0cff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF29                      ((0x0821  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_29     // unsigned ,    RW, default = 32'hfb7d08ff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF30                      ((0x0822  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_30     // unsigned ,    RW, default = 32'hfc7f0500  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF31                      ((0x0823  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cac_cubic_coef_31     // unsigned ,    RW, default = 32'hfe800200  cac interpolation coefficients
#define ISP_PDPC_CNTL                              ((0x0824  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16           reg_pdpc_ic_mimx3x3       // unsigned ,    RW, default = 1  use minmax3 as local range decision, 0: use 5x5; 1:3x3
//Bit 15:13        reserved
//Bit 12           reg_pdpc_oc_minmax        // unsigned ,    RW, default = 1  use out of channel minmax3 same components as local range decision, 0: no use ; 1: use min max of same color (raw_mode=0/1/4, chn=0/3)
//Bit 11: 9        reserved
//Bit  8           reg_pdpc_th_mode          // unsigned ,    RW, default = 1  mode of reg_pulnr_thrd[i].  0:i is for channel number; 1: i is the pixel level 4 piece, can set thrd based on the level. default=1
//Bit  7: 6        reserved
//Bit  5: 4        reg_pdpc_lpf_alp          // unsigned ,    RW, default = 2  alpha for lpf, the larger of alpha, the more heavier of the lpf. default = 2
//Bit  3: 1        reserved
//Bit  0           reg_pdpc_lpf_sel          // unsigned ,    RW, default = 0  select the lpf output when hot/dead pixel
#define ISP_PDPC_THRD0                             ((0x0825  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pdpc_thrd_0           // unsigned ,    RW, default = 1  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 23:16        reg_pdpc_thrd_1           // unsigned ,    RW, default = 2  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 15: 8        reg_pdpc_thrd_2           // unsigned ,    RW, default = 2  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit  7: 0        reg_pdpc_thrd_3           // unsigned ,    RW, default = 3  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
#define ISP_PDPC_RATIO_CTRL                        ((0x0826  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pdpc_thrd_4           // unsigned ,    RW, default = 4  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 23:22        reserved
//Bit 21:16        reg_pdpc_ic_ratio         // unsigned ,    RW, default = 16  same channel (in Channel) margin ratio from each direction [-2,-1] [+1, 2] prediction, norm to 16 as 1.0, default= 16;
//Bit 15:14        reserved
//Bit 13: 8        reg_pdpc_oc_ratio         // unsigned ,    RW, default = 16  nearby neighbor channel (out Channel)var ratio, the larger of this ratio, the less possibility dp detected, norm to 32 as 1.0, default, 16;
//Bit  7: 0        reg_pdpc_oc_coring        // unsigned ,    RW, default = 4  nearby neighbor channel (out Channel)var coring, the larger of this coring, the less possibility dp detected, 4x in uBL scale;
#define ISP_PDPC_THR_CTRL                          ((0x0827  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pdpc_dead_thr         // unsigned ,    RW, default = 512  dead pixel threshold, default , BLC in sqrt domain, sqrt((BLC+0x40)/4096)*4096
//Bit 15: 0        reg_pdpc_hoti_thr         // unsigned ,    RW, default = 65535  hot  pixel threshold, maximum valid pixel range
#define ISP_LCGE_EN                                ((0x0828  << 2) + 0xfe3b4000)
//Bit 31:14        reserved
//Bit 13           reg_lcge_mono_mode_en     // unsigned ,    RW, default = 0  enale of lcge  in mono mode
//Bit 12: 8        reg_lcge_flat_rate        // unsigned ,    RW, default = 3  flat ratio of lpf g, 32 as 1
//Bit  7: 0        reg_lcge_gdiff_rate       // unsigned ,    RW, default = 32  detail ratio of avg g, 256 as 1
#define ISP_LCGE_FLAT_TH_MIN_MAX                   ((0x0829  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcge_flat_var_th_min  // unsigned ,    RW, default = 30  variance min threshold
//Bit 15: 0        reg_lcge_flat_var_th_max  // unsigned ,    RW, default = 2000  variance max threshold
#define ISP_LCGE_FLAT_RATIO_0                      ((0x082a  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_0          // unsigned ,    RW, default = 0  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_0          // unsigned ,    RW, default = 0  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_1                      ((0x082b  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_1          // unsigned ,    RW, default = 4  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_1          // unsigned ,    RW, default = 1  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_2                      ((0x082c  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_2          // unsigned ,    RW, default = 8  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_2          // unsigned ,    RW, default = 2  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_3                      ((0x082d  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_3          // unsigned ,    RW, default = 12  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_3          // unsigned ,    RW, default = 3  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_4                      ((0x082e  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_4          // unsigned ,    RW, default = 16  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_4          // unsigned ,    RW, default = 4  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_5                      ((0x082f  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_5          // unsigned ,    RW, default = 20  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_5          // unsigned ,    RW, default = 5  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_6                      ((0x0830  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_6          // unsigned ,    RW, default = 24  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_6          // unsigned ,    RW, default = 6  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_7                      ((0x0831  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_7          // unsigned ,    RW, default = 28  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_7          // unsigned ,    RW, default = 7  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_ALPHA                             ((0x0832  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 9        reg_lcge_alpha_8          // unsigned ,    RW, default = 8  flat alpha to blend current and avg_g, 16 as 1
//Bit  8           reg_lcge_hv_line_en       // unsigned ,    RW, default = 0  short horizontal or vertical lines
//Bit  7           reg_lcge_hv_line_tnr_meta_en // unsigned ,    RW, default = 1  lcge in motion area, 0: whole frame do lcge, 1: motion area do lcge
//Bit  6: 4        reg_lcge_hv_line_tnr_meta_th // unsigned ,    RW, default = 0  lcge in motion area, tnr_meta <= th
//Bit  3: 0        reg_lcge_hv_line_alpha    // unsigned ,    RW, default = 8  alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_HV_LINE_DIFF_TH                   ((0x0833  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcge_hv_line_diff_th  // signed ,    RW, default = 0  condition1,threshold of diff
//Bit 15: 0        reg_lcge_hv_line_cor2_diff_th // signed ,    RW, default = 0  condition2, threshold of diff corner pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_cac_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_cac_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CAC_GCLK_CTRL                          ((0x0870  << 2) + 0xfe3b4000)
//Bit 31:22       reserved
//Bit 21: 0       reg_cac_wrap_gc                 // unsigned ,    RW, default = 22'h0  reg_cac_wrap_gc
#define ISP_CAC_COL_ALPHA                          ((0x0871  << 2) + 0xfe3b4000)
//Bit 31:24       reserved
//Bit 23: 0       reg_cac_col_alpha_ofst          // unsigned ,    RW, default = 24'h0  reg_cac_col_alpha_ofst=reg_cac_col_idx_offset1*reg_cac_col_step_inv
#define ISP_CAC_TAB_DATA                           ((0x0880  << 2) + 0xfe3b4000)
//Bit 31: 0       reg_cac_ram_data                // unsigned ,    RW, default = 31'h0  reg_cac_ram_data
#define ISP_CAC_TAB_ADDR                           ((0x0881  << 2) + 0xfe3b4000)
//Bit 31:18       reserved
//Bit 17:16       reg_cac_ram_chnx                // unsigned ,    RW, default = 2'h0   reg_cac_ram_chnx
//Bit 15:13       reserved
//Bit 12: 8       reg_cac_ram_vidx                // unsigned ,    RW, default = 5'h0   reg_cac_ram_vidx
//Bit  7: 5       reserved
//Bit  4: 0       reg_cac_ram_hidx                // unsigned ,    RW, default = 5'h0   reg_cac_ram_hidx
#define ISP_CAC_TAB_CTRL                           ((0x0882  << 2) + 0xfe3b4000)
//Bit 31: 1       reserved
//Bit     0       reg_cac_apb2ram_en              // unsigned ,    RW, default = 1'h0   reg_cac_apb2ram_en
#define ISP_CAC_TAB_INT                            ((0x0883  << 2) + 0xfe3b4000)
//Bit 31: 1       reserved
//Bit     0       reg_ram_cfg_done_status         // unsigned ,    RW, default = 1'h0   reg_ram_cfg_done_status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_cac_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_NLM_APB_BASE = 0x09
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_snr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_SNR_CTRL                               ((0x0900  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:26        reg_snr_xphs_ofst         // unsigned ,    RW, default = 1
//Bit 25:24        reg_snr_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 23:21        reserved
//Bit 20           reg_snr_cur_wind_lpf_en   // unsigned ,    RW, default = 1
//Bit 19:17        reserved
//Bit 16           reg_snr_meta_en           // unsigned ,    RW, default = 1  snr meta adaptive enable, 0:disable,1:enable,default:1
//Bit 15:12        reserved
//Bit 11           reg_snr_sad_chk_mb_en     // unsigned ,    RW, default = 0  snr motion boundary add coring enable, 0:disable,1:enable,default:1                                                  //u
//Bit 10           reg_snr_smooth_mask       // unsigned ,    RW, default = 1  smooth maskmap
//Bit  9           reg_snr_rad_en            // unsigned ,    RW, default = 1  snr radius gain enable,0:disable,1:enable .cubic_t.reg_rad_snr1_en = 1 will calculate snr1_rad_gain
//Bit  8           reg_snr_sub_bl_en         // unsigned ,    RW, default = 0  : when calculating average intensity, could choose to subtract the black level,  default:0, do not subtract black level
//Bit  7: 5        reserved
//Bit  4           reg_snr_wt_sad_th_en      // unsigned ,    RW, default = 1  wdr adj
//Bit  3           reg_snr_coring_var_en     // unsigned ,    RW, default = 1  wdr adj
//Bit  2           reg_snr_coring_grad_en    // unsigned ,    RW, default = 1  wdr adj
//Bit  1           reg_snr_wt_ratio_en       // unsigned ,    RW, default = 1  wdr adj
//Bit  0           reg_snr_mask_en           // unsigned ,    RW, default = 1  wdr adj
#define ISP_SNR_RATIO0                             ((0x0901  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_ratio_gr          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit 15: 8        reg_snr_ratio_r           // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit  7: 0        reg_snr_ratio_b           // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
#define ISP_SNR_RATIO1                             ((0x0902  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_ratio_gb          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_ratio_ir          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
#define ISP_SNR_WT_LUT_0                           ((0x0903  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_wt_lut_3          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_2          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_1          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_0          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_1                           ((0x0904  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_wt_lut_7          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_6          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_5          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_4          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_2                           ((0x0905  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_wt_lut_11         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_10         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_9          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_8          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_3                           ((0x0906  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_wt_lut_15         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_14         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_13         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_12         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_APL_BLACK_LEVEL                        ((0x0907  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 8        reg_snr_bl                // unsigned ,    RW, default = 1470  when calculating average intensity, could choose to subtract the black level,  default:sqrt(black_level/2^20)*2^12, fw set
//Bit  7: 0        reg_snr_bl_ratio          // unsigned ,    RW, default = 192  adjest apl ,16 is "1"
#define ISP_SNR_SAD_CURV                           ((0x0908  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_snr_sad_th_mode       // unsigned ,    RW, default = 0  of sad th calcuate, 0: avg and avg_l bland , 1: avg and avg_h bland
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_avg_alpha     // unsigned ,    RW, default = 8  of avg when bland with avg_l or avg_h  16 is "1"  (0-16)
//Bit 15: 8        reg_snr_sad_min_th        // unsigned ,    RW, default = 255  threshold of sad min th
//Bit  7: 0        reg_snr_sad_max_th        // unsigned ,    RW, default = 255  threshold of sad max th
#define ISP_SNR_META_LUT0                          ((0x0909  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_0        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reg_snr_meta_adj_1        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit  7: 0        reg_snr_meta_adj_2        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_META_LUT1                          ((0x090a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_3        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reg_snr_meta_adj_4        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit  7: 0        reg_snr_meta_adj_5        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_META_LUT2                          ((0x090b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_6        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_meta_adj_7        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_MASK_LUT0                          ((0x090c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_0        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reg_snr_mask_adj_1        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit  7: 0        reg_snr_mask_adj_2        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_MASK_LUT1                          ((0x090d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_3        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reg_snr_mask_adj_4        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit  7: 0        reg_snr_mask_adj_5        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_MASK_LUT2                          ((0x090e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_6        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_mask_adj_7        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_PROFILE_ADJ                        ((0x090f  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30           reg_snr_sad_cor_manual_mode // unsigned ,    RW, default = 0  0:noise profile lut, 1: apl curve
//Bit 29:16        reserved
//Bit 15: 8        reg_snr_sad_cor_profile_adj // unsigned ,    RW, default = 64  increase flexibility of LUT noise profile tuning
//Bit  7: 0        reg_snr_sad_cor_profile_ofst // signed ,    RW, default = 0  increase flexibility of lut noise profile tuning
#define ISP_SNR_SAD_META_RATIO                     ((0x0910  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_sad_meta_ratio_3  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_meta_ratio_2  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit 15:13        reserved
//Bit 12: 8        reg_snr_sad_meta_ratio_1  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit  7: 5        reserved
//Bit  4: 0        reg_snr_sad_meta_ratio_0  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
#define ISP_SNR_SAD_META_BND                       ((0x0911  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_snr_sad_meta_bnd_2    // unsigned ,    RW, default = 5  meta boundary2 for sad calculation
//Bit  7: 4        reg_snr_sad_meta_bnd_1    // unsigned ,    RW, default = 3  meta boundary1 for sad calculation
//Bit  3: 0        reg_snr_sad_meta_bnd_0    // unsigned ,    RW, default = 1  meta boundary0 for sad calculation
#define ISP_SNR_CORING                             ((0x0912  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_sad_th_y0         // unsigned ,    RW, default = 4  curve value of coring
//Bit 11: 0        reg_snr_sad_th_y1         // unsigned ,    RW, default = 8
#define ISP_SNR_CORING_1                           ((0x0913  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_sad_th_y2         // unsigned ,    RW, default = 12
//Bit 11: 0        reg_snr_sad_max_coring    // unsigned ,    RW, default = 1024  the max coring for calculate sad
#define ISP_SNR_CORING_2                           ((0x0914  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:24        reg_snr_sad_cor_alp_rs    // unsigned ,    RW, default = 4  shift bits apl for calculate coring
//Bit 23:16        reg_snr_sad_th_x0         // unsigned ,    RW, default = 70  threshold x0 of thr coring curve
//Bit 15:12        reg_snr_sad_th_x1         // unsigned ,    RW, default = 2  threshold = x0 + (1<<x1)
//Bit 11: 8        reg_snr_sad_th_x2         // unsigned ,    RW, default = 2  threshold = x0 + (1<<x1) + (1<<x2)
//Bit  7: 0        reg_snr_mix_th_iso_gain   // unsigned ,    RW, default = 32  iso gain for coring
#define ISP_SNR_CORING_META2ALP_0                  ((0x0915  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_sad_meta2alp_3    // unsigned ,    RW, default = 48  adjust coring according meta
//Bit 23:16        reg_snr_sad_meta2alp_2    // unsigned ,    RW, default = 64  adjust coring according meta
//Bit 15: 8        reg_snr_sad_meta2alp_1    // unsigned ,    RW, default = 120  adjust coring according meta
//Bit  7: 0        reg_snr_sad_meta2alp_0    // unsigned ,    RW, default = 240  adjust coring according meta
#define ISP_SNR_CORING_META2ALP_1                  ((0x0916  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_sad_meta2alp_7    // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 23:16        reg_snr_sad_meta2alp_6    // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 15: 8        reg_snr_sad_meta2alp_5    // unsigned ,    RW, default = 24  adjust coring according meta
//Bit  7: 0        reg_snr_sad_meta2alp_4    // unsigned ,    RW, default = 32  adjust coring according meta
#define ISP_SNR_MB_APL                             ((0x0917  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 8        reg_snr_sad_mb_apl_th     // unsigned ,    RW, default = 48  boundary apl threshold
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_sad_mb_gain       // unsigned ,    RW, default = 0  gain of diff_apl add to coring in light shadow
#define ISP_SNR_MB_META                            ((0x0918  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_sad_mb_meta_sth   // unsigned ,    RW, default = 3  boundary static meta threshold  (0-16)
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_mb_meta_mth   // unsigned ,    RW, default = 1  boundary motion meta threshold   (0-16)
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_sad_mb_meta_cnt_sth // unsigned ,    RW, default = 6  boundary static count threshold  (0-35)
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_sad_mb_meta_cnt_mth // unsigned ,    RW, default = 6  boundary motion count threshold  (0-35)
#define ISP_SNR_CORING_GRAD                        ((0x0919  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_lpf_phs_grad_ratio // unsigned ,    RW, default = 16  max_grad and min_grad ratio decision edge  256 is "1"
//Bit 23:16        reg_snr_grad_max_th       // unsigned ,    RW, default = 8  the threshold of flatness
//Bit 15:13        reserved
//Bit 12: 8        reg_snr_grad_flat_gain    // unsigned ,    RW, default = 16  flatness coring gain
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_gain_4       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
#define ISP_SNR_CORING_GRAD_RATIO                  ((0x091a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_grad_ratio_3      // unsigned ,    RW, default = 6  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit 23:22        reserved
//Bit 21:16        reg_snr_grad_ratio_2      // unsigned ,    RW, default = 12  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_grad_ratio_1      // unsigned ,    RW, default = 20  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_ratio_0      // unsigned ,    RW, default = 32  and min_grad ratio decision the strength of boundary, 64 as 1.0
#define ISP_SNR_CORING_GRAD_GAIN                   ((0x091b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_grad_gain_3       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit 23:22        reserved
//Bit 21:16        reg_snr_grad_gain_2       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_grad_gain_1       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_gain_0       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
#define ISP_SNR_CORING_MASK                        ((0x091c  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_sad_th_mask_gain_0 // unsigned ,    RW, default = 8  adjust coring according mask, for wdr case,norm 16 as .1
//Bit 23:16        reg_snr_sad_th_mask_gain_1 // unsigned ,    RW, default = 10  adjust coring according mask, for wdr case,norm 16 as .1
//Bit 15: 8        reg_snr_sad_th_mask_gain_2 // unsigned ,    RW, default = 14  adjust coring according mask, for wdr case,norm 16 as .1
//Bit  7: 0        reg_snr_sad_th_mask_gain_3 // unsigned ,    RW, default = 16  adjust coring according mask, for wdr case,norm 16 as .1
#define ISP_SNR_WT_LUMA_ADJ                        ((0x091d  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 9        reserved
//Bit  8           reg_snr_luma_adj_en       // unsigned ,    RW, default = 0  adjust wt according luma
//Bit  7: 4        reg_snr_wt_luma_meta_th   // unsigned ,    RW, default = 4  threshold of meta
//Bit  3: 0        reg_snr_wt_luma_idx_rs    // unsigned ,    RW, default = 9
#define ISP_SNR_WT_LUMA_SCAL_0                     ((0x091e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_wt_luma_gain_3    // unsigned ,    RW, default = 32
//Bit 23:22        reserved
//Bit 21:16        reg_snr_wt_luma_gain_2    // unsigned ,    RW, default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_luma_gain_1    // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_luma_gain_0    // unsigned ,    RW, default = 32
#define ISP_SNR_WT_LUMA_SCAL_1                     ((0x091f  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_wt_luma_gain_7    // unsigned ,    RW, default = 32
//Bit 23:22        reserved
//Bit 21:16        reg_snr_wt_luma_gain_6    // unsigned ,    RW, default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_luma_gain_5    // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_luma_gain_4    // unsigned ,    RW, default = 32
#define ISP_SNR_WT_IDX_RATIO                       ((0x0920  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_idx_wt_ratio_3    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit 23:16        reg_snr_idx_wt_ratio_2    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit 15: 8        reg_snr_idx_wt_ratio_1    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit  7: 0        reg_snr_idx_wt_ratio_0    // unsigned ,    RW, default = 128  wt accoring current wt position
#define ISP_SNR_SAD_IDX_RATIO                      ((0x0921  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_sad_idx_ratio_3   // unsigned ,    RW, default = 64  sad according candidate position
//Bit 23:16        reg_snr_sad_idx_ratio_2   // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_sad_idx_ratio_1   // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_sad_idx_ratio_0   // unsigned ,    RW, default = 64
#define ISP_SNR_SAD_IDX_OFFSET                     ((0x0922  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_sad_idx_offset_3  // signed ,    RW, default = 0  sad according candidate position
//Bit 23:16        reg_snr_sad_idx_offset_2  // signed ,    RW, default = 0
//Bit 15: 8        reg_snr_sad_idx_offset_1  // signed ,    RW, default = 0
//Bit  7: 0        reg_snr_sad_idx_offset_0  // signed ,    RW, default = 0
#define ISP_SNR_VARIANCE_FLAT                      ((0x0923  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:29        reg_snr_var_flat_mode     // unsigned ,    RW, default = 1  mode in calculate coring , 0 : sum,  1: max2 ,2: blend
//Bit 28           reg_snr_var_meta_en       // unsigned ,    RW, default = 0  check according meta enble
//Bit 27:25        reserved
//Bit 24:20        reg_snr_var_meta_th       // unsigned ,    RW, default = 4  of meta in variance  (0-16)
//Bit 19: 8        reg_snr_var_flat_th_x0    // unsigned ,    RW, default = 64  x0 of the variance
//Bit  7: 4        reg_snr_var_flat_th_x1    // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_var_flat_th_x2    // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_VARIANCE_FLAT_GAIN                 ((0x0924  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:16        reg_snr_var_flat_th_y_2   // unsigned ,    RW, default = 32  value of variance gain
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_var_flat_th_y_1   // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_var_flat_th_y_0   // unsigned ,    RW, default = 32
#define ISP_SNR_VARIANCE_EDGE                      ((0x0925  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_snr_var_edge_mode     // unsigned ,    RW, default = 1  mode in calculate coring , 0 : sum,  1: max2 ,2: blend
//Bit 23:20        reg_snr_var_edge_weight   // unsigned ,    RW, default = 8  weight in variance blend ,normal 16 as 1
//Bit 19: 8        reg_snr_var_edge_th_x0    // unsigned ,    RW, default = 64  x0 of the variance
//Bit  7: 4        reg_snr_var_edge_th_x1    // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_var_edge_th_x2    // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_VARIANCE_EDGE_GAIN                 ((0x0926  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:16        reg_snr_var_edge_th_y_2   // unsigned ,    RW, default = 32  value of variance gain
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_var_edge_th_y_1   // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_var_edge_th_y_0   // unsigned ,    RW, default = 32
#define ISP_SNR_VARIANCE_BL                        ((0x0927  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16:12        reg_snr_var_coring_ratio  // unsigned ,    RW, default = 16  coring ratio
//Bit 11: 0        reg_snr_var_bl            // unsigned ,    RW, default = 240  black level
#define ISP_SNR_CUR_WT_0                           ((0x0928  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_1          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_0          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_1                           ((0x0929  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_3          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_2          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_2                           ((0x092a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_5          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_4          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_3                           ((0x092b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_7          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_6          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_BLEND_RATIO                    ((0x092c  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_snr_blend_cur_ratio_3 // unsigned ,    RW, default = 0  cur blend ratio
//Bit 11: 8        reg_snr_blend_cur_ratio_2 // unsigned ,    RW, default = 0  cur blend ratio
//Bit  7: 4        reg_snr_blend_cur_ratio_1 // unsigned ,    RW, default = 0  cur blend ratio
//Bit  3: 0        reg_snr_blend_cur_ratio_0 // unsigned ,    RW, default = 0  cur blend ratio
#define ISP_SNR_LPF0                               ((0x092d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_lpf_avg_comp_ratio // unsigned ,    RW, default = 16  ratio
//Bit 23:12        reg_snr_lpf_avg_th        // unsigned ,    RW, default = 1024  of avg in calculate lpf
//Bit 11: 0        reg_snr_lpf_min_th        // unsigned ,    RW, default = 100  of min in calculate lpf
#define ISP_SNR_LPF1                               ((0x092e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_lpf_mm_diff_ratio // unsigned ,    RW, default = 16  of min/max
//Bit 23:12        reg_snr_lpf_mm_diff_th    // unsigned ,    RW, default = 1024  of min/max diff
//Bit 11: 0        reg_snr_lpf_max_th        // unsigned ,    RW, default = 100  of max in calculate lpf
#define ISP_SNR_STRENGHT                           ((0x092f  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_snr_dbg_wt_sft        // unsigned ,    RW, default = 2  weigh sum shift num
//Bit 27:20        reg_snr_wt_th             // unsigned ,    RW, default = 64  of wt used to calculate count sum
//Bit 19:17        reserved
//Bit 16:12        reg_snr_strenght_count_th // unsigned ,    RW, default = 16  of count sum reflect snr strenght
//Bit 11: 0        reg_snr_strenght_wt_th    // unsigned ,    RW, default = 1024  of wt sum reflect snr strenght
#define ISP_SNR_VAR_FLAT_LUMA_SCAL_0               ((0x0930  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_var_flat_luma_gain_3 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_flat_luma_gain_2 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_flat_luma_gain_1 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_flat_luma_gain_0 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_FLAT_LUMA_SCAL_1               ((0x0931  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_var_flat_luma_gain_7 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_flat_luma_gain_6 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_flat_luma_gain_5 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_flat_luma_gain_4 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_EDGE_LUMA_SCAL_0               ((0x0932  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_var_edge_luma_gain_3 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_edge_luma_gain_2 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_edge_luma_gain_1 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_edge_luma_gain_0 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_EDGE_LUMA_SCAL_1               ((0x0933  << 2) + 0xfe3b4000)
//Bit 31:24        reg_snr_var_edge_luma_gain_7 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_edge_luma_gain_6 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_edge_luma_gain_5 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_edge_luma_gain_4 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_LUMA_RS                        ((0x0934  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_snr_var_edge_luma_idx_rs // unsigned ,    RW, default = 9
//Bit  3: 0        reg_snr_var_flat_luma_idx_rs // unsigned ,    RW, default = 9
#define ISP_SNR_WT_VAR_ADJ_X                       ((0x0935  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27           reg_snr_wt_var_adj_en     // unsigned ,    RW, default = 0  adjust variance enable
//Bit 26:24        reserved
//Bit 23:20        reg_snr_wt_var_meta_th    // unsigned ,    RW, default = 0
//Bit 19: 8        reg_snr_wt_var_th_x0      // unsigned ,    RW, default = 1024  x0 of the variance
//Bit  7: 4        reg_snr_wt_var_th_x1      // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_wt_var_th_x2      // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_WT_VAR_ADJ_Y                       ((0x0936  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_wt_var_th_y_2     // unsigned ,    RW, default = 32  value of variance gain
//Bit 15: 8        reg_snr_wt_var_th_y_1     // unsigned ,    RW, default = 32
//Bit  7: 0        reg_snr_wt_var_th_y_0     // unsigned ,    RW, default = 32
#define ISP_SNR_NP_LUT0_0                          ((0x0937  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_1        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_0        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_1                          ((0x0938  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_3        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_2        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_2                          ((0x0939  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_5        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_4        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_3                          ((0x093a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_7        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_6        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_4                          ((0x093b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_9        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_8        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_5                          ((0x093c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_11       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_10       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_6                          ((0x093d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_13       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_12       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_7                          ((0x093e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_15       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_14       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_LPF_PHS_DIFF                       ((0x093f  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19           reg_snr_lpf_use_diff_phs_en // unsigned ,    RW, default = 0  enable of use different phs in snr
//Bit 18           reg_snr_lpf_chk_edge_flag_en // unsigned ,    RW, default = 0  enable of edge check
//Bit 17           reg_snr_lpf_chk_xrate_en  // unsigned ,    RW, default = 0  of check the same phs diff and random phs diff
//Bit 16           reg_snr_lpf_xrate_chk_edge_en // unsigned ,    RW, default = 0  of edge check in check xrate
//Bit 15:12        reserved
//Bit 11: 0        reg_snr_lpf_phs_diff_max  // unsigned ,    RW, default = 400  threshold of phs_th
#define ISP_SNR_LPF_PHS_DIFF_RATEOFSET             ((0x0940  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_lpf_phs_diff_ratio_1 // unsigned ,    RW, default = 16  ratio of phs_diff_th 64 means "1"
//Bit 23:22        reserved
//Bit 21:16        reg_snr_lpf_phs_diff_ratio_0 // unsigned ,    RW, default = 32  ratio of phs_diff_th 64 means "1"
//Bit 15: 8        reg_snr_lpf_phs_diff_ofst_1 // unsigned ,    RW, default = 5  ofset of phs_diff_th
//Bit  7: 0        reg_snr_lpf_phs_diff_ofst_0 // unsigned ,    RW, default = 10  ofset of phs_diff_th
#define ISP_SNR_LPF_PHS_DIFF_XRATEOFSET            ((0x0941  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_lpf_phs_diff_xrate_1 // unsigned ,    RW, default = 12  between the same phs diff and random phs diff
//Bit 23:22        reserved
//Bit 21:16        reg_snr_lpf_phs_diff_xrate_0 // unsigned ,    RW, default = 16  between the same phs diff and random phs diff
//Bit 15: 8        reg_snr_lpf_phs_diff_xofst_1 // unsigned ,    RW, default = 5  between the same phs diff and random phs diff
//Bit  7: 0        reg_snr_lpf_phs_diff_xofst_0 // unsigned ,    RW, default = 10  between the same phs diff and random phs diff
#define ISP_SNR_WT_ADJ                             ((0x0942  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_snr_sad_wt_add_th_ratio // unsigned ,    RW, default = 8  of wt add
//Bit 11: 4        reg_snr_sad_wt_count_th   // unsigned ,    RW, default = 4  of sad sum count
//Bit  3: 2        reserved
//Bit  1           reg_snr_sad_wt_add_en     // unsigned ,    RW, default = 0  enable of add wt adjust according to target snr intensity
//Bit  0           reg_snr_sad_wt_adjust_en  // unsigned ,    RW, default = 0  enable of wt adjust according to target snr intensity
#define ISP_SNR_SAD_MAP_FLAT_TH                    ((0x0943  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:20        reg_snr_sad_flat_th_1     // unsigned ,    RW, default = 32
//Bit 19:18        reserved
//Bit 17: 8        reg_snr_sad_flat_th_0     // unsigned ,    RW, default = 800  of  sad for check flat
//Bit  7: 0        reg_snr_sad_wt_add_wt_th  // unsigned ,    RW, default = 32  of  wt for add wt
#define ISP_SNR_SAD_MAP_EDGE_TH                    ((0x0944  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:12        reg_snr_sad_edge_th_1     // unsigned ,    RW, default = 32
//Bit 11:10        reserved
//Bit  9: 0        reg_snr_sad_edge_th_0     // unsigned ,    RW, default = 800  of  sad for check edge
#define ISP_SNR_SAD_MAP_EDGE_TH1                   ((0x0945  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_snr_sad_edge_th_2     // unsigned ,    RW, default = 32
#define ISP_SNR_SAD_MAP_TXT_TH                     ((0x0946  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:12        reg_snr_sad_txt_th_1      // unsigned ,    RW, default = 32
//Bit 11:10        reserved
//Bit  9: 0        reg_snr_sad_txt_th_0      // unsigned ,    RW, default = 800  of  sad for txt edge
#define ISP_SNR_WT_ADJ_SUM_TH                      ((0x0947  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_snr_sad_wt_sum_th_1   // unsigned ,    RW, default = 512  threshold of target snr intensity
//Bit 15:13        reserved
//Bit 12: 0        reg_snr_sad_wt_sum_th_0   // unsigned ,    RW, default = 1024  threshold of target snr intensity
#define ISP_SNR_MV_CORING_GAIN                     ((0x0948  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:20        reg_snr_coring_mv_gain_x  // unsigned ,    RW, default = 5  x0 of the mv for coring adjust
//Bit 19            reserved
//Bit 18:16        reg_snr_coring_mv_gain_xn // unsigned ,    RW, default = 5  = x0 + 1<<xn
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_coring_mv_gain_y_1 // unsigned ,    RW, default = 16  value of mv gain for coring adjust
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_coring_mv_gain_y_0 // unsigned ,    RW, default = 16
#define ISP_SNR_MV_WT_GAIN                         ((0x0949  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:20        reg_snr_wt_mv_gain_x      // unsigned ,    RW, default = 5  x0 of the mv for wt adjust
//Bit 19            reserved
//Bit 18:16        reg_snr_wt_mv_gain_xn     // unsigned ,    RW, default = 5  = x0 + 1<<xn
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_mv_gain_y_1    // unsigned ,    RW, default = 16  value of mv gain for wt adjust
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_mv_gain_y_0    // unsigned ,    RW, default = 16
#define ISP_SNR_PHS_SEL_ADDR                       ((0x0950  << 2) + 0xfe3b4000)
//Bit 31:3        reserved
//Bit 2:0         reg_snr_phs_sel_addr       // unsigned ,    RW, default = 0
#define ISP_SNR_PHS_SEL_DATA                       ((0x0951  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:0         reg_snr_phs_sel_data     // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_snr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TNR0_APB_BASE = 0x0a
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_mcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_CTRL                            ((0x0a00  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:18        reserved
//Bit 17:16        reg_xphs_ofst             // unsigned ,    RW, default = 1  default:1, range:0~3
//Bit 15:10        reserved
//Bit  9: 8        reg_yphs_ofst             // unsigned ,    RW, default = 0  default:0, range:0~3
//Bit  7: 0        reserved
#define ISP_CUBICT_MIX_CTRL                        ((0x0a01  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21           reg_mix_lpf_en            // unsigned ,    RW, default = 0  lpf enable
//Bit 20:18        reserved
//Bit 17: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_0                ((0x0a02  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_0         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_1                ((0x0a03  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_1         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_2                ((0x0a04  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_2         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_3                ((0x0a05  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_3         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_4                ((0x0a06  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_4         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_mcnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_BW_MODE                         ((0x0a07  << 2) + 0xfe3b4000)
//Bit 31:24        reg_mix_sad_bw_mode       // unsigned ,    RW, default = 0
//Bit 23: 0        reserved
#define ISP_CUBICT_TNR_WINS_CRTL                   ((0x0a08  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reserved
//Bit 27:20        reserved
//Bit 19:12        reg_ma_mix_th_iso_gain    // unsigned ,    RW, default = 32  iso_gain
//Bit 11: 8        reg_ma_tnr_winw           // unsigned ,    RW, default = 3  tnr window width
//Bit  7: 0        reserved
#define ISP_CUBICT_HIGH_MIX_THRD_Y                 ((0x0a09  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_h_th_y0        // unsigned ,    RW, default = 30  curve value of mix_h_thrd
//Bit 15: 8        reg_ma_mix_h_th_y1        // unsigned ,    RW, default = 40  curve value of mix_h_thrd
//Bit  7: 0        reg_ma_mix_h_th_y2        // unsigned ,    RW, default = 50  curve value of mix_h_thrd
#define ISP_CUBICT_MIX_THRD_X                      ((0x0a0a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_th_x0          // unsigned ,    RW, default = 30  threshold x0 of the curve
//Bit 15:12        reserved
//Bit 11: 8        reg_ma_mix_th_x1          // unsigned ,    RW, default = 4  threshold x0 + (1<<x1)
//Bit  7: 4        reserved
//Bit  3: 0        reg_ma_mix_th_x2          // unsigned ,    RW, default = 4  threshold x0 + (1<<x1) + (1<<x2)
#define ISP_CUBICT_LOW_MIX_THRD_Y                  ((0x0a0b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_l_th_y0        // unsigned ,    RW, default = 15  curve value of mix_l_thrd
//Bit 15: 8        reg_ma_mix_l_th_y1        // unsigned ,    RW, default = 25  curve value of mix_l_thrd
//Bit  7: 0        reg_ma_mix_l_th_y2        // unsigned ,    RW, default = 35  curve value of mix_l_thrd
#define ISP_CUBICT_ERR_MIX_RATIO                   ((0x0a0c  << 2) + 0xfe3b4000)
//Bit 31:20        reg_ma_sad_luma_adj_x2    // unsigned ,    RW, default = 42  threshold x2 of luma scale
//Bit 19: 8        reg_ma_sad_luma_adj_x3    // unsigned ,    RW, default = 58  threshold x3 of luma scale
//Bit  7: 0        reg_ma_mix_ratio          // unsigned ,    RW, default = 64
#define ISP_CUBICT_SAD_LUMA_GAIN_X                 ((0x0a0d  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ma_sad_luma_adj_x0    // unsigned ,    RW, default = 30  threshold x0 of luma scale
//Bit 15: 4        reg_ma_sad_luma_adj_x1    // unsigned ,    RW, default = 36  threshold x1 of luma scale
//Bit  3: 0        reserved
#define ISP_CUBICT_SAD_LUMA_GAIN_Y                 ((0x0a0e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_ma_sad_luma_adj_y_0   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 23:18        reg_ma_sad_luma_adj_y_1   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 17:12        reg_ma_sad_luma_adj_y_2   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 11: 6        reg_ma_sad_luma_adj_y_3   // unsigned ,    RW, default = 16  luma gain for sad
//Bit  5: 0        reg_ma_sad_luma_adj_y_4   // unsigned ,    RW, default = 16  luma gain for sad
#define ISP_CUBICT_SAD_CORING_NP_CRTL              ((0x0a0f  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_ma_sad_cor_manual_mode // unsigned ,    RW, default = 0  0: get sad_coring according to noise profile; 1 : get sad_coring according to default curve
//Bit 15: 8        reg_ma_tnr_sad_cor_np_gain // unsigned ,    RW, default = 64  increase flexibility of LUT noise profile tuning
//Bit  7: 0        reg_ma_tnr_sad_cor_np_ofst // signed ,    RW, default = 0  increase flexibility of lut noise profile tuning
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y0       ((0x0a10  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y0          // unsigned ,    RW, default = 8  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y1       ((0x0a11  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y1          // unsigned ,    RW, default = 32  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y2       ((0x0a12  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y2          // unsigned ,    RW, default = 56  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_X        ((0x0a13  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ma_sad_th_x0          // unsigned ,    RW, default = 64  x0 of thr curve
//Bit  7: 4        reg_ma_sad_th_x1          // unsigned ,    RW, default = 5  threshold x0 + (1<<x1)
//Bit  3: 0        reg_ma_sad_th_x2          // unsigned ,    RW, default = 5  threshold x0 + (1<<x1) + (1<<x2)
#define ISP_CUBICT_MASK_GAIN_0                     ((0x0a14  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_0 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_1                     ((0x0a15  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_1 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_2                     ((0x0a16  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_2 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_3                     ((0x0a17  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_3 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MIX_THD_MASK_GAIN_0             ((0x0a18  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_0 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_1             ((0x0a19  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_1 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_2             ((0x0a1a  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_2 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_3             ((0x0a1b  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_3 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_SAD_VAR_GAIN_X                  ((0x0a1c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ma_sad_var_th_x0      // unsigned ,    RW, default = 50  variance for cur block
//Bit 15:12        reg_ma_sad_var_th_x1      // unsigned ,    RW, default = 4
//Bit 11: 8        reg_ma_sad_var_th_x2      // unsigned ,    RW, default = 5
//Bit  7: 0        reserved
#define ISP_CUBICT_SAD_VAR_GAIN_Y                  ((0x0a1d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:20        reg_ma_sad_var_th_y_0     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit 19:14        reg_ma_sad_var_th_y_1     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit 13: 8        reg_ma_sad_var_th_y_2     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit  7: 0        reserved
#define ISP_CUBICT_DETAIL_CORING                   ((0x0a1e  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_pdtl_cor_ratio // unsigned ,    RW, default = 64  soft coring to |Y-APL|
#define ISP_CUBICT_DETAIL_CURV_X                   ((0x0a1f  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ma_sad_pdtl4_x0       // unsigned ,    RW, default = 2  pdtl_10bits threshold0 of the curv
//Bit  7: 4        reg_ma_sad_pdtl4_x1       // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit  3: 0        reg_ma_sad_pdtl4_x2       // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 + 2^th2 to get the th1 of the curv
#define ISP_CUBICT_DETAIL_CURV_Y                   ((0x0a20  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_ma_sad_pdtl4_y0       // unsigned ,    RW, default = 12  curve value0 of pdtl_10bits <= th0
//Bit 23:20        reserved
//Bit 19:16        reg_ma_sad_pdtl4_y1       // unsigned ,    RW, default = 8  curve value1 of pdtl_10bits == th1
//Bit 15:12        reserved
//Bit 11: 8        reg_ma_sad_pdtl4_y2       // unsigned ,    RW, default = 2  curve value2 of pdtl_10bits >= th2
//Bit  7: 0        reserved
#define ISP_CUBICT_ZMV_CURV_X                      ((0x0a21  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 4        reg_ma_sad_zmv_x0         // unsigned ,    RW, default = 2112  threshold 0 of the curv
//Bit  3: 0        reg_ma_sad_zmv_x1         // unsigned ,    RW, default = 6  sad_z threshold1 = th0 + 2^thn to get the th1 of the curv
#define ISP_CUBICT_ZMV_CURV_Y                      ((0x0a22  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_ma_sad_zmv_y0         // unsigned ,    RW, default = 4  gain of sad_z <= th0
//Bit 23:20        reg_ma_sad_zmv_y1         // unsigned ,    RW, default = 9  gain of sad_z >= th1
//Bit 19: 0        reserved
#define ISP_CUBICT_WTSAD_CRTL                      ((0x0a23  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4: 1        reg_ma_wtsad_div          // unsigned ,    RW, default = 2  right shift of sad*(dtl_4b+sad_gain_4b)>> div
//Bit  0           reg_ma_wtsad_sel          // unsigned ,    RW, default = 0  0:output pure_sad; 1: output wt_sad
#define ISP_CUBICT_ALPHA_LUMA_GAIN_BLC             ((0x0a24  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_ma_meta_luma_gain     // unsigned ,    RW, default = 10  luma_gain for meta
//Bit 11: 0        reg_ma_meta_luma_blc      // unsigned ,    RW, default = 0  luma black level for -blc
#define ISP_CUBICT_META_PP0                        ((0x0a25  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:26        reserved
//Bit 25:22        reg_ma_dil_winw           // unsigned ,    RW, default = 2  half width for dilate operation
//Bit 21:18        reg_ma_dil_winh           // unsigned ,    RW, default = 2  half height for dilate operation
//Bit 17:14        reg_ma_ero_winw           // unsigned ,    RW, default = 1  half width for erose operation
//Bit 13:10        reg_ma_ero_winh           // unsigned ,    RW, default = 1  half height for erose operation
//Bit  9: 0        reserved
#define ISP_CUBICT_META_PP1                        ((0x0a26  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_ma_lpf_winw           // unsigned ,    RW, default = 1  half width for lpf
//Bit 19:16        reg_ma_lpf_winh           // unsigned ,    RW, default = 1  half height for lpf
//Bit 15:12        reg_ma_sta_winw           // unsigned ,    RW, default = 2  half width for statistic
//Bit 11: 8        reg_ma_sta_winh           // unsigned ,    RW, default = 2  half height for statistic
//Bit  7: 0        reserved
#define ISP_CUBICT_META_PP2                        ((0x0a27  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_ma_meta_pp_sta_stl_ratio // unsigned ,    RW, default = 12  statistic still ratio
//Bit 19:16        reg_ma_meta_pp_sta_mv_ratio // unsigned ,    RW, default = 12  statistic moving ratio
//Bit 15:12        reg_ma_meta_pp_sta_mv2stl_bnd // unsigned ,    RW, default = 0  moving to still boundary <
//Bit 11: 8        reg_ma_meta_pp_sta_stl2mv_bnd // unsigned ,    RW, default = 0  still to moving boundary >
//Bit  7: 6        reg_ma_meta_pp_mode       // unsigned ,    RW, default = 0  0: no pp for meta; 1: lpf; 2: local statistic
//Bit  5: 0        reserved
#define ISP_CUBICT_GLOBAL_INFO                     ((0x0a28  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_info            // unsigned ,    RO, default = 0  statistic of global SAD
#define ISP_CUBICT_GLOBAL_STL_SAD_INFO             ((0x0a29  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_stl_sad_diff    // unsigned ,    RO, default = 0  statistic of SAD of still region
#define ISP_CUBICT_GLOBAL_MV_SAD_INFO              ((0x0a2a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_mv_sad_diff     // unsigned ,    RO, default = 0  statistic of SAD of mv region
#define ISP_CUBICT_GLOBAL_MV_CNT                   ((0x0a2b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_mv_cnt          // unsigned ,    RO, default = 0  mv pixel number
#define ISP_CUBICT_GLOBAL_STL_CNT                  ((0x0a2c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_stl_cnt         // unsigned ,    RO, default = 0  statistic still pixel number
#define ISP_CUBICT_GLOBAL_STAT_WINDOW              ((0x0a2d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ro_winv_st            // unsigned ,    RW, default = 0  window_start
//Bit 15: 0        reg_ro_winv_ed            // unsigned ,    RW, default = 960  window_end
#define ISP_CUBICT_SAD_SUM_IN_SECTION_0            ((0x0a2e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_0  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_1            ((0x0a2f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_1  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_2            ((0x0a30  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_2  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_3            ((0x0a31  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_3  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_4            ((0x0a32  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_4  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_5            ((0x0a33  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_5  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_6            ((0x0a34  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_6  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_7            ((0x0a35  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_7  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_8            ((0x0a36  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_8  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_9            ((0x0a37  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_9  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_10           ((0x0a38  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_10 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_11           ((0x0a39  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_11 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_12           ((0x0a3a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_12 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_13           ((0x0a3b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_13 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_14           ((0x0a3c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_14 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_15           ((0x0a3d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_sum_sect_15 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_0            ((0x0a3e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_0  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_1            ((0x0a3f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_1  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_2            ((0x0a40  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_2  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_3            ((0x0a41  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_3  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_4            ((0x0a42  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_4  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_5            ((0x0a43  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_5  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_6            ((0x0a44  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_6  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_7            ((0x0a45  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_7  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_8            ((0x0a46  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_8  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_9            ((0x0a47  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_9  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_10           ((0x0a48  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_10 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_11           ((0x0a49  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_11 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_12           ((0x0a4a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_12 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_13           ((0x0a4b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_13 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_14           ((0x0a4c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_14 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_15           ((0x0a4d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_global_sad_cnt_sect_15 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_GLOBAL_RATIO                    ((0x0a4e  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_global_sad_thd_ratio // unsigned ,    RW, default = 16  ratio for sad_thd for abs(mix0[i],mix[1]), norm to 16
#define ISP_CUBICT_ADP_GLOBAL_MIX_THD              ((0x0a4f  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_adp_global_mix_th_ratio // unsigned ,    RW, default = 64  ratio for adaptive mix thd if global motion, norm to 64
#define ISP_CUBICT_ADP_DTL_NFL                     ((0x0a50  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_adp_dtl_mix_th_nfl // unsigned ,    RW, default = 0  detail floor for adaptive mix , norm to 64
#define ISP_CUBICT_MIX_H_GAIN                      ((0x0a51  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:18        reg_ma_mix_h_th_gain_0    // unsigned ,    RW, default = 16  low
//Bit 17:12        reg_ma_mix_h_th_gain_1    // unsigned ,    RW, default = 16
//Bit 11: 6        reg_ma_mix_h_th_gain_2    // unsigned ,    RW, default = 16
//Bit  5: 0        reg_ma_mix_h_th_gain_3    // unsigned ,    RW, default = 16  high
#define ISP_CUBICT_MIX_L_GAIN                      ((0x0a52  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:12        reg_ma_mix_l_th_gain      // unsigned ,    RW, default = 16  low mix gain for delta step decision, still, max
//Bit 11: 0        reserved
#define ISP_CUBICT_DELTA_STEP                      ((0x0a53  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_ma_meta_delt_0        // signed ,    RW, default = 1  still
//Bit 15:12        reg_ma_meta_delt_1        // signed ,    RW, default = 0  keep
//Bit 11: 8        reg_ma_meta_delt_2        // signed ,    RW, default = -7  move
//Bit  7: 0        reserved
#define ISP_CUBICT_MIX_P1_SEL                      ((0x0a54  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11            reserved
//Bit 10           reg_mix_p1_is_iir         // unsigned ,    RW, default = 1  0:mix_p1 is original p1; 1:mix_p1 is iir[0] data
//Bit  9: 0        reserved
#define ISP_TNR_NP_LUT_0                           ((0x0a55  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_1         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_0         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_1                           ((0x0a56  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_3         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_2         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_2                           ((0x0a57  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_5         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_4         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_3                           ((0x0a58  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_7         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_6         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_4                           ((0x0a59  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_9         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_8         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_5                           ((0x0a5a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_11        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_10        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_6                           ((0x0a5b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_13        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_12        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_7                           ((0x0a5c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_15        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_14        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_LOSS_CORING_META2ALP_0                 ((0x0a5d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_loss_lut_meta2alp_3   // unsigned ,    RW, default = 48  adjust coring according meta
//Bit 23:16        reg_loss_lut_meta2alp_2   // unsigned ,    RW, default = 64  adjust coring according meta
//Bit 15: 8        reg_loss_lut_meta2alp_1   // unsigned ,    RW, default = 120  adjust coring according meta
//Bit  7: 0        reg_loss_lut_meta2alp_0   // unsigned ,    RW, default = 240  adjust coring according meta
#define ISP_LOSS_CORING_META2ALP_1                 ((0x0a5e  << 2) + 0xfe3b4000)
//Bit 31:24        reg_loss_lut_meta2alp_7   // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 23:16        reg_loss_lut_meta2alp_6   // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 15: 8        reg_loss_lut_meta2alp_5   // unsigned ,    RW, default = 24  adjust coring according meta
//Bit  7: 0        reg_loss_lut_meta2alp_4   // unsigned ,    RW, default = 32  adjust coring according meta
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_ALPHA0_LUT_ADDR                 ((0x0a6d  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4:0         reg_lut_meta_sad_2alpha_addr       // unsigned ,    RW, default = 0
#define ISP_CUBICT_ALPHA0_LUT_DATA                 ((0x0a6e  << 2) + 0xfe3b4000)
//Bit 31:0         reg_lut_meta_sad_2alpha_data     // unsigned ,    RW, default = 0
#define ISP_CUBICT_TOP_HW_CTRL                     ((0x0a7f  << 2) + 0xfe3b4000)
//Bit 31:0         reg_tnr_mcnr_ctrl         // unsigned , RW ,default = 0 first frame flag ctrl reg
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TNR1_APB_BASE = 0x0b
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_mcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_MCNR_DS                                ((0x0b00  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:14        reg_me_dsx_scale          // unsigned ,    RW, default = 1  downscale mode of x direction for me input data; 0: no downscale; 1:1/2 downscale; 2:1/4 downscale
//Bit 13:12        reg_me_dsy_scale          // unsigned ,    RW, default = 1  downscale mode of y direction for me input data; 0: no downscale; 1:1/2 downscale; 2:1/4 downscale
//Bit 11:10        reg_me_mvx_div_mode       // unsigned ,    RW, default = 0  0: MVx has 2bits decimal; 1: 3bits decimal; 2: 4bits decimal @ME resolution.
//Bit  9: 8        reg_me_mvy_div_mode       // unsigned ,    RW, default = 0  0: MVy has 2bits decimal; 1: 3bits decimal; 2: 4bits decimal @ME resolution.
//Bit  7: 0        reg_me_mv_var_th          // unsigned ,    RW, default = 5  the threshold of diff mvx/mvy as one group
#define ISP_MCNR_ST_CMV_0                          ((0x0b01  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_0    // signed ,    RW, default = 0  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_0    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_0       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_0      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_1                          ((0x0b02  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_1    // signed ,    RW, default = 0  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_1    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_1       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_1      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_2                          ((0x0b03  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_2    // signed ,    RW, default = -1  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_2    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_2       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_2      // unsigned ,    RW, default = 42  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_3                          ((0x0b04  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_3    // signed ,    RW, default = 1  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_3    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_3       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_3      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_4                          ((0x0b05  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_4    // signed ,    RW, default = -2  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_4    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_4       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_4      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_5                          ((0x0b06  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_5    // signed ,    RW, default = 2  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_5    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_5       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_5      // unsigned ,    RW, default = 56  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_6                          ((0x0b07  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_6    // signed ,    RW, default = -3  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_6    // signed ,    RW, default = 0  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_6       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_6      // unsigned ,    RW, default = 56  static penalty for S and T candidate
#define ISP_MCNR_RAND_CMV_0                        ((0x0b08  << 2) + 0xfe3b4000)
//Bit 31:28        reg_me_rad_x1_max_0       // unsigned ,    RW, default = 1  max random offset for the cmv (0~+15) random candidate
//Bit 27:24        reg_me_rad_x2_max_0       // unsigned ,    RW, default = 3  max random offset for the cmv (0~+15) random candidate
//Bit 23:20        reg_me_rad_y1_max_0       // unsigned ,    RW, default = 1  max random offset for the cmv (0~+15) random candidate
//Bit 19:16        reg_me_rad_y2_max_0       // unsigned ,    RW, default = 2  max random offset for the cmv (0~+15) random candidate
//Bit 15:14        reserved
//Bit 13:11        reg_me_cmv_rad_pos_x_0    // signed ,    RW, default = -1  random candidate x offset
//Bit 10: 9        reg_me_cmv_rad_pos_y_0    // signed ,    RW, default = -1  random candidate x offset
//Bit  8           reg_me_add_rad_en_0       // unsigned ,    RW, default = 1  enable of random candidate
//Bit  7: 0        reg_me_penalty_rad_0      // unsigned ,    RW, default = 60  static penalty for random candidate
#define ISP_MCNR_RAND_CMV_1                        ((0x0b09  << 2) + 0xfe3b4000)
//Bit 31:28        reg_me_rad_x1_max_1       // unsigned ,    RW, default = 5  max random offset for the cmv (0~+15) random candidate
//Bit 27:24        reg_me_rad_x2_max_1       // unsigned ,    RW, default = 11  max random offset for the cmv (0~+15) random candidate
//Bit 23:20        reg_me_rad_y1_max_1       // unsigned ,    RW, default = 4  max random offset for the cmv (0~+15) random candidate
//Bit 19:16        reg_me_rad_y2_max_1       // unsigned ,    RW, default = 8  max random offset for the cmv (0~+15) random candidate
//Bit 15:14        reserved
//Bit 13:11        reg_me_cmv_rad_pos_x_1    // signed ,    RW, default = 1  random candidate x offset
//Bit 10: 9        reg_me_cmv_rad_pos_y_1    // signed ,    RW, default = -1  random candidate x offset
//Bit  8           reg_me_add_rad_en_1       // unsigned ,    RW, default = 1  enable of random candidate
//Bit  7: 0        reg_me_penalty_rad_1      // unsigned ,    RW, default = 100  static penalty for random candidate
#define ISP_MCNR_RAND_SEED_INT                     ((0x0b0a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_me_rand_seed_mvx      // unsigned ,    RW, default = 43981  random seed for the LFSR for mvx integer part
//Bit 15: 0        reg_me_rand_seed_mvy      // unsigned ,    RW, default = 39304  random seed for the LFSR for mvy integer part
#define ISP_MCNR_RAND_SEED_FRAC                    ((0x0b0b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_me_rand_seed_mvq      // unsigned ,    RW, default = 14392  random seed for the LFSR for mvx/mvy fractional part
//Bit 15: 0        reserved
#define ISP_MCNR_ZMV                               ((0x0b0c  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_me_penalty_zmv        // unsigned ,    RW, default = 18  static zmv penalty
//Bit  7: 3        reserved
//Bit  2           reg_dym_zmv_penalty_en    // unsigned ,    RW, default = 1  enable of dynamic zmv penalty, 0 use reg_me_penalty_zmv; 1: use the dym one
//Bit  1: 0        reg_dym_zmv_penalty_div   // unsigned ,    RW, default = 0  normalized to (gain_dlt_z + gain_sad_z),
#define ISP_MCNR_ZMV_DETAIL                        ((0x0b0d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_detail_zmv_th0        // unsigned ,    RW, default = 64  threshold 0 of the curv
//Bit 15:12        reserved
//Bit 11: 8        reg_detail_zmv_thn        // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  7: 4        reg_detail_zmv_gain0      // unsigned ,    RW, default = 15  gain of pdtl_10bits <= th0  (TBC, changed from ppt)
//Bit  3: 0        reg_detail_zmv_gain1      // unsigned ,    RW, default = 4  gain of pdtl_10bits >= th1
#define ISP_MCNR_ZMV_SAD                           ((0x0b0e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_sad_zmv_th0           // unsigned ,    RW, default = 4224  threshold 0 of the curv
//Bit 15:12        reserved
//Bit 11: 8        reg_sad_zmv_thn           // unsigned ,    RW, default = 6  sad_z threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  7: 4        reg_sad_zmv_gain0         // unsigned ,    RW, default = 4  gain of sad_z <= th0  (TBC, changed from ppt)
//Bit  3: 0        reg_sad_zmv_gain1         // unsigned ,    RW, default = 9  gain of sad_z >= th1
#define ISP_MCNR_PURE_DETAIL                       ((0x0b0f  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11:10        reg_sad_pdtl_mode_sel     // unsigned ,    RW, default = 1  sad pure detail 10bit sel mode, default = 1, 0: MIN ; 1: MAX; 2/3: AVG
//Bit  9: 2        reg_sad_pdtl_core         // unsigned ,    RW, default = 1<<4  soft coring to |Y-APL|
//Bit  1: 0        reg_sad_pdtl4_mode_sel    // unsigned ,    RW, default = 1  sad pure detail 4bit sel mode, default = 1, 0: MIN ; 1: MAX; 2/3: AVG
#define ISP_MCNR_PURE_DETAIL_GAIN                  ((0x0b10  << 2) + 0xfe3b4000)
//Bit 31:24        reg_sad_pdtl4_gain_th0    // unsigned ,    RW, default = 2  pdtl_10bits threshold 0 of the curv
//Bit 23:20        reg_sad_pdtl4_gain_th1    // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit 19:16        reg_sad_pdtl4_gain_th2    // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 + 2^th2 to get the th1 of the curv
//Bit 15:12        reg_sad_pdtl4_gain0       // unsigned ,    RW, default = 12  gain value0 of pdtl_10bits <= th0  (TBC, changed from ppt)
//Bit 11: 8        reg_sad_pdtl4_gain1       // unsigned ,    RW, default = 8  gain value1 of pdtl_10bits == th1
//Bit  7: 4        reg_sad_pdtl4_gain2       // unsigned ,    RW, default = 2  gain value2 of pdtl_10bits >= th2
//Bit  3: 0        reserved
#define ISP_MCNR_PURE_SAD                          ((0x0b11  << 2) + 0xfe3b4000)
//Bit 31:20        reg_me_sad_dc_curv_th0    // unsigned ,    RW, default = 16<<4  threshold 0 of the curv
//Bit 19:16        reg_me_sad_dc_curv_thn    // unsigned ,    RW, default = 7  threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit 15: 0        reserved
#define ISP_MCNR_MAXTRAN_CURVE                     ((0x0b12  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_me_sad_dc_curv0       // unsigned ,    RW, default = 4<<4  curve value0 of maxtran <= th0  (TBC, changed from ppt)
//Bit 11: 0        reg_me_sad_dc_curv1       // unsigned ,    RW, default = 8<<4  curve value1 of maxtran >= th1
#define ISP_MCNR_PURE_SAD_TH0                      ((0x0b13  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_me_sad_dc_mode_sel    // unsigned ,    RW, default = 1  maxtran sel mode, default = TBC, 0: MIN; 1: MAX; 2/3: AVG
//Bit 27:26        reg_me_sad_th_mode_sel    // unsigned ,    RW, default = 2  sad th mode_sel , 0: maxtran, 1:apl, other: noise profile
//Bit 25:18        reg_me_sad_th_curv_th0    // unsigned ,    RW, default = 64  threshold th0 of the curv
//Bit 17:15        reg_me_sad_th_curv_th1    // unsigned ,    RW, default = 5  threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit 14:12        reg_me_sad_th_curv_th2    // unsigned ,    RW, default = 5  threshold2 = th0 + 2^th2 to get the th1 of the curv
//Bit 11: 0        reg_me_sad_th_curv0       // unsigned ,    RW, default = 32  curve value0 of apl <= th0
#define ISP_MCNR_PURE_SAD_TH1                      ((0x0b14  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_me_sad_th_curv1       // unsigned ,    RW, default = 64  curve value0 of apl <= th1
//Bit 11: 0        reg_me_sad_th_curv2       // unsigned ,    RW, default = 96  curve value0 of apl <= th2
#define ISP_MCNR_PURE_SAD_NP_GAIN                  ((0x0b15  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_me_sad_cor_np_gain    // unsigned ,    RW, default = 64  noise profile gain, increase flexibility of LUT noise profile tuning
//Bit 15: 8        reg_me_sad_cor_np_ofst    // signed ,    RW, default = 0  noise profile ofst, increase flexibility of LUT noise profile tuning
//Bit  7: 0        reserved
#define ISP_MCNR_PURE_SAD_NP_LUT_0                 ((0x0b16  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_0         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_1                 ((0x0b17  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_1         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_2                 ((0x0b18  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_2         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_3                 ((0x0b19  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_3         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_4                 ((0x0b1a  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_4         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_5                 ((0x0b1b  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_5         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_6                 ((0x0b1c  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_6         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_7                 ((0x0b1d  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_7         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_8                 ((0x0b1e  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_8         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_9                 ((0x0b1f  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_9         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_10                ((0x0b20  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_10        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_11                ((0x0b21  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_11        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_12                ((0x0b22  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_12        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_13                ((0x0b23  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_13        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_14                ((0x0b24  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_14        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_15                ((0x0b25  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_15        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_TH_MASK_0                ((0x0b26  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_0 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_1                ((0x0b27  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_1 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_2                ((0x0b28  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_2 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_3                ((0x0b29  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_3 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_MVDIFF                            ((0x0b2a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:26        reg_mvdiff_core           // unsigned ,    RW, default = 3  hard coring to mvdiff_count, <core, mvdiff set to 0;
//Bit 25:16        reg_mvdiff_smooth_th0     // unsigned ,    RW, default = 128  threshold 0 of the curv   (change name)
//Bit 15:12        reg_mvdiff_smooth_thn     // unsigned ,    RW, default = 6  mvdiff threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit 11: 8        reg_mvdiff_smooth_gain0   // unsigned ,    RW, default = 4  gain of mvdiff <= th0  (TBC, changed from ppt)
//Bit  7: 4        reg_mvdiff_smooth_gain1   // unsigned ,    RW, default = 12  gain of mvdiff >= th1
//Bit  3           reg_mvdiff_zmv_disable    // unsigned ,    RW, default = 1  calc mvdiff not contail zmv
//Bit  2: 0        reserved
#define ISP_MCNR_WEIGTH_SAD                        ((0x0b2b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:26        reg_wtdc_wsad_div         // unsigned ,    RW, default = 2  right shift of sad_dc*(dtl_4b+mvdiff_gain_4b)>> div
//Bit 25:16        reg_wtdc_pure_detail_max  // unsigned ,    RW, default = 512  max of pur detail (10bits) for pure_detail_tmp calculation
//Bit 15: 8        reg_wtdc_pure_detail_wt   // unsigned ,    RW, default = 0  gain (weight) to the pure_detail_tmp to get the DC_SAD_result, norm to 16 as "1"
//Bit  7: 4        reg_wtdc_mvdf_smooth_wt   // unsigned ,    RW, default = 0  gain (weight) to the mvdiff_10b to get the DC_SAD_result, norm to 4 as "1"
//Bit  3: 0        reserved
#define ISP_MCNR_SMOOTH_PROC_0                     ((0x0b2c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_me_periodic_apl_sel   // unsigned ,    RW, default = 0  apl selection for smooth proc.
//Bit 23:20        reg_me_periodic_apl_gain0 // unsigned ,    RW, default = 3  apl gain0 for smooth proc.
//Bit 19:16        reg_me_periodic_apl_gain1 // unsigned ,    RW, default = 4  apl gain1 for smooth proc.
//Bit 15:12        reg_me_periodic_apl_gain2 // unsigned ,    RW, default = 6  apl gain2 for smooth proc.
//Bit 11: 8        reg_me_periodic_apl_gain_th0 // unsigned ,    RW, default = 15  apl threshold0 for apl gain for smooth proc.
//Bit  7: 4        reg_me_periodic_apl_gain_th1 // unsigned ,    RW, default = 6  apl threshold1 for apl gain for smooth proc., th0 + 2^th1
//Bit  3: 0        reg_me_periodic_apl_gain_th2 // unsigned ,    RW, default = 6  apl threshold2 for apl gain for smooth proc., th0 + 2^th1 + 2^th2
#define ISP_MCNR_SMOOTH_PROC_1                     ((0x0b2d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_me_periodic_sad_similar_th1 // unsigned ,    RW, default = 0  threshold1 for similar sad decision
//Bit 23:16        reg_me_periodic_sad_similar_th2 // unsigned ,    RW, default = 0  threshold2 for similar sad decision
//Bit 15: 8        reg_me_periodic_sad_similar_th3 // unsigned ,    RW, default = 4  threshold3 for similar sad decision
//Bit  7: 0        reserved
#define ISP_MCNR_SMOOTH_PROC_2                     ((0x0b2e  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_me_periodic_sad_similar_th // unsigned ,    RW, default = 2  threshold for similar sad decision
//Bit 15: 8        reg_me_periodic_mv_diff_th // unsigned ,    RW, default = 40  diff for similar mvdiff decision
//Bit  7           reg_me_periodic_mv_diff_rule_en // unsigned ,    RW, default = 1  enable mv diff rule for periodic case
//Bit  6           reg_me_periodic_z_rule_en // unsigned ,    RW, default = 1  zero mv enable for periodic case
//Bit  5           reg_me_periodic_en        // unsigned ,    RW, default = 1  mv smooth enable
//Bit  4           reg_me_periodic_aplsad_rule_en // unsigned ,    RW, default = 1  mv smooth enable
//Bit  3: 0        reserved
#define ISP_MCNR_ZMV_PATCH_EN                      ((0x0b2f  << 2) + 0xfe3b4000)
//Bit 31           reg_me_zmv_patch_en       // unsigned ,    RW, default = 0  enable zmv patch
//Bit 30:23        reg_me_zmv_patch_mv_length_th // unsigned ,    RW, default = 10  zmv patch mv length threshold
//Bit 22:13        reg_me_zmv_patch_sad_th   // unsigned ,    RW, default = 10  sad threshold
//Bit 12: 3        reg_me_zmv_patch_dtl_th   // unsigned ,    RW, default = 120  detail threshold
//Bit  2: 0        reserved
#define ISP_MCNR_ZMV_PATCH_PENALTY                 ((0x0b30  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_me_zmv_patch_penalty  // unsigned ,    RW, default = 10  zmv patch penalty
#define ISP_MCNR_SSAD_DETAIL                       ((0x0b31  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:21        reg_me_meta_mv_length_th  // unsigned ,    RW, default = 10  calc meta delta patch mv length threshold
//Bit 20           reg_me_meta_data_sad_sel  // unsigned ,    RW, default = 0  sad to generate meta delta, 0:pure_sad, 1:sad
//Bit 19:16        reg_me_ssad_detail_th0    // unsigned ,    RW, default = 4  static area sad detail threshold th0
//Bit 15:12        reg_me_ssad_detail_thn    // unsigned ,    RW, default = 2  static area sad detail threshold1 = th0+(1<<thn)
//Bit 11: 6        reg_me_ssad_detail_gain0  // unsigned ,    RW, default = 16  static area sad detail gain0, normalize 16 as"1"
//Bit  5: 0        reg_me_ssad_detail_gain1  // unsigned ,    RW, default = 8  static area sad detail gain1, normalize 16 as"1"
#define ISP_MCNR_MSAD_DETAIL                       ((0x0b32  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_me_msad_detail_th0    // unsigned ,    RW, default = 4  motion area sad detail threshold th0
//Bit 15:12        reg_me_msad_detail_thn    // unsigned ,    RW, default = 2  motion area sad detail threshold1 = th0+(1<<thn)
//Bit 11: 6        reg_me_msad_detail_gain0  // unsigned ,    RW, default = 16  static area sad detail gain0, normalize 16 as"1"
//Bit  5: 0        reg_me_msad_detail_gain1  // unsigned ,    RW, default = 16  static area sad detail gain1, normalize 16 as"1"
#define ISP_MCNR_MVDIFF_GAIN                       ((0x0b33  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:11        reg_me_sad_mvdiff_th0     // unsigned ,    RW, default = 128  sad mvdiff threshold th0
//Bit 10: 8        reg_me_sad_mvdiff_thn     // unsigned ,    RW, default = 6  sad mvdiff threshold1 = th0+(1<<thn)
//Bit  7: 4        reg_me_sad_mvdiff_gain0   // unsigned ,    RW, default = 4  mvdiff gain, 4 as 1
//Bit  3: 0        reg_me_sad_mvdiff_gain1   // unsigned ,    RW, default = 12  mvdiff gain, 4 as 1
#define ISP_MCNR_META_SAD_TH0                      ((0x0b34  << 2) + 0xfe3b4000)
//Bit 31:24        reg_me_meta_sad_th0_0     // unsigned ,    RW, default = 60  static area sad th
//Bit 23:16        reg_me_meta_sad_th0_1     // unsigned ,    RW, default = 90  static area sad th
//Bit 15: 8        reg_me_meta_sad_th0_2     // unsigned ,    RW, default = 110  static area sad th
//Bit  7: 0        reg_me_meta_sad_th0_3     // unsigned ,    RW, default = 110  static area sad th
#define ISP_MCNR_META_DELTA_STEP0                  ((0x0b35  << 2) + 0xfe3b4000)
//Bit 31:24        reg_me_meta_sad_th0_4     // unsigned ,    RW, default = 110  static area sad th
//Bit 23:20        reg_me_meta_delta_step0_0 // signed ,    RW, default = 1  meta delta step
//Bit 19:16        reg_me_meta_delta_step0_1 // signed ,    RW, default = 0  meta delta step
//Bit 15:12        reg_me_meta_delta_step0_2 // signed ,    RW, default = -1  meta delta step
//Bit 11: 8        reg_me_meta_delta_step0_3 // signed ,    RW, default = -2  meta delta step
//Bit  7: 4        reg_me_meta_delta_step0_4 // signed ,    RW, default = -3  meta delta step
//Bit  3: 0        reserved
#define ISP_MCNR_META_SAD_TH1                      ((0x0b36  << 2) + 0xfe3b4000)
//Bit 31:24        reg_me_meta_sad_th1_0     // unsigned ,    RW, default = 50  area sad th
//Bit 23:16        reg_me_meta_sad_th1_1     // unsigned ,    RW, default = 80  area sad th
//Bit 15: 8        reg_me_meta_sad_th1_2     // unsigned ,    RW, default = 120  area sad th
//Bit  7: 0        reg_me_meta_sad_th1_3     // unsigned ,    RW, default = 120  area sad th
#define ISP_MCNR_META_DELTA_STEP1                  ((0x0b37  << 2) + 0xfe3b4000)
//Bit 31:24        reg_me_meta_sad_th1_4     // unsigned ,    RW, default = 120  area sad th
//Bit 23:20        reg_me_meta_delta_step1_0 // signed ,    RW, default = 1  meta delta step
//Bit 19:16        reg_me_meta_delta_step1_1 // signed ,    RW, default = 0  meta delta step
//Bit 15:12        reg_me_meta_delta_step1_2 // signed ,    RW, default = -1  meta delta step
//Bit 11: 8        reg_me_meta_delta_step1_3 // signed ,    RW, default = -2  meta delta step
//Bit  7: 4        reg_me_meta_delta_step1_4 // signed ,    RW, default = -4  meta delta step
//Bit  3: 0        reserved
#define ISP_MCNR_META_POST_PROC                    ((0x0b38  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8           reg_me_meta_data_post_process_en // unsigned ,    RW, default = 0  enable do morphology,erosion and dilation
//Bit  7: 6        reg_me_meta_data_dil_wind_x // unsigned ,    RW, default = 2  dilation window xsize=2*wind_x+1
//Bit  5: 4        reg_me_meta_data_dil_wind_y // unsigned ,    RW, default = 2  dilation window ysize=2*wind_y+1
//Bit  3: 2        reg_me_meta_data_ero_wind_x // unsigned ,    RW, default = 2  erosion window xsize=2*wind_x+1
//Bit  1: 0        reg_me_meta_data_ero_wind_y // unsigned ,    RW, default = 2  erosion window ysize=2*wind_y+1
#define ISP_MCNR_OBMC_0                            ((0x0b39  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_0     // unsigned ,    RW, default = 40  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_0     // unsigned ,    RW, default = 40  v table
#define ISP_MCNR_OBMC_1                            ((0x0b3a  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_1     // unsigned ,    RW, default = 32  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_1     // unsigned ,    RW, default = 32  v table
#define ISP_MCNR_OBMC_2                            ((0x0b3b  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_2     // unsigned ,    RW, default = 24  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_2     // unsigned ,    RW, default = 24  v table
#define ISP_MCNR_OBMC_3                            ((0x0b3c  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_3     // unsigned ,    RW, default = 16  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_3     // unsigned ,    RW, default = 16  v table
#define ISP_MCNR_ALPHA_0_0                         ((0x0b3d  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_0     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_1                         ((0x0b3e  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_1     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_2                         ((0x0b3f  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_2     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_3                         ((0x0b40  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_3     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_4                         ((0x0b41  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_4     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_5                         ((0x0b42  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_5     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_6                         ((0x0b43  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_6     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_7                         ((0x0b44  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_0_7     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_0                         ((0x0b45  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_0     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_1                         ((0x0b46  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_2                         ((0x0b47  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_2     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_3                         ((0x0b48  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_3     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_4                         ((0x0b49  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_4     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_5                         ((0x0b4a  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_5     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_6                         ((0x0b4b  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_6     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_7                         ((0x0b4c  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_1_7     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_0                         ((0x0b4d  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_0     // unsigned ,    RW, default = 									32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_1                         ((0x0b4e  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_2                         ((0x0b4f  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_2     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_3                         ((0x0b50  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_3     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_4                         ((0x0b51  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_4     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_5                         ((0x0b52  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_5     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_6                         ((0x0b53  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_6     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_7                         ((0x0b54  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_2_7     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_0                         ((0x0b55  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_0     // unsigned ,    RW, default = 									32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_1                         ((0x0b56  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_2                         ((0x0b57  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_2     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_3                         ((0x0b58  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_3     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_4                         ((0x0b59  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_4     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_5                         ((0x0b5a  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_6                         ((0x0b5b  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_7                         ((0x0b5c  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_3_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_0                         ((0x0b5d  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_0     // unsigned ,    RW, default = 									36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_1                         ((0x0b5e  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_1     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_2                         ((0x0b5f  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_2     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_3                         ((0x0b60  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_3     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_4                         ((0x0b61  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_4     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_5                         ((0x0b62  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_6                         ((0x0b63  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_7                         ((0x0b64  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_4_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_0                         ((0x0b65  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_1                         ((0x0b66  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_1     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_2                         ((0x0b67  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_2     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_3                         ((0x0b68  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_3     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_4                         ((0x0b69  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_4     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_5                         ((0x0b6a  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_6                         ((0x0b6b  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_7                         ((0x0b6c  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_5_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_0                         ((0x0b6d  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_1                         ((0x0b6e  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_1     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_2                         ((0x0b6f  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_2     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_3                         ((0x0b70  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_3     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_4                         ((0x0b71  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_4     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_5                         ((0x0b72  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_5     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_6                         ((0x0b73  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_6     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_7                         ((0x0b74  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_6_7     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_0                         ((0x0b75  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_1                         ((0x0b76  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_1     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_2                         ((0x0b77  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_2     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_3                         ((0x0b78  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_3     // unsigned ,    RW, default = 38  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_4                         ((0x0b79  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_4     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_5                         ((0x0b7a  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_5     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_6                         ((0x0b7b  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_6     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_7                         ((0x0b7c  << 2) + 0xfe3b4000)
//Bit 31:26        reg_mc_meta2alpha_7_7     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ZMV_ALPHA                         ((0x0b7d  << 2) + 0xfe3b4000)
//Bit 31:22        reg_mc_zmv_length_th      // unsigned ,    RW, default = 10  mv length
//Bit 21:16        reg_mc_zmv_alpha_gain     // unsigned ,    RW, default = 20  normalize 16 as "1"
//Bit 15: 8        reg_mc_zmv_alpha_max      // unsigned ,    RW, default = 240  zmv alpha max
//Bit  7           reg_mc_force_zdata_en     // unsigned ,    RW, default = 1  enable force zmv data
//Bit  6: 3        reg_mc_pre_alpha_curv_thn // unsigned ,    RW, default = 4  threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  2: 0        reserved
#define ISP_MCNR_PRE_ALPHA                         ((0x0b7e  << 2) + 0xfe3b4000)
//Bit 31:24        reg_mc_pre_alpha_curv_th0 // unsigned ,    RW, default = 8  threshold 0 of the curv
//Bit 23:16        reg_mc_pre_alpha_curv0    // unsigned ,    RW, default = 128  curve value0 of sad_diff <= th0  (TBC, changed from ppt)
//Bit 15: 8        reg_mc_pre_alpha_curv1    // unsigned ,    RW, default = 0  curve value1 of sad_diff >= th1
//Bit  7: 0        reg_mc_mv_length_th       // unsigned ,    RW, default = 0  threshold of mv length to do mctnr, if mv_length>th, do mctnr
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_mcnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_mcnr_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_MCNR_TOP_GCLK_CTRL                     ((0x0bf0  << 2) + 0xfe3b4000)
//Bit 31:0      reg_gclk_ctrl         //unsigned, RW, default=0
//
#define ISP_MCNR_HW_CTRL0                          ((0x0bf1  << 2) + 0xfe3b4000)
//Bit 31        reg_sw_rst            //unsigned, W1T, default=0
//Bit 30        reg_mcnr_use_tnr      //unsigned, RW, default=1
//Bit 29        reg_force_sblk_pre    //unsigned, RW, default=0
//Bit 28:4      reserved
//Bit 3         reg_rand_mv_seed_rst  //unsigned, W1T, default=0
//Bit 2:0       reg_mcnr_dbg_path_sel //unsigned, RW, default=0
#define ISP_MCNR_DBG0                              ((0x0bf2  << 2) + 0xfe3b4000)
//Bit 31:0      ro_mcnr_dbg0        //unsigned, RO, default=0
#define ISP_MCNR_DBG1                              ((0x0bf3  << 2) + 0xfe3b4000)
//Bit 31:0      ro_mcnr_dbg1        //unsigned, RO, default=0
#define ISP_MCNR_MV_DBG0                           ((0x0bf4  << 2) + 0xfe3b4000)
//Bit 31        reg_mcnr_force_vmv_en   // unsigned, RW, default=0
//Bit 30        reg_mcnr_force_vec_en   // unsigned, RW, default=0
//Bit 29        reg_mcnr_force_meta_en  // unsigned, RW, default=0
//Bit 28:19     reserved
//Bit 18:16     reg_mcnr_force_meta  // unsigned, RW, default=0
//Bit 15:10     reg_mcnr_force_mvy   // unsigned, RW, default=0
//Bit 9:0       reg_mcnr_force_mvx   // unsigned, RW, default=0
#define ISP_MCNR_MV_DBG1                           ((0x0bf5  << 2) + 0xfe3b4000)
//Bit 31        reg_mcnr_force_sad_en // unsigned, RW, default=0
//Bit 30:26     reserved
//Bit 25:13     reg_mcnr_force_zsad  // unsigned, RW, default=0
//Bit 12:0      reg_mcnr_force_psad  // unsigned, RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_mcnr_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_RCNR_APB_BASE = 0x0c
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_RAWCNR_CTRL                            ((0x0c00  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_rawcnr_force_lpf_en   // unsigned ,    RW, default = 0  enable force raw cnr lpf in large area
//Bit 19:18        reg_rawcnr_xphs_ofst      // unsigned ,    RW, default = 0
//Bit 17:16        reg_rawcnr_yphs_ofst      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9           reg_rawcnr_meta_adaptive_en // unsigned ,    RW, default = 0  raw-cnr strength adaptive to motion meta enable, 0: no adaptive, 1: adaptive, set 0 for static images, 1 for video sequence
//Bit  8           reg_rawcnr_luma_adaptive_en // unsigned ,    RW, default = 0  rate scale base on luma function enable
//Bit  7: 6        reg_rawcnr_ishigfreq_mode // unsigned ,    RW, default = 0  is_higfreq mode for curblock for final blend, 0: ishigfrq either yhigfreq==1 or chigfreq; 1: ishigfrq both yhigfreq an chigfreq==1; 2:ishigfreq when only chigfreq==1
//Bit  5: 4        reg_rawcnr_totblk_ishigfreq_mode // unsigned ,    RW, default = 2  is_higfreq mode for curblock for final blend, 0: ishigfrq either yhigfreq==1 or chigfreq; 1: ishigfrq both yhigfreq an chigfreq==1; 2:ishigfreq when only chigfreq==1
//Bit  3            reserved
//Bit  2           reg_rawcnr_curblk_higfrq_en // unsigned ,    RW, default = 1  curblk higfreq based blk enable, 1 : use sub-block higfreq info
//Bit  1           reg_rawcnr_totblk_higfrq_en // unsigned ,    RW, default = 1  totblk higfreq  enable, 1 : use total higfreq info based on avg_blknxn
//Bit  0           reg_rawcnr_svalid_mode    // unsigned ,    RW, default = 0  is svalid mode for curblock for sigma filter, 0: isvalid either yhigfreq_sublknxn==1 or chigfreq_sublknxn; 1:isvalid when only chigfreq_sublknxn==0
#define ISP_RAWCNR_META_ADP_LUT_0                  ((0x0c01  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_meta_gain_lut_3 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_meta_gain_lut_2 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_meta_gain_lut_1 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_meta_gain_lut_0 // unsigned ,    RW, default = 16  gain ,16 is 1
#define ISP_RAWCNR_META_ADP_LUT_1                  ((0x0c02  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_meta_gain_lut_7 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_meta_gain_lut_6 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_meta_gain_lut_5 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_meta_gain_lut_4 // unsigned ,    RW, default = 16  gain ,16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_0          ((0x0c03  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_1 // unsigned ,    RW, default = 16  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_1 // unsigned ,    RW, default = 16  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_0 // unsigned ,    RW, default = 16  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_0 // unsigned ,    RW, default = 16  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_1          ((0x0c04  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_3 // unsigned ,    RW, default = 18  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_3 // unsigned ,    RW, default = 18  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_2 // unsigned ,    RW, default = 18  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_2 // unsigned ,    RW, default = 18  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_2          ((0x0c05  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_5 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_5 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_4 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_4 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_3          ((0x0c06  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_7 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_7 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_6 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_6 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_4          ((0x0c07  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_9 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_9 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_8 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_8 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_5          ((0x0c08  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_11 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_11 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_10 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_10 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_6          ((0x0c09  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_13 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_13 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_12 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_12 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_7          ((0x0c0a  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_15 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_15 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_14 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_14 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_0            ((0x0c0b  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_rawcnr_sps_csig_weight5x5_9 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 27:25        reg_rawcnr_sps_csig_weight5x5_8 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 24:22        reg_rawcnr_sps_csig_weight5x5_7 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 21:19        reg_rawcnr_sps_csig_weight5x5_6 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 18:16        reg_rawcnr_sps_csig_weight5x5_5 // unsigned ,    RW, default = 										1  weight of the the filter
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_4 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_3 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_2 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_1 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_0 // unsigned ,    RW, default = 1  weight of the the filter
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_1            ((0x0c0c  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_rawcnr_sps_csig_weight5x5_19 // unsigned ,    RW, default = 0  weight of the the filter
//Bit 27:25        reg_rawcnr_sps_csig_weight5x5_18 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 24:22        reg_rawcnr_sps_csig_weight5x5_17 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 21:19        reg_rawcnr_sps_csig_weight5x5_16 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 18:16        reg_rawcnr_sps_csig_weight5x5_15 // unsigned ,    RW, default = 									0  weight of the the filter
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_14 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_13 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_12 // unsigned ,    RW, default = 2  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_11 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_10 // unsigned ,    RW, default = 									1  weight of the the filter
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_2            ((0x0c0d  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_24 // unsigned ,    RW, default = 0  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_23 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_22 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_21 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_20 // unsigned ,    RW, default = 									0  weight of the the filter
#define ISP_RAWCNR_NP_0                            ((0x0c0e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_1     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_0     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_1                            ((0x0c0f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_3     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_2     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_2                            ((0x0c10  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_5     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_4     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_3                            ((0x0c11  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_7     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_6     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_4                            ((0x0c12  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_9     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_8     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_5                            ((0x0c13  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_11    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_10    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_6                            ((0x0c14  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_13    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_12    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_7                            ((0x0c15  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_15    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_14    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_CTRL                         ((0x0c16  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:16        reg_rawcnr_sad_cor_np_gain // unsigned ,    RW, default = 63  np gain
//Bit 15: 9        reserved
//Bit  8: 0        reg_rawcnr_sad_cor_np_ofst // signed ,    RW, default = 0  np offset
#define ISP_RAWCNR_SNRFLAG_GAIN                    ((0x0c17  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_cor_csnrflg_gain_0 // unsigned ,    RW, default = 16  snrflag gain for c chn coring
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_cor_csnrflg_gain_1 // unsigned ,    RW, default = 31  snrflag gain for c chn coring
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_cor_ysnrflg_gain_0 // unsigned ,    RW, default = 16  snrflag gain for y chn yoring
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_cor_ysnrflg_gain_1 // unsigned ,    RW, default = 31  snrflag gain for y chn yoring
#define ISP_RAWCNR_UCOR_SUM_DIF_THD                ((0x0c18  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_higfrq_sublk_sum_dif_thd_0 // unsigned ,    RW, default = 200  high freq sum thrd for sub block, 0:for y, 1:for color channel
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_higfrq_sublk_sum_dif_thd_1 // unsigned ,    RW, default = 100  high freq sum thrd for sub block, 0:for y, 1:for color channel
#define ISP_RAWCNR_MISC_CTRL0                      ((0x0c19  << 2) + 0xfe3b4000)
//Bit 31:28        reg_rawcnr_ucor_ygain     // unsigned ,    RW, default = 8  coring gain for upper parts subblocks
//Bit 27:24        reg_rawcnr_ucor_cgain     // unsigned ,    RW, default = 12  coring gain for upper parts subblocks
//Bit 23:22        reserved
//Bit 21:16        reg_rawcnr_sps_csigfn_alph // unsigned ,    RW, default = 62  rawCNR final alpha blend to snr output;   0: snr; 63:100% CNR sigma filter output
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_sub_snrflg_sum_thd // unsigned ,    RW, default = 16  snrflag_sum thd for each 5x5 block
//Bit  7: 4        reg_rawcnr_luma_gain_shift_bits // unsigned ,    RW, default = 8  luma to check luma gain lut[16], luma 12 bits
//Bit  3: 0        reg_rawcnr_chroma_gain_shift_bits // unsigned ,    RW, default = 8  chroma to check chroma gain lut[16], chroma 12 bits
#define ISP_RAWCNR_CURBLK_SUM_THD                  ((0x0c1a  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_higfrq_curblk_sum_difnxn_thd_0 // unsigned ,    RW, default = 1400  high freq sum thrd for blknxn, 0:for y, 1:for color channel
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_higfrq_curblk_sum_difnxn_thd_1 // unsigned ,    RW, default = 1200  high freq sum thrd for blknxn, 0:for y, 1:for color channel
#define ISP_RAWCNR_CHROMA_MAX_MIN_THD              ((0x0c1b  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_thrd_ca_max    // unsigned ,    RW, default = 512  max chroma threshold in check diff between current subblock and others
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_thrd_ca_min    // unsigned ,    RW, default = 5  min chroma threshold in check diff between current subblock and others
#define ISP_RAWCNR_LUMA_MAX_MIN_THD                ((0x0c1c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_thrd_ya_max    // unsigned ,    RW, default = 1024  max luma threshold in check diff between current subblock and others
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_thrd_ya_min    // unsigned ,    RW, default = 5  min luma threshold in check diff between current subblock and others
#define ISP_RAWCNR_SUBLK_SNR_FLAG_GAIN_LUT         ((0x0c1d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_rawcnr_hbsize         // unsigned ,    RW, default = 32  h blank size
//Bit 23:16        reg_rawcnr_vbsize         // unsigned ,    RW, default = 88  v blank size
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_subblk_snr_flag_gain_lut_0 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit 11            reserved
//Bit 10: 8        reg_rawcnr_subblk_snr_flag_gain_lut_1 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit  7            reserved
//Bit  6: 4        reg_rawcnr_subblk_snr_flag_gain_lut_2 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit  3            reserved
//Bit  2: 0        reg_rawcnr_subblk_snr_flag_gain_lut_3 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rcnr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB0_APB_BASE = 0x0d
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_lens_shading_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LSWB_EOTF_OFST0                        ((0x0d00  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16: 0        reg_eotf_pre_ofst         // signed ,    RW, default = 0  pre offset (-) before eotf
#define ISP_LSWB_EOTF_OFST1                        ((0x0d01  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20: 0        reg_eotf_pst_ofst         // signed ,    RW, default = 0  post offset (+) after eotf
#define ISP_LSWB_EOTF_PARAM                        ((0x0d02  << 2) + 0xfe3b4000)
//Bit 31: 3        reserved
//Bit  2           reg_eotf0_en              // unsigned ,    RW, default = 1  enable eotf0
//Bit  1           reg_eotf1_en              // unsigned ,    RW, default = 1  enable eotf1
//Bit  0           reg_eotf1_mode            // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for eotf 1 lut
#define ISP_LSWB_EOTF_NUM                          ((0x0d03  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:27        reg_eotf1_num_0           // unsigned ,    RW, default = 5  numbers for each segment of eotf 1 lut
//Bit 26:24        reg_eotf1_num_1           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 23:22        reserved
//Bit 21:19        reg_eotf1_num_2           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 18:16        reg_eotf1_num_3           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 15:14        reserved
//Bit 13:11        reg_eotf1_num_4           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 10: 8        reg_eotf1_num_5           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit  7: 6        reserved
//Bit  5: 3        reg_eotf1_num_6           // unsigned ,    RW, default = 3  numbers for each segment of eotf 1 lut
//Bit  2: 0        reg_eotf1_num_7           // unsigned ,    RW, default = 3  numbers for each segment of eotf 1 lut
#define ISP_LSWB_EOTF_STP                          ((0x0d04  << 2) + 0xfe3b4000)
//Bit 31:28        reg_eotf1_stp_0           // unsigned ,    RW, default = 11  step for each segment of eotf 1 lut
//Bit 27:24        reg_eotf1_stp_1           // unsigned ,    RW, default = 12  step for each segment of eotf 1 lut
//Bit 23:20        reg_eotf1_stp_2           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 19:16        reg_eotf1_stp_3           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 15:12        reg_eotf1_stp_4           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 11: 8        reg_eotf1_stp_5           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit  7: 4        reg_eotf1_stp_6           // unsigned ,    RW, default = 14  step for each segment of eotf 1 lut
//Bit  3: 0        reg_eotf1_stp_7           // unsigned ,    RW, default = 15  step for each segment of eotf 1 lut
#define ISP_LSWB_IDG_GAIN0                         ((0x0d05  << 2) + 0xfe3b4000)
//Bit 31:16        reg_idg_gain_0            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
//Bit 15: 0        reg_idg_gain_1            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_GAIN1                         ((0x0d06  << 2) + 0xfe3b4000)
//Bit 31:16        reg_idg_gain_2            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
//Bit 15: 0        reg_idg_gain_3            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_GAIN2                         ((0x0d07  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_idg_gain_4            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_OFST                          ((0x0d08  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 4        reg_idg_ofst              // unsigned ,    RW, default = 0  float16 offset before and after inv digital gain
//Bit  3: 2        reg_idg_xphs_ofst         // unsigned ,    RW, default = 0
//Bit  1: 0        reg_idg_yphs_ofst         // unsigned ,    RW, default = 0
#define ISP_LSWB_BLC_MODE                          ((0x0d09  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4           reg_blc_mode_0            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  3           reg_blc_mode_1            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  2           reg_blc_mode_2            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  1           reg_blc_mode_3            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  0           reg_blc_mode_4            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
#define ISP_LSWB_BLC_OFST0                         ((0x0d0a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_blc_ofst_0            // unsigned ,    RW, default = 0  float16 Gr for blc offset each color each channels
//Bit 15: 0        reg_blc_ofst_1            // unsigned ,    RW, default = 0  float16 R  for blc offset each color each channels
#define ISP_LSWB_BLC_OFST1                         ((0x0d0b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_blc_ofst_2            // unsigned ,    RW, default = 0  float16 B  for blc offset each color each channels
//Bit 15: 0        reg_blc_ofst_3            // unsigned ,    RW, default = 0  float16 Gb for blc offset each color each channels
#define ISP_LSWB_BLC_OFST2                         ((0x0d0c  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_blc_ofst_4            // unsigned ,    RW, default = 0  float16 Ir of 4x4 rgbir pattern for blc offset each color each channels
#define ISP_LSWB_BLC_PHSOFST                       ((0x0d0d  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_blc_xphs_ofst         // unsigned ,    RW, default = 0  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_blc_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_LSWB_WB_GAIN0                          ((0x0d0e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_wb_gain_0             // unsigned ,    RW, default = 256  u4.8 Gr gain for wb each color each channels
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_1             // unsigned ,    RW, default = 256  u4.8 R gain for wb each color each channels
#define ISP_LSWB_WB_GAIN1                          ((0x0d0f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_wb_gain_2             // unsigned ,    RW, default = 256  u4.8 B gain for wb each color each channels
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_3             // unsigned ,    RW, default = 256  u4.8 Gb gain for wb each color each channels
#define ISP_LSWB_WB_GAIN2                          ((0x0d10  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_wb_rate_rs            // unsigned ,    RW, default = 0  extra fractional bits (right shift)  for the reg_wb_gain[5], default=0; 0:gain=4.8; 1:gain=3.9; 2:2.10; 3: 1.11
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_4             // unsigned ,    RW, default = 256  u4.8 Ir gain of 4x4 rgbir pattern for wb each color each channels
#define ISP_LSWB_WB_LIMIT0                         ((0x0d11  << 2) + 0xfe3b4000)
//Bit 31:16        reg_wb_limit_0            // unsigned ,    RW, default = 0  float16 Gr for white balance each color each channels
//Bit 15: 0        reg_wb_limit_1            // unsigned ,    RW, default = 0  float16 Rg for white balance each color each channels
#define ISP_LSWB_WB_LIMIT1                         ((0x0d12  << 2) + 0xfe3b4000)
//Bit 31:16        reg_wb_limit_2            // unsigned ,    RW, default = 0  float16 Bg for white balance each color each channels
//Bit 15: 0        reg_wb_limit_3            // unsigned ,    RW, default = 0  float16 Gb for white balance each color each channels
#define ISP_LSWB_WB_LIMIT2                         ((0x0d13  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_wb_limit_4            // unsigned ,    RW, default = 0  float16 IR for white balance each color each channels
#define ISP_LSWB_WB_PHSOFST                        ((0x0d14  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_wb_xphs_ofst          // unsigned ,    RW, default = 0  wb horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_wb_yphs_ofst          // unsigned ,    RW, default = 0  wb vertical phase offset, supporting 4x4
#define ISP_LSWB_LNS_PHSOFST                       ((0x0d15  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_lns_xphs_ofst         // unsigned ,    RW, default = 1  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_lns_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_LSWB_RS_PARAM                          ((0x0d16  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11           reg_lns_rad_chnmode       // unsigned ,    RW, default = 1  0:RGB three channel LUT, 1:GRBG/RGBIr four channel LUT
//Bit 10           reg_lns_rad_gainmode      // unsigned ,    RW, default = 0  0: final gain = (x); 1:final gain = (1+x)
//Bit  9           reg_lns_rad_dbg           // unsigned ,    RW, default = 0  0: debug mode off, 1: debug mode on
//Bit  8: 0        reg_lns_rad_strength      // unsigned ,    RW, default = 256  radial shading correction strength
#define ISP_LSWB_RS_XSCALE                         ((0x0d17  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lns_rad_xscale        // unsigned ,    RW, default = 8738  scale to x_dist to norm to 2^16 as "1" as input of the cordic; x scale <=65536/(ColMax)*256, ColMax>=256
#define ISP_LSWB_RS_YSCALE                         ((0x0d18  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lns_rad_yscale        // unsigned ,    RW, default = 15534  scale to y_dist to norm to 2^16 as "1" as input of the cordic; y scale <=65536/(RowMax)*256, RowMax>=256
#define ISP_LSWB_RS_CENTER                         ((0x0d19  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lns_rad_centerx       // unsigned ,    RW, default = 0  coordinates of the center of the image on the X axis, default = xsize/2
//Bit 15: 0        reg_lns_rad_centery       // unsigned ,    RW, default = 0  coordinates of the center of the image on the Y axis, default = ysize/2
#define ISP_LSWB_RS_CENTEROFST_0                   ((0x0d1a  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_0   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_0   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_0    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_1                   ((0x0d1b  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_1   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_1   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_1    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_2                   ((0x0d1c  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_2   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_2   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_2    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_3                   ((0x0d1d  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_3   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_3   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_3    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_MS_PARAM                          ((0x0d1e  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19           reg_lns_mesh_chnmode      // unsigned ,    RW, default = 1  0:RGB three channel LUT, 1:GRBG/RGBIr four channel LUT
//Bit 18           reg_lns_mesh_gainmode     // unsigned ,    RW, default = 0  0: final gain = (x); 1:final gain = (1+x)
//Bit 17:16        reg_lns_mesh_alpmode      // unsigned ,    RW, default = 0  0: orgin, 1:two light sources with 32 cols and 64 rows, 2 or 3: four light sources with 32 cols and 32 rows
//Bit 15           reg_lns_mesh_prtmode      // unsigned ,    RW, default = 0  0:no protect mesh shading correction 1:protect mesh shading correction
//Bit 14:13        reserved
//Bit 12: 1        reg_lns_mesh_strength     // unsigned ,    RW, default = 4095  0: no correction 4095: correction to match mesh data
//Bit  0           reg_lns_mesh_dbg          // unsigned ,    RW, default = 0  debug 1: debug mode on
#define ISP_LSWB_MS_LUTNORM_0                      ((0x0d1f  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_0 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_1                      ((0x0d20  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_1 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_2                      ((0x0d21  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_2 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_3                      ((0x0d22  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_3 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_ALP                            ((0x0d23  << 2) + 0xfe3b4000)
//Bit 31:24        reg_lns_mesh_alp_0        // unsigned ,    RW, default = 255  for 1/2/4 light sources alp blend
//Bit 23:16        reg_lns_mesh_alp_1        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
//Bit 15: 8        reg_lns_mesh_alp_2        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
//Bit  7: 0        reg_lns_mesh_alp_3        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
#define ISP_LSWB_MS_XSHIFT                         ((0x0d24  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17: 0        reg_lns_mesh_xshift       // unsigned ,    RW, default = 0  scalar shift in X axis
#define ISP_LSWB_MS_YSHIFT                         ((0x0d25  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17: 0        reg_lns_mesh_yshift       // unsigned ,    RW, default = 0  scalar shift in Y axis
#define ISP_LSWB_MS_NUM                            ((0x0d26  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_lns_mesh_xnum         // unsigned ,    RW, default = 32  horizontal direction region number, valid lut size = (xnum)*(ynum)*4
//Bit 15: 7        reserved
//Bit  6: 0        reg_lns_mesh_ynum         // unsigned ,    RW, default = 32  vertical direction region number, valid lut size = (xnum)*(ynum)*4
#define ISP_LSWB_MS_XSCALE                         ((0x0d27  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lns_mesh_xscale       // unsigned ,    RW, default = 256  max support xnum = 64
#define ISP_LSWB_MS_YSCALE                         ((0x0d28  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lns_mesh_yscale       // unsigned ,    RW, default = 256  max support ynum = 64
#define ISP_LSWB_MS_LIMIT                          ((0x0d29  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lns_mesh_xlimit       // unsigned ,    RW, default = 255
//Bit  7: 0        reg_lns_mesh_ylimit       // unsigned ,    RW, default = 255
#define ISP_EOTF_DEBUG_IN_CHECKSUM                 ((0x0d2a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_eotf_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_EOTF_DEBUG_OUT_CHECKSUM                ((0x0d2b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_eotf_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_IDG_DEBUG_IN_CHECKSUM                  ((0x0d2c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_idg_debug_in_checksum  // unsigned ,    RO, default = 0
#define ISP_IDG_DEBUG_OUT_CHECKSUM                 ((0x0d2d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_idg_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_BL_DEBUG_IN_CHECKSUM                   ((0x0d2e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_bl_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_BL_DEBUG_OUT_CHECKSUM                  ((0x0d2f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_bl_debug_out_checksum  // unsigned ,    RO, default = 0
#define ISP_WB_DEBUG_IN_CHECKSUM                   ((0x0d30  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wb_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_WB_DEBUG_OUT_CHECKSUM                  ((0x0d31  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_wb_debug_out_checksum  // unsigned ,    RO, default = 0
#define ISP_LSN_RAD_DEBUG_IN_CHECKSUM              ((0x0d32  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_lsn_rad_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_RAD_DEBUG_OUT_CHECKSUM             ((0x0d33  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_lsn_rad_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_MESH_DEBUG_IN_CHECKSUM             ((0x0d34  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_lsn_mesh_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_MESH_DEBUG_OUT_CHECKSUM            ((0x0d35  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_lsn_mesh_debug_out_checksum // unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_lens_shading_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_lns_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LNS_RAD_LUT_ADDR                       ((0x0df0  << 2) + 0xfe3b4000)
//Bit 31: 0       reg_lns_rad_lut_addr            // unsigned, RW, default = 32'h0
#define ISP_LNS_RAD_LUT_DATA                       ((0x0df1  << 2) + 0xfe3b4000)
//Bit 31:0        reg_lns_rad_lut_data            // unsigned, RW, default = 32'h0
#define ISP_LNS_MESH_LUT_ADDR                      ((0x0df2  << 2) + 0xfe3b4000)
//Bit 31: 0       reg_lns_mesh_lut_addr            // unsigned , RW, default = 32'h0
#define ISP_LNS_MESH_LUT_DATA                      ((0x0df3  << 2) + 0xfe3b4000)
//Bit 31: 0       reg_lns_mesh_lut_data            // unsigned , RW, default = 32'h0
#define ISP_LNS_EOTF0_LUT_ADDR                     ((0x0df4  << 2) + 0xfe3b4000)
//Bit 31:0       reg_eotf0_lut_addr         // unsigned, RW, default=0
#define ISP_LNS_EOTF0_LUT_DATA                     ((0x0df5  << 2) + 0xfe3b4000)
//Bit 31:20      reserved
//Bit 19:0       reg_eotf0_lut_data         //unsigned, RW, default=0
#define ISP_LNS_EOTF1_LUT_ADDR                     ((0x0df6  << 2) + 0xfe3b4000)
//Bit 31:0       reg_eotf1_lut_addr         //unsigned, RW, default=0
#define ISP_LNS_EOTF1_LUT_DATA                     ((0x0df7  << 2) + 0xfe3b4000)
//Bit 31:20      reserved
//Bit 19:0       reg_eotf1_lut_data         //unsigned, RW, default=0
#define ISP_LNS_GCLK_CTRL                          ((0x0df8  << 2) + 0xfe3b4000)
//Bit 31:0       reg_gclk_ctrl              //unsigned, RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_lns_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB1_APB_BASE = 0x0e
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_gtm_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GTM_GAIN                               ((0x0e00  << 2) + 0xfe3b4000)
//Bit 31:16        reg_gtm_gain              // unsigned ,    RW, default = 256  gain (u8.8) before tone mapping
//Bit 15: 1        reserved
//Bit  0           reg_gtm_lut_mode          // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for global tone mapping lut
#define ISP_GTM_OFST                               ((0x0e01  << 2) + 0xfe3b4000)
//Bit 31:16        reg_gtm_pre_ofst          // unsigned ,    RW, default = 0  float16 offset before tone mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_gtm_pst_ofst          // unsigned ,    RW, default = 0  (BIT_DEPTH5), offset after tone mapping
#define ISP_GTM_LUT_NUM                            ((0x0e02  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_gtm_lut_num_7         // unsigned ,    RW, default = 5  numbers for each segment
//Bit 27            reserved
//Bit 26:24        reg_gtm_lut_num_6         // unsigned ,    RW, default = 4  numbers for each segment
//Bit 23            reserved
//Bit 22:20        reg_gtm_lut_num_5         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 19            reserved
//Bit 18:16        reg_gtm_lut_num_4         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 15            reserved
//Bit 14:12        reg_gtm_lut_num_3         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 11            reserved
//Bit 10: 8        reg_gtm_lut_num_2         // unsigned ,    RW, default = 3  numbers for each segment
//Bit  7            reserved
//Bit  6: 4        reg_gtm_lut_num_1         // unsigned ,    RW, default = 4  numbers for each segment
//Bit  3            reserved
//Bit  2: 0        reg_gtm_lut_num_0         // unsigned ,    RW, default = 5  numbers for each segment
#define ISP_GTM_LUT_STP                            ((0x0e03  << 2) + 0xfe3b4000)
//Bit 31:28        reg_gtm_lut_stp_7         // unsigned ,    RW, default = 14  steps for each segment
//Bit 27:24        reg_gtm_lut_stp_6         // unsigned ,    RW, default = 14  steps for each segment
//Bit 23:20        reg_gtm_lut_stp_5         // unsigned ,    RW, default = 14  steps for each segment
//Bit 19:16        reg_gtm_lut_stp_4         // unsigned ,    RW, default = 13  steps for each segment
//Bit 15:12        reg_gtm_lut_stp_3         // unsigned ,    RW, default = 12  steps for each segment
//Bit 11: 8        reg_gtm_lut_stp_2         // unsigned ,    RW, default = 11  steps for each segment
//Bit  7: 4        reg_gtm_lut_stp_1         // unsigned ,    RW, default = 9  steps for each segment
//Bit  3: 0        reg_gtm_lut_stp_0         // unsigned ,    RW, default = 8  steps for each segment
#define ISP_GTM_LUT129_ADDR                        ((0x0e10  << 2) + 0xfe3b4000)
//Bit  31:7        reserved
//Bit  6: 0        reg_gtm_lut129_addr        // unsigned ,    RW, default = 0
#define ISP_GTM_LUT129_DATA                        ((0x0e11  << 2) + 0xfe3b4000)
//Bit  31: 24      reserved
//Bit  23: 0       reg_gtm_lut129_data        // unsigned ,    RW, default = 0
#define ISP_GTM_GLK_CTRL                           ((0x0e12  << 2) + 0xfe3b4000)
//Bit  31: 4       reserved
//Bit   3: 0       reg_glk_ctrl               // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_gtm_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB2_APB_BASE = 0x0f
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ltm_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LTM_HIST_POW_Y                         ((0x0f00  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_pow_y_u20         // unsigned ,    RW, default = 699051  pow y coef(x^y)
#define ISP_LTM_GLBWIN_H                           ((0x0f01  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_glbwin_hend       // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_ltm_glbwin_hstart     // unsigned ,    RW, default = 0
#define ISP_LTM_GLBWIN_V                           ((0x0f02  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_glbwin_vend       // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_ltm_glbwin_vstart     // unsigned ,    RW, default = 0
#define ISP_LTM_HIST_POW_DIVISOR                   ((0x0f03  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22: 0        reg_ltm_pow_divisor_u23   // unsigned ,    RW, default = 82570  pow divisor coef
#define ISP_LTM_STA_FLOOR                          ((0x0f04  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ltm_dark_floor_u8     // unsigned ,    RW, default = 32  dark noise floor base
//Bit 15:14        reserved
//Bit 13: 0        reg_ltm_bright_floor_u14  // unsigned ,    RW, default = 8192  noise bright floor
#define ISP_LTM_STAT_BIN                           ((0x0f05  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14: 8        reg_ltm_lmax_bin          // unsigned ,    RW, default = 0  min width of lmax histogram bin num,
//Bit  7            reserved
//Bit  6: 0        reg_ltm_lmin_bin          // unsigned ,    RW, default = 0  min width of lmin histogram bin num,
#define ISP_LTM_STA_DARK_NOISE                     ((0x0f06  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_dark_noise_u20    // unsigned ,    RW, default = 32768  dark side noise ofst
#define ISP_LTM_STA_GMIN_TOTAL                     ((0x0f07  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_ltm_gmin_total        // unsigned ,    RW, default = 7441  gmin total
#define ISP_LTM_STA_GMAX_TOTAL                     ((0x0f08  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_ltm_gmax_total        // unsigned ,    RW, default = 761303  gmax total
#define ISP_LTM_STA_LOC_PERC                       ((0x0f09  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_ltm_lmax_pct_u10      // unsigned ,    RW, default = 1023  range 0...1024, #/1024
//Bit 15:10        reserved
//Bit  9: 0        reg_ltm_lmin_pct_u10      // unsigned ,    RW, default = 2  rnage 0...1024, #/1024
#define ISP_LTM_POW_CRTL                           ((0x0f0a  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ltm_min_factor_u8     // unsigned ,    RW, default = 32  range 0...255,   #/64
//Bit 23:16        reg_ltm_max_factor_u8     // unsigned ,    RW, default = 128  range 0...255,  #/64
//Bit 15            reserved
//Bit 14: 8        reg_ltm_hi_gm_u7          // unsigned ,    RW, default = 32  range 0...128, #/128
//Bit  7: 6        reserved
//Bit  5: 0        reg_ltm_lo_gm_u6          // unsigned ,    RW, default = 32  range 0...64,  #/32
#define ISP_LTM_SHRP_CRTL                          ((0x0f0b  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:24        reg_ltm_shrp_smth_lvlsft  // unsigned ,    RW, default = 3  level to adjust sigma filter
//Bit 23:16        reg_ltm_shrp_s_u8         // unsigned ,    RW, default = 16  sharpness strength(boost level), norm to 16 as 1.0 for no boost; default , 16
//Bit 15:14        reserved
//Bit 13: 8        reg_ltm_shrp_r_u6         // unsigned ,    RW, default = 32  sharpness range 0...64,  #/64
//Bit  7: 2        reg_ltm_shrp_base_alpha   // unsigned ,    RW, default = 0  R1024 blend coef in sharpen
//Bit  1            reserved
//Bit  0           reg_ltm_dtl_ehn_en        // unsigned ,    RW, default = 1  detail enhancement en
#define ISP_LTM_SHRP_NOISE                         ((0x0f0c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:20        reg_ltm_hi_noise_1024     // unsigned ,    RW, default = 51  hgh noise in sharpen
//Bit 19:10        reg_ltm_md_noise_1024     // unsigned ,    RW, default = 51  mid noise in sharpen
//Bit  9: 0        reg_ltm_lo_noise_1024     // unsigned ,    RW, default = 51  low noise in sharpen
#define ISP_LTM_SHRP_EXP_THD                       ((0x0f0d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_ltm_expblend_thd1     // unsigned ,    RW, default = 3600  wdr expblend thrd1 T_EXPSTITCH_PARAM prm_expst->reg_wdr_expcomb_blend_thd1;
//Bit 15:14        reserved
//Bit 13: 0        reg_ltm_expblend_thd0     // unsigned ,    RW, default = 2576  wdr expblend thrd0 T_EXPSTITCH_PARAM prm_expst->reg_wdr_expcomb_blend_thd0;
#define ISP_LTM_LOG_KEY                            ((0x0f0e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27: 0        reg_ltm_lr_u28            // unsigned ,    RW, default = 676200  key coef to adjust log mapping
#define ISP_LTM_WHITE_LEVEL                        ((0x0f0f  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_white_level       // unsigned ,    RW, default = 1048575  white level threshold
#define ISP_LTM_BLACK_LEVEL                        ((0x0f10  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_black_level       // unsigned ,    RW, default = 0  black level threshold
#define ISP_LTM_FINAL_CTRL                         ((0x0f11  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_ltm_vs_gtm_alpha      // unsigned ,    RW, default = 63  alpha blender coef between ltm and gtm, norm to 64 as 1.0, 0: 100% gtm; 63: 100% ltm_result
//Bit 23:22        reserved
//Bit 21:16        reg_ltm_b2luma_alpha      // unsigned ,    RW, default = 63  alpha of luma using filter Y or mRGB, 0: luma filter way; 63: mRGB way; 1~62 blender of filter results and mRGB results, default, 63
//Bit 15:12        reserved
//Bit 11: 8        reg_ltm_dbg_mode          // unsigned ,    RW, default = 0  ltm debug model
//Bit  7           reg_ltm_mrgb_mode         // unsigned ,    RW, default = 0  mrgb mode selection 0: MAX(avg(rgb)), 1: MAX( MAX(avg(rgb)), y)
//Bit  6: 0        reg_ltm_final_gain        // unsigned ,    RW, default = 64  final gain norm 64 as 1.0
#define ISP_LTM_FLT_CTRL                           ((0x0f12  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28           reg_ltm_cc_en             // unsigned ,    RW, default = 0  color compensation enable register
//Bit 27:26        reg_ltm_xphs_ofst         // unsigned ,    RW, default = 1  phase offset in x dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each senso
//Bit 25:24        reg_ltm_yphs_ofst         // unsigned ,    RW, default = 0  phase offset in y dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each senso
//Bit 23:20        reserved
//Bit 19: 8        reg_ltm_ccdis_thd         // unsigned ,    RW, default = 4095  to disable cc path, replace with out_fc_12b if in_ratio>thr*16, default = 4095
//Bit  7: 4        reg_ltm_stat_hblk_num     // unsigned ,    RW, default = 12  horizontal block number for ltm statistic
//Bit  3: 0        reg_ltm_stat_vblk_num     // unsigned ,    RW, default = 8  vertical block number for ltm statistic
#define ISP_LTM_STA_LPF_CTRL                       ((0x0f13  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_ltm_lmin_lpf_taps     // unsigned ,    RW, default = 1  lpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:17        reserved
//Bit 16           reg_ltm_lmax_lpf_taps     // unsigned ,    RW, default = 1  lpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 15:13        reserved
//Bit 12           reg_ltm_lmin_med_en       // unsigned ,    RW, default = 1  enable lmin median filter: 0: disable, 1: enable
//Bit 11: 9        reserved
//Bit  8           reg_ltm_lmax_med_en       // unsigned ,    RW, default = 1  enable lmax median filter: 0: disable, 1: enable
//Bit  7: 6        reserved
//Bit  5: 4        reg_ltm_lmin_lpf_mode     // unsigned ,    RW, default = 2  adaptive lmin filter mode of regional statistics, 0: no lpf 1:mean, 2:MIN(org,mean), 3:min
//Bit  3: 2        reserved
//Bit  1: 0        reg_ltm_lmax_lpf_mode     // unsigned ,    RW, default = 2  adaptive lmax filter mode of regional statistics, 0: no lpf 1:mean, 2:MAX(org,mean), 3:max
#define ISP_LTM_STA_HIDX_0_1                       ((0x0f14  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_1       // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_0       // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LTM_STA_HIDX_2_3                       ((0x0f15  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_3       // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_2       // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LTM_STA_HIDX_4_5                       ((0x0f16  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_5       // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_4       // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LTM_STA_HIDX_6_7                       ((0x0f17  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_7       // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_6       // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LTM_STA_HIDX_8_9                       ((0x0f18  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_9       // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_8       // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LTM_STA_HIDX_10_11                     ((0x0f19  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_hidx_11      // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_10      // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LTM_STA_HIDX_12                        ((0x0f1a  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ltm_stat_hidx_12      // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LTM_STA_VIDX_0_1                       ((0x0f1b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_vidx_1       // unsigned ,    RW, default = 270  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_0       // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LTM_STA_VIDX_2_3                       ((0x0f1c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_vidx_3       // unsigned ,    RW, default = 810  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_2       // unsigned ,    RW, default = 540  block boundary x-index
#define ISP_LTM_STA_VIDX_4_5                       ((0x0f1d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_vidx_5       // unsigned ,    RW, default = 1350  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_4       // unsigned ,    RW, default = 1080  block boundary x-index
#define ISP_LTM_STA_VIDX_6_7                       ((0x0f1e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ltm_stat_vidx_7       // unsigned ,    RW, default = 1890  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_6       // unsigned ,    RW, default = 1620  block boundary x-index
#define ISP_LTM_STA_VIDX_8                         ((0x0f1f  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ltm_stat_vidx_8       // unsigned ,    RW, default = 2160  block boundary x-index
#define ISP_LTM_STA_HST_SUM_GLBL                   ((0x0f20  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_sum_log_4096_l         // unsigned ,    RO, default = 0  log_4096 sum lower u32
#define ISP_LTM_STA_HST_SUM_GLBH                   ((0x0f21  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16: 0        ro_sum_log_4096_h         // unsigned ,    RO, default = 0  log_4096 sum higher u17
#define ISP_LTM_STA_GLB                            ((0x0f22  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        ro_ltm_gmax_idx           // unsigned ,    RO, default = 0  global max index
//Bit 15:10        reserved
//Bit  9: 0        ro_ltm_gmin_idx           // unsigned ,    RO, default = 0  global min index
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ltm_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ltm_reg_hw.h
//
// synopsys translate_off
// synopsys translate_on
//====================================================================================
//      ToneMapping HW/LUT register SPACE
//      0x80-0xff
//====================================================================================
#define ISP_LTM_STA_THD_ADDR                       ((0x0f30  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_sta_thd_lut_addr // unsigned ,    RW, default = 0
#define ISP_LTM_STA_THD_DATA                       ((0x0f31  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_sta_thd_lut_data // unsigned ,    RW, default = 0
#define ISP_LTM_BLK_STA_ADDR                       ((0x0f32  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_blk_sta_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_BLK_STA_DATA                       ((0x0f33  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_blk_sta_data     // unsigned ,    RW, default = 0
#define ISP_LTM_CCRAT_ADDR                         ((0x0f34  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_ccrat_lut_addr   // unsigned ,    RW, default = 0
#define ISP_LTM_CCRAT_DATA                         ((0x0f35  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_ccrat_lut_data   // unsigned ,    RW, default = 0
#define ISP_LTM_CCALP_ADDR                         ((0x0f36  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_ccalp_lut_addr   // unsigned ,    RW, default = 0
#define ISP_LTM_CCALP_DATA                         ((0x0f37  << 2) + 0xfe3b4000)
//Bit 31:0      reg_isp_ltm_ccalp_lut_data   // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMIN_ADDR                       ((0x0f38  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_lmin_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMIN_DATA                       ((0x0f39  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_lmin_data     // unsigned ,    RO, default = 0
#define ISP_LTM_RO_LMAX_ADDR                       ((0x0f3a  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_lmax_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMAX_DATA                       ((0x0f3b  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_lmax_data     // unsigned ,    RO, default = 0
#define ISP_LTM_RO_BLK_SUM_ADDR                    ((0x0f3c  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_blk_sum_addr      // unsigned ,    RW, default = 0
#define ISP_LTM_RO_BLK_SUM_DATA                    ((0x0f3d  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_blk_sum_data      // unsigned ,    RO, default = 0
#define ISP_LTM_RO_GLB_ADDR                        ((0x0f3e  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_glb_addr      // unsigned ,    RW, default = 0
#define ISP_LTM_RO_GLB_DATA                        ((0x0f3f  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_sta_glb_data      // unsigned ,    RO, default = 0
#define ISP_LTM_RO_BIN_ADDR                        ((0x0f40  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_bin_addr          // unsigned ,    RW, default = 0
#define ISP_LTM_RO_BIN_DATA                        ((0x0f41  << 2) + 0xfe3b4000)
//Bit 31:0      ro_isp_ltm_bin_data          // unsigned ,    RO, default = 0
#define ISP_TM_GCLK                                ((0x0f42  << 2) + 0xfe3b4000)
//Bit 31:13     reserved
//Bit 12        pls_frm_flg_clr              // unsigned  ,   W1T, default = 0 //pls to clear pingpong frm cnt
//Bit 11:0      reg_tm_gclk_ctrl             // unsigned  ,   RW, default = 0
#define ISP_LTM_DBGINFO_RST                        ((0x0f43  << 2) + 0xfe3b4000)
//Bit 31:3         reserved
//Bit 2:1          reg_ltm_frm_end_mask      // unsigned ,    RW, default = 0
//Bit 0            reg_ltm_dbginfo_rst       // unsigned ,    RW, default = 0
#define ISP_LTM_DBG_RO_0                           ((0x0f44  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ltm_dbg0               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_1                           ((0x0f45  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ltm_dbg1               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_2                           ((0x0f46  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ltm_dbg2               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_3                           ((0x0f47  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ltm_dbg3               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_4                           ((0x0f48  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ltm_dbg4               // unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ltm_reg_hw.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB0_APB_BASE = 0x10
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dms_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DMS_COMMON_PARAM0                      ((0x1000  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 5        reserved
//Bit  4           reg_dms_cdif_sgn_invrt    // unsigned ,    RW, default = 1  cdif sign invert enable, default = (reg_dms_xphase_ofst%2,=1, set once for each sensor
//Bit  3: 2        reg_dms_xphase_ofst       // unsigned ,    RW, default = 1  offset in x dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each sensor
//Bit  1: 0        reg_dms_yphase_ofst       // unsigned ,    RW, default = 0  offset in y dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each sensor
#define ISP_DMS_COMMON_PARAM1                      ((0x1001  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25           reg_dms_ext_type          // unsigned ,    RW, default = 1  extend type for dms.0:2 lines extend 1:4 lines extend.
//Bit 24           reg_dms_pipe2b_org_en     // unsigned ,    RW, default = 1  enable register to do CDM filter on original R/B channels, default = 1
//Bit 23           reg_dms_rb_cerr_usecdif   // unsigned ,    RW, default = 0  int pipe2 use cdif for error_c calc instead of RB diff, default = 0, if set 1, care more about color diff as gradient
//Bit 22:19        reg_dms_rb_cerr_gain      // unsigned ,    RW, default = 4  int pipe2 error_c gain for blend with error_g for error, norm to 4 as 1.0, default = 4
//Bit 18:15        reg_dms_rb_cur_chn_cerr_gain // unsigned ,    RW, default = 8  int pipe2 error_c gain for blend with error_g for error, norm to 4 as 1.0, default = 4
//Bit 14: 9        reg_dms_rb_coring_ratio   // unsigned ,    RW, default = 24  adaptive coring ratio for high frequency color noise reduction for PIPE2 , norm to 64 as 1.0; default = 24;
//Bit  8: 3        reg_dms_p3_coring_ratio   // unsigned ,    RW, default = 24  adaptive coring ratio for high frequency color noise reduction for PIPE3 , norm to 64 as 1.0; default = 24;
//Bit  2: 0        reg_dms_bypass            // unsigned ,    RW, default = 0  0/1: n (no debug); 2: n-2 line results; 3:n-1 line;4:n-line 5:n+1 6:n+2; ; 7: n-line dms bypassed and put Bayer on RGB channels
#define ISP_DMS_CDM_GRN                            ((0x1002  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:17        reg_dms_grn_cdm_err_rs    // unsigned ,    RW, default = 2  right shift for the 6abs to get the normalized u8 error, default = 2
//Bit 16           reg_dms_grn_cdm_cor_dif   // unsigned ,    RW, default = 0  only have bigger texture cored by smaller one as adaptive coring, smaller texture coring to 0; default = 0;
//Bit 15:14        reserved
//Bit 13: 8        reg_dms_grn_cdm_cor_rat   // unsigned ,    RW, default = 8  coring rate to texture for the gradient, normalized to 64 as 1.0, default = 16, if rat=0, no coring
//Bit  7: 0        reg_dms_grn_cdm_cor_lmt   // unsigned ,    RW, default = 255  limit of coring to the gradient, final coring no more than this 2x in u11 scale, default = 255(*2);
#define ISP_DMS_GRN_REF0                           ((0x1003  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_dms_gref_marginx4     // signed ,    RW, default = 0  condition margin for green interpolation refinement
//Bit  7            reserved
//Bit  6           reg_dms_gref_chk_hfrq     // unsigned ,    RW, default = 1  check high frequency for green interpolation refinement
//Bit  5           reg_dms_gref_grd_sel      // unsigned ,    RW, default = 0  0: use gradh/gradv, 1: use varh/varv for green interpolation refinement
//Bit  4           reg_dms_gref_en_4         // unsigned ,    RW, default = 0  enable green interpolation refinement
//Bit  3           reg_dms_gref_en_3         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  2           reg_dms_gref_en_2         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  1           reg_dms_gref_en_1         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  0           reg_dms_gref_en_0         // unsigned ,    RW, default = 0  enable green interpolation refinement
#define ISP_DMS_GRN_REF1                           ((0x1004  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17: 8        reg_dms_gref_hrfq_thrd    // unsigned ,    RW, default = 94  high frequency threshold for green interpolation refinement
//Bit  7: 0        reg_dms_gref_strength     // unsigned ,    RW, default = 255  strength for green interpolation refinement
#define ISP_DMS_PRE_PARAM                          ((0x1005  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_prefilt_thrd_igrn     // unsigned ,    RW, default = 20  four pixel grouping sigma threshold for Green Channels, set to 255 will be force filter, default= 20
//Bit 15: 8        reg_prefilt_thrd_ired     // unsigned ,    RW, default = 18  four pixel grouping sigma threshold for Blue/Red Channels, set to 255 will be force filter, default=18
//Bit  7: 2        reserved
//Bit  1           reg_prefilt_force_raw2_ir // unsigned ,    RW, default = 0  force raw data onto IR, 0: no force, 1: force raw to IR component, default =0;
//Bit  0           reg_prefilt_force_raw2_bayer // unsigned ,    RW, default = 0  force raw data considered as bayer2x2, default =0
#define ISP_DMS_CT_PARAM0                          ((0x1006  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ctran_coring          // unsigned ,    RW, default = 30  coring to the color transition_level, ignore small color transition
//Bit  7: 6        reg_ctran_h_dial_win      // unsigned ,    RW, default = 2  horizontal dialation window size for ctran_h, 0: no dialation  else (x+1)
//Bit  5: 4        reg_ctran_v_dial_win      // unsigned ,    RW, default = 2  horizontal dialation window size for ctran_v, 0: no dialation, else (x+1)
//Bit  3           reg_ctran_powersaving     // unsigned ,    RW, default = 0  enable bit gate the ctran clock for power saving, just output cdf_l
//Bit  2           reg_ctrs_csat_max_en      // unsigned ,    RW, default = 1  enable bit to do ctrs and csat max to get ctrans, default = 1
//Bit  1           reg_ctran_h_lpf_en        // unsigned ,    RW, default = 1  enable bit to do horizontal [12221] lpf for lbuf_ctran_h_lpf, default = 1
//Bit  0           reg_ctran_v_lpf_en        // unsigned ,    RW, default = 1  enable bit to do horizontal [12221] lpf for lbuf_ctran_v_lpf, default = 1
#define ISP_DMS_CT_PARAM1                          ((0x1007  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_ctran_sat_thrd        // unsigned ,    RW, default = 40  to sat=abs(u or v), if smaller than thrd, sat_trs_leve=0; sat_level norm to 128 as 1
//Bit 15: 8        reg_ctran_sat_ratio        // unsigned ,    RW, default = 32  to (sat-thrd)/32, norm to 32 as "1"; default = 32;
//Bit  7: 0        reg_ctran_sat_limt        // unsigned ,    RW, default = 128  limit, normalized 128 as 1
#define ISP_DMS_CT_PARAM2                          ((0x1008  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ctran_gain_h          // unsigned ,    RW, default = 128  final gain to tran_level_h to get alpha, normalized to 64 as 1, if =0, means cdf_l 100%
//Bit 23:16        reg_ctran_gain_v          // unsigned ,    RW, default = 128  final gain to tran_level_v to get alpha, normalized to 64 as 1, if =0, means cdf_l 100%
//Bit 15: 8        reg_ctran_alph_minmax_1   // unsigned ,    RW, default = 255  min and max limit for pct_h(alpha) for cdifh_long and cdifh_short blender, larger of pct_h, the more use cdifh_short
//Bit  7: 0        reg_ctran_alph_minmax_0   // unsigned ,    RW, default = 0  min and max limit for pct_h(alpha) for cdifh_long and cdifh_short blender, larger of pct_h, the more use cdifh_short
#define ISP_DMS_CT_PARAM3                          ((0x1009  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ctran_alpv_minmax_1   // unsigned ,    RW, default = 255  min and max limit for pct_v(alpha) for cdifv_long and cdifv_short blender, larger of pct_v, the more use cdifv_short
//Bit  7: 0        reg_ctran_alpv_minmax_0   // unsigned ,    RW, default = 1  min and max limit for pct_v(alpha) for cdifv_long and cdifv_short blender, larger of pct_v, the more use cdifv_short
#define ISP_DMS_DRT_GRAD                           ((0x100a  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_drt_gradh_gain        // unsigned ,    RW, default = 8  gain to err_horz(2), normalized to 4 as 1.0
//Bit 11: 8        reg_drt_gradv_gain        // unsigned ,    RW, default = 8  gain to err_vert(2), normalized to 4 as 1.0
//Bit  7: 4        reg_drt_gradd_gain        // unsigned ,    RW, default = 8  gain to err_diag(1/3), normalized to 4 as 1.0
//Bit  3           reg_drt_onirraw_en        // unsigned ,    RW, default = 0  enable for IR raw, 0: only apply on bayer RGB2x2 after pre-filter, no Ir; 1: apply on raw with RGBIr, 2x2/4x4
//Bit  2           reg_drt_grad_phs03        // unsigned ,    RW, default = 1  enable to include Gr/Gb gradient, 0: no Gr/Gb gradient; 1: ws Gr/Gb gradient;
//Bit  1           reg_drt_grad_phs1         // unsigned ,    RW, default = 1  enable to include phase-1 pixels gradient, 0: no phs1 gradient; 1: ws phs1 gradient; ir4x4 is for R/B mix, set to "0"
//Bit  0           reg_drt_grad_phs2         // unsigned ,    RW, default = 1  enable to include phase-2 pixels gradient, 0: no phs2 gradient; 1: ws phs2 gradient; ir4x4 is for Ir, can set to '1'
#define ISP_DMS_DRT_MAXERR                         ((0x100b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_drt_maxerr_viir_thrd  // unsigned ,    RW, default = 60  4x is thrd to |maxerr_cur- maxerr_iir| for IIR mute, larger than 4x will mute the viir
//Bit 15:12        reg_drt_maxerr_viir_ratio  // unsigned ,    RW, default = 8  if (|maxerr_cur- maxerr_iir|> Max(maxerr_cur, maxerr_iir)*ratio), for IIR mute,
//Bit 11: 8        reg_drt_maxerr_viir_alph  // unsigned ,    RW, default = 8  alpha for viir to maxerr, normalized to 16 as 1.0, default = 8;
//Bit  7: 5        reserved
//Bit  4           reg_drt_maxerr_viir_en    // unsigned ,    RW, default = 1  enable for the vertical iir filter enable
//Bit  3: 1        reserved
//Bit  0           reg_drt_maxerr_viir_frce  // unsigned ,    RW, default = 1  force viir if min_idx=2 detected
#define ISP_DMS_DRT_PARAM                          ((0x100c  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_grad_calp         // unsigned ,    RW, default = 40  color error alpha for final error blend, normalized to 32 as 1.0
//Bit 23:16        reg_drt_grad_calp_for_color_transition // unsigned ,    RW, default = 50  color error alpha for final error blend, normalized to 32 as 1.0
//Bit 15: 4        reg_drt_hfrq_coring       // unsigned ,    RW, default = 16  coring threshold for high frequency count in drt
//Bit  3: 1        reserved
//Bit  0           reg_drt_grad_err_mode     // unsigned ,    RW, default = 0  0: orginal error, 1: blended error, error mode for final error ouput
#define ISP_DMS_DRT_HFRQ0                          ((0x100d  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_drt_hfrq_dif_thd_1    // unsigned ,    RW, default = 256  dif threshold1 for dif to gain calc. for high frequency count in drt
//Bit 15:12        reserved
//Bit 11: 0        reg_drt_hfrq_dif_thd_0    // unsigned ,    RW, default = 64  dif threshold0 for dif to gain calc. for high frequency count in drt
#define ISP_DMS_DRT_HFRQ1                          ((0x100e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_drt_hfrq_dif_thd_3    // unsigned ,    RW, default = 128  dif threshold3 for dif to gain calc. for high frequency count in drt
//Bit 15:12        reserved
//Bit 11: 0        reg_drt_hfrq_dif_thd_2    // unsigned ,    RW, default = 384  dif threshold2 for dif to gain calc. for high frequency count in drt
#define ISP_DMS_DRT_HFRQ2                          ((0x100f  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_drt_hfrq_hv_gain      // unsigned ,    RW, default = 16  horizontal or vertical gains for high frequency count in drt
//Bit  7: 4        reserved
//Bit  3: 0        reg_drt_hfrq_bld_alp      // unsigned ,    RW, default = 8  blend alpha for high frequency count in drt, normalized to 16 as 1.0
#define ISP_DMS_DRT_AMBG0                          ((0x1010  << 2) + 0xfe3b4000)
//Bit 31:28        reg_drt_ambg_alp_lut_7    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 27:24        reg_drt_ambg_alp_lut_6    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 23:20        reg_drt_ambg_alp_lut_5    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 19:16        reg_drt_ambg_alp_lut_4    // unsigned ,    RW, default = 14  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 15:12        reg_drt_ambg_alp_lut_3    // unsigned ,    RW, default = 12  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 11: 8        reg_drt_ambg_alp_lut_2    // unsigned ,    RW, default = 10  alpha lut of high frequency ambiguity for drt ambiguity
//Bit  7: 4        reg_drt_ambg_alp_lut_1    // unsigned ,    RW, default = 8  alpha lut of high frequency ambiguity for drt ambiguity
//Bit  3: 0        reg_drt_ambg_alp_lut_0    // unsigned ,    RW, default = 4  alpha lut of high frequency ambiguity for drt ambiguity
#define ISP_DMS_DRT_AMBG1                          ((0x1011  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_drt_ambg_mxerr_lmt_1  // unsigned ,    RW, default = 256  max err limit (min/max) for drt ambiguity
//Bit 15:10        reserved
//Bit  9: 0        reg_drt_ambg_mxerr_lmt_0  // unsigned ,    RW, default = 12  max err limit (min/max) for drt ambiguity
#define ISP_DMS_DRT_AMBG2                          ((0x1012  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_drt_ambg_hfrq_thd     // unsigned ,    RW, default = 128  high frequency threshold for dmsc with drt ambiguity
//Bit 15:10        reserved
//Bit  9: 0        reg_drt_ambg_cerr_thd     // unsigned ,    RW, default = 512  color error threshold for dmsc with drt ambiguity
#define ISP_DMS_DRT_AMBG3                          ((0x1013  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_drt_ambg_var_sft      // signed ,    RW, default = -2  shift for var calc. for drt ambiguity
//Bit 11: 9        reserved
//Bit  8           reg_drt_ambg_var_frce     // unsigned ,    RW, default = 0  force var calc. for drt ambiguity
//Bit  7: 5        reserved
//Bit  4           reg_drt_ambg_ref_en_4     // unsigned ,    RW, default = 0  enable dmsc refinement for drt ambiguity
//Bit  3           reg_drt_ambg_ref_en_3     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  2           reg_drt_ambg_ref_en_2     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  1           reg_drt_ambg_ref_en_1     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  0           reg_drt_ambg_ref_en_0     // unsigned ,    RW, default = 0  enable dmsc refinement for drt ambiguity
#define ISP_DMS_DRT_AMBG4                          ((0x1014  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_ambg_var_frce_val_0 // unsigned ,    RW, default = 255  force value for var calc. for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_frce_val_1 // unsigned ,    RW, default = 0  force value for var calc. for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_grd_thrd // unsigned ,    RW, default = 128  threshold of grad for var calc. for drt ambiguity
//Bit  7: 5        reserved
//Bit  4           reg_drt_ambg_var_grd_sel  // unsigned ,    RW, default = 1  0:short, 1: long, selection of grad for var calc. for drt ambiguity
//Bit  3: 1        reserved
//Bit  0           reg_drt_ambg_var_cdf_sel  // unsigned ,    RW, default = 0  0:short, 1: long, selection of cdif for var calc. for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_0                     ((0x1015  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_ambg_var_lut_3    // unsigned ,    RW, default = 45  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_2    // unsigned ,    RW, default = 32  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_1    // unsigned ,    RW, default = 23  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_0    // unsigned ,    RW, default = 0  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_1                     ((0x1016  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_ambg_var_lut_7    // unsigned ,    RW, default = 128  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_6    // unsigned ,    RW, default = 111  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_5    // unsigned ,    RW, default = 91  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_4    // unsigned ,    RW, default = 64  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_2                     ((0x1017  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_ambg_var_lut_11   // unsigned ,    RW, default = 181  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_10   // unsigned ,    RW, default = 169  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_9    // unsigned ,    RW, default = 157  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_8    // unsigned ,    RW, default = 143  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_3                     ((0x1018  << 2) + 0xfe3b4000)
//Bit 31:24        reg_drt_ambg_var_lut_15   // unsigned ,    RW, default = 255  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_14   // unsigned ,    RW, default = 239  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_13   // unsigned ,    RW, default = 222  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_12   // unsigned ,    RW, default = 202  lut of vars for drt ambiguity
#define ISP_DMS_PP_EN                              ((0x1019  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reserved
//Bit  7: 6        reserved
//Bit  5           reg_dms_pp_enable         // unsigned ,    RW, default = 1  enable for dms post-processing, 0, disable pp; 1: enable pp
//Bit  4           reg_plp_en                // unsigned ,    RW, default = 0  enable post median filter
//Bit  3: 0        reg_plp_alp               // unsigned ,    RW, default = 0  alpha to blend output of low-pass filter and current value.)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dms_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dms_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
// in page offset 8'h00 | 8'h70~8'h7f
#define ISP_DMS_CORE_GCLK_CTRL                     ((0x1070  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_dms_core_gclk_ctrl          // unsigned ,    RW, default = 0
#define ISP_DMS_PP_GCLK_CTRL                       ((0x1071  << 2) + 0xfe3b4000)
//Bit  31: 0        reg_dms_pp_gclk_ctrl            // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dms_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB1_APB_BASE = 0x11
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg0_top_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_POST_TOP_MISC                          ((0x1100  << 2) + 0xfe3b4000)
//Bit 31: 4        reg_post_misc             // unsigned ,    RW, default = 0
//Bit  3           reg_af_stats_path_en      // unsigned ,    RW, default = 0
//Bit  2           reg_flkr_stats_path_en    // unsigned ,    RW, default = 0
//Bit  1           reg_ir_out_path_en        // unsigned ,    RW, default = 0
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0
#define ISP_POST_TOP_GCLK_CTRL0                    ((0x1101  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl0            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_GCLK_CTRL1                    ((0x1102  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl1            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_SYNC_CTRL0                    ((0x1103  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_sync_ctrl0            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_SYNC_CTRL1                    ((0x1104  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_sync_ctrl1            // unsigned ,    RW, default = 0
#define ISP_POST_STATS_RAM_ADDR                    ((0x1105  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0
#define ISP_POST_RO_STATS_RAM_DATA                 ((0x1106  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0
#define ISP_POST_INT_EN                            ((0x1107  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_post_int_en           // unsigned ,    RW, default = 0
#define ISP_POST_INT_STATUS                        ((0x1108  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_post_int_status       // unsigned ,    RW, default = 0
#define ISP_POST_RO_DBG_STATE                      ((0x1109  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_post_dbg_state         // unsigned ,    RO, default = 0
#define ISP_POST_C422_MODE                         ((0x110f  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_444to422_mode         // unsigned ,    RW, default = 2
#define ISP_CM0_INP_OFST01                         ((0x1110  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_offset_inp_1      // signed ,    RW, default = 0  input data offset1 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_offset_inp_0      // signed ,    RW, default = 0  input data offset0 for cm0
#define ISP_CM0_INP_OFST2                          ((0x1111  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_cm0_offset_inp_2      // signed ,    RW, default = 0  input data offset2 for cm0
#define ISP_CM0_COEF00_01                          ((0x1112  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_0_1     // signed ,    RW, default = 150  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_0_0     // signed ,    RW, default = 77  matrix coefficients for cm0
#define ISP_CM0_COEF02_10                          ((0x1113  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_1_0     // signed ,    RW, default = -43  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_0_2     // signed ,    RW, default = 29  matrix coefficients for cm0
#define ISP_CM0_COEF11_12                          ((0x1114  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_1_2     // signed ,    RW, default = 128  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_1_1     // signed ,    RW, default = -85  matrix coefficients for cm0
#define ISP_CM0_COEF20_21                          ((0x1115  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_2_1     // signed ,    RW, default = -107  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_2_0     // signed ,    RW, default = 128  matrix coefficients for cm0
#define ISP_CM0_COEF22_OUP_OFST0                   ((0x1116  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_offset_oup_0      // signed ,    RW, default = 0  output data offset0 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_2_2     // signed ,    RW, default = -21  matrix coefficients for cm0
#define ISP_CM0_OUP_OFST12_RS                      ((0x1117  << 2) + 0xfe3b4000)
//Bit 31:30        reg_cm0_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s4.8; 1: s3.9; 2: s2.10 3:s1.11, matrix right shift for cm0
//Bit 29            reserved
//Bit 28:16        reg_cm0_offset_oup_2      // signed ,    RW, default = 512  output data offset2 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_offset_oup_1      // signed ,    RW, default = 512  output data offset1 for cm0
#define ISP_CM1_INP_OFST01                         ((0x111e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_offset_inp_1      // signed ,    RW, default = -512  input data offset1 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_offset_inp_0      // signed ,    RW, default = 0  input data offset0 for cm1
#define ISP_CM1_INP_OFST2                          ((0x111f  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_cm1_offset_inp_2      // signed ,    RW, default = -512  input data offset2 for cm1
#define ISP_CM1_COEF00_01                          ((0x1120  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_0_1     // signed ,    RW, default = 0  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_0_0     // signed ,    RW, default = 256  matrix coefficients for cm1
#define ISP_CM1_COEF02_10                          ((0x1121  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_1_0     // signed ,    RW, default = 256  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_0_2     // signed ,    RW, default = 359  matrix coefficients for cm1
#define ISP_CM1_COEF11_12                          ((0x1122  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_1_2     // signed ,    RW, default = -183  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_1_1     // signed ,    RW, default = -88  matrix coefficients for cm1
#define ISP_CM1_COEF20_21                          ((0x1123  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_2_1     // signed ,    RW, default = 454  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_2_0     // signed ,    RW, default = 256  matrix coefficients for cm1
#define ISP_CM1_COEF22_OUP_OFST0                   ((0x1124  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_offset_oup_0      // signed ,    RW, default = 0  output data offset0 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_2_2     // signed ,    RW, default = 0  matrix coefficients for cm1
#define ISP_CM1_OUP_OFST12_RS                      ((0x1125  << 2) + 0xfe3b4000)
//Bit 31:30        reg_cm1_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s4.8; 1: s3.9; 2: s2.10 3:s1.11, matrix right shift for cm0
//Bit 29            reserved
//Bit 28:16        reg_cm1_offset_oup_2      // signed ,    RW, default = 0  output data offset2 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_offset_oup_1      // signed ,    RW, default = 0  output data offset1 for cm1
#define ISP_CCM_MTX_00_01                          ((0x1126  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_0_1     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_0_0     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_02_03                          ((0x1127  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_0_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_0_2     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_10_11                          ((0x1128  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_1_1     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_1_0     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_12_13                          ((0x1129  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_1_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_1_2     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_20_21                          ((0x112a  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_2_1     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_2_0     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_22_23_RS                       ((0x112b  << 2) + 0xfe3b4000)
//Bit 31:30        reg_ccm_4x3mtrx_rs        // unsigned ,    RW, default = 0  0: s4.8 1: s3.9 2: s2.10, 3: s1.11, right shift for ccm normalization,
//Bit 29            reserved
//Bit 28:16        reg_ccm_4x3matrix_2_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_2_2     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_GAIN01                         ((0x112c  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_gain_1            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_gain_0            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
#define ISP_CCM_MTX_GAIN23                         ((0x112d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_gain_3            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_gain_2            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
#define ISP_CCM_MTX_OFST01                         ((0x112e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ccm_ofst_1            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
//Bit 15:12        reserved
//Bit 11: 0        reg_ccm_ofst_0            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
#define ISP_CCM_MTX_OFST23                         ((0x112f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ccm_ofst_3            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
//Bit 15:12        reserved
//Bit 11: 0        reg_ccm_ofst_2            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
#define ISP_PST_GAMMA_MODE                         ((0x1130  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_pst_gamma_mode        // unsigned ,    RW, default = 0  0: equidistance, 1: non-equidistance, mode for pst gamma lut
#define ISP_PST_GAMMA_STP                          ((0x1131  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pst_gamma_stp_7       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 27:24        reg_pst_gamma_stp_6       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 23:20        reg_pst_gamma_stp_5       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 19:16        reg_pst_gamma_stp_4       // unsigned ,    RW, default = 2  step for each segment of  pst gamma lut
//Bit 15:12        reg_pst_gamma_stp_3       // unsigned ,    RW, default = 2  step for each segment of  pst gamma lut
//Bit 11: 8        reg_pst_gamma_stp_2       // unsigned ,    RW, default = 1  step for each segment of  pst gamma lut
//Bit  7: 4        reg_pst_gamma_stp_1       // unsigned ,    RW, default = 0  step for each segment of  pst gamma lut
//Bit  3: 0        reg_pst_gamma_stp_0       // unsigned ,    RW, default = 0  step for each segment of  pst gamma lut
#define ISP_PST_GAMMA_NUM                          ((0x1132  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_pst_gamma_num_7       // unsigned ,    RW, default = 5  numbers for each segment of  pst gamma lut
//Bit 27            reserved
//Bit 26:24        reg_pst_gamma_num_6       // unsigned ,    RW, default = 4  numbers for each segment of  pst gamma lut
//Bit 23            reserved
//Bit 22:20        reg_pst_gamma_num_5       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 19            reserved
//Bit 18:16        reg_pst_gamma_num_4       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 15            reserved
//Bit 14:12        reg_pst_gamma_num_3       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 11            reserved
//Bit 10: 8        reg_pst_gamma_num_2       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit  7            reserved
//Bit  6: 4        reg_pst_gamma_num_1       // unsigned ,    RW, default = 4  numbers for each segment of  pst gamma lut
//Bit  3            reserved
//Bit  2: 0        reg_pst_gamma_num_0       // unsigned ,    RW, default = 5  numbers for each segment of  pst gamma lut
#define ISP_PST_GAMMA_LUT_ADDR                     ((0x1133  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_pst_gamma_lut_addr    // unsigned ,    RW, default = 0  gamma LUT address, max size is (129+1)/2*4=65*4
#define ISP_PST_GAMMA_LUT_DATA                     ((0x1134  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_pst_gamma_lut_data    // unsigned ,    RW, default = 0  gamma LUT data
#define ISP_CVR_RECT_EN                            ((0x1139  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_hlc_luma_trgt         // unsigned ,    RW, default = 40 hlc target luma value
//Bit 15:14        reserved
//Bit 13: 4        reg_hlc_luma_thd          // unsigned ,    RW, default = 992 hlc threshold
//Bit  3           reserved
//Bit  2           reg_hlc_en                // unsigned ,    RW, default = 0  enable high light cover
//Bit  1           reserved
//Bit  0           reg_cvr_rect_en           // unsigned ,    RW, default = 0  enable cover rectangles
#define ISP_CVR_RECT_HVSTART_0                     ((0x113a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_0     // unsigned ,    RW, default = 0  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_0     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_0                      ((0x113b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_0       // unsigned ,    RW, default = 180  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_0       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_0                         ((0x113c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_0      // unsigned ,    RW, default = 0  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_0      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_0      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_1                     ((0x113d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_1     // unsigned ,    RW, default = 200  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_1     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_1                      ((0x113e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_1       // unsigned ,    RW, default = 380  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_1       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_1                         ((0x113f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_1      // unsigned ,    RW, default = 36  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_1      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_1      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_2                     ((0x1140  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_2     // unsigned ,    RW, default = 400  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_2     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_2                      ((0x1141  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_2       // unsigned ,    RW, default = 580  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_2       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_2                         ((0x1142  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_2      // unsigned ,    RW, default = 72  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_2      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_2      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_3                     ((0x1143  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_3     // unsigned ,    RW, default = 600  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_3     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_3                      ((0x1144  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_3       // unsigned ,    RW, default = 780  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_3       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_3                         ((0x1145  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_3      // unsigned ,    RW, default = 108  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_3      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_3      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_4                     ((0x1146  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_4     // unsigned ,    RW, default = 800  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_4     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_4                      ((0x1147  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_4       // unsigned ,    RW, default = 980  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_4       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_4                         ((0x1148  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_4      // unsigned ,    RW, default = 144  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_4      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_4      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_5                     ((0x1149  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_5     // unsigned ,    RW, default = 1000  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_5     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_5                      ((0x114a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_5       // unsigned ,    RW, default = 1180  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_5       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_5                         ((0x114b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_5      // unsigned ,    RW, default = 180  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_5      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_5      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_6                     ((0x114c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_6     // unsigned ,    RW, default = 1200  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_6     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_6                      ((0x114d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_6       // unsigned ,    RW, default = 1380  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_6       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_6                         ((0x114e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_6      // unsigned ,    RW, default = 216  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_6      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_6      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_7                     ((0x114f  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hstart_7     // unsigned ,    RW, default = 1400  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_7     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_7                      ((0x1150  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cvr_rect_hend_7       // unsigned ,    RW, default = 1580  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_7       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_7                         ((0x1151  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_7      // unsigned ,    RW, default = 255  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_7      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_7      // unsigned ,    RW, default = 128  V values of cover rectangles
//cm2 from 0x52-0xbf
//
// Reading file:  ./isp_inc/inc_sw/isp_post_cm2_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CM2_ADDR_PORT                          ((0x1152  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cm2_ram_addr          // unsigned ,    RW, default = 0
#define ISP_CM2_DATA_PORT                          ((0x1153  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cm2_ram_data          // unsigned ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_0                     ((0x1154  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_adj_satglbgain_via_y_3 // signed ,    RW, default = 0
//Bit 23:16        reg_cm2_adj_satglbgain_via_y_2 // signed ,    RW, default = 0
//Bit 15: 8        reg_cm2_adj_satglbgain_via_y_1 // signed ,    RW, default = 0
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_0 // signed ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_1                     ((0x1155  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_adj_satglbgain_via_y_7 // signed ,    RW, default = 0
//Bit 23:16        reg_cm2_adj_satglbgain_via_y_6 // signed ,    RW, default = 0
//Bit 15: 8        reg_cm2_adj_satglbgain_via_y_5 // signed ,    RW, default = 0
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_4 // signed ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_2                     ((0x1156  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_8 // signed ,    RW, default = 0
#define ISP_CM2_EN                                 ((0x1157  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28            reserved
//Bit 27           reg_cm2_filter_en         // unsigned ,    RW, default = 1  enable signal for CM2 filter
//Bit 26           reg_cm2_lum_adj_en        // unsigned ,    RW, default = 1  enable bit for CM2_Lum_adj
//Bit 25           reg_cm2_hue_adj_en        // unsigned ,    RW, default = 1  enable bit for CM2_Hue_adj
//Bit 24           reg_cm2_sat_adj_en        // unsigned ,    RW, default = 1  Enable bit for CM2_Sat_adj
//Bit 23:12        reg_cm2_global_hue        // unsigned ,    RW, default = 0  global hue setting
//Bit 11: 0        reg_cm2_global_sat        // unsigned ,    RW, default = 512  global saturation setting normalized to 512
#define ISP_CM2_LUMA_MIN_MAX                       ((0x1158  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:25        reg_cm2_onlpf_mode        // unsigned ,    RW, default = 0
//Bit 24           reg_cm2_onlpf_interleave  // unsigned ,    RW, default = 0
//Bit 23:12        reg_cm2_luma_min          // unsigned ,    RW, default = 0  luma minimal
//Bit 11: 0        reg_cm2_luma_max          // unsigned ,    RW, default = 4095  luma max
#define ISP_CM2_CHRM_U_MIN_MAX                     ((0x1159  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_chrm_u_min        // unsigned ,    RW, default = 0  chroma u minimal
//Bit 11: 0        reg_cm2_chrm_u_max        // unsigned ,    RW, default = 4095  chroma u maximum
#define ISP_CM2_CHRM_V_MIN_MAX                     ((0x115a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_chrm_v_min        // unsigned ,    RW, default = 0  chroma v minimal
//Bit 11: 0        reg_cm2_chrm_v_max        // unsigned ,    RW, default = 4095  chroma v maximum
#define ISP_CM2_ADJ_LUMA_VIA_HUE                   ((0x115b  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:20        reg_cm2_adj_luma_via_hue_lshift // unsigned ,    RW, default = 0  no shift.  1: (-256~254) 2:(-512~508)  3: (-1024~1016)
//Bit 19: 8        reg_cm2_adj_luma_via_hue_satth // unsigned ,    RW, default = 400
//Bit  7: 0        reg_cm2_adj_luma_via_hue_satk // unsigned ,    RW, default = 64  normalized with 16
#define ISP_CM2_ADJ_HUE_VIA_HUE                    ((0x115c  << 2) + 0xfe3b4000)
//Bit 31:20        reg_cm2_adj_hue_via_hue_satth // unsigned ,    RW, default = 100
//Bit 19:12        reg_cm2_adj_hue_via_hue_satk // unsigned ,    RW, default = 64  u4.4 normalized with 16
//Bit 11: 0        reg_cm2_adj_sat_via_hue_satth // unsigned ,    RW, default = 20
#define ISP_CM2_BEFORE_UV_OFFSET                   ((0x115d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_adj_sat_via_hue_satk // unsigned ,    RW, default = 16
//Bit 23:12        reg_cm2_before_u_offset   // signed ,    RW, default = 0
//Bit 11: 0        reg_cm2_before_v_offset   // signed ,    RW, default = 0
#define ISP_CM2_AFTER_UV_OFFSET                    ((0x115e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_after_u_offset    // signed ,    RW, default = 0
//Bit 11: 0        reg_cm2_after_v_offset    // signed ,    RW, default = 0
#define ISP_CM2_HUE_ADJ_MISC                       ((0x115f  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16: 5        reg_cm2_before_hue_offset // unsigned ,    RW, default = 0  0~4095
//Bit  4           reg_cm2_hue_div_mode      // unsigned ,    RW, default = 0  32 pieces 360/32 degrees each slice; 1: first 20 slices 360/64 degrees, others 360/16 degrees
//Bit  3: 1        reg_cm2_adj_hue_via_hs_mode // unsigned ,    RW, default = 0  0: 1024/2048/3072, 4095; 1: 512, 1024, 1536, 2048; 2: 256, 512, 768, 1024; 3: 128, 256, 384, 512; 4: 512/1024/2048/4096; 5: 256/512/1024/2048; 6: 128/256/512/1024; 7: 128/256/512/1024
//Bit  0           reg_cm2_hue_protect_en    // unsigned ,    RW, default = 1  Hue protection if Saturation is out of UV range.
#define ISP_CM2_ADJ_SAT_VIA_HS                     ((0x1160  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:19        reg_cm2_adj_sat_via_hs_satth0 // unsigned ,    RW, default = 400  threshold on Sat
//Bit 18: 7        reg_cm2_adj_sat_via_hs_satth1 // unsigned ,    RW, default = 800
//Bit  6: 5        reg_cm2_adj_sat_via_hs_rshift // unsigned ,    RW, default = 0  0: (0,2)  1: (0.5, 1.5)
//Bit  4: 3        reg_cm2_adj_satgain_via_y_rshift // unsigned ,    RW, default = 0  0: (0,2)  1: (0.5, 1.5)
//Bit  2: 0        reg_cm2_adj_hue_via_hsv_lshift // unsigned ,    RW, default = 4  0: (-128,127)  1: (-256, 254)
#define ISP_CM2_LUMA_BC                            ((0x1161  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24:12        reg_cm2_luma_brightness   // signed ,    RW, default = 0  brightness of the image
//Bit 11: 0        reg_cm2_luma_contrast     // unsigned ,    RW, default = 1024  contrast of the luma, normalized to 1024 as 1.0
#define ISP_CM2_LUMA_BL                            ((0x1162  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_cm2_luma_blacklevel   // unsigned ,    RW, default = 256  black level of the luma during contrast adjustments
#define ISP_CM2_DEMO_ROI_START                     ((0x1163  << 2) + 0xfe3b4000)
//Bit 31:28        reg_cm2_demo_coi_rplmode  // unsigned ,    RW, default = 0  bits[1:0] for COI, bits[3:2] for other pixels than COI;  bit[1:0]: 0 - no replacement for COI   1: disable CM2 Enhance for COI; 2 - Keep COI pixelsY, but replace [*HS];  3: ow COI pixels to [*YHS]; bit[3:2]: similar control to pixels other than COI
//Bit 27:14        reg_cm2_demo_roi_xstart   // unsigned ,    RW, default = 0  start col index of the Region of Interest (ROI)
//Bit 13: 0        reg_cm2_demo_roi_ystart   // unsigned ,    RW, default = 0  col index of the Region of Interest (ROI)
#define ISP_CM2_DEMO_ROI_END                       ((0x1164  << 2) + 0xfe3b4000)
//Bit 31:18        reg_cm2_demo_roi_xend     // unsigned ,    RW, default = 0  ending row index of the Region of Interest (ROI)
//Bit 17: 4        reg_cm2_demo_roi_yend     // unsigned ,    RW, default = 0  ending row index of the Region of Interest (ROI)
//Bit  3: 0        reg_cm2_demo_roi_cm2mode  // unsigned ,    RW, default = 0  control ROI, bit[3:2] control other than ROI
#define ISP_CM2_DEMO_POI                           ((0x1165  << 2) + 0xfe3b4000)
//Bit 31:18        reg_cm2_demo_poi_x        // unsigned ,    RW, default = 0  col index of the Pixel(position) of Interest (POI)
//Bit 17: 4        reg_cm2_demo_poi_y        // unsigned ,    RW, default = 0  row index of the Pixel(position) of Interest (POI)
//Bit  3: 0        reg_cm2_demo_poi_rplmode  // unsigned ,    RW, default = 0  pixel replace mode pixel(position) of Interest, 0 no replacements ;1 one pixle replace to [*YHS]; 2 3X3 pixels replace to [*YHS]; 3 5X5 pixels replace to [*YHS]
#define ISP_CM2_DEMO_OWR                           ((0x1166  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_demo_owr_y        // unsigned ,    RW, default = 200  luma value overwrite ROI/POI/COI
//Bit 23:12        reg_cm2_demo_owr_h        // unsigned ,    RW, default = 1000  hue value overwrite ROI/POI/COI
//Bit 11: 0        reg_cm2_demo_owr_s        // unsigned ,    RW, default = 2547  sat value overwrite ROI/POI/COI
#define ISP_CM2_DEMO_COI_START                     ((0x1167  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_demo_coi_ystart   // unsigned ,    RW, default = 10  start of Luma value for Color of Interest (COI)
//Bit 23:12        reg_cm2_demo_coi_hstart   // unsigned ,    RW, default = 1748  start of Hue value for Color of Interest (COI)
//Bit 11: 0        reg_cm2_demo_coi_sstart   // unsigned ,    RW, default = 10  start of Sat value for Color of Interest (COI)
#define ISP_CM2_DEMO_COI_END                       ((0x1168  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_demo_coi_yend     // unsigned ,    RW, default = 220  ending of Luma value for Color of Interest (COI)
//Bit 23:12        reg_cm2_demo_coi_send     // unsigned ,    RW, default = 3000  ending of Sat value for Color of Interest (COI)
//Bit 11: 0        reg_cm2_demo_coi_hend     // unsigned ,    RW, default = 3000  ending of Hue value for Color of Interest (COI)
#define ISP_CM2_DEMO_SPLIT_CTR                     ((0x1169  << 2) + 0xfe3b4000)
//Bit 31:19        reserved
//Bit 18:17        reg_cm2_demo_split_mode   // unsigned ,    RW, default = 0
//Bit 16: 4        reg_cm2_demo_split_post   // unsigned ,    RW, default = 0
//Bit  3: 0        reg_cm2_demo_split_width  // unsigned ,    RW, default = 0
#define ISP_CM2_DEMO_SPLIT_CHN                     ((0x116a  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_demo_split_Y      // unsigned ,    RW, default = 0  luma value  for the split line
//Bit 23:12        reg_cm2_demo_split_H      // unsigned ,    RW, default = 0  hue value for the split line
//Bit 11: 0        reg_cm2_demo_split_S      // unsigned ,    RW, default = 0  sat value for the split line
#define ISP_CM2_STA_WIN_01                         ((0x116b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_cm2_sta_stable_en     // unsigned ,    RW, default = 1  enable bits for statistics function 0: no sta, 1: sta enable within window, 2, sta enable outside window
//Bit 27:14        reg_cm2_sta_win_xxyy_0    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
//Bit 13: 0        reg_cm2_sta_win_xxyy_1    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
#define ISP_CM2_STA_WIN_23                         ((0x116c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:14        reg_cm2_sta_win_xxyy_2    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
//Bit 13: 0        reg_cm2_sta_win_xxyy_3    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
#define ISP_CM2_STA_SAT_HIST_MODE                  ((0x116d  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24:22        reg_cm2_sta_sat_hist_mode // unsigned ,    RW, default = 0  mode of saturation histogram: 0/3/7, 1 hue-range, sat_hist as 32bin*1range; 1: 2 hue-range, sat_hist as 16bins*2ranges; 2: 4 hue-range, sat_hist as 8bins*4ranges;4:  2 luma-range, sat_hist as 16bins*2ranges;  5:  4 luma-ranges, sat_hist as 8bins*4ranges;6: 2 hue-ranges, 2 luma_ranges, sat_hist as 8bins*4ranges
//Bit 21:16        reg_cm2_sta_sat_hist_scale // unsigned ,    RW, default = 29  norm to 16 as 1.0
//Bit 15: 8        reg_cm2_sta_sat_hist_rang_thrd_0 // unsigned ,    RW, default = 0  for hue range nodes for histogram statistics of saturations. 256 as 1.0
//Bit  7: 0        reg_cm2_sta_sat_hist_rang_thrd_1 // unsigned ,    RW, default = 64
#define ISP_CM2_STA_SAT_HIST_RANG_HTRD             ((0x116e  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cm2_sta_sat_hist_rang_thrd_2 // unsigned ,    RW, default = 128
//Bit 23:16        reg_cm2_sta_sat_hist_rang_thrd_3 // unsigned ,    RW, default = 192
//Bit 15: 8        reg_cm2_sta_sat_hist_rang_thrd_4 // unsigned ,    RW, default = 255
//Bit  7: 0        reg_cm2_sta_sat_hist_rang_thrd_5 // unsigned ,    RW, default = 255
#define ISP_CM2_STA_MISC                           ((0x116f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cm2_sta_hue_hist_sat_thrd // unsigned ,    RW, default = 32  hue_hist statistics only on pixels saturation>= thrd. 1024 as 1.0, default= 10
//Bit 15: 8        reg_cm2_sta_blk_thrd      // unsigned ,    RW, default = 1  threshold to luma_u8 to count number of black pixels luma_u8<thrd);
//Bit  7: 0        reg_cm2_sta_brt_thrd      // unsigned ,    RW, default = 254  threshold to luma_u8 to count number of bright pixels luma_u8>thrd);
#define FRAME_SIZE_REG                             ((0x1170  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_frm_height            // unsigned ,    RW, default = 0
//Bit 15:13        reserved
//Bit 12: 0        reg_frm_width             // unsigned ,    RW, default = 0
#define RO_FRAME_REG                               ((0x1171  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_cm_ro_frame           // unsigned ,    RW, default = 0
#define ISP_RO_CM2_HUE_HIST_0                      ((0x1172  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_0     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_0                      ((0x1173  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_0     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_1                      ((0x1174  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_1     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_1                      ((0x1175  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_1     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_2                      ((0x1176  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_2     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_2                      ((0x1177  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_2     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_3                      ((0x1178  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_3     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_3                      ((0x1179  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_3     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_4                      ((0x117a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_4     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_4                      ((0x117b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_4     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_5                      ((0x117c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_5     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_5                      ((0x117d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_5     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_6                      ((0x117e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_6     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_6                      ((0x117f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_6     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_7                      ((0x1180  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_7     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_7                      ((0x1181  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_7     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_8                      ((0x1182  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_8     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_8                      ((0x1183  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_8     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_9                      ((0x1184  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_9     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_9                      ((0x1185  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_9     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_10                     ((0x1186  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_10    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_10                     ((0x1187  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_10    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_11                     ((0x1188  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_11    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_11                     ((0x1189  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_11    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_12                     ((0x118a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_12    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_12                     ((0x118b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_12    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_13                     ((0x118c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_13    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_13                     ((0x118d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_13    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_14                     ((0x118e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_14    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_14                     ((0x118f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_14    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_15                     ((0x1190  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_15    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_15                     ((0x1191  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_15    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_16                     ((0x1192  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_16    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_16                     ((0x1193  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_16    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_17                     ((0x1194  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_17    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_17                     ((0x1195  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_17    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_18                     ((0x1196  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_18    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_18                     ((0x1197  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_18    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_19                     ((0x1198  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_19    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_19                     ((0x1199  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_19    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_20                     ((0x119a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_20    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_20                     ((0x119b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_20    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_21                     ((0x119c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_21    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_21                     ((0x119d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_21    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_22                     ((0x119e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_22    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_22                     ((0x119f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_22    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_23                     ((0x11a0  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_23    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_23                     ((0x11a1  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_23    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_24                     ((0x11a2  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_24    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_24                     ((0x11a3  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_24    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_25                     ((0x11a4  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_25    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_25                     ((0x11a5  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_25    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_26                     ((0x11a6  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_26    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_26                     ((0x11a7  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_26    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_27                     ((0x11a8  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_27    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_27                     ((0x11a9  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_27    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_28                     ((0x11aa  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_28    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_28                     ((0x11ab  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_28    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_29                     ((0x11ac  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_29    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_29                     ((0x11ad  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_29    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_30                     ((0x11ae  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_30    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_30                     ((0x11af  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_30    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_31                     ((0x11b0  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_31    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_31                     ((0x11b1  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_31    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_BLK_BIN                         ((0x11b2  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_blk_bin            // unsigned ,    RO, default = 0  number of pixels withi luma< sta_blk_thrd.
#define ISP_RO_CM2_BRT_BIN                         ((0x11b3  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_brt_bin            // unsigned ,    RO, default = 0  number of pixels withi luma> sta_brt_thrd.
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_cm2_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_post_stat_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LC_STA_CTRL                            ((0x11c0  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8           reg_lcstahist_lpf         // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
//Bit  7: 5        reserved
//Bit  4           reg_lc_sta_mode_blk       // unsigned ,    RW, default = 1  regional LC hst sta on XX separately 20bits*16bins:  0: Y-only; 1: MAX(R,G,B),
//Bit  3: 2        reg_lcstahist_pix_drop_mode // unsigned ,    RW, default = 0
//Bit  1           reg_lcsta_inputrgb_glb    // unsigned ,    RW, default = 1  LC glb statistic input 3 components is RGB or YUV:  0: YUV; 1:RGB
//Bit  0           reg_lcsta_inputrgb        // unsigned ,    RW, default = 1  LC blk statistic input 3 components is RGB or YUV:  0: YUV; 1:RGB
#define ISP_PST_DNLP_STA_CTRL                      ((0x11c1  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_pst_sta_sel           // unsigned ,    RW, default = 0  0: global hst sta after lut3d, 1: global hst sta after sharpness, 2: global hst sta after dmsc
//Bit 27:25        reserved
//Bit 24           reg_pst_sta_mode          // unsigned ,    RW, default = 0  LC global hst sta on 256bins:  0: Y-only; 1: MAX(R,G,B),
//Bit 23:17        reserved
//Bit 16           reg_pst_sta_hst_lpf       // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
//Bit 15:10        reserved
//Bit  9: 8        reg_dnlp_sta_sel          // unsigned ,    RW, default = 0  DNLP global hst sta source data sel reg, 0: post_proc NR Y_input; 1: post_proc NR_ouput; 2: post_proc Gaussian Y_output; 3 MAX_RGB of CCM output;
//Bit  7: 5        reserved
//Bit  4           reg_dnlp_sta_mode         // unsigned ,    RW, default = 0  DNLP global hst sta on 64bins:  0: Y-only; 1: MAX(R,G,B),
//Bit  3: 1        reserved
//Bit  0           reg_dnlp_sta_hst_lpf      // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
#define ISP_PST_GLBWIN_H                           ((0x11c2  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pst_glbwin_hend       // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_pst_glbwin_hstart     // unsigned ,    RW, default = 0
#define ISP_PST_GLBWIN_V                           ((0x11c3  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pst_glbwin_vend       // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_pst_glbwin_vstart     // unsigned ,    RW, default = 0
#define ISP_DNLP_GLBWIN_H                          ((0x11c4  << 2) + 0xfe3b4000)
//Bit 31:16        reg_dnlp_glbwin_hend      // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_dnlp_glbwin_hstart    // unsigned ,    RW, default = 0
#define ISP_DNLP_GLBWIN_V                          ((0x11c5  << 2) + 0xfe3b4000)
//Bit 31:16        reg_dnlp_glbwin_vend      // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_dnlp_glbwin_vstart    // unsigned ,    RW, default = 0
#define ISP_LC_STA_HV_NUM                          ((0x11c6  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lcsta_vnum            // unsigned ,    RW, default = 8  Maximum to BLKVMAX, should be same as reg_lc_blk_vnum
//Bit  7: 5        reserved
//Bit  4: 0        reg_lcsta_hnum            // unsigned ,    RW, default = 12  Maximum to BLKHMAX, should be same as reg_lc_blk_hnum
#define ISP_LC_STA_HIDX_0                          ((0x11c7  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_1          // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_0          // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LC_STA_HIDX_1                          ((0x11c8  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_3          // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_2          // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LC_STA_HIDX_2                          ((0x11c9  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_5          // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_4          // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LC_STA_HIDX_3                          ((0x11ca  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_7          // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_6          // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LC_STA_HIDX_4                          ((0x11cb  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_9          // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_8          // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LC_STA_HIDX_5                          ((0x11cc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_hidx_11         // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_10         // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LC_STA_HIDX_12                         ((0x11cd  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lcsta_hidx_12         // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LC_STA_VIDX_0                          ((0x11ce  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_vidx_1          // unsigned ,    RW, default = 270  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_0          // unsigned ,    RW, default = 0  block boundary y-index
#define ISP_LC_STA_VIDX_1                          ((0x11cf  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_vidx_3          // unsigned ,    RW, default = 810  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_2          // unsigned ,    RW, default = 540  block boundary y-index
#define ISP_LC_STA_VIDX_2                          ((0x11d0  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_vidx_5          // unsigned ,    RW, default = 1350  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_4          // unsigned ,    RW, default = 1080  block boundary y-index
#define ISP_LC_STA_VIDX_3                          ((0x11d1  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lcsta_vidx_7          // unsigned ,    RW, default = 1890  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_6          // unsigned ,    RW, default = 1620  block boundary y-index
#define ISP_LC_STA_VIDX_8                          ((0x11d2  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lcsta_vidx_8          // unsigned ,    RW, default = 2240  block boundary y-index
#define ISP_LC_STA_CSC_PREOFST_BLK                 ((0x11d3  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_preofst_0   // signed ,    RW, default = 0  pre-offset for luma, limit=1<<(bit_depth-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_preofst_1   // signed ,    RW, default = -512  pre-offset for chroma,       RGB2YUV=-512; / YUV2RGB=0;
#define ISP_LC_STA_CSC_PSTOFST_BLK                 ((0x11d4  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_pstofst_0   // signed ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_pstofst_1   // signed ,    RW, default = 512  rgb2yuv post-offset to yuv,  RGB2YUV=0;  / YUV2RGB=512;
#define ISP_LC_STA_CSC_CLIP_BLK                    ((0x11d5  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_lcsta_csc_clip_0      // unsigned ,    RW, default = 0  down clipping for rgb
//Bit 15:12        reserved
//Bit 11: 0        reg_lcsta_csc_clip_1      // unsigned ,    RW, default = 1023  down clipping for rgb
#define ISP_LC_STA_CSC_PREOFST_GLB                 ((0x11d6  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_preofst_glb_0 // signed ,    RW, default = 0  pre-offset for luma, limit=1<<(bit_depth-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_preofst_glb_1 // signed ,    RW, default = -512  pre-offset for chroma,       RGB2YUV=-512; / YUV2RGB=0;
#define ISP_LC_STA_CSC_PSTOFST_GLB                 ((0x11d7  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_pstofst_glb_0 // signed ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_pstofst_glb_1 // signed ,    RW, default = 512  rgb2yuv post-offset to yuv,  RGB2YUV=0;  / YUV2RGB=512;
#define ISP_LC_STA_CSC_CLIP_GLB                    ((0x11d8  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_lcsta_csc_clip_glb_0  // unsigned ,    RW, default = 0  down clipping for rgb
//Bit 15:12        reserved
//Bit 11: 0        reg_lcsta_csc_clip_glb_1  // unsigned ,    RW, default = 1023  down clipping for rgb
#define ISP_LC_STA_BLK_BRT_THRD                    ((0x11d9  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lcsta_blk_thrd        // unsigned ,    RW, default = 1  to luma_u8 to count number of black pixels luma_u8 <drk_thrd;
//Bit  7: 0        reg_lcsta_brt_thrd        // unsigned ,    RW, default = 254  to luma_u8 to count number of bright pixels luma_u8>brt_thrd;
#define ISP_RO_LC_STA_BLK_NUM                      ((0x11da  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_lcsta_blk_num          // unsigned ,    RO, default = 0  of pixels withi luma< sta_blk_thrd.
#define ISP_RO_LC_STA_BRT_NUM                      ((0x11db  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        ro_lcsta_brt_num          // unsigned ,    RO, default = 0  of pixels withi luma> sta_brt_thrd.
#define ISP_RO_PST_STA                             ((0x11dc  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        ro_min_val_glb            // unsigned ,    RO, default = 1023  post glb hst min val
//Bit 15:10        reserved
//Bit  9: 0        ro_max_val_glb            // unsigned ,    RO, default = 0  post glb hst max val
#define ISP_LC_SKIN_HUE_SAT_CTRL                   ((0x11dd  << 2) + 0xfe3b4000)
//Bit 31:24        reg_skin_sat_max          // unsigned ,    RW, default = 48  saturation max for skin color matching, dft =255
//Bit 23:16        reg_skin_sat_min          // unsigned ,    RW, default = 2  saturation min for skin color matching, dft =5,
//Bit 15: 8        reserved
//Bit  7: 4        reg_skin_hue_ed           // unsigned ,    RW, default = 5  hue end  of skin, dft =6
//Bit  3: 0        reg_skin_hue_st           // unsigned ,    RW, default = 4  hue start of skin, dft =5
#define ISP_LC_SKIN_LUMA_CTRL                      ((0x11de  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_skin_luma_max         // unsigned ,    RW, default = 120  luma max for skin color matching, dft =180
//Bit  7: 0        reg_skin_luma_min         // unsigned ,    RW, default = 60  luma min for skin color matching, dft =40
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_stat_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_post_sta_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
//Bit 31:18        reserved
//Bit 17           lc_start_read_region      // unsigned ,    RW, default = 0  signal to start reading region data
//Bit 16           lc_auto_clr_rd_idx        // unsigned ,    RW, default = 0  hist index read clear
//Bit 15:14        lc_rd_idx_auto_inc_mode   // unsigned ,    RW, default = 0  mode of reading hist data, 0: no inc 1: inc by block 2:inc by bin 3: no inc
//Bit 13: 9        lc_rd_sub_index           // unsigned ,    RW, default = 0  hist bin index
//Bit  8: 7        reserved
//Bit  6: 0        lc_rd_index               // unsigned ,    RW, default = 0  hist block index
//Bit 31:31        lc_rd_vld                 // unsigned ,    RO, default = 0  hist read valid signal
//Bit 30: 0        lc_region_out             // unsigned ,    RO, default = 0  hist read data
#define ISP_LC_HIST_BLK_MISC                       ((0x11f6  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 6        lc_sta_blk_enable         // unsigned ,    RW, default = 0  blk stat enalbe
//Bit  5: 0        clk_gating                // unsigned ,    RW, default = 0  clock gating
#define ISP_POST_STA_GLB_MISC                      ((0x11f7  << 2) + 0xfe3b4000)
//Bit 31:30        ro_status                 // unsigned ,    RO, default = 0  bit0:1:ram init done 0:ram not init done bit1:1:data in when ram init 0:normal
//Bit 29:16        reserved
//Bit 15: 8        reg_pst_sta_rd_paddr      // unsigned ,    RW, default = 0  apb read address
//Bit  7: 5        reserved
//Bit  4           reg_pst_sta_err_clr       // unsigned ,    RW, default = 0  ram state error clear
//Bit  3           reg_pst_sta_auto_inc      // unsigned ,    RW, default = 0  1:addr auto increase 0:addr not increase
//Bit  2           reg_pst_sta_clr_ram       // unsigned ,    WO, default = 0  glb ram clear zero, pulse
//Bit  1           reg_pst_sta_auto_clr      // unsigned ,    RW, default = 0  1:clear hist data automatically 0:clear hist data manually
//Bit  0           reg_pst_sta_enable        // unsigned ,    RW, default = 0  global stat enable
#define ISP_POST_STA_GLB_RD                        ((0x11f8  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:0         post_sta_glb_hist_out     // unsigned ,    RO, default = 0  hist read data
#define ISP_POST_STA_BLK_DMA_CNT                   ((0x11f9  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15           reg_clr_errcnt1           // unsigned ,    WO, default = 0  errcnt1 clear signal, pulse
//Bit 14:8         ro_error_cnt1             // unsigned ,    RO, default = 0  errcnt1, the block num which is not received by dma
//Bit 7            reg_clr_errcnt0           // unsigned ,    WO, default = 0  errcnt0 clear signal, pulse
//Bit 6:0          ro_error_cnt0             // unsigned ,    RO, default = 0  errcnt0, the block num which 4 pipe does not finish before next de comes
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_sta_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg0_top_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB2_APB_BASE = 0x12
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg1_peak_cnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_POST_PK_GCLK_CTRL                      ((0x1200  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_pk_gclk_ctrl0         // unsigned ,    RW, default = 0
#define ISP_POST_PK_MISC                           ((0x1201  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_hblank             // unsigned ,    RW, default = 8
//Bit 23: 0        reg_pk_gclk_ctrl1         // unsigned ,    RW, default = 0
#define ISP_POST_PK_SYNC_CTRL                      ((0x1202  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_pk_sync_ctrl          // unsigned ,    RW, default = 0
#define ISP_POST_DPS_CTL                           ((0x1204  << 2) + 0xfe3b4000)
//Bit 31           reg_pk_luma_ir_mux        // unsigned ,    RW, default = 0  0: luma, 1: ir, luma or ir mux for sharpness
//Bit 30: 8        reserved
//Bit  7           reg_dps_nrssd_en          // unsigned ,    RW, default = 0  enable of power saving for nr ssd calculation module; default=0
//Bit  6           reg_dps_nryflt_en         // unsigned ,    RW, default = 0  enable of power saving for nr Luma filter module; default=0
//Bit  5           reg_dps_nrcflt_en         // unsigned ,    RW, default = 0  enable of power saving for nr Chroma filter module; default=0
//Bit  4           reg_dps_nrbld_en          // unsigned ,    RW, default = 0  enable of power saving for nr Luma/chroma blender module; default=0
//Bit  3           reg_dps_hvcon_en          // unsigned ,    RW, default = 0  enable of power saving for peaking hvcon bank calculation module; default=0
//Bit  2           reg_dps_drtlpfpk_en       // unsigned ,    RW, default = 0  enable of power saving for peaking  module; default=0
//Bit  1           reg_dps_pktibld_en        // unsigned ,    RW, default = 0  enable of power saving for peaking lti  blender module; default=0
//Bit  0           reg_dps_osctr_en          // unsigned ,    RW, default = 0  enable of power saving for os_control module; default=0
#define ISP_POST_NRY_GAU_FILTER                    ((0x1205  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:22        reg_nry_gau_horz          // unsigned ,    RW, default = 1  gaussian filter mode for luma. 0: [1 2 1]/4; 1: [1 2 2 2 1]/8,  2/3: [1 2 3 4 3 2 1]/16
//Bit 21:20        reg_nry_gau_vert          // unsigned ,    RW, default = 1  gaussian filter mode for luma. 0: [1 2 1]/4; 1/up: [1 2 2 2 1]/8,
//Bit 19:16        reg_nry_gau_xrs4          // unsigned ,    RW, default = 15  x/16 is the percentage of gau blending org luma, 0: 100% ori; 15: 100% gau;  defaul= 0
//Bit 15: 8        reserved
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_strength          // unsigned ,    RW, default = 63  strength of the luma noise filter, 63: 100% NR, 0: no NR
#define ISP_POST_NRY_SIGMA_LUT                     ((0x1206  << 2) + 0xfe3b4000)
//Bit 31:24        reg_nry_sigma_lut_4       // unsigned ,    RW, default = 35  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 23:16        reg_nry_sigma_lut_3       // unsigned ,    RW, default = 28  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 15: 8        reg_nry_sigma_lut_2       // unsigned ,    RW, default = 25  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit  7: 0        reg_nry_sigma_lut_1       // unsigned ,    RW, default = 20  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
#define ISP_POST_NRY_SIGMA_BURST                   ((0x1207  << 2) + 0xfe3b4000)
//Bit 31:24        reg_nry_sigma_lut_0       // unsigned ,    RW, default = 15  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 23:20        reg_nry_sigma_rate        // unsigned ,    RW, default = 4  sigma=  Max(k*|max-min|, ofst_luma) for adaptive sigma, the larger of this rate, the more LPF.
//Bit 19: 8        reserved
//Bit  7: 4        reg_nry_burst_num         // unsigned ,    RW, default = 0  number of homo pixels in SGM threshold for burst noise detection,  the larger of this threshold, the easier burst detected, default=3;
//Bit  3: 0        reg_nry_burst_rate        // unsigned ,    RW, default = 4  burst detection thresold delta= range*rate/16, the large this rate, the difficult to detect as burst, default=4;
#define ISP_POST_NRY_ALPHA_MAX_LUT                 ((0x1208  << 2) + 0xfe3b4000)
//Bit 31:28        reg_nry_alpha0_maxerr_lut_7 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 27:24        reg_nry_alpha0_maxerr_lut_6 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 23:20        reg_nry_alpha0_maxerr_lut_5 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 19:16        reg_nry_alpha0_maxerr_lut_4 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 15:12        reg_nry_alpha0_maxerr_lut_3 // unsigned ,    RW, default = 14  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 11: 8        reg_nry_alpha0_maxerr_lut_2 // unsigned ,    RW, default = 12  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit  7: 4        reg_nry_alpha0_maxerr_lut_1 // unsigned ,    RW, default = 3  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit  3: 0        reg_nry_alpha0_maxerr_lut_0 // unsigned ,    RW, default = 0  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
#define ISP_POST_NRC_GAU_FILTER                    ((0x1209  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:22        reg_nrc_gau_horz          // unsigned ,    RW, default = 0  gaussian filter mode for chroma. 0: [1 2 1]/4; 1: [1 2 2 2 1]/8,  2/3: [1 2 3 4 3 2 1]/16
//Bit 21:20        reg_nrc_gau_vert          // unsigned ,    RW, default = 0  gaussian filter mode for chroma. 0: [1 2 1]/4; 1/up: [1 2 2 2 1]/8,
//Bit 19:16        reg_nrc_gau_xrs4          // unsigned ,    RW, default = 15  x/16 is the percentage of gau blending org chroma, 0: 100% ori; 15: 100% gau;  defaul= 0
//Bit 15: 6        reserved
//Bit  5: 0        reg_nrc_strength          // unsigned ,    RW, default = 63  strength of the chroma noise filter, 63: 100% NR, 0: no NR
#define ISP_POST_PK_SAD_GAIN                       ((0x120d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_sad_hor_gain       // unsigned ,    RW, default = 16  gain to sad[0], 16 normalized to "1";
//Bit 15: 8        reg_pk_sad_ver_gain       // unsigned ,    RW, default = 16  gain to sad[4], 16 normalized to "1";
//Bit  7: 0        reg_pk_sad_diag_gain      // unsigned ,    RW, default = 16  gain to sad[2] and sad[6], 16 normalized to "1";
#define ISP_POST_PK_SAD_RATE                       ((0x120e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_sadla_dis_rate     // unsigned ,    RW, default = 63  low angle and high angle error should not be no less than nearby_error*rate/64; default = 24; 0 same as before changes
//Bit 23:22        reserved
//Bit 21:16        reg_pk_sad_core_rate      // unsigned ,    RW, default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
//Bit 15           reg_pk_sad_intlev_mode    // unsigned ,    RW, default = 1  interleave detection xerr mode: 0 max; 1:sum ;
//Bit 14           reg_pk_sad_intlev_mod1    // unsigned ,    RW, default = 1  mode 1 of using diagonal protection: 0: no digonal protection; 1: with diagonal protection
//Bit 13: 8        reg_pk_sad_intlev_gain    // unsigned ,    RW, default = 12  interleave detection for sad gain applied, normalized to 8 as 1
//Bit  7: 0        reg_pk_drtdif_min2sad_th  // unsigned ,    RW, default = 16  for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;
#define ISP_POST_PK_CIR_HP_GAIN                    ((0x120f  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_cir_hp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 23:16        reg_pk_cir_hp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_hp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_hp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_HP_GAIN_1                  ((0x1210  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cir_hp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_hp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_hp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_BP_GAIN                    ((0x1211  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_cir_bp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit 23:16        reg_pk_cir_bp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).
//Bit 15: 8        reg_pk_cir_bp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_bp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_BP_GAIN_1                  ((0x1212  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cir_bp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_bp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_bp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_DRT_HP_GAIN                    ((0x1213  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_drt_hp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit 23:16        reg_pk_drt_hp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_hp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_hp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_HP_GAIN_1                  ((0x1214  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_drt_hp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).
//Bit 15: 8        reg_pk_drt_hp_con2gain_3  // unsigned ,    RW, default = 61  level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_hp_con2gain_4  // unsigned ,    RW, default = 61  level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_BP_GAIN                    ((0x1215  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_drt_bp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 23:16        reg_pk_drt_bp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_bp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_bp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_BP_GAIN_1                  ((0x1216  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_drt_bp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_bp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_bp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
#define ISP_POST_PK_CIR_FILT_GAIN                  ((0x1217  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_pk_circ_bpf_2dgain    // unsigned ,    RW, default = 64  gain to 2d circle bandpass filter results, normalized to 64 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2dgain    // unsigned ,    RW, default = 64  gain to 2d circle bandpass filter results, normalized to 64 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_0             ((0x1218  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_0_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_0_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_0_1 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_0_0 // signed ,    RW, default = 40  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_1             ((0x1219  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_1_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_1_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_1_1 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_1_0 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_2             ((0x121a  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_2_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_2_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_2_1 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_2_0 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_0               ((0x121b  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_0_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_0_2 // signed ,    RW, default = -2  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_0_1 // signed ,    RW, default = -10  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_0_0 // signed ,    RW, default = 64  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_1               ((0x121c  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_1_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_1_2 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_1_1 // signed ,    RW, default = -4  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_1_0 // signed ,    RW, default = -10  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_2               ((0x121d  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_2_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_2_2 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_2_1 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_2_0 // signed ,    RW, default = -2  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_GAIN                  ((0x121e  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_bpf_hzgain         // unsigned ,    RW, default = 64  gain to long horizontal BPF for peaking, normalized to 64 as 1.0
//Bit 23:16        reg_pk_bpf_vdgain         // unsigned ,    RW, default = 64  gain to long vertical and diagonal BPF for peaking, normalized to 64 as 1.0
//Bit 15: 8        reg_pk_hpf_hzgain         // unsigned ,    RW, default = 64  gain to long horizontal HPF for peaking, normalized to 64 as 1.0
//Bit  7: 0        reg_pk_hpf_vdgain         // unsigned ,    RW, default = 64  gain to long vertical and diagonal HPF for peaking, normalized to 64 as 1.0
#define ISP_POST_PK_DRT_FILT_BP_LUT                ((0x121f  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_bpf_hztap09_3      // signed ,    RW, default = 0  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_bpf_hztap09_2      // signed ,    RW, default = -32  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_bpf_hztap09_1      // signed ,    RW, default = 4  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_bpf_hztap09_0      // signed ,    RW, default = 56  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_HP_LUT                ((0x1220  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_hpf_hztap09_3      // signed ,    RW, default = 0  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_hpf_hztap09_2      // signed ,    RW, default = -4  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_hpf_hztap09_1      // signed ,    RW, default = -28  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_hpf_hztap09_0      // signed ,    RW, default = 64  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_BP_LUT_1              ((0x1221  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_bpf_hztap09_4      // signed ,    RW, default = 0  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_bpf_vdtap05_2      // signed ,    RW, default = -32  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_bpf_vdtap05_1      // signed ,    RW, default = 4  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_bpf_vdtap05_0      // signed ,    RW, default = 56  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_HP_LUT_1              ((0x1222  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_hpf_hztap09_4      // signed ,    RW, default = 0  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_hpf_vdtap05_2      // signed ,    RW, default = -4  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_hpf_vdtap05_1      // signed ,    RW, default = -28  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_hpf_vdtap05_0      // signed ,    RW, default = 64  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_FILT_CORING                    ((0x1223  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_cir_hp_coring      // unsigned ,    RW, default = 2  coring of HP for circle filter, is in u10 scale
//Bit 23:22        reserved
//Bit 21:16        reg_pk_cir_bp_coring      // unsigned ,    RW, default = 2  coring of BP for circle filter, is in u10 scale
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_drt_hp_coring      // unsigned ,    RW, default = 2  coring of HP for directional filter, is in u10 scale
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_drt_bp_coring      // unsigned ,    RW, default = 2  coring of BP for directional filter, is in u10 scale
#define ISP_POST_PK_DRT_FILT_MODE                  ((0x1224  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_pk_bias_diag          // unsigned ,    RW, default = 0  bias towards diagonal (45/135) filter for low/high angle filters, default = 0;
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_drt_hp_elpf_mode   // unsigned ,    RW, default = 2  edge adaptive lpf mode for direction HP, larger mode means heavier lpf along edge. 0:no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_drt_bp_elpf_mode   // unsigned ,    RW, default = 2  edge adaptive lpf mode for direction BP, larger mode means heavier lpf along edge. 0:no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8
#define ISP_POST_PK_BLEND                          ((0x1225  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_drtbld_beta_3      // unsigned ,    RW, default = 0  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 27:24        reg_pk_drtbld_beta_2      // unsigned ,    RW, default = 4  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 23:20        reg_pk_drtbld_beta_1      // unsigned ,    RW, default = 8  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 19:16        reg_pk_drtbld_beta_0      // unsigned ,    RW, default = 15  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_min           // unsigned ,    RW, default = 0  normalized to 64 as '1'
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_max           // unsigned ,    RW, default = 63  normalized to 64 as '1'
#define ISP_POST_PK_BLEND_ALP_LUT_0                ((0x1226  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_alp2_lut2d_7       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_6       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_5       // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_4       // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_3       // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_2       // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_1       // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_0       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_1                ((0x1227  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_alp2_lut2d_15      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_14      // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_13      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_12      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_11      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_10      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_9       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_8       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_2                ((0x1228  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_alp2_lut2d_23      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_22      // unsigned ,    RW, default = 10  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_21      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_20      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_19      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_18      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_17      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_16      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_3                ((0x1229  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_alp2_lut2d_31      // unsigned ,    RW, default = 14  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_30      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_29      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_28      // unsigned ,    RW, default = 8  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_27      // unsigned ,    RW, default = 10  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_26      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_25      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_24      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 31           reg_pk_drtbld_beta_en     // unsigned ,    RW, default = 1  enable of direction ambiguity protection for drt and cir blend, beta for , 0, equivalent beta[i]=15, 1, enable
//Bit 30           reg_pk_alp2_maxerr_mode   // unsigned ,    RW, default = 1  0 max err; 1: xerr
//Bit 29:16        reserved
//Bit 15:12        reg_pk_alp2_lut2d_35      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_34      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_33      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_32      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_0            ((0x122b  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_elpf_lut2d_7       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_6       // unsigned ,    RW, default = 0
//Bit 23:20        reg_pk_elpf_lut2d_5       // unsigned ,    RW, default = 2
//Bit 19:16        reg_pk_elpf_lut2d_4       // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_3       // unsigned ,    RW, default = 4
//Bit 11: 8        reg_pk_elpf_lut2d_2       // unsigned ,    RW, default = 6
//Bit  7: 4        reg_pk_elpf_lut2d_1       // unsigned ,    RW, default = 12
//Bit  3: 0        reg_pk_elpf_lut2d_0       // unsigned ,    RW, default = 15
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_1            ((0x122c  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_elpf_lut2d_15      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_14      // unsigned ,    RW, default = 0
//Bit 23:20        reg_pk_elpf_lut2d_13      // unsigned ,    RW, default = 2
//Bit 19:16        reg_pk_elpf_lut2d_12      // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_11      // unsigned ,    RW, default = 4
//Bit 11: 8        reg_pk_elpf_lut2d_10      // unsigned ,    RW, default = 6
//Bit  7: 4        reg_pk_elpf_lut2d_9       // unsigned ,    RW, default = 15
//Bit  3: 0        reg_pk_elpf_lut2d_8       // unsigned ,    RW, default = 15
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_2            ((0x122d  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_elpf_lut2d_23      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_22      // unsigned ,    RW, default = 10
//Bit 23:20        reg_pk_elpf_lut2d_21      // unsigned ,    RW, default = 15
//Bit 19:16        reg_pk_elpf_lut2d_20      // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_19      // unsigned ,    RW, default = 2
//Bit 11: 8        reg_pk_elpf_lut2d_18      // unsigned ,    RW, default = 4
//Bit  7: 4        reg_pk_elpf_lut2d_17      // unsigned ,    RW, default = 6
//Bit  3: 0        reg_pk_elpf_lut2d_16      // unsigned ,    RW, default = 12
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_3            ((0x122e  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_elpf_lut2d_31      // unsigned ,    RW, default = 14  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_30      // unsigned ,    RW, default = 15
//Bit 23:20        reg_pk_elpf_lut2d_29      // unsigned ,    RW, default = 4
//Bit 19:16        reg_pk_elpf_lut2d_28      // unsigned ,    RW, default = 8
//Bit 15:12        reg_pk_elpf_lut2d_27      // unsigned ,    RW, default = 10
//Bit 11: 8        reg_pk_elpf_lut2d_26      // unsigned ,    RW, default = 15
//Bit  7: 4        reg_pk_elpf_lut2d_25      // unsigned ,    RW, default = 2
//Bit  3: 0        reg_pk_elpf_lut2d_24      // unsigned ,    RW, default = 4
//Bit 31:16        reserved
//Bit 15:12        reg_pk_elpf_lut2d_35      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_elpf_lut2d_34      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_elpf_lut2d_33      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_elpf_lut2d_32      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_FILT_BLEND                     ((0x1230  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_bpf_elpf_frcalp    // unsigned ,    RW, default = 0  force alpha of non-elpf result for bpf calculation, 0:use elpf_lut2d interpolated results, 1: 100% elpf; 63: 100% non-elpf; default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_pk_hpf_elpf_frcalp    // unsigned ,    RW, default = 0  force alpha of non-elpf result for bpf calculation, 0:use elpf_lut2d interpolated results, 1: 100% elpf; 63: 100% non-elpf; default = 0
//Bit 15:10        reserved
//Bit  9: 8        reg_pk_hpdrt_mode         // unsigned ,    RW, default = 3  mode for HPdrt filter: 0 legacy, use minsad direction filter out; 1: new blend between min and min2 corresponding filter results;2: only blend when dat_min and dat_min2 same sign; otherwise use max amp of two; 3: always use max amp of dat_min and dat_min; default 2
//Bit  7: 6        reserved
//Bit  5: 4        reg_pk_bpdrt_mode         // unsigned ,    RW, default = 3  mode for BPdrt filter: 0 legacy, use minsad direction filter out; 1: new blend between min and min2 corresponding filter results;2: only blend when dat_min and dat_min2 same sign; otherwise use max amp of two; 3: always use max amp of dat_min and dat_min; default 2
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_drtbld_range       // unsigned ,    RW, default = 3  range of the min2 and min direction distance: 0 no this condition, 1: distance = 1; 2: distance =1,2; 3: distance = 1,2,3; default =1
#define ISP_POST_PK_LUMA_GAIN_LUT                  ((0x1231  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pkgain_vsluma_lut_7   // unsigned ,    RW, default = 6  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 27:24        reg_pkgain_vsluma_lut_6   // unsigned ,    RW, default = 8  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 23:20        reg_pkgain_vsluma_lut_5   // unsigned ,    RW, default = 7  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 19:16        reg_pkgain_vsluma_lut_4   // unsigned ,    RW, default = 7  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 15:12        reg_pkgain_vsluma_lut_3   // unsigned ,    RW, default = 6  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 11: 8        reg_pkgain_vsluma_lut_2   // unsigned ,    RW, default = 5  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit  7: 4        reg_pkgain_vsluma_lut_1   // unsigned ,    RW, default = 4  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit  3: 0        reg_pkgain_vsluma_lut_0   // unsigned ,    RW, default = 3  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_LUMA_GAIN_LUT_1                ((0x1232  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_pkgain_vsluma_lut_8   // unsigned ,    RW, default = 5  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_LUMA_OSHT_LUT                  ((0x1233  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pkosht_vsluma_lut_7   // unsigned ,    RW, default = 5  peaking overshoot up/down vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 27:24        reg_pkosht_vsluma_lut_6   // unsigned ,    RW, default = 0
//Bit 23:20        reg_pkosht_vsluma_lut_5   // unsigned ,    RW, default = 1
//Bit 19:16        reg_pkosht_vsluma_lut_4   // unsigned ,    RW, default = 2
//Bit 15:12        reg_pkosht_vsluma_lut_3   // unsigned ,    RW, default = 3
//Bit 11: 8        reg_pkosht_vsluma_lut_2   // unsigned ,    RW, default = 3
//Bit  7: 4        reg_pkosht_vsluma_lut_1   // unsigned ,    RW, default = 3
//Bit  3: 0        reg_pkosht_vsluma_lut_0   // unsigned ,    RW, default = 2
#define ISP_POST_PK_LUMA_OSHT_LUT_1                ((0x1234  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_pkosht_vsluma_lut_8   // unsigned ,    RW, default = 0  peaking overshoot up/down vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_FINAL_GAIN                     ((0x1235  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:18        reserved
//Bit 17:16        reg_final_gain_rs         // signed ,    RW, default = 0  right shift bits for the gain normalization, 0 normal to 32 as 1; 1 normalize to 64 as 1; -2 normalized to 8 as 1; -1 normalize 16 as 1. default = 0,
//Bit 15: 8        reg_hp_final_gain         // unsigned ,    RW, default = 100  gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32
//Bit  7: 0        reg_bp_final_gain         // unsigned ,    RW, default = 100  gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32
#define ISP_POST_PK_OSHT                           ((0x1236  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:20        reg_pk_os_up              // unsigned ,    RW, default = 830  up margin for overshoot control in 10bits scale, set to 1023 means now OS control.
//Bit 19:18        reserved
//Bit 17: 8        reg_pk_os_down            // unsigned ,    RW, default = 830  dn margin for overshoot control in 10bits scale, set to 1023 means now OS control.
//Bit  7: 6        reserved
//Bit  5: 4        reg_pk_osh_winsize        // unsigned ,    RW, default = 2  (2x+1) is window size in H direction for overshoot control
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_osv_winsize        // unsigned ,    RW, default = 2  (2x+1) is window size in V direction for overshoot control
#define ISP_POST_PK_DEBUG                          ((0x1237  << 2) + 0xfe3b4000)
//Bit 31           reg_demo_hsvsharp_enable  // unsigned ,    RW, default = 0  enable for demo, 0: full screen sharpness enable: 1: only demo region with sharpness on; default=0
//Bit 30:28        reserved
//Bit 27:20        reg_pk_debug_edge         // unsigned ,    RW, default = 0  0 show color for edge
//Bit 19:18        reserved
//Bit 17:16        reg_demo_disp_position    // unsigned ,    RW, default = 2  demo screen split mode: 0: top region as demo; 1: bottom region as demo; 2: left region as demo; 3: right region as demo
//Bit 15: 0        reg_demo_left_top_screen_width // unsigned ,    RW, default = 360  demo mode x/y index for split;
#define ISP_POST_PK_DEBUG_DRT_FORCE                ((0x1238  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_pk_drt_force          // unsigned ,    RW, default = 24  direction of drt peaking filter: 0~7 hp drt force, 8~15: bp drt force; 16~23: bp+hp drt force; else no force; default=24 (do not change in application)
#define ISP_SDE_MODE                               ((0x1239  << 2) + 0xfe3b4000)
//Bit 31:30        reg_pksde_lp_sel          // unsigned ,    RW, default = 1
//Bit 29:11        reserved
//Bit 10: 8        reg_pksde_yuv_mode_0      // unsigned ,    RW, default = 0  Y sde mode for pk, 0: no SDE; 1: YUVrplc+ peaking; 2: YUVrplc - peaking; 3: YUVrplc+ peaking>0; 4: YUVrplc + peaking<0; 5: YUVrplc+ abs(peaking) 6: YUVrplc-abs(peaking); 7: binary
//Bit  7: 0        reserved
#define ISP_SDE_RPLC_PKGAIN                        ((0x123a  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_pksde_pkgain_0        // unsigned ,    RW, default = 8  sde pk Y gain, normalized 8 as "1"
//Bit 19:16        reserved
//Bit 15:12        reserved
//Bit 11: 9        reserved
//Bit  8           reg_pksde_rplc_en_0       // unsigned ,    RW, default = 0  enable replace Y by replace value
//Bit  7: 5        reserved
//Bit  4            reserved
//Bit  3: 1        reserved
//Bit  0            reserved
#define ISP_SDE_YUVRPLC01                          ((0x123b  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reserved
//Bit 15:12        reserved
//Bit 11: 0        reg_pksde_yuv_rplc_0      // unsigned ,    RW, default = 512  Y replace value
#define ISP_SDE_YUV_POS                            ((0x123d  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pksde_yuv_posi_0      // unsigned ,    RW, default = 192  x4 for Y positive value in binary effects
//Bit 15: 8        reserved
//Bit  7: 0        reserved
#define ISP_SDE_YUV_NEG                            ((0x123e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pksde_yuv_negative_0      // unsigned ,    RW, default = 64  x4 for Y negative value in binary effects
//Bit 15: 8        reserved
//Bit  7: 0        reserved
#define ISP_POST_DRT_EN_CTL                        ((0x123f  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19           reg_pk_flt_src_mux        // unsigned ,    RW, default = 1  0: pre filtered data, 1: drt lpf data, filtered source mux for pk,
//Bit 18           reg_dps_drtlpf_en         // unsigned ,    RW, default = 1  enable of power saving for directed low-pass module; default=0
//Bit 17           reg_drtlpf_line_num       // unsigned ,    RW, default = 1  line number used in drt lpf; 0: 3 lines, 1:5 lines
//Bit 16           reg_drtlpf_theta_min_idx_replace // unsigned ,    RW, default = 0  replace min_idx and min_san with min2_idx and min2_sad. default:1
//Bit 15            reserved
//Bit 14           reg_sr3_drtlpf_enable_0   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels; filter module; default=0
//Bit 13           reg_sr3_drtlpf_enable_1   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels;
//Bit 12           reg_sr3_drtlpf_enable_2   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels;
//Bit 11            reserved
//Bit 10           reg_sr3_drtlpf_theta_en_0 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection of power saving for nr Luma filter module; default=0
//Bit  9           reg_sr3_drtlpf_theta_en_1 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  8           reg_sr3_drtlpf_theta_en_2 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  7            reserved
//Bit  6           reg_sr7_drtlpf_beta_en_0  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  5           reg_sr7_drtlpf_beta_en_1  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  4           reg_sr7_drtlpf_beta_en_2  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  3            reserved
//Bit  2           reg_sr7_drtlpf_edge_en_0  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
//Bit  1           reg_sr7_drtlpf_edge_en_1  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
//Bit  0           reg_sr7_drtlpf_edge_en_2  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
#define ISP_POST_SR3_DRTLPF_DIFF_CTL               ((0x1240  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_drtlpf_diff_ratio     // unsigned ,    RW, default = 4  shift bits for the diff threshold. default:4
//Bit 23:22        reserved
//Bit 21:12        reg_drtlpf_diff_minimum   // unsigned ,    RW, default = 200  value of diff threshold. default: 200
//Bit 11:10        reserved
//Bit  9: 0        reg_drtlpf_diff_maximum   // unsigned ,    RW, default = 500  vvalue of diff threshold, the value must be bigger than minimum. defalut:500
#define ISP_POST_SR3_DRTLPF_ALP0_0                 ((0x1241  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_3    // unsigned ,    RW, default = 9  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_2    // unsigned ,    RW, default = 10  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_1    // unsigned ,    RW, default = 11  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_0    // unsigned ,    RW, default = 12  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_1                 ((0x1242  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_7    // unsigned ,    RW, default = 1  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_6    // unsigned ,    RW, default = 4  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_5    // unsigned ,    RW, default = 7  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_4    // unsigned ,    RW, default = 8  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_2                 ((0x1243  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_11   // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_10   // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_9    // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_8    // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_OFST              ((0x1244  << 2) + 0xfe3b4000)
//Bit 31:28        reg_sr3_drtlpf_alpha_ofst_7 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 27:24        reg_sr3_drtlpf_alpha_ofst_6 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 23:20        reg_sr3_drtlpf_alpha_ofst_5 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 19:16        reg_sr3_drtlpf_alpha_ofst_4 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 15:12        reg_sr3_drtlpf_alpha_ofst_3 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 11: 8        reg_sr3_drtlpf_alpha_ofst_2 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit  7: 4        reg_sr3_drtlpf_alpha_ofst_1 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit  3: 0        reg_sr3_drtlpf_alpha_ofst_0 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
#define ISP_POST_SR3_DRTLPF_THETA                  ((0x1245  << 2) + 0xfe3b4000)
//Bit 31:28        reg_sr3_drtlpf_theta_7    // unsigned ,    RW, default = 15  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 27:24        reg_sr3_drtlpf_theta_6    // unsigned ,    RW, default = 14  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 23:20        reg_sr3_drtlpf_theta_5    // unsigned ,    RW, default = 12  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 19:16        reg_sr3_drtlpf_theta_4    // unsigned ,    RW, default = 9  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 15:12        reg_sr3_drtlpf_theta_3    // unsigned ,    RW, default = 6  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 11: 8        reg_sr3_drtlpf_theta_2    // unsigned ,    RW, default = 4  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit  7: 4        reg_sr3_drtlpf_theta_1    // unsigned ,    RW, default = 2  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit  3: 0        reg_sr3_drtlpf_theta_0    // unsigned ,    RW, default = 0  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
#define ISP_POST_SR3_DRTLPF_BETA                   ((0x1246  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_sr7_drtlpf_beta_3     // unsigned ,    RW, default = 0  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit 11: 8        reg_sr7_drtlpf_beta_2     // unsigned ,    RW, default = 4  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit  7: 4        reg_sr7_drtlpf_beta_1     // unsigned ,    RW, default = 8  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit  3: 0        reg_sr7_drtlpf_beta_0     // unsigned ,    RW, default = 15  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
#define ISP_POST_SR3_DRTLPF_EDGE_0                 ((0x1247  << 2) + 0xfe3b4000)
//Bit 31:28        reg_sr7_drtlpf_edge_7     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit 27:24        reg_sr7_drtlpf_edge_6     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit 23:20        reg_sr7_drtlpf_edge_5     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit 19:16        reg_sr7_drtlpf_edge_4     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit 15:12        reg_sr7_drtlpf_edge_3     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit 11: 8        reg_sr7_drtlpf_edge_2     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit  7: 4        reg_sr7_drtlpf_edge_1     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit  3: 0        reg_sr7_drtlpf_edge_0     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
#define ISP_POST_SR3_DRTLPF_EDGE_1                 ((0x1248  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_sr7_drtlpf_edge_9     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
//Bit  3: 0        reg_sr7_drtlpf_edge_8     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128 255];
#define ISP_POST_ADA_GAIN_EN                       ((0x1249  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_pk_alp2_averstderr_en // unsigned ,    RW, default = 0  enable adaptive gain for peaking
//Bit  0           reg_nr_alp2_averstderr_en // unsigned ,    RW, default = 0  enable adaptive gain for nr.
#define ISP_POST_PK_ADA_GIAN_LUT_0                 ((0x124a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_3 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_2 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_1 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_0 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_1                 ((0x124b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_7 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_6 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_5 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_4 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_2                 ((0x124c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_11 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_10 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_9 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_8 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_3                 ((0x124d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_15 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_14 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_13 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_12 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_4                 ((0x124e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_19 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_18 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_17 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_16 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_5                 ((0x124f  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_23 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_22 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_21 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_20 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_6                 ((0x1250  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_27 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_26 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_25 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_24 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_7                 ((0x1251  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_31 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_30 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_29 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_28 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_8                 ((0x1252  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_35 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_34 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_33 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_32 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_9                 ((0x1253  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_39 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_38 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_37 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_36 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_10                ((0x1254  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_43 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_42 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_41 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_40 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_11                ((0x1255  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_47 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_46 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_45 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_44 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_12                ((0x1256  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_48 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
#define ISP_POST_NR_ADA_GIAN_LUT_0                 ((0x1257  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_3 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_2 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_1 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_0 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_1                 ((0x1258  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_7 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_6 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_5 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_4 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_2                 ((0x1259  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_11 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_10 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_9 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_8 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_3                 ((0x125a  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_15 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_14 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_13 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_12 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_4                 ((0x125b  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_19 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_18 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_17 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_16 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_5                 ((0x125c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_23 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_22 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_21 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_20 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_6                 ((0x125d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_27 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_26 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_25 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_24 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_7                 ((0x125e  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_31 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_30 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_29 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_28 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_8                 ((0x125f  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_35 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_34 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_33 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_32 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_9                 ((0x1260  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_39 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_38 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_37 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_36 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_10                ((0x1261  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_43 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_42 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_41 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_40 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_11                ((0x1262  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_47 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_46 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_45 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_44 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_12                ((0x1263  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_48 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
#define ISP_PK_MOTION_ADP_CTRL                     ((0x1264  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_nry_motion_adp_en     // unsigned ,    RW, default = 0  motion adaptive nry enable
//Bit  0           reg_pk_motion_adp_en      // unsigned ,    RW, default = 0  motion adaptive pk enable
#define ISP_NRY_MOTION_ADP_LUT_0                   ((0x1265  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nry_motion_adp_lut_3  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 23:22        reserved
//Bit 21:16        reg_nry_motion_adp_lut_2  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 15:14        reserved
//Bit 13: 8        reg_nry_motion_adp_lut_1  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_motion_adp_lut_0  // unsigned ,    RW, default = 63  motion adaptive nry lut
#define ISP_NRY_MOTION_ADP_LUT_1                   ((0x1266  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_nry_motion_adp_lut_7  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 23:22        reserved
//Bit 21:16        reg_nry_motion_adp_lut_6  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 15:14        reserved
//Bit 13: 8        reg_nry_motion_adp_lut_5  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_motion_adp_lut_4  // unsigned ,    RW, default = 63  motion adaptive nry lut
#define ISP_BP_MOTION_ADP_GAIN_LUT_0               ((0x1267  << 2) + 0xfe3b4000)
//Bit 31:24        reg_bp_motion_adp_gain_lut_3 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 23:16        reg_bp_motion_adp_gain_lut_2 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 15: 8        reg_bp_motion_adp_gain_lut_1 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit  7: 0        reg_bp_motion_adp_gain_lut_0 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
#define ISP_BP_MOTION_ADP_GAIN_LUT_1               ((0x1268  << 2) + 0xfe3b4000)
//Bit 31:24        reg_bp_motion_adp_gain_lut_7 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 23:16        reg_bp_motion_adp_gain_lut_6 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 15: 8        reg_bp_motion_adp_gain_lut_5 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit  7: 0        reg_bp_motion_adp_gain_lut_4 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
#define ISP_HP_MOTION_ADP_GAIN_LUT_0               ((0x1269  << 2) + 0xfe3b4000)
//Bit 31:24        reg_hp_motion_adp_gain_lut_3 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 23:16        reg_hp_motion_adp_gain_lut_2 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 15: 8        reg_hp_motion_adp_gain_lut_1 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit  7: 0        reg_hp_motion_adp_gain_lut_0 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
#define ISP_HP_MOTION_ADP_GAIN_LUT_1               ((0x126a  << 2) + 0xfe3b4000)
//Bit 31:24        reg_hp_motion_adp_gain_lut_7 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 23:16        reg_hp_motion_adp_gain_lut_6 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 15: 8        reg_hp_motion_adp_gain_lut_5 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit  7: 0        reg_hp_motion_adp_gain_lut_4 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
#define ISP_PST_PRE_CTRL                           ((0x1280  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_pre_hlpf_mode         // unsigned ,    RW, default = 1  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 23:21        reserved
//Bit 20           reg_pre_vlpf_mode         // unsigned ,    RW, default = 1  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 19:17        reserved
//Bit 16           reg_pre_hvlpf_mode        // unsigned ,    RW, default = 0  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 15:13        reserved
//Bit 12           reg_pre_bpc_en            // unsigned ,    RW, default = 0  enable pre bad pixel correction
//Bit 11: 9        reserved
//Bit  8           reg_pre_cbc_en            // unsigned ,    RW, default = 0  enable pre check board correction
//Bit  7: 5        reserved
//Bit  4           reg_pre_flt_en            // unsigned ,    RW, default = 1  enable pre fliter
//Bit  3: 1        reserved
//Bit  0           reg_pre_art_rmv_en        // unsigned ,    RW, default = 1  enable pre artifact removing in post
#define ISP_PST_PRE_STRENGTH                       ((0x1281  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_pre_flt_thrd          // unsigned ,    RW, default = 2  threshold for pre filter
//Bit 23:22        reserved
//Bit 21:16        reg_pre_bpc_strength      // unsigned ,    RW, default = 63  strength for pre bad pixel correction
//Bit 15:14        reserved
//Bit 13: 8        reg_pre_flt_strength      // unsigned ,    RW, default = 32  strength for pre single line correction
//Bit  7: 6        reserved
//Bit  5: 0        reg_pre_cbc_strength      // unsigned ,    RW, default = 63  strength for pre filter
#define ISP_PST_PRE_BPC_THRD_MARGIN                ((0x1282  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_bpc_dif_thrd      // unsigned ,    RW, default = 12  difference threshold for bpc function
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_bpc_margin        // signed ,    RW, default = -8  os margin for bpc function
#define ISP_PST_PRE_BPC_CTRL                       ((0x1283  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:12        reg_pre_bpc_adpt_rat      // unsigned ,    RW, default = 16  adaptive mode ratio for bpc function, 32 normalized as "1"
//Bit 11: 8        reg_pre_bpc_grp_thrd      // unsigned ,    RW, default = 2  group thresholds for bpc function
//Bit  7: 6        reserved
//Bit  5: 4        reg_pre_bpc_os_mode       // unsigned ,    RW, default = 1  0:use max/min, 1: use max2/min2, 2: use avg+dif1, 3: use avg+dif2, as OS mode for bpc function
//Bit  3: 1        reserved
//Bit  0           reg_pre_bpc_mode          // unsigned ,    RW, default = 0  0: use min2/max2, 1: use adaptive mode, for bpc function
#define ISP_PST_PRE_CBC_THRD0                      ((0x1284  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_cbc_dif01_thrd    // unsigned ,    RW, default = 40  dif01 threshold for cbc
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_cbc_dif02_thrd    // unsigned ,    RW, default = 20  dif02 threshold for cbc
#define ISP_PST_PRE_CBC_THRD1                      ((0x1285  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_pre_cbc_flg_thrd      // unsigned ,    RW, default = 0  threshold for cbc flag
//Bit  7: 6        reserved
//Bit  5: 0        reg_pre_cbc_dif02_vs_01_rat // unsigned ,    RW, default = 30  dif02 vs dif01 ratio for cbc
#define ISP_PST_PRE_SLINE_THRD01                   ((0x1286  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_sline_dif01_min_thrd // unsigned ,    RW, default = 16  dif01 min threshold for single line detection
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_sline_dif02_thrd  // unsigned ,    RW, default = 128  dif02 threshold for single line detection
#define ISP_POST_YRND_CRTL                         ((0x1290  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12           reg_pst_yrnd_seed_reset   // unsigned ,    RW, default = 1  random noise seed reset each frame
//Bit 11            reserved
//Bit 10: 8        reg_pst_yrnd_bandrand     // unsigned ,    RW, default = 6  strength of the noise to added to Y
//Bit  7: 4        reg_pst_yrnd_randlsft     // unsigned ,    RW, default = 5  left shift of rand noise before feeding to randslut, 0
//Bit  3           reg_pst_yrnd_randmode     // unsigned ,    RW, default = 1  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs
//Bit  2           reg_pst_yrnd_lpf_mode     // unsigned ,    RW, default = 0  lpf mode, 0: 3x3, 1:3x5
//Bit  1           reg_pst_yrnd_hpxor        // unsigned ,    RW, default = 1  random hp portion xor, [0] for luma, [1] for chroma, same for below
//Bit  0           reg_pst_yrnd_en           // unsigned ,    RW, default = 0  enable adding y random noise for post proc.
#define ISP_POST_YRND_APRCT                        ((0x1291  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_pst_yrnd_adp_prct     // unsigned ,    RW, default = 0  adaptive protection for y random noise
#define ISP_POST_LUMA_THRD46                       ((0x1292  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pst_yrnd_luma_thrd_6  // unsigned ,    RW, default = 224  thresholds for luma decision
//Bit 15: 8        reg_pst_yrnd_luma_thrd_5  // unsigned ,    RW, default = 192  thresholds for luma decision
//Bit  7: 0        reg_pst_yrnd_luma_thrd_4  // unsigned ,    RW, default = 160  thresholds for luma decision
#define ISP_POST_LUMA_THRD03                       ((0x1293  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pst_yrnd_luma_thrd_3  // unsigned ,    RW, default = 128  thresholds for luma decision
//Bit 23:16        reg_pst_yrnd_luma_thrd_2  // unsigned ,    RW, default = 96  thresholds for luma decision
//Bit 15: 8        reg_pst_yrnd_luma_thrd_1  // unsigned ,    RW, default = 64  thresholds for luma decision
//Bit  7: 0        reg_pst_yrnd_luma_thrd_0  // unsigned ,    RW, default = 32  thresholds for luma decision
#define ISP_POST_YRND_MAX_MARGIN_LUT1              ((0x1294  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pst_yrnd_max_adp_margin_7 // signed ,    RW, default = -8  of the variation for max Y val after add random noise
//Bit 23:16        reg_pst_yrnd_max_adp_margin_6 // signed ,    RW, default = -7  of the variation for max Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_max_adp_margin_5 // signed ,    RW, default = -6  of the variation for max Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_max_adp_margin_4 // signed ,    RW, default = -5  of the variation for max Y val after add random noise
#define ISP_POST_YRND_MAX_MARGIN_LUT2              ((0x1295  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pst_yrnd_max_adp_margin_3 // signed ,    RW, default = -4  of the variation for max Y val after add random noise
//Bit 23:16        reg_pst_yrnd_max_adp_margin_2 // signed ,    RW, default = -3  of the variation for max Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_max_adp_margin_1 // signed ,    RW, default = -2  of the variation for max Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_max_adp_margin_0 // signed ,    RW, default = -1  of the variation for max Y val after add random noise
#define ISP_POST_YRND_MIN_MARGIN_LUT1              ((0x1296  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pst_yrnd_min_adp_margin_7 // signed ,    RW, default = -8  of the variation for min Y val after add random noise
//Bit 23:16        reg_pst_yrnd_min_adp_margin_6 // signed ,    RW, default = -7  of the variation for min Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_min_adp_margin_5 // signed ,    RW, default = -6  of the variation for min Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_min_adp_margin_4 // signed ,    RW, default = -5  of the variation for min Y val after add random noise
#define ISP_POST_YRND_MIN_MARGIN_LUT2              ((0x1297  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pst_yrnd_min_adp_margin_3 // signed ,    RW, default = -4  of the variation for min Y val after add random noise
//Bit 23:16        reg_pst_yrnd_min_adp_margin_2 // signed ,    RW, default = -3  of the variation for min Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_min_adp_margin_1 // signed ,    RW, default = -2  of the variation for min Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_min_adp_margin_0 // signed ,    RW, default = -1  of the variation for min Y val after add random noise
#define ISP_POST_YRND_LUT                          ((0x1298  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_pst_yrnd_randslut_7   // unsigned ,    RW, default = 0  strenght of randon noise adding base on different luma level
//Bit 27            reserved
//Bit 26:24        reg_pst_yrnd_randslut_6   // unsigned ,    RW, default = 1  strenght of randon noise adding base on different luma level
//Bit 23            reserved
//Bit 22:20        reg_pst_yrnd_randslut_5   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
//Bit 19            reserved
//Bit 18:16        reg_pst_yrnd_randslut_4   // unsigned ,    RW, default = 3  strenght of randon noise adding base on different luma level
//Bit 15            reserved
//Bit 14:12        reg_pst_yrnd_randslut_3   // unsigned ,    RW, default = 4  strenght of randon noise adding base on different luma level
//Bit 11            reserved
//Bit 10: 8        reg_pst_yrnd_randslut_2   // unsigned ,    RW, default = 3  strenght of randon noise adding base on different luma level
//Bit  7            reserved
//Bit  6: 4        reg_pst_yrnd_randslut_1   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
//Bit  3            reserved
//Bit  2: 0        reg_pst_yrnd_randslut_0   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
#define ISP_POST_YRND_SEED                         ((0x1299  << 2) + 0xfe3b4000)
//Bit 31           reg_pst_yrnd_seed_start   // unsigned ,    RW, default = 1  random seed start
//Bit 30: 0        reg_pst_yrnd_seed         // unsigned ,    RW, default = 31'h60a52f20  noise adding seed for Y. seed[0], 0x60a52f20); as default);
#define ISP_POST_UV_COMPENSATION1                  ((0x129a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_uvdiff_th             // unsigned ,    RW, default = 30  threshold of uv(cur line and cur-1 line,cur line and cur+1 line ) difference,
//Bit 15: 8        reg_uv_compensation_k     // unsigned ,    RW, default = 51  x slope for uv compensation alpha
//Bit  7: 1        reserved
//Bit  0           reg_uv_compensation_en    // unsigned ,    RW, default = 1  enable uv compensation befor cnr2.
#define ISP_POST_UV_COMPENSATION2                  ((0x129b  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:22        reserved
//Bit 21:16        reg_uv_compensation_y0    // unsigned ,    RW, default = 63  threshold0 for uv compensation beta
//Bit 15:14        reserved
//Bit 13: 8        reg_uv_compensation_y1    // unsigned ,    RW, default = 0  y threshold1 for uv compensation beta
//Bit  7: 4        reg_uv_compensation_norm  // unsigned ,    RW, default = 3  normalization for uv compensation beta
//Bit  3: 0        reserved
#define CNR_GCLK_CTRL                              ((0x12a0  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cnr2_gclk_ctrl        // unsigned ,    RW, default = 0
#define CNR_MISC                                   ((0x12a1  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_cnr2_input_hblank     // unsigned ,    RW, default = 8
#define CNR_CTRL                                   ((0x12a2  << 2) + 0xfe3b4000)
//Bit 31:11        reserved
//Bit 10: 8        reg_cnr2_hwnd             // unsigned ,    RW, default = 4  horizontal filter window for cnr2
//Bit  7: 6        reserved
//Bit  5: 4        reg_cnr2_vwnd             // unsigned ,    RW, default = 2  vertical filter window for cnr2
//Bit  3           reg_cnr2_inp_sel          // unsigned ,    RW, default = 1  0: no replace, 1: replace, replace yuv5x center line by pk out line for cnr2
//Bit  2           reg_cnr2_proc_sel         // unsigned ,    RW, default = 0  0: ds42, 1: ds82, nr proc. enable for cnr2
//Bit  1           reg_cnr2_hflt_en          // unsigned ,    RW, default = 1  horizontal filter enable for nr proc. enable for cnr2
//Bit  0           reg_cnr2_vflt_en          // unsigned ,    RW, default = 1  vertical filter enable for nr proc. enable for cnr2
#define CNR_HVDIF_COR_SFT                          ((0x12a3  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:26        reg_cnr2_hdif_rsft        // unsigned ,    RW, default = 2  hdif gain right shift for nr proc. of cnr2
//Bit 25:24        reg_cnr2_vdif_rsft        // unsigned ,    RW, default = 2  vdif gain right shift for nr proc. of cnr2
//Bit 23:16        reg_cnr2_hdif_coring      // unsigned ,    RW, default = 0  hdif coring for nr proc. of cnr2
//Bit 15: 8        reg_cnr2_vdif_coring      // unsigned ,    RW, default = 0  vdif coring for nr proc. of cnr2
//Bit  7            reserved
//Bit  6: 4        reg_cnr2_hdif_mode        // unsigned ,    RW, default = 1  0: ydif, 1: max(udif, vdif), 2: avg(udif, vdif), 3: max(ydif, udif, vdif), 4 or else: avg(ydif, udif, vdif), horizontal dif mode for nr proc. enable for cnr2
//Bit  3            reserved
//Bit  2: 0        reg_cnr2_vdif_mode        // unsigned ,    RW, default = 1  0: ydif, 1: max(udif, vdif), 2: avg(udif, vdif), 3: max(ydif, udif, vdif), 4 or else: avg(ydif, udif, vdif), vertical dif mode for nr proc. enable for cnr2
#define CNR_HVDIF_THRD                             ((0x12a4  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_hdif_minthrd     // unsigned ,    RW, default = 12  hdif min threshold for nr proc. of cnr2
//Bit 23:16        reg_cnr2_vdif_minthrd     // unsigned ,    RW, default = 12  vdif min threshold for nr proc. of cnr2
//Bit 15: 8        reg_cnr2_hdif_maxthrd     // unsigned ,    RW, default = 4  hdif max threshold for nr proc. of cnr2
//Bit  7: 0        reg_cnr2_vdif_maxthrd     // unsigned ,    RW, default = 4  vdif max threshold for nr proc. of cnr2
#define CNR_HDIF_GAIN                              ((0x12a5  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_cnr2_hdif_gain_0      // unsigned ,    RW, default = 0  hdif gain for weight of large min dif
//Bit 15:12        reg_cnr2_hdif_gain_1      // unsigned ,    RW, default = 8  hdif gain for weight related to min/max dif
//Bit 11: 8        reg_cnr2_hdif_gain_2      // unsigned ,    RW, default = 4  hdif gain for weight related to min/max dif
//Bit  7: 4        reg_cnr2_hdif_gain_3      // unsigned ,    RW, default = 1  hdif gain for weight related to min/max dif
//Bit  3: 0        reg_cnr2_hdif_gain_4      // unsigned ,    RW, default = 1  hdif gain for weight related to min/max dif
#define CNR_VDIF_GAIN                              ((0x12a6  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_cnr2_vdif_gain_0      // unsigned ,    RW, default = 0  vdif gain for weight of large min dif
//Bit 15:12        reg_cnr2_vdif_gain_1      // unsigned ,    RW, default = 8  vdif gain for weight related to min/max dif
//Bit 11: 8        reg_cnr2_vdif_gain_2      // unsigned ,    RW, default = 4  vdif gain for weight related to min/max dif
//Bit  7: 4        reg_cnr2_vdif_gain_3      // unsigned ,    RW, default = 1  vdif gain for weight related to min/max dif
//Bit  3: 0        reg_cnr2_vdif_gain_4      // unsigned ,    RW, default = 1  vdif gain for weight related to min/max dif
#define CNR_HVBLD_CTRL                             ((0x12a7  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 8        reg_cnr2_hbld_difgain     // unsigned ,    RW, default = 4  diff gain for horizontal blending, 8 is normalized as "1"
//Bit  7: 4        reg_cnr2_vbld_difgain     // unsigned ,    RW, default = 4  diff gain for vertical blending, 8 is normalized as "1"
//Bit  3           reg_cnr2_hbld_dltmode     // unsigned ,    RW, default = 0  0: max, 1: avg, delta mode for horizontal blending
//Bit  2           reg_cnr2_vbld_dltmode     // unsigned ,    RW, default = 0  0: max, 1: avg, delta mode for vertical blending
//Bit  1           reg_cnr2_hbld_en          // unsigned ,    RW, default = 0  enable horizontal blending
//Bit  0           reg_cnr2_vbld_en          // unsigned ,    RW, default = 0  enalbe vertical blending
#define CNR_HVBLD_ALP_MIMX                         ((0x12a8  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_hbld_alpmin      // unsigned ,    RW, default = 0  min alpha for horizontal blending
//Bit 23:16        reg_cnr2_hbld_alpmax      // unsigned ,    RW, default = 255  max alpha for horizontal blending
//Bit 15: 8        reg_cnr2_vbld_alpmin      // unsigned ,    RW, default = 0  min alpha for vertical blending
//Bit  7: 0        reg_cnr2_vbld_alpmax      // unsigned ,    RW, default = 255  max alpha for vertical blending
#define CNR_HVADD_GAIN                             ((0x12a9  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hadd_gain        // unsigned ,    RW, default = 0  u2.6 horizontal added gain for nr proc. of cnr2
//Bit  7: 0        reg_cnr2_vadd_gain        // unsigned ,    RW, default = 0  u2.6 vertical added gain for nr proc. of cnr2
#define CNR_ADPT_PRCT                              ((0x12aa  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_adp_prct_thrd    // signed ,    RW, default = 0  thresholds for adaptive protection before cnr2 output
//Bit  7: 1        reserved
//Bit  0           reg_cnr2_adp_prct_en      // unsigned ,    RW, default = 0  enable adaptive protection before cnr2 output
#define CNR_UMARGIN                                ((0x12ab  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_cnr2_umargin_up       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin up for nr proc. of cnr2
//Bit 15:12        reserved
//Bit 11: 0        reg_cnr2_umargin_dw       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin down for nr proc. of cnr2
#define CNR_VMARGIN                                ((0x12ac  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_cnr2_vmargin_up       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin up for nr proc. of cnr2
//Bit 15:12        reserved
//Bit 11: 0        reg_cnr2_vmargin_dw       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin down for nr proc. of cnr2
#define CNR_TDIF_RNG_LUT_0                         ((0x12ad  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_3   // unsigned ,    RW, default = 254  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_2   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_1   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_0   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_1                         ((0x12ae  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_7   // unsigned ,    RW, default = 172  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_6   // unsigned ,    RW, default = 205  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_5   // unsigned ,    RW, default = 232  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_4   // unsigned ,    RW, default = 249  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_2                         ((0x12af  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_11  // unsigned ,    RW, default = 53  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_10  // unsigned ,    RW, default = 76  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_9   // unsigned ,    RW, default = 105  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_8   // unsigned ,    RW, default = 138  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_3                         ((0x12b0  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_15  // unsigned ,    RW, default = 0  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_14  // unsigned ,    RW, default = 2  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_13  // unsigned ,    RW, default = 7  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_12  // unsigned ,    RW, default = 21  tdif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_0                         ((0x12b1  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_3   // unsigned ,    RW, default = 254  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_2   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_1   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_0   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_1                         ((0x12b2  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_7   // unsigned ,    RW, default = 172  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_6   // unsigned ,    RW, default = 205  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_5   // unsigned ,    RW, default = 232  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_4   // unsigned ,    RW, default = 249  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_2                         ((0x12b3  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_11  // unsigned ,    RW, default = 53  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_10  // unsigned ,    RW, default = 76  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_9   // unsigned ,    RW, default = 105  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_8   // unsigned ,    RW, default = 138  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_3                         ((0x12b4  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_15  // unsigned ,    RW, default = 0  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_14  // unsigned ,    RW, default = 2  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_13  // unsigned ,    RW, default = 7  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_12  // unsigned ,    RW, default = 21  ydif range lut for ds84 uv proc.
#define CNR_FRG_CENT_RAD                           ((0x12b5  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_frg_cent_1       // unsigned ,    RW, default = 0  fringe center1 for cnr2 fringe weight
//Bit 23:16        reg_cnr2_frg_rad_1        // unsigned ,    RW, default = 0  fringe radius1 for cnr2 fringe weight
//Bit 15: 8        reg_cnr2_frg_cent_0       // unsigned ,    RW, default = 245  fringe center0 for cnr2 fringe weight
//Bit  7: 0        reg_cnr2_frg_rad_0        // unsigned ,    RW, default = 40  fringe radius0 for cnr2 fringe weight
#define CNR_CTRST_XTH_K                            ((0x12b6  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_ctrst_xthd       // unsigned ,    RW, default = 16  x threshold for cnr2 contrast
//Bit 15: 0        reg_cnr2_ctrst_kappa      // unsigned ,    RW, default = 480  x slope for cnr2 contrast
#define CNR_CTRST_YTH_NRM                          ((0x12b7  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_ctrst_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 contrast
//Bit 15: 8        reg_cnr2_ctrst_ythd1      // unsigned ,    RW, default = 255  y threshold1 for cnr2 contrast
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_ctrst_norm       // unsigned ,    RW, default = 6  normalization for cnr2 contrast
#define CNR_HMAP0_XTH                              ((0x12b8  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hmap0_xthd0      // unsigned ,    RW, default = 205  x threshold0 for cnr2 hue map0
//Bit  7: 0        reg_cnr2_hmap0_xthd1      // unsigned ,    RW, default = 30  x threshold1 for cnr2 hue map0
#define CNR_HMAP0_K                                ((0x12b9  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cnr2_hmap0_kappa0     // unsigned ,    RW, default = 852  x slope0 for cnr2 hue map0
//Bit 15: 0        reg_cnr2_hmap0_kappa1     // unsigned ,    RW, default = 4266  x slope1 for cnr2 hue map0
#define CNR_HMAP0_YTH_NRM                          ((0x12ba  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_hmap0_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 hue map0
//Bit 23:16        reg_cnr2_hmap0_ythd1      // unsigned ,    RW, default = 0  y threshold1 for cnr2 hue map0
//Bit 15: 8        reg_cnr2_hmap0_ythd2      // unsigned ,    RW, default = 255  y threshold2 for cnr2 hue map0
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_hmap0_norm       // unsigned ,    RW, default = 6  normalization for cnr2 hue map0
#define CNR_HMAP1_XTH                              ((0x12bb  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hmap1_xthd0      // unsigned ,    RW, default = 52  x threshold0 for cnr2 hue map1
//Bit  7: 0        reg_cnr2_hmap1_xthd1      // unsigned ,    RW, default = 89  x threshold1 for cnr2 hue map1
#define CNR_HMAP1_K                                ((0x12bc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cnr2_hmap1_kappa0     // unsigned ,    RW, default = 852  x slope0 for hue cnr2 map1
//Bit 15: 0        reg_cnr2_hmap1_kappa1     // unsigned ,    RW, default = 1800  x slope1 for hue cnr2 map1
#define CNR_HMAP1_YTH_NRM                          ((0x12bd  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_hmap1_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 hue map1
//Bit 23:16        reg_cnr2_hmap1_ythd1      // unsigned ,    RW, default = 0  y threshold1 for cnr2 hue map1
//Bit 15: 8        reg_cnr2_hmap1_ythd2      // unsigned ,    RW, default = 0  y threshold2 for cnr2 hue map1
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_hmap1_norm       // unsigned ,    RW, default = 6  normalization for cnr2 hue map1
#define CNR_RAD_CENT                               ((0x12be  << 2) + 0xfe3b4000)
//Bit 31:16        reg_cnr2_rad_xcent        // unsigned ,    RW, default = 240  x center for cnr2 radial map
//Bit 15: 0        reg_cnr2_rad_ycent        // unsigned ,    RW, default = 270  y center for cnr2 radial map
#define CNR_RAD_XTH_K                              ((0x12bf  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_rad_xthd         // unsigned ,    RW, default = 24  x threshold for cnr2 radial map
//Bit 15: 0        reg_cnr2_rad_kappa        // unsigned ,    RW, default = 186  x slope for cnr2 radial map
#define CNR_RAD_YTH_NRM                            ((0x12c0  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_rad_ythd0        // unsigned ,    RW, default = 255  y threshold0 for cnr2 radial map
//Bit 15: 8        reg_cnr2_rad_ythd1        // unsigned ,    RW, default = 255  y threshold1 for cnr2 radial map
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_rad_norm         // unsigned ,    RW, default = 6  normalization for cnr2 radial map
#define CNR_LUMA_XTH_K                             ((0x12c1  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_luma_xthd        // unsigned ,    RW, default = 128  x threshold for cnr2 luma mapping
//Bit 15: 0        reg_cnr2_luma_kappa       // unsigned ,    RW, default = 640  x slope for cnr2 luma mapping
#define CNR_LUMA_YTH_NRM                           ((0x12c2  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_luma_ythd0       // unsigned ,    RW, default = 255  y threshold0 for cnr2 luma mapping
//Bit 15: 8        reg_cnr2_luma_ythd1       // unsigned ,    RW, default = 160  y threshold1 for cnr2 luma mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_luma_norm        // unsigned ,    RW, default = 8  normalization for cnr2 luma mapping
#define CNR_SAT0_XTH_K                             ((0x12c3  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat0_xthd        // unsigned ,    RW, default = 64  x threshold for cnr2 sat0 mapping
//Bit 15: 0        reg_cnr2_sat0_kappa       // unsigned ,    RW, default = 1920  x slope for cnr2 sat0 mapping
#define CNR_SAT0_YTH_NRM                           ((0x12c4  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat0_ythd0       // unsigned ,    RW, default = 255  y threshold0 for cnr2 sat0 mapping
//Bit 15: 8        reg_cnr2_sat0_ythd1       // unsigned ,    RW, default = 0  y threshold1 for cnr2 sat0 mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_sat0_norm        // unsigned ,    RW, default = 6  normalization for cnr2 sat0 mapping
#define CNR_SAT1_XTH_K                             ((0x12c5  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat1_xthd        // unsigned ,    RW, default = 16  x threshold for cnr2 sat1 mapping
//Bit 15: 0        reg_cnr2_sat1_kappa       // unsigned ,    RW, default = 320  x slope for cnr2 sat1 mapping
#define CNR_SAT1_YTH                               ((0x12c6  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat1_ythd0       // unsigned ,    RW, default = 0  y threshold0 for cnr2 sat1 mapping
//Bit 15: 8        reg_cnr2_sat1_ythd1       // unsigned ,    RW, default = 255  y threshold1 for cnr2 sat1 mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_sat1_norm        // unsigned ,    RW, default = 6  normalization for cnr2 sat1 mapping
#define CNR_ALP_XTH_K                              ((0x12c7  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_alp_xthd         // unsigned ,    RW, default = 16  x threshold for cnr2 final alpha
//Bit 15: 0        reg_cnr2_alp_kappa        // unsigned ,    RW, default = 64  x slope for cnr2 final alpha
#define CNR_ALP_YTH_NRM                            ((0x12c8  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_alp_ythd0        // unsigned ,    RW, default = 255  y threshold0 for cnr2 final alpha
//Bit 15: 8        reg_cnr2_alp_ythd1        // unsigned ,    RW, default = 255  y threshold1 for cnr2 final alpha
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_alp_norm         // unsigned ,    RW, default = 6  normalization for cnr2 final alpha
#define CNR_FRG_HVWT_BLD                           ((0x12c9  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_frg_hwt_bld      // unsigned ,    RW, default = 128  horizontal blending between hue/sat and difs, for cnr2 fringe weight
//Bit 15: 8        reg_cnr2_frg_vwt_bld      // unsigned ,    RW, default = 128  vertical blending between hue/sat and difs, for cnr2 fringe weight
//Bit  7: 5        reserved
//Bit  4           reg_cnr2_frg_hwt_bypss    // unsigned ,    RW, default = 0  bypass horizontal fringe weight for cnr2 fringe weight
//Bit  3: 1        reserved
//Bit  0           reg_cnr2_frg_vwt_bypss    // unsigned ,    RW, default = 0  bypass vertical fringe weight for cnr2 fringe weight
#define CNR_HUE_PRT_LUT_0                          ((0x12ca  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_3    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_2    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_1    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_0    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_1                          ((0x12cb  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_7    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_6    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_5    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_4    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_2                          ((0x12cc  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_11   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_10   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_9    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_8    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_3                          ((0x12cd  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_15   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_14   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_13   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_12   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_4                          ((0x12ce  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_19   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_18   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_17   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_16   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_5                          ((0x12cf  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_23   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_22   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_21   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_20   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_6                          ((0x12d0  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_27   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_26   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_25   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_24   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_7                          ((0x12d1  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_31   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_30   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_29   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_28   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_SATUR_BLK_NUM                          ((0x12d2  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 8        reg_cnr2_satur_blk_hnum_m1 // unsigned ,    RW, default = 31  horizontal block number minus 1 for cnr2 block saturation
//Bit  7: 5        reserved
//Bit  4: 0        reg_cnr2_satur_blk_vnum_m1 // unsigned ,    RW, default = 31  vertical block number minus 1 for cnr2 block saturation
#define CNR_SATUR_BLK_XSCL                         ((0x12d3  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_cnr2_satur_blk_xscl   // unsigned ,    RW, default = 8738  x scaler coefficient for cnr2 block saturation
#define CNR_SATUR_BLK_YSCL                         ((0x12d4  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_cnr2_satur_blk_yscl   // unsigned ,    RW, default = 7767  y scaler coefficient for cnr2 block saturation
#define CNR_SATUR_BLK_LUT_IDX                      ((0x12d5  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 0        reg_cnr2_satur_blk_idx    // unsigned ,    RW, default = 0
#define CNR_SATUR_BLK_LUT_DATA                     ((0x12d6  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_cnr2_satur_blk_data   // unsigned ,    RW, default = 0
#define CNR_CTRST_FRG_ALP                          ((0x12d7  << 2) + 0xfe3b4000)
//Bit 31:24        reg_cnr2_frg_alp_min      // unsigned ,    RW, default = 0  min of fringe alpha
//Bit 23:16        reg_cnr2_frg_alp_max      // unsigned ,    RW, default = 255  max of fringe alpha
//Bit 15: 8        reg_cnr2_luma_osat_thd    // unsigned ,    RW, default = 80  luma over-saturated threshold for cnr2
//Bit  7           reg_cnr2_ctrst_mode       // unsigned ,    RW, default = 0  0: (max - cur), 1: (max - min); contrast calc. mode for cnr2 ctrst mapping
//Bit  6: 4        reg_cnr2_ctrst_hwnd       // unsigned ,    RW, default = 1  horizontal window size for contrast calc. mode for cnr2 ctrst mapping
//Bit  3            reserved
//Bit  2: 0        reg_cnr2_ctrst_vwnd       // unsigned ,    RW, default = 1  horizontal window size for contrast calc. mode for cnr2 ctrst mapping
#define CNR_HS_DBG_MISC                            ((0x12d8  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:24        reg_cnr2_adp_desat_hrz    // unsigned ,    RW, default = 0  0: no desaturation, 1: desaturate with middle value, 2or3: desaturate with min sat, horizontal adaptive desaturation mode
//Bit 23:22        reserved
//Bit 21:20        reg_cnr2_adp_desat_vrt    // unsigned ,    RW, default = 0  0: no desaturation, 1: desaturate with middle value, 2or3: desaturate with min sat, vertical adaptive desaturation mode
//Bit 19            reserved
//Bit 18:16        reg_cnr2_hue_rsft         // unsigned ,    RW, default = 4  hue right shift for cnr2 hue mapping
//Bit 15            reserved
//Bit 14:12        reg_cnr2_sat_sft          // signed ,    RW, default = 0  sat shift for sat mode0 for cnr2 hue mapping
//Bit 11           reg_cnr2_sat_mode         // unsigned ,    RW, default = 0  0: sqrt(udif^2 + vdif^2), 1: |udif| + |vdif|; sat calc. mode for cnr2 sat mapping
//Bit 10           reg_cnr2_sat2wt_mode      // unsigned ,    RW, default = 1  0: use sat value, 1: use sat1 map, for hs weight calc. for cnr2 sat mapping
//Bit  9: 8        reg_cnr2_fin_alp_mode     // unsigned ,    RW, default = 2  use 0: fin alp, 1: fringe alp, 2or3: fin alpha + fringe alpha, for cnr2 final blending
//Bit  7: 5        reserved
//Bit  4: 0        reg_cnr2_dbg_mode         // unsigned ,    RW, default = 0  cnr2 debug mode,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg1_peak_cnr_regs.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_post_tnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_PST_TNR_ALP_LUT_0                      ((0x12f0  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pst_tnr_alp_lut_3     // unsigned ,    RW, default = 16  pst tnr alpha
//Bit 23:22        reserved
//Bit 21:16        reg_pst_tnr_alp_lut_2     // unsigned ,    RW, default = 8  pst tnr alpha
//Bit 15:14        reserved
//Bit 13: 8        reg_pst_tnr_alp_lut_1     // unsigned ,    RW, default = 2  pst tnr alpha
//Bit  7: 6        reserved
//Bit  5: 0        reg_pst_tnr_alp_lut_0     // unsigned ,    RW, default = 0  pst tnr alpha
#define ISP_PST_TNR_ALP_LUT_1                      ((0x12f1  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_pst_tnr_alp_lut_7     // unsigned ,    RW, default = 45  pst tnr alpha
//Bit 23:22        reserved
//Bit 21:16        reg_pst_tnr_alp_lut_6     // unsigned ,    RW, default = 41  pst tnr alpha
//Bit 15:14        reserved
//Bit 13: 8        reg_pst_tnr_alp_lut_5     // unsigned ,    RW, default = 32  pst tnr alpha
//Bit  7: 6        reserved
//Bit  5: 0        reg_pst_tnr_alp_lut_4     // unsigned ,    RW, default = 24  pst tnr alpha
#define ISP_PST_TNR_CTRL                           ((0x12f2  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_pst_tnr_abs_diff_thrd // unsigned ,    RW, default = 1023  post tnr absolute difference threshold
#define ISP_PST_TNR_HW                             ((0x12f6  << 2) + 0xfe3b4000)
//Bit  31:3        reserved
//Bit  2           reg_fst_frm_flg_sw        // unsigned ,    RW, default = 0
//Bit  1           reg_fst_frm_flg_sel       // unsigned ,    RW, default = 0
//Bit  0           reg_sw_rst                // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_tnr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB3_APB_BASE = 0x13
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg2_ctrst_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CNTRST_MISC                            ((0x1300  << 2) + 0xfe3b4000)
//Bit 31:24        reg_ctrst_hblank          // unsigned ,    RW, default = 8
//Bit 23: 0        reg_ctrst_gclk_ctrl       // unsigned ,    RW, default = 0
#define ISP_CNTRST_DNLP_CTRL                       ((0x1304  << 2) + 0xfe3b4000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_dnlp_input_mode       // unsigned ,    RW, default = 4  dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os)
#define ISP_CNTRST_DNLP_YGRID_0                    ((0x1305  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_1          // unsigned ,    RW, default = 14  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_0          // unsigned ,    RW, default = 0  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_1                    ((0x1306  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_3          // unsigned ,    RW, default = 43  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_2          // unsigned ,    RW, default = 29  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_2                    ((0x1307  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_5          // unsigned ,    RW, default = 72  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_4          // unsigned ,    RW, default = 58  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_3                    ((0x1308  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_7          // unsigned ,    RW, default = 101  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_6          // unsigned ,    RW, default = 86  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_4                    ((0x1309  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_9          // unsigned ,    RW, default = 130  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_8          // unsigned ,    RW, default = 115  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_5                    ((0x130a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_11         // unsigned ,    RW, default = 159  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_10         // unsigned ,    RW, default = 144  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_6                    ((0x130b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_13         // unsigned ,    RW, default = 188  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_12         // unsigned ,    RW, default = 173  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_7                    ((0x130c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_15         // unsigned ,    RW, default = 217  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_14         // unsigned ,    RW, default = 202  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_8                    ((0x130d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_17         // unsigned ,    RW, default = 247  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_16         // unsigned ,    RW, default = 232  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_9                    ((0x130e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_19         // unsigned ,    RW, default = 277  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_18         // unsigned ,    RW, default = 262  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_10                   ((0x130f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_21         // unsigned ,    RW, default = 307  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_20         // unsigned ,    RW, default = 292  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_11                   ((0x1310  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_23         // unsigned ,    RW, default = 338  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_22         // unsigned ,    RW, default = 322  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_12                   ((0x1311  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_25         // unsigned ,    RW, default = 368  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_24         // unsigned ,    RW, default = 353  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_13                   ((0x1312  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_27         // unsigned ,    RW, default = 400  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_26         // unsigned ,    RW, default = 384  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_14                   ((0x1313  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_29         // unsigned ,    RW, default = 435  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_28         // unsigned ,    RW, default = 417  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_15                   ((0x1314  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_31         // unsigned ,    RW, default = 473  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_30         // unsigned ,    RW, default = 454  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_16                   ((0x1315  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_33         // unsigned ,    RW, default = 512  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_32         // unsigned ,    RW, default = 492  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_17                   ((0x1316  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_35         // unsigned ,    RW, default = 552  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_34         // unsigned ,    RW, default = 532  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_18                   ((0x1317  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_37         // unsigned ,    RW, default = 590  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_36         // unsigned ,    RW, default = 571  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_19                   ((0x1318  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_39         // unsigned ,    RW, default = 629  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_38         // unsigned ,    RW, default = 610  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_20                   ((0x1319  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_41         // unsigned ,    RW, default = 667  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_40         // unsigned ,    RW, default = 648  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_21                   ((0x131a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_43         // unsigned ,    RW, default = 706  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_42         // unsigned ,    RW, default = 686  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_22                   ((0x131b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_45         // unsigned ,    RW, default = 746  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_44         // unsigned ,    RW, default = 726  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_23                   ((0x131c  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_47         // unsigned ,    RW, default = 786  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_46         // unsigned ,    RW, default = 766  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_24                   ((0x131d  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_49         // unsigned ,    RW, default = 826  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_48         // unsigned ,    RW, default = 806  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_25                   ((0x131e  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_51         // unsigned ,    RW, default = 865  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_50         // unsigned ,    RW, default = 846  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_26                   ((0x131f  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_53         // unsigned ,    RW, default = 902  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_52         // unsigned ,    RW, default = 884  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_27                   ((0x1320  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_55         // unsigned ,    RW, default = 938  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_54         // unsigned ,    RW, default = 921  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_28                   ((0x1321  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_57         // unsigned ,    RW, default = 968  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_56         // unsigned ,    RW, default = 954  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_29                   ((0x1322  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_59         // unsigned ,    RW, default = 992  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_58         // unsigned ,    RW, default = 981  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_30                   ((0x1323  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_61         // unsigned ,    RW, default = 1010  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_60         // unsigned ,    RW, default = 1002  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_31                   ((0x1324  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_63         // unsigned ,    RW, default = 1022  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_62         // unsigned ,    RW, default = 1016  dnlp ygrid lut
#define ISP_CNTRST_SAT_PRT_CRTL                    ((0x1325  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_satprt_sat_core       // unsigned ,    RW, default = 80  will be coring to cor(irgb_max-irgb_min) to calculate the oy_delt, the smaller the more protection to color, the larger only the rich color will be protected;
//Bit 15: 8        reg_satprt_sat_rate       // unsigned ,    RW, default = 64  rate to cor(irgb_max-irgb_min) to calculate the oy_delt, the larger the more protection to rich color; norm 16 as 1
//Bit  7: 4        reserved
//Bit  3: 2        reg_satprt_csc_mode       // unsigned ,    RW, default = 1  csc mode of current yuv input: 0:601, 1:709, 2:BT2020 NCL, 3:reserved
//Bit  1           reg_satprt_is_lmt         // unsigned ,    RW, default = 1  flag telling the YUV is limited range data or full range data, 0 full range, 1: limited range
//Bit  0           reg_satprt_enable         // unsigned ,    RW, default = 0  enable of saturation protection for dnlp adjustments
#define ISP_CNTRST_SAT_PRT_DIV_M                   ((0x1326  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_satprt_div_m_2        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
//Bit 15: 8        reg_satprt_div_m_1        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
//Bit  7: 0        reg_satprt_div_m_0        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
#define ISP_CNTRST_SAT_PRT_LMT_0_1                 ((0x1327  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_satprt_lmt_rgb_1      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
//Bit 15:12        reserved
//Bit 11: 0        reg_satprt_lmt_rgb_0      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
#define ISP_CNTRST_SAT_PRT_LMT_2                   ((0x1328  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_satprt_lmt_rgb_2      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
#define ISP_CNTRST_LC_INPUT_MUX                    ((0x1329  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 4        reg_lcinput_ysel          // unsigned ,    RW, default = 4  local contrast luma input options 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os)
//Bit  3            reserved
//Bit  2: 0        reg_lcinput_csel          // unsigned ,    RW, default = 4  local contrast chroma input options 0: org_c; 1: gau_c; 2: gauadp_c; 3: edgadplpf_c; 4: nr_c;5: cti_c; 6: pk_c
#define ISP_CNTRST_PK_CLR_PRCT_CTL                 ((0x132a  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4           reg_pk_clr_prct_en        // unsigned ,    RW, default = 1  enable color protection
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_clr_prct_inpsel    // unsigned ,    RW, default = 1  input UV selection for color protection, 0: org; 1: NRout;
#define ISP_CNTRST_PK_CLR_PRCT_LUT_0               ((0x132b  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_7     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_6     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_5     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_4     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_3     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_2     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_1     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_0     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_1               ((0x132c  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_15    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_14    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_13    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_12    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_11    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_10    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_9     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_8     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_2               ((0x132d  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_23    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_22    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_21    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_20    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_19    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_18    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_17    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_16    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_3               ((0x132e  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_31    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_30    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_29    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_28    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_27    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_26    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_25    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_24    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_4               ((0x132f  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_39    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_38    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_37    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_36    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_35    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_34    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_33    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_32    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_5               ((0x1330  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_47    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_46    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_45    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_44    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_43    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_42    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_41    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_40    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_6               ((0x1331  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_55    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_54    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_53    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_52    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_51    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_50    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_49    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_48    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_7               ((0x1332  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_63    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_62    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_61    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_60    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_59    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_58    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_57    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_56    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_8               ((0x1333  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_71    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_70    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_69    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_68    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_67    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_66    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_65    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_64    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_9               ((0x1334  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_79    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_78    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_77    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_76    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_75    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_74    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_73    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_72    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_10              ((0x1335  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_87    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_86    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_85    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_84    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_83    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_82    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_81    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_80    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_11              ((0x1336  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_95    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_94    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_93    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_92    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_91    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_90    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_89    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_88    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_12              ((0x1337  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_103   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_102   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_101   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_100   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_99    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_98    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_97    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_96    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_13              ((0x1338  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_111   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_110   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_109   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_108   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_107   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_106   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_105   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_104   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_14              ((0x1339  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_119   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_118   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_117   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_116   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_115   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_114   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_113   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_112   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_15              ((0x133a  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_127   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_126   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_125   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_124   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_123   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_122   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_121   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_120   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_16              ((0x133b  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_135   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_134   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_133   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_132   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_131   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_130   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_129   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_128   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_17              ((0x133c  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_143   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_142   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_141   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_140   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_139   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_138   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_137   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_136   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_18              ((0x133d  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_151   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_150   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_149   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_148   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_147   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_146   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_145   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_144   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_19              ((0x133e  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_159   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_158   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_157   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_156   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_155   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_154   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_153   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_152   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_20              ((0x133f  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_167   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_166   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_165   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_164   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_163   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_162   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_161   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_160   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_21              ((0x1340  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_175   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_174   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_173   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_172   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_171   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_170   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_169   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_168   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_22              ((0x1341  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_183   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_182   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_181   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_180   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_179   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_178   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_177   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_176   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_23              ((0x1342  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_191   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_190   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_189   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_188   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_187   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_186   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_185   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_184   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_24              ((0x1343  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_199   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_198   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_197   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_196   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_195   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_194   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_193   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_192   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_25              ((0x1344  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_207   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_206   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_205   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_204   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_203   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_202   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_201   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_200   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_26              ((0x1345  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_215   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_214   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_213   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_212   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_211   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_210   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_209   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_208   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_27              ((0x1346  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_223   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_222   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_221   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_220   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_219   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_218   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_217   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_216   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_28              ((0x1347  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_231   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_230   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_229   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_228   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_227   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_226   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_225   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_224   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_29              ((0x1348  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_239   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_238   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_237   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_236   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_235   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_234   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_233   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_232   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_30              ((0x1349  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_247   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_246   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_245   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_244   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_243   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_242   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_241   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_240   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_31              ((0x134a  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_clr_prct_lut_255   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_254   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_253   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_252   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_251   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_250   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_249   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_248   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_GAIN                ((0x134b  << 2) + 0xfe3b4000)
//Bit 31:24        reg_pk_clr_prct_lc_gain_2 // unsigned ,    RW, default = 0;//64
//Bit 23:16        reg_pk_clr_prct_lc_gain_1 // unsigned ,    RW, default = 0;//64
//Bit 15: 8        reg_pk_clr_prct_lc_gain_0 // unsigned ,    RW, default = 0;//64  gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable
//Bit  7: 0        reg_pk_clr_prct_dnlp_gain // unsigned ,    RW, default = 0;//64  gain to de-boost of dnlp_dlt base on color region, norm to 64 as 1.0, set to 0 as disable
#define ISP_CNTRST_PK_CC_CTRL                      ((0x134c  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cc_ydlt_pscl       // unsigned ,    RW, default = 64  prescale to the y-delta (if >0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.
//Bit 15: 8        reg_pk_cc_ydlt_nscl       // unsigned ,    RW, default = 64  prescale to the y-delta (if <0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.
//Bit  7: 6        reg_pk_cc_yinp_sel        // unsigned ,    RW, default = 0  color compensation input luma selection, 0: org_y; 1: gau_y ; 2:gauadp_y; 3:edgeadp_y (same as dnlp input sel), default= 0
//Bit  5: 4        reg_pk_cc_ydlt_sel        // unsigned ,    RW, default = 2  color compensation output luma selection, 0: peaking+lti output; 1: dnlp output; 2/3: peaking+lti+dnlp, default = 2
//Bit  3: 2        reg_pk_cc_sat_norm        // unsigned ,    RW, default = 1  normalization of lut cell to saturation. 0: norm to 8 as 1.0, sat[0:23/8]; 1: norm to 16 as 1.0, sat[1/16:31/16]; 2: norm to 32 as 1.0, sat[17/32:47/32]; 3:norm to 64 as 1.0, sat[49/64:79/64]
//Bit  1            reserved
//Bit  0           reg_pk_cc_enable          // unsigned ,    RW, default = 1  color compensation enable, 0: no CC, 1: with CC, default = 1
#define ISP_CNTRST_PK_CC_LUT_0                     ((0x134d  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_cc_lut0_1_3        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 27:24        reg_pk_cc_lut0_1_2        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 23:20        reg_pk_cc_lut0_1_1        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 19:16        reg_pk_cc_lut0_1_0        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 15:12        reg_pk_cc_lut0_0_3        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit 11: 8        reg_pk_cc_lut0_0_2        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit  7: 4        reg_pk_cc_lut0_0_1        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit  3: 0        reg_pk_cc_lut0_0_0        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
#define ISP_CNTRST_PK_CC_LUT_1                     ((0x134e  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_cc_lut1_1_3        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 27:24        reg_pk_cc_lut1_1_2        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 23:20        reg_pk_cc_lut1_1_1        // unsigned ,    RW, default = 2  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 19:16        reg_pk_cc_lut1_1_0        // unsigned ,    RW, default = 1  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 15:12        reg_pk_cc_lut1_0_3        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit 11: 8        reg_pk_cc_lut1_0_2        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit  7: 4        reg_pk_cc_lut1_0_1        // unsigned ,    RW, default = 2  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit  3: 0        reg_pk_cc_lut1_0_0        // unsigned ,    RW, default = 1  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
#define ISP_CNTRST_PK_CC_LUT_2                     ((0x134f  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_pk_cc_lut2_1_2        // unsigned ,    RW, default = 12  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 19:16        reg_pk_cc_lut2_1_1        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 15:12        reg_pk_cc_lut2_1_0        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 11: 8        reg_pk_cc_lut2_0_2        // unsigned ,    RW, default = 12  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
//Bit  7: 4        reg_pk_cc_lut2_0_1        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
//Bit  3: 0        reg_pk_cc_lut2_0_0        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
#define ISP_CNTRST_PK_CC_LUT_3                     ((0x1350  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_pk_cc_lut3_1_2        // unsigned ,    RW, default = 15  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 19:16        reg_pk_cc_lut3_1_1        // unsigned ,    RW, default = 10  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 15:12        reg_pk_cc_lut3_1_0        // unsigned ,    RW, default = 5  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 11: 8        reg_pk_cc_lut3_0_2        // unsigned ,    RW, default = 15  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
//Bit  7: 4        reg_pk_cc_lut3_0_1        // unsigned ,    RW, default = 10  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
//Bit  3: 0        reg_pk_cc_lut3_0_0        // unsigned ,    RW, default = 5  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
#define ISP_CNTRST_PK_CC_LUT_4                     ((0x1351  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_pk_cc_lut4_1_1        // unsigned ,    RW, default = 15  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}
//Bit 11: 8        reg_pk_cc_lut4_1_0        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}
//Bit  7: 4        reg_pk_cc_lut4_0_1        // unsigned ,    RW, default = 15  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}
//Bit  3: 0        reg_pk_cc_lut4_0_0        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}
#define ISP_CNTRST_PK_CC_LUT_5_6_7                 ((0x1352  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pk_cc_lut7_1_0        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4,              ; of x-lumainput=1/8   dft={4}
//Bit 27:24        reg_pk_cc_lut7_0_0        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4,              ; of x-lumainput=7/8   dft={4}
//Bit 23:20        reg_pk_cc_lut6_1_0        // unsigned ,    RW, default = 5  valid for y-lumadlt= -1/4,              ; of x-lumainput=2/8   dft={5}
//Bit 19:16        reg_pk_cc_lut6_0_0        // unsigned ,    RW, default = 5  valid for y-lumadlt=  1/4,              ; of x-lumainput=6/8   dft={5}
//Bit 15:12        reg_pk_cc_lut5_1_1        // unsigned ,    RW, default = 13  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}
//Bit 11: 8        reg_pk_cc_lut5_1_0        // unsigned ,    RW, default = 6  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}
//Bit  7: 4        reg_pk_cc_lut5_0_1        // unsigned ,    RW, default = 13  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}
//Bit  3: 0        reg_pk_cc_lut5_0_0        // unsigned ,    RW, default = 6  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}
#define ISP_LC_TOP_CTRL                            ((0x1360  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:13        reserved
//Bit 12           reg_dhz_blkblend_mode     // unsigned ,    RW, default = 1  DHZ use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
//Bit 11: 9        reserved
//Bit  8           reg_dhz_cc_en             // unsigned ,    RW, default = 0  DHZ color compensation enable register
//Bit  7: 5        reserved
//Bit  4           reg_lc_blkblend_mode      // unsigned ,    RW, default = 1  LC use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
//Bit  3: 1        reserved
//Bit  0           reg_lc_cc_en              // unsigned ,    RW, default = 0  LC color compensation enable register
#define ISP_LC_DHZ_SKY_PROT0                       ((0x1361  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25           reg_dhz_sky_prot_en       // unsigned ,    RW, default = 0  DHZ sky protection enable register
//Bit 24           reg_dhz_sky_prot_cc_en    // unsigned ,    RW, default = 0  DHZ sky color compensation enable register
//Bit 23:22        reserved
//Bit 21:12        reg_dhz_sky_prot_stre     // unsigned ,    RW, default = 614  DHZ sky protection strength register
//Bit 11:10        reserved
//Bit  9: 0        reg_dhz_atmos_light       // unsigned ,    RW, default = 625  DHZ sky atmosphere light register
#define ISP_LC_DHZ_SKY_PROT1                       ((0x1362  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22: 8        reg_dhz_atmos_light_inver // unsigned ,    RW, default = 1677  dehaze 1/atmosphere light register
//Bit  7: 0        reg_dhz_atmo_light_upd_rat // unsigned ,    RW, default = 1  DHZ sky atmosphere light update rate register
#define ISP_LC_DHZ_SKY_TRANS_COEF                  ((0x1363  << 2) + 0xfe3b4000)
//Bit 31:24        reg_dhz_satura_ratio_sky  // unsigned ,    RW, default = 25
//Bit 23:22        reserved
//Bit 21:12        reg_dhz_trans_calcu_coeft // unsigned ,    RW, default = 973
//Bit 11:10        reserved
//Bit  9: 0        reg_dhz_sky_prot_offset   // unsigned ,    RW, default = 400
#define ISP_LC_HV_NUM                              ((0x1364  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lc_blk_hnum           // unsigned ,    RW, default = 12  lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12)
//Bit  7: 5        reserved
//Bit  4: 0        reg_lc_blk_vnum           // unsigned ,    RW, default = 8  lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8)
#define ISP_LC_SAT_LUT_IDX                         ((0x1365  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_lc_sta_lut_idx        // unsigned ,    RW, default = 0
#define ISP_LC_SAT_LUT_DATA                        ((0x1366  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_lc_satur_lut_d1       // unsigned ,    RW, default = 0  saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_satur_lut_d0       // unsigned ,    RW, default = 0  saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define ISP_LC_DHZ_SKY_PROT_LUT_IDX                ((0x1367  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_dhz_sky_prot_lut_idx  // unsigned ,    RW, default = 0
#define ISP_LC_DHZ_SKY_PROT_LUT_DATA               ((0x1368  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_sky_prot_lut_d1   // unsigned ,    RW, default = 0  sky protection curve, normalized to 1024 as 1
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_sky_prot_lut_d0   // unsigned ,    RW, default = 0  sky protection curve, normalized to 1024 as 1
#define ISP_LC_CURVE_BLK_HIDX_0                    ((0x1369  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_1         // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_0         // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_1                    ((0x136a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_3         // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_2         // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_2                    ((0x136b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_5         // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_4         // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_3                    ((0x136c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_7         // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_6         // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_4                    ((0x136d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_9         // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_8         // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_5                    ((0x136e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_hidx_11        // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_10        // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_12                   ((0x136f  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lc_blk_hidx_12        // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LC_CURVE_BLK_VIDX_0                    ((0x1370  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_vidx_1         // unsigned ,    RW, default = 270  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_0         // unsigned ,    RW, default = 0  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_1                    ((0x1371  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_vidx_3         // unsigned ,    RW, default = 810  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_2         // unsigned ,    RW, default = 540  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_2                    ((0x1372  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_vidx_5         // unsigned ,    RW, default = 1350  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_4         // unsigned ,    RW, default = 1080  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_3                    ((0x1373  << 2) + 0xfe3b4000)
//Bit 31:16        reg_lc_blk_vidx_7         // unsigned ,    RW, default = 1890  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_6         // unsigned ,    RW, default = 1620  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_8                    ((0x1374  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lc_blk_vidx_8         // unsigned ,    RW, default = 2160  block boundary y-index
#define ISP_LC_YUV2RGB_MAT_0                       ((0x1375  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_1   // signed ,    RW, default = 0  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_0   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_1                       ((0x1376  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_3   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_2   // signed ,    RW, default = 1613  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_2                       ((0x1377  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_5   // signed ,    RW, default = -479  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_4   // signed ,    RW, default = -191  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_3                       ((0x1378  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_7   // signed ,    RW, default = 1901  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_6   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_8                       ((0x1379  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_8   // signed ,    RW, default = 0  yuv2rgb 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_0                       ((0x137a  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_1   // signed ,    RW, default = 732  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_0   // signed ,    RW, default = 218  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_1                       ((0x137b  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_3   // signed ,    RW, default = -118  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_2   // signed ,    RW, default = 74  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_2                       ((0x137c  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_5   // signed ,    RW, default = 512  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_4   // signed ,    RW, default = -394  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_3                       ((0x137d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_7   // signed ,    RW, default = -465  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_6   // signed ,    RW, default = 512  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_8                       ((0x137e  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_8   // signed ,    RW, default = -47  rgb2yuv 3x3 matrix
#define ISP_LC_YUV2RGB_OFST                        ((0x137f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_lc_yuv2rgb_ofset_0    // unsigned ,    RW, default = 0  yuv2rgb pre-offset to yuv,limit=1<<(bit-4); or full=0;
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_yuv2rgb_ofset_1    // unsigned ,    RW, default = 512  yuv2rgb pre-offset to yuv,
#define ISP_LC_YUV2RGB_CLIP                        ((0x1380  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:28        reg_lc_yuv2rgb_rs         // unsigned ,    RW, default = 2  matrix normalization right shift extra bits, norm= (1<<(8+rs))
//Bit 27:16        reg_lc_yuv2rgb_clip_0     // unsigned ,    RW, default = 0  yuv2rgb converted RGB clipping range
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_yuv2rgb_clip_1     // unsigned ,    RW, default = 1023  yuv2rgb converted RGB clipping range
#define ISP_LC_RGB2YUV_OFST                        ((0x1381  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_ofset_0    // unsigned ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_ofset_1    // unsigned ,    RW, default = 1024  rgb2yuv post-offset to yuv, u12, 2048
#define ISP_LC_RGB2YUV_CLIP                        ((0x1382  << 2) + 0xfe3b4000)
//Bit 31:30        reg_lc_rgb2yuv_rs         // unsigned ,    RW, default = 2  matrix normalization right shift extra bits, norm=(1<<(8+rs))
//Bit 29            reserved
//Bit 28:16        reg_lc_rgb2yuv_clip_0     // unsigned ,    RW, default = 0  rgb2yuv converted YUV clipping range
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_clip_1     // unsigned ,    RW, default = 2047  rgb2yuv converted YUV clipping range, u12, 4095
#define ISP_LC_MAP_RAM_CTRL                        ((0x1383  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_lc_cbus2ram_en        // unsigned ,    RW, default = 0  apb access LC RAM enable
#define ISP_LC_MAP_RAM_ADDR                        ((0x1384  << 2) + 0xfe3b4000)
//Bit 31           reg_lc_cbus2ram_rd_pflg   // unsigned ,    RW, default = 0
//Bit 30: 8        reserved
//Bit  7: 4        reg_lc_cbus2ram_vidx      // unsigned ,    RW, default = 0
//Bit  3: 0        reg_lc_cbus2ram_hidx      // unsigned ,    RW, default = 0
#define ISP_LC_MAP_RAM_DATA                        ((0x1385  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_lc_cbus2ram_data      // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_CTRL                          ((0x13a0  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15:12        reg_sync_ctrl             // unsigned ,    RW, default = 0
//Bit 11: 8        reg_gclk_ctrl             // unsigned ,    RW, default = 0
//Bit  7: 4        reserved
//Bit  3: 2        reg_curve_ram_rdmode      // unsigned ,    RW, default = 0  00: read lc nodes/pk nodes; 01: read lc nodes only; 10: read pk nodes only
//Bit  1           reg_curve_dhz_en          // unsigned ,    RW, default = 0
//Bit  0           reg_curve_lc_en           // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_RAM_ADDR                      ((0x13a1  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_curve_ram_addr        // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_RO_RAM_DATA                   ((0x13a2  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_curve_ram_data        // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_YMINVAL_LMT_0                 ((0x13a4  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_1      // unsigned ,    RW, default = 80  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_0      // unsigned ,    RW, default = 48  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_1                 ((0x13a5  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_3      // unsigned ,    RW, default = 128  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_2      // unsigned ,    RW, default = 120  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_2                 ((0x13a6  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_5      // unsigned ,    RW, default = 196  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_4      // unsigned ,    RW, default = 160  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_3                 ((0x13a7  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_7      // unsigned ,    RW, default = 256  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_6      // unsigned ,    RW, default = 224  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_4                 ((0x13a8  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_9      // unsigned ,    RW, default = 320  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_8      // unsigned ,    RW, default = 288  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_5                 ((0x13a9  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_11     // unsigned ,    RW, default = 400  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_10     // unsigned ,    RW, default = 352  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_6                 ((0x13aa  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_13     // unsigned ,    RW, default = 420  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_12     // unsigned ,    RW, default = 410  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_7                 ((0x13ab  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_15     // unsigned ,    RW, default = 440  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_14     // unsigned ,    RW, default = 430  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YPKBV_LMT_0                   ((0x13ac  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_1        // unsigned ,    RW, default = 128  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_0        // unsigned ,    RW, default = 65  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_1                   ((0x13ad  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_3        // unsigned ,    RW, default = 256  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_2        // unsigned ,    RW, default = 192  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_2                   ((0x13ae  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_5        // unsigned ,    RW, default = 384  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_4        // unsigned ,    RW, default = 320  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_3                   ((0x13af  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_7        // unsigned ,    RW, default = 512  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_6        // unsigned ,    RW, default = 448  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_4                   ((0x13b0  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_9        // unsigned ,    RW, default = 640  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_8        // unsigned ,    RW, default = 576  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_5                   ((0x13b1  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_11       // unsigned ,    RW, default = 768  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_10       // unsigned ,    RW, default = 704  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_6                   ((0x13b2  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_13       // unsigned ,    RW, default = 896  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_12       // unsigned ,    RW, default = 832  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_7                   ((0x13b3  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_15       // unsigned ,    RW, default = 1023  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_14       // unsigned ,    RW, default = 960  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_0                 ((0x13b4  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_1      // unsigned ,    RW, default = 150  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_0      // unsigned ,    RW, default = 120  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_1                 ((0x13b5  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_3      // unsigned ,    RW, default = 274  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_2      // unsigned ,    RW, default = 230  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_2                 ((0x13b6  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_5      // unsigned ,    RW, default = 384  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_4      // unsigned ,    RW, default = 330  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_3                 ((0x13b7  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_7      // unsigned ,    RW, default = 524  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_6      // unsigned ,    RW, default = 456  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_4                 ((0x13b8  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_9      // unsigned ,    RW, default = 660  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_8      // unsigned ,    RW, default = 592  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_5                 ((0x13b9  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_11     // unsigned ,    RW, default = 800  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_10     // unsigned ,    RW, default = 728  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_6                 ((0x13ba  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_13     // unsigned ,    RW, default = 916  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_12     // unsigned ,    RW, default = 856  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_7                 ((0x13bb  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_15     // unsigned ,    RW, default = 1023  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_14     // unsigned ,    RW, default = 976  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_LPF_MOD_TAPS                  ((0x13bc  << 2) + 0xfe3b4000)
//Bit 31           reg_lc_vlpf_taps_5        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 30           reg_lc_vlpf_taps_4        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 29           reg_lc_vlpf_taps_3        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 28           reg_lc_vlpf_taps_2        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 27           reg_lc_vlpf_taps_1        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 26           reg_lc_vlpf_taps_0        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 25           reg_lc_hlpf_taps_5        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 24           reg_lc_hlpf_taps_4        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 23           reg_lc_hlpf_taps_3        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 22           reg_lc_hlpf_taps_2        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 21           reg_lc_hlpf_taps_1        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 20           reg_lc_hlpf_taps_0        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:16        reserved
//Bit 15           reg_lc_vlpf_mode_5        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 14           reg_lc_vlpf_mode_4        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 13           reg_lc_vlpf_mode_3        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 12           reg_lc_vlpf_mode_2        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 11           reg_lc_vlpf_mode_1        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 10           reg_lc_vlpf_mode_0        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  9           reg_lc_hlpf_mode_5        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  8           reg_lc_hlpf_mode_4        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  7           reg_lc_hlpf_mode_3        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  6           reg_lc_hlpf_mode_2        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  5           reg_lc_hlpf_mode_1        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  4           reg_lc_hlpf_mode_0        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  3: 1        reserved
//Bit  0           reg_lc_blackbar_mute_en   // unsigned ,    RW, default = 1  the black bar corresponding bin, 0: no mute, 1: mute enable; default= 1
#define ISP_LC_CURVE_HV_NUM                        ((0x13bd  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lc_cur_blk_hnum       // unsigned ,    RW, default = 12  lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8), should be same as reg_lc_blk_hnum
//Bit  7: 5        reserved
//Bit  4: 0        reg_lc_cur_blk_vnum       // unsigned ,    RW, default = 8  lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12), should be same as reg_lc_blk_vnum
#define ISP_LC_CURVE_LMT_RAT                       ((0x13be  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_lmtrat_minmax      // unsigned ,    RW, default = 6  of amount
//Bit  7: 0        reg_lc_lmtrat_valid       // unsigned ,    RW, default = 20  of amount
#define ISP_LC_CURVE_CONTRAST_LH                   ((0x13bf  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_contrast_low       // unsigned ,    RW, default = 20  gain to the lc for dark side, normalized 256 as "1", set adaptive TODO
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_contrast_hig       // unsigned ,    RW, default = 32  gain to the lc for bright side, normalized 256 as "1"
#define ISP_LC_CURVE_CONTRAST_LMT_LH               ((0x13c0  << 2) + 0xfe3b4000)
//Bit 31:24        reg_lc_cntstlmt_low_0     // unsigned ,    RW, default = 10  for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit 23:16        reg_lc_cntstlmt_hig_0     // unsigned ,    RW, default = 20  for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
//Bit 15: 8        reg_lc_cntstlmt_low_1     // unsigned ,    RW, default = 255  for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit  7: 0        reg_lc_cntstlmt_hig_1     // unsigned ,    RW, default = 255  for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define ISP_LC_CURVE_CONTRAST_SCL_LH               ((0x13c1  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_cntstscl_low       // unsigned ,    RW, default = 20  for the contrast low, norm 8 as 1; delta_low = MIN(delta_low, MIN(MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit  7: 0        reg_lc_cntstscl_hig       // unsigned ,    RW, default = 32  for the contrast high,norm 8 as 1; delta_hig = MIN(delta_hig, MIN(MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define ISP_LC_CURVE_CONTRAST_BVN_LH               ((0x13c2  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_cntstbvn_low       // unsigned ,    RW, default = 20  to num_m as limit of min_val to minBV distance, to protect mono-color, default = 32; min_val= MAX(min_val, minBV- MAX(num_m-1,0)*bvn_low)
//Bit  7: 0        reg_lc_cntstbvn_hig       // unsigned ,    RW, default = 32  to num_m as limit of max_val to maxBV distance, to protect mono-color, default = 32; min_val= MIN(max_val, maxBV+ MAX(num_m-1,0)*bvn_lo
#define ISP_LC_CURVE_MISC0                         ((0x13c3  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_lc_num_m_coring       // unsigned ,    RW, default = 2  to num_m, soft coring,default = 2;
//Bit 15: 8        reg_lc_vbin_min           // unsigned ,    RW, default = 48  is min width of valid histogram bin num,
//Bit  7: 0        reg_lc_slope_max_face     // unsigned ,    RW, default = 48  maximum slope for the pkBin-maxBV range curve to do face protection, normalized to 32 as 1, default= 48
#define ISP_LC_CURVE_YPKBV_RAT                     ((0x13c4  << 2) + 0xfe3b4000)
//Bit 31:24        reg_lc_ypkbv_ratio_0      // unsigned ,    RW, default = 140  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 4
//Bit 23:16        reg_lc_ypkbv_ratio_1      // unsigned ,    RW, default = 192  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 62
//Bit 15: 8        reg_lc_ypkbv_ratio_2      // unsigned ,    RW, default = 192  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 120
//Bit  7: 0        reg_lc_ypkbv_ratio_3      // unsigned ,    RW, default = 96  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
#define ISP_LC_CURVE_YPKBV_SLP_LMT                 ((0x13c5  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_ypkbv_slope_lmt_0  // unsigned ,    RW, default = 32  min max slop for the curves to avoid artifacts, [0] for min_slope, [1] for max_slop, e.g.max_slope= limit*(pkBv-minBv)+min_val as high bound of the ypkBV; normalized to 32 as 1
//Bit  7: 0        reg_lc_ypkbv_slope_lmt_1  // unsigned ,    RW, default = 64
#define ISP_LC_CURVE_HISTVLD_THRD                  ((0x13c6  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_lc_histvld_thrd       // unsigned ,    RW, default = 506  threshold to compare to bin to get number of valid bins
#define ISP_LC_CURVE_BB_MUTE_THRD                  ((0x13c7  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        reg_lc_blackbar_mute_thrd // unsigned ,    RW, default = 10800  1/8 of the region
#define ISP_LC_PK_1STB_TH                          ((0x13c8  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23: 0        reg_lc_pk_1stb_th         // unsigned ,    RW, default = 0  th of first bin to determin if it is pks;
#define ISP_LC_DB_VLD                              ((0x13c9  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lc_pk_vld             // unsigned ,    RW, default = 506  pk valid thd
#define ISP_LC_DB_TRD_MRGN                         ((0x13ca  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lc_pk_no_trd_mrgn     // unsigned ,    RW, default = 506  pk no trend margin
#define ISP_LC_PK_ADP_TH_0                         ((0x13cb  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_3         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_2         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_1         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_0         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_1                         ((0x13cc  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_7         // unsigned ,    RW, default = 15  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_6         // unsigned ,    RW, default = 15  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_5         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_4         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_2                         ((0x13cd  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_11        // unsigned ,    RW, default = 11  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_10        // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_9         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_8         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_3                         ((0x13ce  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_15        // unsigned ,    RW, default = 4  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_14        // unsigned ,    RW, default = 5  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_13        // unsigned ,    RW, default = 7  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_12        // unsigned ,    RW, default = 9  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_DHZ_CURVE_CUT                          ((0x13d0  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_dhz_lmtrat_lowc       // unsigned ,    RW, default = 8  x/4096 of amount, //2000/1048576
//Bit 15:12        reserved
//Bit 11: 0        reg_dhz_lmtrat_higc       // unsigned ,    RW, default = 8  x/4096 of amount, //2000/1048576
#define ISP_DHZ_CURVE_RAT                          ((0x13d1  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14: 0        reg_dhz_dlt_rat           // unsigned ,    RW, default = 750  dehaze delta ratio, norm 1024 as 1
#define ISP_DHZ_CURVE_DLT_RAT                      ((0x13d2  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_hig_dlt_rat       // unsigned ,    RW, default = 256  dehaze high delta ratio, norm 256 as 1
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_low_dlt_rat       // unsigned ,    RW, default = 256  dehaze low delta ratio, norm 256 as 1
#define ISP_DHZ_CURVE_MIN_LMT_0                    ((0x13d3  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_1     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_0     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_1                    ((0x13d4  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_3     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_2     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_2                    ((0x13d5  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_5     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_4     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_3                    ((0x13d6  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_7     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_6     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_4                    ((0x13d7  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_9     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_8     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_5                    ((0x13d8  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_11    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_10    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_6                    ((0x13d9  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_13    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_12    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_7                    ((0x13da  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_15    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_14    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MAX_LMT_0                    ((0x13db  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_1     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_0     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_1                    ((0x13dc  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_3     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_2     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_2                    ((0x13dd  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_5     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_4     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_3                    ((0x13de  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_7     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_6     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_4                    ((0x13df  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_9     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_8     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_5                    ((0x13e0  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_11    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_10    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_6                    ((0x13e1  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_13    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_12    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_7                    ((0x13e2  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_15    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_14    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_LPF_MOD_TAPS                 ((0x13e3  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29           reg_dhz_vlpf_taps_4       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 28           reg_dhz_vlpf_taps_3       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 27           reg_dhz_vlpf_taps_2       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 26           reg_dhz_vlpf_taps_1       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 25           reg_dhz_vlpf_taps_0       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 24           reg_dhz_hlpf_taps_4       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 23           reg_dhz_hlpf_taps_3       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 22           reg_dhz_hlpf_taps_2       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 21           reg_dhz_hlpf_taps_1       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 20           reg_dhz_hlpf_taps_0       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:18        reg_dhz_vlpf_mode_4       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 17:16        reg_dhz_vlpf_mode_3       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 15:14        reg_dhz_vlpf_mode_2       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 13:12        reg_dhz_vlpf_mode_1       // unsigned ,    RW, default = 2  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 11:10        reg_dhz_vlpf_mode_0       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  9: 8        reg_dhz_hlpf_mode_4       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  7: 6        reg_dhz_hlpf_mode_3       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  5: 4        reg_dhz_hlpf_mode_2       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  3: 2        reg_dhz_hlpf_mode_1       // unsigned ,    RW, default = 2  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  1: 0        reg_dhz_hlpf_mode_0       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg2_ctrst_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB0_APB_BASE = 0x14
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_af_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AF_ROI01                               ((0x1400  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_1      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_0      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI23                               ((0x1401  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_3      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_2      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI45                               ((0x1402  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_5      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_4      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI0_WIN01                          ((0x1403  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_roi_xywin_0_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_0_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI1_WIN01                          ((0x1404  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_roi_xywin_1_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_1_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI0_WIN23                          ((0x1405  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_roi_xywin_0_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_0_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI1_WIN23                          ((0x1406  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_roi_xywin_1_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_1_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI_EN_0                            ((0x1407  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_af_roi_enable_0       // unsigned ,    RW, default = 1  enable of af_roi_sta
#define ISP_RO_AF_ROI_STAT_PCK0_0                  ((0x1408  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack0_0     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [31:16] I4, [15:0] I2 or [31:16] h1, [15:0] h0
#define ISP_RO_AF_ROI_STAT_PCK1_0                  ((0x1409  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack1_0     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:16] v1, [15:0] v0
#define ISP_RO_AF_ROI_STAT_PCK2_0                  ((0x140a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack2_0     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [23:16] ycnt, [15:0] y
#define ISP_RO_AF_ROI_STAT_PCK3_0                  ((0x140b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack3_0     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:24] v1,[23:16] v0,[15:8] h1, [7:0] h0
#define ISP_AF_ROI_EN_1                            ((0x140c  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_af_roi_enable_1       // unsigned ,    RW, default = 1  enable of af_roi_sta
#define ISP_RO_AF_ROI_STAT_PCK0_1                  ((0x140d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack0_1     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [31:16] I4, [15:0] I2 or [31:16] h1, [15:0] h0
#define ISP_RO_AF_ROI_STAT_PCK1_1                  ((0x140e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack1_1     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:16] v1, [15:0] v0
#define ISP_RO_AF_ROI_STAT_PCK2_1                  ((0x140f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack2_1     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [23:16] ycnt, [15:0] y
#define ISP_RO_AF_ROI_STAT_PCK3_1                  ((0x1410  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_afroi_stat_pack3_1     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:24] v1,[23:16] v0,[15:8] h1, [7:0] h0
#define ISP_AF_CTRL                                ((0x1411  << 2) + 0xfe3b4000)
//Bit 31:18        reserved
//Bit 17:16        reg_af_xphs_ofst          // unsigned ,    RW, default = 1  phase shift for raw data for AF statistics, same as modules for corresponding block
//Bit 15:14        reg_af_yphs_ofst          // unsigned ,    RW, default = 0  phase shift for raw data for AF statistics, same as modules for corresponding block
//Bit 13           reg_af_stat_onchn_0       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 12           reg_af_stat_onchn_1       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 11           reg_af_stat_onchn_2       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 10           reg_af_stat_onchn_3       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit  9           reg_af_stat_onchn_4       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit  8           reg_af_stat_flt_vmode     // unsigned ,    RW, default = 0  filter mode for auto focus statistics:   0: step=1; 1 and up: step=2
//Bit  7: 6        reg_af_stat_c4_mode       // unsigned ,    RW, default = 0  mode for C4 filter components 0sum(diff[i]^4))1: sum(abs(dif[i])); 2: sum((dif[i])^2); i=0~4, default=0
//Bit  5: 4        reg_af_stat_flt_hmode     // unsigned ,    RW, default = 0  filter mode for auto focus statistics: 0: step=1; 1: step=3;  2: step=5; 3: step=7; default=0
//Bit  3: 2        reg_af_stat_rsft          // unsigned ,    RW, default = 0  right shift of input data for the AF statistics, under u15 precision
//Bit  1: 0        reg_af_stat_c4rs          // unsigned ,    RW, default = 0  4(x+1) as the right shift of the C4 before padding to RO, default =1;
#define ISP_AF_HV_START                            ((0x1412  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_stat_hstart        // unsigned ,    RW, default = 0  AF global statistics window xstart, better to be >=8 to avoid boundary issue of filter
//Bit 15: 0        reg_af_stat_vstart        // unsigned ,    RW, default = 0  AF global statistics window ystart, better to be >=4 to avoid boundary issue of filter
#define ISP_AF_HV_SIZE                             ((0x1413  << 2) + 0xfe3b4000)
//Bit 31:16        reg_af_stat_hsize         // unsigned ,    RW, default = 1920  AF global statistics window xsize, better to be <=xsize-16 to avoid boundary issue of filter
//Bit 15: 0        reg_af_stat_vsize         // unsigned ,    RW, default = 1080  AF global statistics window ysize, better to be <=ysize-8 to avoid boundary issue of filter
#define ISP_AF_HV_BLKNUM                           ((0x1414  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:16        reg_af_stat_hblk_num      // unsigned ,    RW, default = 17  AF local block horizontal number, support max 17 horizontal blks for auto focus statistics
//Bit 15: 6        reserved
//Bit  5: 0        reg_af_stat_vblk_num      // unsigned ,    RW, default = 15  AF local block vertical number, support max 15 vertical blks for auto focus statistics
#define ISP_AF_EN_CTRL                             ((0x1415  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23           reg_af_iir0_ds_sel        // unsigned ,    RW, default = 0  it is used to select the iir0 odd/even channel in downsmple mode,0=even,1=odd
//Bit 22           reg_af_iir1_ds_sel        // unsigned ,    RW, default = 0  it is used to select the iir1 odd/even channel in downsmple mode,0=even,1=odd
//Bit 21           reg_af_stat_sel           // unsigned ,    RW, default = 0  it is used to select the statistics output, 0 = old, 1 = new
//Bit 20           reg_af_oe_sel             // unsigned ,    RW, default = 0  it is used to control the odd even line selection in statistics
//Bit 19           reg_af_iir0_0_en          // unsigned ,    RW, default = 1  it is used to enable the first biquard filter in IIR0
//Bit 18           reg_af_iir0_1_en          // unsigned ,    RW, default = 1  it is used to enable the second biquard filter in IIR0
//Bit 17           reg_af_iir0_2_en          // unsigned ,    RW, default = 1  it is used to enable the third biquard filter in IIR0
//Bit 16           reg_af_iir1_0_en          // unsigned ,    RW, default = 1  it is used to enable the first biquard filter in IIR1
//Bit 15           reg_af_iir1_1_en          // unsigned ,    RW, default = 1  it is used to enable the second biquard filter in IIR1
//Bit 14           reg_af_iir1_2_en          // unsigned ,    RW, default = 1  it is used to enable the third biquard filter in IIR1
//Bit 13           reg_af_iir0_ds_en         // unsigned ,    RW, default = 0  it is used to set downsample mode for IIR0. 1= downsample, 1= normal
//Bit 12           reg_af_iir1_ds_en         // unsigned ,    RW, default = 0  it is used to set downsample mode for IIR1. 1= downsample, 1= normal
//Bit 11           reg_af_iir0_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for IIR0
//Bit 10           reg_af_iir1_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for IIR1
//Bit  9           reg_af_iir0_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for IIR0
//Bit  8           reg_af_iir1_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for IIR1
//Bit  7           reg_af_peak_mode          // unsigned ,    RW, default = 1  it used to set the statistics mode for IIR. 1= peak mode, 0= normal mode
//Bit  6           reg_af_sqr_mode           // unsigned ,    RW, default = 1  it used to set the statistics mode. 1= square mode, 0= normal mode
//Bit  5           reg_af_fir0_en            // unsigned ,    RW, default = 1  it is used to enable the FIR0
//Bit  4           reg_af_fir1_en            // unsigned ,    RW, default = 1  it is used to enable the FIR1
//Bit  3           reg_af_fir0_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for FIR0
//Bit  2           reg_af_fir1_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for FIR1
//Bit  1           reg_af_fir0_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for FIR0
//Bit  0           reg_af_fir1_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for FIR1
#define ISP_AF_IIR0_0_COEF                         ((0x1416  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_0_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_0 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_0_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_0 coef
#define ISP_AF_IIR0_1_COEF                         ((0x1417  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_1_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_1 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_1_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_1 coef
#define ISP_AF_IIR0_2_COEF                         ((0x1418  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_2_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_2 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_2_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_2 coef
#define ISP_AF_IIR1_0_COEF                         ((0x1419  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_0_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_0 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_0_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_0 coef
#define ISP_AF_IIR1_1_COEF                         ((0x141a  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_1_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_1 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_1_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_1 coef
#define ISP_AF_IIR1_2_COEF                         ((0x141b  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_2_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_2 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_2_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_2 coef
#define ISP_AF_IIR_INOUT_SHIFT                     ((0x141c  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14:12        reg_af_iir0_in_sft        // unsigned ,    RW, default = 3  it is used to set the shift of IIR0 input
//Bit 11            reserved
//Bit 10: 8        reg_af_iir1_in_sft        // unsigned ,    RW, default = 3  it is used to set the shift of IIR1 input
//Bit  7: 4        reg_af_iir0_out_sft       // unsigned ,    RW, default = 3  it is used to set the shift of IIR0 output
//Bit  3: 0        reg_af_iir1_out_sft       // unsigned ,    RW, default = 3  it is used to set the shift of IIR1 output
#define ISP_AF_IIR_SHIFT                           ((0x141d  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:20        reg_af_iir0_0_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_0
//Bit 19            reserved
//Bit 18:16        reg_af_iir0_1_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_1
//Bit 15            reserved
//Bit 14:12        reg_af_iir0_2_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_2
//Bit 11            reserved
//Bit 10: 8        reg_af_iir1_0_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_0
//Bit  7            reserved
//Bit  6: 4        reg_af_iir1_1_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_1
//Bit  3            reserved
//Bit  2: 0        reg_af_iir1_2_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_2
#define ISP_AF_IIR_GAIN                            ((0x141e  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_af_iir0_gain          // unsigned ,    RW, default = 3  it is used to set the gain of IIR0
//Bit 15: 8        reserved
//Bit  7: 0        reg_af_iir1_gain          // unsigned ,    RW, default = 3  it is used to set the gain of IIR1
#define ISP_AF_FIR0_COEF                           ((0x141f  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_af_fir0_coef_0        // signed ,    RW, default = 0  it is used to set the FIR0 coef0
//Bit 23:18        reg_af_fir0_coef_1        // signed ,    RW, default = 0  it is used to set the FIR0 coef1
//Bit 17:12        reg_af_fir0_coef_2        // signed ,    RW, default = 32  it is used to set the FIR0 coef2
//Bit 11: 6        reg_af_fir0_coef_3        // signed ,    RW, default = 0  it is used to set the FIR0 coef3
//Bit  5: 0        reg_af_fir0_coef_4        // signed ,    RW, default = 0  it is used to set the FIR0 coef4
#define ISP_AF_FIR1_COEF                           ((0x1420  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_af_fir1_coef_0        // signed ,    RW, default = 0  it is used to set the FIR1 coef0
//Bit 23:18        reg_af_fir1_coef_1        // signed ,    RW, default = 0  it is used to set the FIR1 coef1
//Bit 17:12        reg_af_fir1_coef_2        // signed ,    RW, default = 32  it is used to set the FIR1 coef2
//Bit 11: 6        reg_af_fir1_coef_3        // signed ,    RW, default = 0  it is used to set the FIR1 coef3
//Bit  5: 0        reg_af_fir1_coef_4        // signed ,    RW, default = 0  it is used to set the FIR1 coef4
#define ISP_AF_IIR0_LDG                            ((0x1421  << 2) + 0xfe3b4000)
//Bit 31:24        reg_af_iir0_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in IIR0 LDG
//Bit 23:16        reg_af_iir0_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in IIR0 LDG
//Bit 15: 8        reg_af_iir0_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in IIR0 LDG
//Bit  7: 0        reg_af_iir0_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in IIR0 LDG
#define ISP_AF_IIR1_LDG                            ((0x1422  << 2) + 0xfe3b4000)
//Bit 31:24        reg_af_iir1_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in IIR1 LDG
//Bit 23:16        reg_af_iir1_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in IIR1 LDG
//Bit 15: 8        reg_af_iir1_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in IIR1 LDG
//Bit  7: 0        reg_af_iir1_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in IIR1 LDG
#define ISP_AF_IIR_LDG_SLP                         ((0x1423  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:20        reg_af_iir0_dilate        // unsigned ,    RW, default = 1  it is used to set the dilate selection in IIR0 LDG
//Bit 19            reserved
//Bit 18:16        reg_af_iir1_dilate        // unsigned ,    RW, default = 1  it is used to set the dilate selection in IIR1 LDG
//Bit 15:12        reg_af_iir0_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in IIR0 LDG
//Bit 11: 8        reg_af_iir0_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in IIR0 LDG
//Bit  7: 4        reg_af_iir1_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in IIR1 LDG
//Bit  3: 0        reg_af_iir1_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in IIR1 LDG
#define ISP_AF_IIR0_CORING                         ((0x1424  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_iir0_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in IIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_iir0_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in IIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_iir0_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in IIR1 coring
#define ISP_AF_IIR1_CORING                         ((0x1425  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_iir1_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in IIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_iir1_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in IIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_iir1_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in IIR1 coring
#define ISP_AF_FIR0_LDG                            ((0x1426  << 2) + 0xfe3b4000)
//Bit 31:24        reg_af_fir0_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in FIR0 LDG
//Bit 23:16        reg_af_fir0_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in FIR0 LDG
//Bit 15: 8        reg_af_fir0_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in FIR0 LDG
//Bit  7: 0        reg_af_fir0_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in FIR0 LDG
#define ISP_AF_FIR1_LDG                            ((0x1427  << 2) + 0xfe3b4000)
//Bit 31:24        reg_af_fir1_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in FIR1 LDG
//Bit 23:16        reg_af_fir1_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in FIR1 LDG
//Bit 15: 8        reg_af_fir1_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in FIR1 LDG
//Bit  7: 0        reg_af_fir1_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in FIR1 LDG
#define ISP_AF_FIR_LDG_SLOPE                       ((0x1428  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_af_fir0_out_sft       // unsigned ,    RW, default = 0  it is used to set the output shift in FIR0
//Bit 19:16        reg_af_fir1_out_sft       // unsigned ,    RW, default = 0  it is used to set the output_shift in FIR1
//Bit 15:12        reg_af_fir0_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in FIR0 LDG
//Bit 11: 8        reg_af_fir0_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in FIR0 LDG
//Bit  7: 4        reg_af_fir1_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in FIR1 LDG
//Bit  3: 0        reg_af_fir1_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in FIR1 LDG
#define ISP_AF_FIR0_CORING                         ((0x1429  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_fir0_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in FIR0 coring
//Bit 23            reserved
//Bit 22:12        reg_af_fir0_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in FIR0 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_fir0_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in FIR0 coring
#define ISP_AF_FIR1_CORING                         ((0x142a  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_fir1_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in FIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_fir1_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in FIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_fir1_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in FIR1 coring
#define ISP_AF_HOR_THD                             ((0x142b  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_af_h0_thd             // unsigned ,    RW, default = 0  it is used to set the horizontal theshold
//Bit 15:11        reserved
//Bit 10: 0        reg_af_h1_thd             // unsigned ,    RW, default = 0  it is used to set the horizontal theshold
#define ISP_AF_VER_THD                             ((0x142c  << 2) + 0xfe3b4000)
//Bit 31:27        reserved
//Bit 26:16        reg_af_v0_thd             // unsigned ,    RW, default = 0  it is used to set the vertical theshold
//Bit 15:11        reserved
//Bit 10: 0        reg_af_v1_thd             // unsigned ,    RW, default = 0  it is used to set the vertical theshold
#define ISP_AF_STA_SHIFT                           ((0x142d  << 2) + 0xfe3b4000)
//Bit 31:28        reg_af_h0_sft             // unsigned ,    RW, default = 8  it is used to set the shift for horizontal statistics0
//Bit 27:24        reg_af_h1_sft             // unsigned ,    RW, default = 8  it is used to set the shift for horizontal statistics1
//Bit 23:20        reg_af_v0_sft             // unsigned ,    RW, default = 8  it is used to set the shift for vertical statistics0
//Bit 19:16        reg_af_v1_sft             // unsigned ,    RW, default = 8  it is used to set the shift for vertical statistics1
//Bit 15:12        reg_af_hcnt0_sft          // unsigned ,    RW, default = 3  it is used to set the shift for horizontal counter0
//Bit 11: 8        reg_af_hcnt1_sft          // unsigned ,    RW, default = 3  it is used to set the shift for horizontal counter1
//Bit  7: 4        reg_af_vcnt0_sft          // unsigned ,    RW, default = 3  it is used to set the shift for vertical counter0
//Bit  3: 0        reg_af_vcnt1_sft          // unsigned ,    RW, default = 3  it is used to set the shift for vertical counter1
#define ISP_AF_STA_Y                               ((0x142e  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19:16        reg_af_y_sft              // unsigned ,    RW, default = 8  it is used to set the shift for y statistics
//Bit 15:12        reg_af_ycnt_sft           // unsigned ,    RW, default = 3  it is used to set the shift for y counter
//Bit 11: 0        reg_af_y_thd              // unsigned ,    RW, default = 0  it is used to set the Y theshold
#define ISP_AF_ROI0_STA_SHIFT                      ((0x142f  << 2) + 0xfe3b4000)
//Bit 31:28        reg_af_roi_h0_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI0 statistics0
//Bit 27:24        reg_af_roi_h1_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI0 statistics1
//Bit 23:20        reg_af_roi_v0_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI0 statistics0
//Bit 19:16        reg_af_roi_v1_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI0 statistics1
//Bit 15:12        reg_af_roi_hcnt0_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI0 counter0
//Bit 11: 8        reg_af_roi_hcnt1_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI0 counter1
//Bit  7: 4        reg_af_roi_vcnt0_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI0 counter0
//Bit  3: 0        reg_af_roi_vcnt1_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI0 counter1
#define ISP_AF_ROI0_STA_Y_SFT                      ((0x1430  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_af_roi_y_sft_0        // unsigned ,    RW, default = 8  it is used to set the shift for ROI0 y statistics
//Bit  3: 0        reg_af_roi_ycnt_sft_0     // unsigned ,    RW, default = 3  it is used to set the shift for ROI0 y counter
#define ISP_AF_ROI1_STA_SHIFT                      ((0x1431  << 2) + 0xfe3b4000)
//Bit 31:28        reg_af_roi_h0_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI1 statistics0
//Bit 27:24        reg_af_roi_h1_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI1 statistics1
//Bit 23:20        reg_af_roi_v0_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI1 statistics0
//Bit 19:16        reg_af_roi_v1_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI1 statistics1
//Bit 15:12        reg_af_roi_hcnt0_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI1 counter0
//Bit 11: 8        reg_af_roi_hcnt1_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI1 counter1
//Bit  7: 4        reg_af_roi_vcnt0_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI1 counter0
//Bit  3: 0        reg_af_roi_vcnt1_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI1 counter1
#define ISP_AF_ROI1_STA_Y_SFT                      ((0x1432  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_af_roi_y_sft_1        // unsigned ,    RW, default = 8  it is used to set the shift for ROI1 y statistics
//Bit  3: 0        reg_af_roi_ycnt_sft_1     // unsigned ,    RW, default = 3  it is used to set the shift for ROI1 y counter
#define ISP_AF_DEBUG_IN_CHECKSUM                   ((0x1433  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_AF_DEBUG_PACK0_CHECKSUM                ((0x1434  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_debug_pack0_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK1_CHECKSUM                ((0x1435  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_debug_pack1_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK2_CHECKSUM                ((0x1436  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_debug_pack2_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK3_CHECKSUM                ((0x1437  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_debug_pack3_checksum // unsigned ,   RO, default = 0
#define ISP_RO_AF_GLB_STAT_PCK0                    ((0x1438  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack0      // unsigned ,    RO, default = 0  LSB of the AF global block sparam_3a_inittatistic, [31:16] I4, [15:0] I2 or [31:0] h0
#define ISP_RO_AF_GLB_STAT_PCK1                    ((0x1439  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack1      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:0] h1
#define ISP_RO_AF_GLB_STAT_PCK2                    ((0x143a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack2      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] v0
#define ISP_RO_AF_GLB_STAT_PCK3                    ((0x143b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack3      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] v1
#define ISP_RO_AF_GLB_STAT_PCK4                    ((0x143c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack4      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] Y
#define ISP_RO_AF_GLB_STAT_PCK5                    ((0x143d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack5      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [23:0] hcnt0
#define ISP_RO_AF_GLB_STAT_PCK6                    ((0x143e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack6      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [23:0] hcnt1
#define ISP_RO_AF_GLB_STAT_PCK7                    ((0x143f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack7      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=vcnt0
#define ISP_RO_AF_GLB_STAT_PCK8                    ((0x1440  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack8      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=vcnt1
#define ISP_RO_AF_GLB_STAT_PCK9                    ((0x1441  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_af_glb_stat_pack9      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=y_cnt
#define ISP_AF_IDX_ADDR                            ((0x1470  << 2) + 0xfe3b4000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_af_idx_addr       //unsigned  ,    RW, default = 0  addr for af_idx
#define ISP_AF_IDX_DATA                            ((0x1471  << 2) + 0xfe3b4000)
//Bit 31:16        reg_isp_af_hidx_data      //unsigned  ,    RW, default = 0  data for af_hidx
//Bit 15:0         reg_isp_af_vidx_data      //unsigned  ,    RW, default = 0  data for af_vidx
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_af_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_flkr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DEFLICKER_OFST                         ((0x1480  << 2) + 0xfe3b4000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_flkr_xphs_ofst        // unsigned ,    RW, default = 1  horizontal phase offset
//Bit  3: 2        reserved
//Bit  1: 0        reg_flkr_yphs_ofst        // unsigned ,    RW, default = 0  vertical phase offset
#define ISP_DEFLICKER_STAT_YPOSITION               ((0x1481  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_flkr_stat_yst         // unsigned ,    RW, default = 0  row start for row statistic for flicker statistic
//Bit 15:14        reserved
//Bit 13: 0        reg_flkr_stat_yed         // unsigned ,    RW, default = 1079  row end for row statistic for flicker statistic
#define ISP_DEFLICKER_STAT_XPOSITION               ((0x1482  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_flkr_stat_xst         // unsigned ,    RW, default = 0  column start for flicker statistic
//Bit 15:14        reserved
//Bit 13: 0        reg_flkr_stat_xed         // unsigned ,    RW, default = 1919  column end for flicker statistic
#define ISP_DEFLICKER_DIV_COEF                     ((0x1483  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_flkr_stat_div_coef    // unsigned ,    RW, default = 1920  divide coefficient for sum diff for row statistic for flicker detection
#define ISP_DEFLICKER_WDR_RATIO                    ((0x1484  << 2) + 0xfe3b4000)
//Bit 31:15        reserved
//Bit 14: 0        reg_flkr_wdr_ratio        // unsigned ,    RW, default = 64  exposure ratio between long and short1 for wdr mode. T7 wdr mode short frame input =long_expo/short_expo, else =1. default 64
#define ISP_DEFLICKER_CNTL                         ((0x1485  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_flkr_avg_chnen_0      // unsigned ,    RW, default = 1  enable of averaging of channel data during line sum calculation. for T7, mono/GrRBGb/GrRBIr/IrRBGb, default [1 1 1 1]; for isp GrRBGbIr, default=[1 0 0 1 0]
//Bit 19           reg_flkr_avg_chnen_1      // unsigned ,    RW, default = 0
//Bit 18           reg_flkr_avg_chnen_2      // unsigned ,    RW, default = 0
//Bit 17           reg_flkr_avg_chnen_3      // unsigned ,    RW, default = 1
//Bit 16           reg_flkr_avg_chnen_4      // unsigned ,    RW, default = 0
//Bit 15            reserved
//Bit 14:13        reserved
//Bit 12           reg_flkr_sta_input_format // unsigned ,    RW, default = 0  STA input select ISP output, 0: raw input 1: YUV/RGB
//Bit 11:10        reserved
//Bit  9: 8        reg_flkr_sta_cmpsel       // unsigned ,    RW, default = 0  component combine to Y when reg_flkr_sta_input_format, 1. 0: dat[0],Y, 1:dat[3], IR); 2/3: (dat[0]+ 2*dat[1]+ dat[2])/4, RGB
//Bit  7: 5        reserved
//Bit  4: 2        reg_flkr_binning_rs       // unsigned ,    RW, default = 0  row average binning step, 2^x. 0: RO for each row avg); 1: each RO for two rows); 2: each RO for 4rows); 3: each RO for 8rows);
//Bit  1            reserved
//Bit  0           reg_flkr_ro_mode          // unsigned ,    RW, default = 0  mode of RO-RAM, 0: avg(cur-p1); 1: avg(cur), 2: debug info, default, 0.
#define ISP_DEFLICKER_RO_IN_CHECKSUM0              ((0x1486  << 2) + 0xfe3b4000)
//Bit 31:0         ro_flkr_debug_in_checksum0 //unsigned ,    RO, default = 0
#define ISP_DEFLICKER_RO_IN_CHECKSUM1              ((0x1487  << 2) + 0xfe3b4000)
//Bit 31:0         ro_flkr_debug_in_checksum1 //unsigned ,    RO, default = 0
#define ISP_DEFLICKER_RO_OUT_CHECKSUM              ((0x1488  << 2) + 0xfe3b4000)
//Bit 31:0         ro_flkr_debug_out_checksum //unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_flkr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_3a_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_3A_GCLK_CTRL                           ((0x14c0  << 2) + 0xfe3b4000)
//Bit 31:21 reserved
//Bit 20    reg_3a_dma_dbg              //unsigned, RW, default=0
//Bit 19:18 reg_3a_reg_gclk_ctrl        //unsigned, RW, default=0
//Bit 17:16 reg_awb_1c2_gclk_ctrl       //unsigned, RW, default=0
//Bit 15:12 reg_flkr_gclk_ctrl          //unsigned, RW, default=0
//Bit 11:8  reg_ae_gclk_ctrl            //unsigned, RW, default=0
//Bit 7:4   reg_awb_gclk_ctrl           //unsigned, RW, default=0
//Bit 3:0   reg_af_gclk_ctrl            //unsigned, RW, default=0
#define ISP_3A_DBGRO_CTRL                          ((0x14c1  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:8  reg_3a_dbg_en               //unsigned, RW, default=0
//Bit 7:0   reg_3a_dbg_clr              //unsigned, RW, default=0
#define ISP_3A_WATDOG_CTRL                         ((0x14c2  << 2) + 0xfe3b4000)
//Bit 31:20 reserved
//Bit 19:4  reg_3a_watchdog_thrd        //unsigned, RW, default=65535
//Bit 3:0   reg_3a_watchdog_en          //unsigned, RW, default=15
#define ISP_3A_DBGPATH_SEL                         ((0x14d0  << 2) + 0xfe3b4000)
//Bit 31:0   reg_3a_dbgpath_sel          //unsigned, RW, default=0
#define ISP_3A_DBG_CNT_EN                          ((0x14d1  << 2) + 0xfe3b4000)
//Bit 31:4  reserved
//Bit 3:0   reg_3a_dbg_cnt_en           //unsigned, RW, default=0
#define ISP_3A_DBG_SIZE_0                          ((0x14d2  << 2) + 0xfe3b4000)
//Bit 31:16 reg_3a_dbg_size_af          //unsigned, RW, default=0
//Bit 15:0  reg_3a_dbg_size_awb         //unsigned, RW, default=0
#define ISP_3A_DBG_SIZE_1                          ((0x14d3  << 2) + 0xfe3b4000)
//Bit 31:16 reg_3a_dbg_size_ae          //unsigned, RW, default=0
//Bit 15:0  reg_3a_dbg_size_flkr        //unsigned, RW, default=0
#define ISP_3A_RO_STAT                             ((0x14e0  << 2) + 0xfe3b4000)
//Bit 31:8  reserved
//Bit 7:0   ro_dma_size_err             //unsigned, RO, default=0 bit[7:4] dma_size setting larger than requested for each channel bit[3:0] dma_size setting smaller than requested for each channel
#define ISP_3A_RO_DBGPATH0                         ((0x14e1  << 2) + 0xfe3b4000)
//Bit 31:0   ro_3a_dbgpath_dat0         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH1                         ((0x14e2  << 2) + 0xfe3b4000)
//Bit 31:0   ro_3a_dbgpath_dat1         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH2                         ((0x14e3  << 2) + 0xfe3b4000)
//Bit 31:0   ro_3a_dbgpath_dat2         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH3                         ((0x14e4  << 2) + 0xfe3b4000)
//Bit 31:0   ro_3a_dbgpath_dat3         //unsigned, RO, default=0
#define ISP_3A_RO_FRM_END                          ((0x14e5  << 2) + 0xfe3b4000)
//Bit 31:8   reserved
//Bit 7:0    ro_3a_dbg_frm_end          //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_3a_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB1_APB_BASE = 0x15
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ae_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AE_ROI01                               ((0x1500  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_1      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_0      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI23                               ((0x1501  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_3      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_2      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI45                               ((0x1502  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_5      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_4      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI0_WIN01                          ((0x1503  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_roi_xywin_0_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_0_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI1_WIN01                          ((0x1504  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_roi_xywin_1_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_1_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI0_WIN23                          ((0x1505  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_roi_xywin_0_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_0_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI1_WIN23                          ((0x1506  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_roi_xywin_1_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_1_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI_EN_0                            ((0x1507  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_ae_roi_enable_0       // unsigned ,    RW, default = 1  enable of ae_roi_sta
//Bit  0           reg_ae_roi_mode_0         // unsigned ,    RW, default = 0  mode of the his5, 0: bins0134; 1: avg4
#define ISP_AE_ROI_EN_1                            ((0x1508  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_ae_roi_enable_1       // unsigned ,    RW, default = 1  enable of ae_roi_sta
//Bit  0           reg_ae_roi_mode_1         // unsigned ,    RW, default = 0  mode of the his5, 0: bins0134; 1: avg4
#define ISP_RO_AE_ROI_STAT_PCK0_0                  ((0x1509  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack0_0     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_0                  ((0x150a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack1_0     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_1                  ((0x150b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack0_1     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_1                  ((0x150c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack1_1     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_2                  ((0x150d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack0_2     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_2                  ((0x150e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack1_2     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_3                  ((0x150f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack0_3     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_3                  ((0x1510  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_aeroi_stat_pack1_3     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_AE_SATUR_THRD                          ((0x1511  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ae_stat_satur_thrd    // unsigned ,    RW, default = 61440  global saturation threshold for saturation/unsaturation statistic in each block
#define ISP_AE_CTRL                                ((0x1512  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:26        reg_ae_xphs_ofst          // unsigned ,    RW, default = 1  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit 25:24        reg_ae_yphs_ofst          // unsigned ,    RW, default = 0  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit 23            reserved
//Bit 22:20        reg_ae_expos_stt          // unsigned ,    RW, default = 0  start of exposure frame AE statistics,  0: long, 1: short, 2: very short, 3: veryvery short, default = 0
//Bit 19            reserved
//Bit 18:16        reg_ae_expos_num          // unsigned ,    RW, default = 1  exposure number for AE statistics,  e.g DOL2+AESTA_GE, set to 2, x=[1,2]
//Bit 15:12        reg_ae_stat_hist_updt     // unsigned ,    RW, default = 0  bit0-bit3 set to 1, the possible hist0-hist3 to be updated at current AE histogram statistic
//Bit 11:10        reg_ae_stat_hist_mode     // unsigned ,    RW, default = 0  0: single hist, 1: two hist, 2or3: four hist, AE histogram mode for single exposure
//Bit  9: 8        reg_ae_luma_mode          // unsigned ,    RW, default = 0  blender mode between grn', red and blu to get luma for AE STA: 0: cur (reg_ae_input_2ln=0); 1: MAX(grn',Red, BLU); 2/3: filter
//Bit  7           reg_ae_input_2ln          // unsigned ,    RW, default = 1  input buffer 2 lines together, reg_ae_stat_switch=0, set 1, otherwise set to 0
//Bit  6            reserved
//Bit  5           reg_ae_histo_useweight    // unsigned ,    RW, default = 1  hist1024 use regional weight, default=1
//Bit  4           reg_ae_glbal_useweight    // unsigned ,    RW, default = 1  global use regional weight, default=1
//Bit  3: 2        reg_ae_stat_local_mode    // unsigned ,    RW, default = 0  AE statisic local sta mode: 0: BIN0/1/3/4 in pack0 and pack1; 1: Gr/R/B/Gb/Ir_avg in pack0 and pack1; 2o3: mean/max/min/sat/unsat etc packed. default=0
//Bit  1           reg_ae_stat_hist_sel      // unsigned ,    RW, default = 0  0: global win, 1: roi window, histogram from global window or roi window for ae stats
//Bit  0           reg_ae_stat_glbal_mode    // unsigned ,    RW, default = 0  AE statisic global sta mode: 0: BIN0/1/3/4 in pack0 and pack1; 1: Gr/R/B/Gb/Ir_avg in pack0 and pack1; default=0
#define ISP_AE_CRTL2_0                             ((0x1513  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_0        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_0       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_0       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_1                             ((0x1514  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_1        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_1       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_1       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_2                             ((0x1515  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_2        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_2       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_2       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_3                             ((0x1516  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_3        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_3       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_3       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_4                             ((0x1517  << 2) + 0xfe3b4000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_4        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_4       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_4       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_HV_START                            ((0x1518  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_stat_hstart        // unsigned ,    RW, default = 0  horizontal start for auto exposure statistics
//Bit 15: 0        reg_ae_stat_vstart        // unsigned ,    RW, default = 0  vertical start for auto exposure statistics
#define ISP_AE_HV_SIZE                             ((0x1519  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_stat_hsize         // unsigned ,    RW, default = 1920  horizontal size for auto exposure statistics
//Bit 15: 0        reg_ae_stat_vsize         // unsigned ,    RW, default = 1080  vertical size for auto exposure statistics
#define ISP_AE_HV_BLKNUM                           ((0x151a  << 2) + 0xfe3b4000)
//Bit 31:23        reserved
//Bit 22:16        reg_ae_stat_hblk_num      // unsigned ,    RW, default = 17  AE local block horizontal number
//Bit 15: 7        reserved
//Bit  6: 0        reg_ae_stat_vblk_num      // unsigned ,    RW, default = 15  AE local block vertical number
#define ISP_AE_STAT_THD01                          ((0x151b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_stat_thrd_1        // unsigned ,    RW, default = 16'h6000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
//Bit 15: 0        reg_ae_stat_thrd_0        // unsigned ,    RW, default = 16'h2000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
#define ISP_AE_STAT_THD23                          ((0x151c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ae_stat_thrd_3        // unsigned ,    RW, default = 16'h9000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
//Bit 15: 0        reg_ae_stat_thrd_2        // unsigned ,    RW, default = 16'h6000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
#define ISP_AE_DEBUG_IN0_CHECKSUM                  ((0x151d  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_in_checksum_0 // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_IN1_CHECKSUM                  ((0x151e  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_in_checksum_1 // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK0_CHECKSUM                ((0x151f  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_pack0_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK1_CHECKSUM                ((0x1520  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_pack1_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK2_CHECKSUM                ((0x1521  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_pack2_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK3_CHECKSUM                ((0x1522  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_debug_pack3_checksum // unsigned ,    RO, default = 0
#define ISP_RO_AE_GLB_STAT_PCK0_0                  ((0x1523  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_glb_stat_pack0_0    // unsigned ,    RO, default = 0  LSB of the AE global block statistic normalized, [31:16] BIN1 or Red_avg or Max,             [15:0] BIN0 or Gr_avg, or Ir_avg or Min
#define ISP_RO_AE_GLB_STAT_PCK1_0                  ((0x1524  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_glb_stat_pack1_0    // unsigned ,    RO, default = 0  MSB of the AE global block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg or NULL; [15:0] BIN3 or blu_avg or Mean
#define ISP_RO_AE_GLB_STAT_PCK0_1                  ((0x1525  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_glb_stat_pack0_1    // unsigned ,    RO, default = 0  LSB of the AE global block statistic normalized, [31:16] BIN1 or Red_avg or Max,             [15:0] BIN0 or Gr_avg, or Ir_avg or Min
#define ISP_RO_AE_GLB_STAT_PCK1_1                  ((0x1526  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_glb_stat_pack1_1    // unsigned ,    RO, default = 0  MSB of the AE global block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg or NULL; [15:0] BIN3 or blu_avg or Mean
#define ISP_RO_AE_STAT_GPNUM                       ((0x1527  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_ae_stat_glbpixnum      // unsigned ,    RO, default = 0  weighted global pixel num, equal to hist1024 sum for easier normalization
#define ISP_AE_IDX_ADDR                            ((0x1580  << 2) + 0xfe3b4000)
//Bit 31:8         reserved
//Bit 7:0          reg_isp_ae_idx_addr       //unsigned  ,    RW, default = 0  addr for ae_idx
#define ISP_AE_IDX_DATA                            ((0x1581  << 2) + 0xfe3b4000)
//Bit 31:16        reg_isp_ae_hidx_data      //unsigned  ,    RW, default = 0  data for ae_hidx
//Bit 15:0         reg_isp_ae_vidx_data      //unsigned  ,    RW, default = 0  data for ae_vidx
#define ISP_AE_BLK_WT_ADDR                         ((0x1582  << 2) + 0xfe3b4000)
//Bit 31:9         reserved
//Bit 8:0          reg_isp_ae_blk_wt_addr    //unsigned  ,    RW, default = 0  addr for ae_weight
#define ISP_AE_BLK_WT_DATA                         ((0x1583  << 2) + 0xfe3b4000)
//Bit 31:0         reg_isp_ae_blk_wt_data    //unsigned  ,    RW, default = 0  data for ae_weight
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ae_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB2_APB_BASE = 0x16
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_awb_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AWB_STAT_ROI01                         ((0x1600  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_1     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_0     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI23                         ((0x1601  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_3     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_2     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI45                         ((0x1602  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_5     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_4     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI0_WIN01                    ((0x1603  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_roi_xywin_0_1     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_0_0     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI1_WIN01                    ((0x1604  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_roi_xywin_1_1     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_1_0     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI0_WIN23                    ((0x1605  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_roi_xywin_0_3     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_0_2     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI1_WIN23                    ((0x1606  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_roi_xywin_1_3     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_1_2     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI_EN_0                      ((0x1607  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_awb_roi_enable_0      // unsigned ,    RW, default = 1  enable of awb_roi_sta
//Bit  0           reg_awb_roi_mode_0        // unsigned ,    RW, default = 0  AWB statisic roi sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default=0
#define ISP_RO_AWB_ROI_STAT_PCK0_0                 ((0x1608  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awbroi_stat_pack0_0    // unsigned ,    RO, default = 0  LSB of the AWB roi statistic normalized, [31:16] AVG_GdivB or Red_avg,        [15:0] AVG_GdivRed or Gr_avg
#define ISP_RO_AWB_ROI_STAT_PCK1_0                 ((0x1609  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awbroi_stat_pack1_0    // unsigned ,    RO, default = 0  MSB of the AWB roi statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_STAT_ROI_EN_1                      ((0x160a  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_awb_roi_enable_1      // unsigned ,    RW, default = 1  enable of awb_roi_sta
//Bit  0           reg_awb_roi_mode_1        // unsigned ,    RW, default = 0  AWB statisic roi sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default=0
#define ISP_RO_AWB_ROI_STAT_PCK0_1                 ((0x160b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awbroi_stat_pack0_1    // unsigned ,    RO, default = 0  LSB of the AWB roi statistic normalized, [31:16] AVG_GdivB or Red_avg,        [15:0] AVG_GdivRed or Gr_avg
#define ISP_RO_AWB_ROI_STAT_PCK1_1                 ((0x160c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awbroi_stat_pack1_1    // unsigned ,    RO, default = 0  MSB of the AWB roi statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_CTRL                               ((0x160d  << 2) + 0xfe3b4000)
//Bit 31: 5        reserved
//Bit  4           reg_awb_stat_ratio_mode   // unsigned ,    RW, default = 1  0: ratio g/r and g/b, 1: ratio r/g and b/g, statistic ratio mode
//Bit  3: 2        reg_awb_xphs_ofst         // unsigned ,    RW, default = 1  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit  1: 0        reg_awb_yphs_ofst         // unsigned ,    RW, default = 0  phase shift for raw data for AE statistics, same as modules for corresponding block
#define ISP_AWB_HV_START                           ((0x160e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_stat_hstart       // unsigned ,    RW, default = 0  horizontal start for awb statistics
//Bit 15: 0        reg_awb_stat_vstart       // unsigned ,    RW, default = 0  vertical start for awb statistics
#define ISP_AWB_HV_SIZE                            ((0x160f  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_stat_hsize        // unsigned ,    RW, default = 1920  horizontal size for awb statistics
//Bit 15: 0        reg_awb_stat_vsize        // unsigned ,    RW, default = 1080  vertical size for awb statistics
#define ISP_AWB_HV_BLKNUM                          ((0x1610  << 2) + 0xfe3b4000)
//Bit 31:22        reserved
//Bit 21:16        reg_awb_stat_hblk_num     // unsigned ,    RW, default = 32  support max 33 horizontal blks for awb statistics
//Bit 15: 6        reserved
//Bit  5: 0        reg_awb_stat_vblk_num     // unsigned ,    RW, default = 24  support max 33 vertical blks for awb statistics
#define ISP_AWB_STAT_THD                           ((0x1611  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_max_thd      // unsigned ,    RW, default = 4095  max threshold for pixel intensity of awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_min_thd      // unsigned ,    RW, default = 0  min threshold for pixel intensity of awb
#define ISP_AWB_STAT_RG                            ((0x1612  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_rg_max       // unsigned ,    RW, default = 2048  u4.8, max value of r/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_rg_min       // unsigned ,    RW, default = 64  u4.8, min value of r/g in white region for awb
#define ISP_AWB_STAT_BG                            ((0x1613  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_bg_max       // unsigned ,    RW, default = 2048  u4.8, max value of b/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_bg_min       // unsigned ,    RW, default = 64  u4.8, min value of b/g in white region for awb
#define ISP_AWB_STAT_RG_HL                         ((0x1614  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_rg_high      // unsigned ,    RW, default = 4095  u4.8, high value of r/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_rg_low       // unsigned ,    RW, default = 0  u4.8, low value of r/g in white region for awb
#define ISP_AWB_STAT_BG_HL                         ((0x1615  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_bg_high      // unsigned ,    RW, default = 4095  u4.8, high value of b/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_bg_low       // unsigned ,    RW, default = 0  u4.8, low value of b/g in white region for awb
#define ISP_AWB_STAT_CTRL2                         ((0x1616  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12:11        reg_awb_luma_mode         // unsigned ,    RW, default = 2  blender mode between grn', red and blu to get luma for AWB STA: 0: cur; 1: MAX(grn',Red, BLU); 2/3: filter
//Bit 10: 9        reserved
//Bit  8           reg_awb_stat_input_format // unsigned ,    RW, default = 0  input frame buffer format: 0: raw; 1: RGB;  default = 0;
//Bit  7            reserved
//Bit  6           reg_awb_grn_use_avg       // unsigned ,    RW, default = 0  enable of Gb=Gr=(Gb+Gr+1)/2, 0: no average, 1: average
//Bit  5           reg_awb_glbal_useweight   // unsigned ,    RW, default = 1  global use regional weight, default=1
//Bit  4: 3        reg_awb_stat_luma_div_mode // unsigned ,    RW, default = 0  AWB separate STATS on Luma (x+1) ranges, Total STATS RAM same size, needs to reduce hblk_num/vblk_num if x>0. 0: no division; 1: div to 2 range; ...3: div to 4 ranges
//Bit  2           reg_awb_stat_local_mode   // unsigned ,    RW, default = 0  AWB statisic local sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default,0
//Bit  1           reg_awb_stat_glbal_mode   // unsigned ,    RW, default = 0  AWB statisic global sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default,0
//Bit  0           reg_awb_stat_satur_vald   // unsigned ,    RW, default = 0  AWB statistic over saturation control
#define ISP_AWB_STAT_BLC20_0                       ((0x1617  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_0      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_1                       ((0x1618  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_1      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_2                       ((0x1619  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_2      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_3                       ((0x161a  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_3      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_GAIN10_0                      ((0x161b  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_0     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_1                      ((0x161c  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_1     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_2                      ((0x161d  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_2     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_3                      ((0x161e  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_3     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_LDIV_01                       ((0x161f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_luma_divth_1 // unsigned ,    RW, default = 2000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_luma_divth_0 // unsigned ,    RW, default = 1000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
#define ISP_AWB_STAT_LDIV_2                        ((0x1620  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_awb_stat_luma_divth_2 // unsigned ,    RW, default = 3000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
#define ISP_AWB_STAT_SATUR_CTRL                    ((0x1621  << 2) + 0xfe3b4000)
//Bit 31:16        reg_awb_stat_satur_high   // unsigned ,    RW, default = 65535  AWB statistic over-saturation threshold
//Bit 15: 0        reg_awb_stat_satur_low    // unsigned ,    RW, default = 0  AWB statistic under-saturation threshold
#define ISP_RO_AWB_GLB_STAT_PCK0_0                 ((0x1622  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack0_0   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_0                 ((0x1623  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack1_0   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_1                 ((0x1624  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack0_1   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_1                 ((0x1625  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack1_1   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_2                 ((0x1626  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack0_2   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_2                 ((0x1627  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack1_2   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_3                 ((0x1628  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack0_3   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_3                 ((0x1629  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_glb_stat_pack1_3   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_DEBUG_IN_CHECKSUM                  ((0x162a  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_debug_in_checksum  // unsigned ,    RO, default = 0
#define ISP_AWB_DEBUG_PACK0_CHECKSUM               ((0x162b  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_debug_pack0_checksum // unsigned ,    RO, default = 0
#define ISP_AWB_DEBUG_PACK1_CHECKSUM               ((0x162c  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_awb_debug_pack1_checksum // unsigned ,    RO, default = 0
#define ISP_AWB_IDX_ADDR                           ((0x1680  << 2) + 0xfe3b4000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_awb_idx_addr      //unsigned  ,    RW, default = 0  addr for awb_idx
#define ISP_AWB_IDX_DATA                           ((0x1681  << 2) + 0xfe3b4000)
//Bit 31:16        reg_isp_awb_hidx_data     //unsigned  ,    RW, default = 0  data for awb_hidx
//Bit 15:0         reg_isp_awb_vidx_data     //unsigned  ,    RW, default = 0  data for awb_vidx
#define ISP_AWB_BLK_WT_ADDR                        ((0x1682  << 2) + 0xfe3b4000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_awb_blk_wt_addr   //unsigned  ,    RW, default = 0  addr for awb_weight
#define ISP_AWB_BLK_WT_DATA                        ((0x1683  << 2) + 0xfe3b4000)
//Bit 31:0         reg_isp_awb_blk_wt_data   //unsigned  ,    RW, default = 0  data for awb_weight
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_awb_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB0_APB_BASE = 0x17
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_TOP_TOP_CTRL                         ((0x1700  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP0_TOP_CRP2_START                       ((0x1701  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP0_TOP_CRP2_SIZE                        ((0x1702  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP0_TOP_OUT_SIZE                         ((0x1703  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP0_TOP_DITHER_EN                        ((0x1704  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP0_TOP_UV_DS_MODE                       ((0x1705  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP0_TOP_DTH_DATA                     ((0x1710  << 2) + 0xfe3b4000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP0_TOP_DTH_ADDR                     ((0x1711  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP0_TOP_TOP_REG                      ((0x1712  << 2) + 0xfe3b4000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP0_TOP_IN_SIZE                      ((0x1713  << 2) + 0xfe3b4000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP0_TOP_TOP_GLK                      ((0x1714  << 2) + 0xfe3b4000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_PPS_CLR                      ((0x1715  << 2) + 0xfe3b4000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_PPS_DBG_RO                   ((0x1716  << 2) + 0xfe3b4000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP0_TOP_SW_RST                       ((0x1717  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_HW_RE                        ((0x1718  << 2) + 0xfe3b4000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_csc1_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_CSC2_OFFSET_INP01                    ((0x1740  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_inp_0     // signed ,    RW, default = 0  csc1 offset input
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_1     // signed ,    RW, default = 0  csc1 offset input
#define DISP0_CSC2_OFFSET_INP2                     ((0x1741  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_2     // signed ,    RW, default = 0  csc1 offset input
#define DISP0_CSC2_COEF_00_01                      ((0x1742  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_0    // signed ,    RW, default = 218  csc1 matrix00
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_0_1    // signed ,    RW, default = 732  csc1 matrix01
#define DISP0_CSC2_COEF_02_10                      ((0x1743  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_2    // signed ,    RW, default = 74  csc1 matrix 02
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_0    // signed ,    RW, default = -117  csc1 matrix 10
#define DISP0_CSC2_COEF_11_12                      ((0x1744  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_1_1    // signed ,    RW, default = -395  csc1 matrix 11
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_2    // signed ,    RW, default = 512  csc1 matrix 12
#define DISP0_CSC2_COEF_20_21                      ((0x1745  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_2_0    // signed ,    RW, default = 512  csc1 matrix 20
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_1    // signed ,    RW, default = -465  csc1 matrix 21
#define DISP0_CSC2_COEF_22                         ((0x1746  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_2    // signed ,    RW, default = -48  csc1 matrix 22
#define DISP0_CSC2_OFFSET_OUP01                    ((0x1747  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_0     // signed ,    RW, default = 0  csc1 offset output
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_oup_1     // signed ,    RW, default = 2048  csc1 offset output
#define DISP0_CSC2_OFFSET_OUP2                     ((0x1748  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_2     // signed ,    RW, default = 2048  csc1 offset output
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc1_3x3mtrx_rs       // unsigned ,    RW, default = 2  coef shift, 0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_csc1_regs_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_PPS_SCALE_EN                         ((0x1780  << 2) + 0xfe3b4000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP0_PPS_PRE_HSCALE_COEF_0                ((0x1781  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_1                ((0x1782  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_2                ((0x1783  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_3                ((0x1784  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP0_PPS_PRE_VSCALE_COEF_0                ((0x1785  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_1                ((0x1786  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_2                ((0x1787  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_3                ((0x1788  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_VSC_START_PHASE_STEP             ((0x1789  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP0_PPS_VSC_LUMA_TOP_FIELD               ((0x178a  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP0_PPS_VSC_CHROMA_TOP_FIELD             ((0x178b  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP0_PPS_HSC_START_PHASE_STEP             ((0x178c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP0_PPS_HSC_LUMA_PHASE_CTRL              ((0x178d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP0_PPS_HSC_CHROMA_PHASE_CTRL            ((0x178e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP0_PPS_444TO422                         ((0x178f  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE0_COEF_IDX_LUMA                   ((0x1790  << 2) + 0xfe3b4000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_LUMA                       ((0x1791  << 2) + 0xfe3b4000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_IDX_CHRO                   ((0x1792  << 2) + 0xfe3b4000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_CHRO                       ((0x1793  << 2) + 0xfe3b4000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB1_APB_BASE = 0x18
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP1_TOP_TOP_CTRL                         ((0x1800  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP1_TOP_CRP2_START                       ((0x1801  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP1_TOP_CRP2_SIZE                        ((0x1802  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP1_TOP_OUT_SIZE                         ((0x1803  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP1_TOP_DITHER_EN                        ((0x1804  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP1_TOP_UV_DS_MODE                       ((0x1805  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP1_TOP_DTH_DATA                     ((0x1810  << 2) + 0xfe3b4000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP1_TOP_DTH_ADDR                     ((0x1811  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP1_TOP_TOP_REG                      ((0x1812  << 2) + 0xfe3b4000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP1_TOP_IN_SIZE                      ((0x1813  << 2) + 0xfe3b4000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP1_TOP_TOP_GLK                      ((0x1814  << 2) + 0xfe3b4000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_PPS_CLR                      ((0x1815  << 2) + 0xfe3b4000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_PPS_DBG_RO                   ((0x1816  << 2) + 0xfe3b4000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP1_TOP_SW_RST                       ((0x1817  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_HW_RE                        ((0x1818  << 2) + 0xfe3b4000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_csc1_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP1_CSC2_OFFSET_INP01                    ((0x1840  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_inp_0     // signed ,    RW, default = 0  csc1 offset input
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_1     // signed ,    RW, default = 0  csc1 offset input
#define DISP1_CSC2_OFFSET_INP2                     ((0x1841  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_2     // signed ,    RW, default = 0  csc1 offset input
#define DISP1_CSC2_COEF_00_01                      ((0x1842  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_0    // signed ,    RW, default = 218  csc1 matrix00
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_0_1    // signed ,    RW, default = 732  csc1 matrix01
#define DISP1_CSC2_COEF_02_10                      ((0x1843  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_2    // signed ,    RW, default = 74  csc1 matrix 02
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_0    // signed ,    RW, default = -117  csc1 matrix 10
#define DISP1_CSC2_COEF_11_12                      ((0x1844  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_1_1    // signed ,    RW, default = -395  csc1 matrix 11
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_2    // signed ,    RW, default = 512  csc1 matrix 12
#define DISP1_CSC2_COEF_20_21                      ((0x1845  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_2_0    // signed ,    RW, default = 512  csc1 matrix 20
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_1    // signed ,    RW, default = -465  csc1 matrix 21
#define DISP1_CSC2_COEF_22                         ((0x1846  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_2    // signed ,    RW, default = -48  csc1 matrix 22
#define DISP1_CSC2_OFFSET_OUP01                    ((0x1847  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_0     // signed ,    RW, default = 0  csc1 offset output
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_oup_1     // signed ,    RW, default = 2048  csc1 offset output
#define DISP1_CSC2_OFFSET_OUP2                     ((0x1848  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_2     // signed ,    RW, default = 2048  csc1 offset output
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc1_3x3mtrx_rs       // unsigned ,    RW, default = 2  coef shift, 0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_csc1_regs_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP1_PPS_SCALE_EN                         ((0x1880  << 2) + 0xfe3b4000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP1_PPS_PRE_HSCALE_COEF_0                ((0x1881  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_1                ((0x1882  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_2                ((0x1883  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_3                ((0x1884  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP1_PPS_PRE_VSCALE_COEF_0                ((0x1885  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_1                ((0x1886  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_2                ((0x1887  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_3                ((0x1888  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_VSC_START_PHASE_STEP             ((0x1889  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP1_PPS_VSC_LUMA_TOP_FIELD               ((0x188a  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP1_PPS_VSC_CHROMA_TOP_FIELD             ((0x188b  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP1_PPS_HSC_START_PHASE_STEP             ((0x188c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP1_PPS_HSC_LUMA_PHASE_CTRL              ((0x188d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP1_PPS_HSC_CHROMA_PHASE_CTRL            ((0x188e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP1_PPS_444TO422                         ((0x188f  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE1_COEF_IDX_LUMA                   ((0x1890  << 2) + 0xfe3b4000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_LUMA                       ((0x1891  << 2) + 0xfe3b4000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_IDX_CHRO                   ((0x1892  << 2) + 0xfe3b4000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_CHRO                       ((0x1893  << 2) + 0xfe3b4000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB2_APB_BASE = 0x19
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_2.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP2_TOP_TOP_CTRL                         ((0x1900  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP2_TOP_CRP2_START                       ((0x1901  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP2_TOP_CRP2_SIZE                        ((0x1902  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP2_TOP_OUT_SIZE                         ((0x1903  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP2_TOP_DITHER_EN                        ((0x1904  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP2_TOP_UV_DS_MODE                       ((0x1905  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP2_TOP_DTH_DATA                     ((0x1910  << 2) + 0xfe3b4000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP2_TOP_DTH_ADDR                     ((0x1911  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP2_TOP_TOP_REG                      ((0x1912  << 2) + 0xfe3b4000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP2_TOP_IN_SIZE                      ((0x1913  << 2) + 0xfe3b4000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP2_TOP_TOP_GLK                      ((0x1914  << 2) + 0xfe3b4000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_PPS_CLR                      ((0x1915  << 2) + 0xfe3b4000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_PPS_DBG_RO                   ((0x1916  << 2) + 0xfe3b4000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP2_TOP_SW_RST                       ((0x1917  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_HW_RE                        ((0x1918  << 2) + 0xfe3b4000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_csc1_regs_2.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP2_CSC2_OFFSET_INP01                    ((0x1940  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_inp_0     // signed ,    RW, default = 0  csc1 offset input
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_1     // signed ,    RW, default = 0  csc1 offset input
#define DISP2_CSC2_OFFSET_INP2                     ((0x1941  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_2     // signed ,    RW, default = 0  csc1 offset input
#define DISP2_CSC2_COEF_00_01                      ((0x1942  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_0    // signed ,    RW, default = 218  csc1 matrix00
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_0_1    // signed ,    RW, default = 732  csc1 matrix01
#define DISP2_CSC2_COEF_02_10                      ((0x1943  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_2    // signed ,    RW, default = 74  csc1 matrix 02
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_0    // signed ,    RW, default = -117  csc1 matrix 10
#define DISP2_CSC2_COEF_11_12                      ((0x1944  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_1_1    // signed ,    RW, default = -395  csc1 matrix 11
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_2    // signed ,    RW, default = 512  csc1 matrix 12
#define DISP2_CSC2_COEF_20_21                      ((0x1945  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_2_0    // signed ,    RW, default = 512  csc1 matrix 20
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_1    // signed ,    RW, default = -465  csc1 matrix 21
#define DISP2_CSC2_COEF_22                         ((0x1946  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_2    // signed ,    RW, default = -48  csc1 matrix 22
#define DISP2_CSC2_OFFSET_OUP01                    ((0x1947  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_0     // signed ,    RW, default = 0  csc1 offset output
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_oup_1     // signed ,    RW, default = 2048  csc1 offset output
#define DISP2_CSC2_OFFSET_OUP2                     ((0x1948  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_2     // signed ,    RW, default = 2048  csc1 offset output
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc1_3x3mtrx_rs       // unsigned ,    RW, default = 2  coef shift, 0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_csc1_regs_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_2.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP2_PPS_SCALE_EN                         ((0x1980  << 2) + 0xfe3b4000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP2_PPS_PRE_HSCALE_COEF_0                ((0x1981  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_1                ((0x1982  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_2                ((0x1983  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_3                ((0x1984  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP2_PPS_PRE_VSCALE_COEF_0                ((0x1985  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_1                ((0x1986  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_2                ((0x1987  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_3                ((0x1988  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_VSC_START_PHASE_STEP             ((0x1989  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP2_PPS_VSC_LUMA_TOP_FIELD               ((0x198a  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP2_PPS_VSC_CHROMA_TOP_FIELD             ((0x198b  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP2_PPS_HSC_START_PHASE_STEP             ((0x198c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP2_PPS_HSC_LUMA_PHASE_CTRL              ((0x198d  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP2_PPS_HSC_CHROMA_PHASE_CTRL            ((0x198e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP2_PPS_444TO422                         ((0x198f  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE2_COEF_IDX_LUMA                   ((0x1990  << 2) + 0xfe3b4000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_LUMA                       ((0x1991  << 2) + 0xfe3b4000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_IDX_CHRO                   ((0x1992  << 2) + 0xfe3b4000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_CHRO                       ((0x1993  << 2) + 0xfe3b4000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_2.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB3_APB_BASE = 0x1a
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_3.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP3_TOP_TOP_CTRL                         ((0x1a00  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP3_TOP_CRP2_START                       ((0x1a01  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP3_TOP_CRP2_SIZE                        ((0x1a02  << 2) + 0xfe3b4000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP3_TOP_OUT_SIZE                         ((0x1a03  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP3_TOP_DITHER_EN                        ((0x1a04  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP3_TOP_UV_DS_MODE                       ((0x1a05  << 2) + 0xfe3b4000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP3_TOP_DTH_DATA                     ((0x1a10  << 2) + 0xfe3b4000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP3_TOP_DTH_ADDR                     ((0x1a11  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP3_TOP_TOP_REG                      ((0x1a12  << 2) + 0xfe3b4000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP3_TOP_IN_SIZE                      ((0x1a13  << 2) + 0xfe3b4000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP3_TOP_TOP_GLK                      ((0x1a14  << 2) + 0xfe3b4000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP3_TOP_PPS_CLR                      ((0x1a15  << 2) + 0xfe3b4000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP3_TOP_PPS_DBG_RO                   ((0x1a16  << 2) + 0xfe3b4000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP3_TOP_SW_RST                       ((0x1a17  << 2) + 0xfe3b4000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP3_TOP_HW_RE                        ((0x1a18  << 2) + 0xfe3b4000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_3.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_csc1_regs_3.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP3_CSC2_OFFSET_INP01                    ((0x1a40  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_inp_0     // signed ,    RW, default = 0  csc1 offset input
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_1     // signed ,    RW, default = 0  csc1 offset input
#define DISP3_CSC2_OFFSET_INP2                     ((0x1a41  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_2     // signed ,    RW, default = 0  csc1 offset input
#define DISP3_CSC2_COEF_00_01                      ((0x1a42  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_0    // signed ,    RW, default = 218  csc1 matrix00
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_0_1    // signed ,    RW, default = 732  csc1 matrix01
#define DISP3_CSC2_COEF_02_10                      ((0x1a43  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_2    // signed ,    RW, default = 74  csc1 matrix 02
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_0    // signed ,    RW, default = -117  csc1 matrix 10
#define DISP3_CSC2_COEF_11_12                      ((0x1a44  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_1_1    // signed ,    RW, default = -395  csc1 matrix 11
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_2    // signed ,    RW, default = 512  csc1 matrix 12
#define DISP3_CSC2_COEF_20_21                      ((0x1a45  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_2_0    // signed ,    RW, default = 512  csc1 matrix 20
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_1    // signed ,    RW, default = -465  csc1 matrix 21
#define DISP3_CSC2_COEF_22                         ((0x1a46  << 2) + 0xfe3b4000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_2    // signed ,    RW, default = -48  csc1 matrix 22
#define DISP3_CSC2_OFFSET_OUP01                    ((0x1a47  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_0     // signed ,    RW, default = 0  csc1 offset output
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_oup_1     // signed ,    RW, default = 2048  csc1 offset output
#define DISP3_CSC2_OFFSET_OUP2                     ((0x1a48  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_2     // signed ,    RW, default = 2048  csc1 offset output
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc1_3x3mtrx_rs       // unsigned ,    RW, default = 2  coef shift, 0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_csc1_regs_3.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB0_APB_BASE = 0x1b
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_top_reg.h
//
#define ISP_INTF_TOP_CTRL                          ((0x1b00  << 2) + 0xfe3b4000)
//Bit 31:28  reserved
//Bit 27:16  reg_intf_force_en             // unsigned ,    RW, default = 0,{wr{meta,mv,mix,pix},rd{meta,mv,mix,pix}
//Bit 15:4   reg_intf_force_val            // unsigned ,    RW, default = 0,{wr{meta,mv,mix,pix},rd{meta,mv,mix,pix}
//Bit 3:1    reserved
//Bit 0      reg_intf_sw_rst               // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_EN                        ((0x1b01  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_irq_en                // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_CLR                       ((0x1b02  << 2) + 0xfe3b4000)
//Bit 31:0  pls_intf_irq_clr               // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_GCLK_CLR                      ((0x1b03  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  reg_gclk_ctrl                  // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_STATS                     ((0x1b04  << 2) + 0xfe3b4000)
//Bit 31:0  ro_intf_irq_status             // unsigned ,    RO, default = 0
#define ISP_INTF_IDMAP_WRARB0_L                    ((0x1b05  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_wrarb0_l        // unsigned ,    RW, default = 32'h11110000
#define ISP_INTF_IDMAP_WRARB0_H                    ((0x1b06  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_wrarb0_h        // unsigned ,    RW, default = 32'h33332222
#define ISP_INTF_IDMAP_WRARB1_L                    ((0x1b07  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_wrarb1_l        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_WRARB1_H                    ((0x1b08  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_wrarb1_h        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_RDRB0_L                     ((0x1b09  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_rdarb0_l        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_RDARB0_H                    ((0x1b0a  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_rdarb0_h        // unsigned ,    RW, default = 32'h77777777
#define ISP_INTF_IDMAP_RDRB1_L                     ((0x1b0b  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_rdarb1_l        // unsigned ,    RW, default = 32'h32103210
#define ISP_INTF_IDMAP_RDARB1_H                    ((0x1b0c  << 2) + 0xfe3b4000)
//Bit 31:0  reg_intf_idmap_rdarb1_h        // unsigned ,    RW, default = 32'h32103210
#define ISP_INTF_LOSSE_CTRL                        ((0x1b10  << 2) + 0xfe3b4000)
//Bit 31:25  reserved
//Bit 24:16  reg_losse1_slice_num          // unsigned ,    RW, default = 1
//Bit 15:9   reserved
//Bit 8 :0   reg_losse0_slice_num          // unsigned ,    RW, default = 1
#define ISP_INTF_LOSSE0_SIZE                       ((0x1b11  << 2) + 0xfe3b4000)
//Bit 31:29  reserved
//Bit 28:16  reg_losse0_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_losse0_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSE1_SIZE                       ((0x1b12  << 2) + 0xfe3b4000)
//Bit 31:29  reserved
//Bit 28:16  reg_losse1_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_losse1_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSD_CTRL                        ((0x1b13  << 2) + 0xfe3b4000)
//Bit 31:26  reserved
//Bit 25     reg_lossd1_mif_mode            // unsigned ,    RW, default = 1
//Bit 24:16  reg_lossd1_slice_num           // unsigned ,    RW, default = 1
//Bit 15:10  reserved
//Bit 9      reg_lossd0_mif_mode            // unsigned ,    RW, default = 1
//Bit 8 :0   reg_lossd0_slice_num           // unsigned ,    RW, default = 1
#define ISP_INTF_LOSSD0_SIZE                       ((0x1b14  << 2) + 0xfe3b4000)
//Bit 31:29  reserved
//Bit 28:16  reg_lossd0_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_lossd0_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSD1_SIZE                       ((0x1b15  << 2) + 0xfe3b4000)
//Bit 31:29  reserved
//Bit 28:16  reg_lossd1_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_lossd1_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSS_LOOP0_CTRL                   ((0x1b16  << 2) + 0xfe3b4000)
//Bit 31:8  reserved
//Bit  7:4  reg_loop0_num                   // unsigned ,    RW, default = 2
//Bit  3:2  reserved
//Bit    1  reg_loop0_loss_en               // unsigned ,    RW, default = 0
//Bit    0  reg_loop0_en                    // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP1_CTRL                   ((0x1b17  << 2) + 0xfe3b4000)
//Bit 31:8  reserved
//Bit  7:4  reg_loop1_num                   // unsigned ,    RW, default = 2
//Bit  3:2  reserved
//Bit    1  reg_loop1_loss_en               // unsigned ,    RW, default = 0
//Bit    0  reg_loop1_en                    // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP0_BADDR00                ((0x1b20  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_link_adr0           // unsigned ,    RW, default = 32'h5000000
#define ISP_INTF_LOSS_LOOP0_BADDR01                ((0x1b21  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_link_adr1           // unsigned ,    RW, default = 32'h5100000
#define ISP_INTF_LOSS_LOOP0_BADDR02                ((0x1b22  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_link_adr2           // unsigned ,    RW, default = 32'h5200000
#define ISP_INTF_LOSS_LOOP0_BADDR03                ((0x1b23  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_link_adr3           // unsigned ,    RW, default = 32'h5300000
#define ISP_INTF_LOSS_LOOP0_BADDR10                ((0x1b24  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_slice_adr0           // unsigned ,    RW, default = 32'h6000000
#define ISP_INTF_LOSS_LOOP0_BADDR11                ((0x1b25  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_slice_adr1           // unsigned ,    RW, default = 32'h7000000
#define ISP_INTF_LOSS_LOOP0_BADDR12                ((0x1b26  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_slice_adr2           // unsigned ,    RW, default = 32'h8000000
#define ISP_INTF_LOSS_LOOP0_BADDR13                ((0x1b27  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop0_slice_adr3           // unsigned ,    RW, default = 32'h9000000
#define ISP_INTF_LOSS_LOOP1_BADDR00                ((0x1b30  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_link_adr0           // unsigned ,    RW, default = 32'h5400000
#define ISP_INTF_LOSS_LOOP1_BADDR01                ((0x1b31  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_link_adr1           // unsigned ,    RW, default = 32'h5500000
#define ISP_INTF_LOSS_LOOP1_BADDR02                ((0x1b32  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_link_adr2           // unsigned ,    RW, default = 32'h5600000
#define ISP_INTF_LOSS_LOOP1_BADDR03                ((0x1b33  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_link_adr3           // unsigned ,    RW, default = 32'h5700000
#define ISP_INTF_LOSS_LOOP1_BADDR10                ((0x1b34  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_slice_adr0           // unsigned ,    RW, default = 32'h16000000
#define ISP_INTF_LOSS_LOOP1_BADDR11                ((0x1b35  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_slice_adr1           // unsigned ,    RW, default = 32'h17000000
#define ISP_INTF_LOSS_LOOP1_BADDR12                ((0x1b36  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_slice_adr2           // unsigned ,    RW, default = 32'h18000000
#define ISP_INTF_LOSS_LOOP1_BADDR13                ((0x1b37  << 2) + 0xfe3b4000)
//Bit  31:0 reg_loop1_slice_adr3           // unsigned ,    RW, default = 32'h19000000
#define ISP_INTF_LOSS_LOOP0_SW                     ((0x1b38  << 2) + 0xfe3b4000)
//Bit  31:28 reserved
//Bit  27:24 reg_loop0_lossen_sw_sel         // unsigned ,    RW, default = 4
//Bit  23:22 reserved
//Bit  21:20 reg_loop0_lossen_sw_val         // unsigned ,    RW, default = 0
//Bit  19:18 reserved
//Bit  17:16 reg_loop0_lossen_sw_en          // unsigned ,    RW, default = 0
//Bit  15:8  reg_loop0_idx_sw_val            // unsigned ,    RW, default = 0
//Bit  7:4   reg_loop0_idx_sw_sel            // unsigned ,    RW, default = 4
//Bit  3:2   reserved
//Bit  1:0   reg_loop0_idx_sw_en             // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP1_SW                     ((0x1b39  << 2) + 0xfe3b4000)
//Bit  31:28 reserved
//Bit  27:24 reg_loop1_lossen_sw_sel         // unsigned ,    RW, default = 4
//Bit  23:22 reserved
//Bit  21:20 reg_loop1_lossen_sw_val         // unsigned ,    RW, default = 0
//Bit  19:18 reserved
//Bit  17:16 reg_loop1_lossen_sw_en          // unsigned ,    RW, default = 0
//Bit  15:8  reg_loop1_idx_sw_val            // unsigned ,    RW, default = 0
//Bit  7:4   reg_loop1_idx_sw_sel            // unsigned ,    RW, default = 4
//Bit  3:2   reserved
//Bit  1:0   reg_loop1_idx_sw_en             // unsigned ,    RW, default = 0
#define ISP_INTF_CHECKSUM_CTRL                     ((0x1b40  << 2) + 0xfe3b4000)
//Bit  31:8  reserved
//Bit  7:4   reg_checksum_sel                // unsigned ,    RW, default = 0
//Bit  3:1   reserved
//Bit  0     reg_checksum_en                 // unsigned ,    RW, default = 0
#define ISP_INTF_CHECKSUM_RO0                      ((0x1b41  << 2) + 0xfe3b4000)
//Bit  31:0  ro_checksum_in                  // unsigned ,    RO, default = 0
#define ISP_INTF_CHECKSUM_RO1                      ((0x1b42  << 2) + 0xfe3b4000)
//Bit  31:0  ro_checksum_out                 // unsigned ,    RO, default = 0
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_top_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF0_CTRL1                            ((0x1b80  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF0_CTRL2                            ((0x1b81  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF0_CTRL3                            ((0x1b82  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF0_CTRL4                            ((0x1b83  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF0_SCOPE_X                          ((0x1b84  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF0_SCOPE_Y                          ((0x1b85  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF0_RO_STAT                          ((0x1b86  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF0_CTRL5                            ((0x1b87  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_rdmifx3_reg_0.h
//
//==========================================================================
// NOR_RD_MIF
//==========================================================================
#define ISP_RDMIF1_GEN_REG                         ((0x1bc0  << 2) + 0xfe3b4000)
//Bit 31        reg_enable_free_clk                //unsigned, RW, default = 0
//Bit 30        reserved                            //unsigned, pulse reg_sw_reset
//Bit 29        reg_reset_on_go_field              //unsigned, RW, default = 0
//Bit 28        reg_urgent_chroma                  //unsigned, RW, default = 0
//Bit 27        reg_urgent_luma                    //unsigned, RW, default = 0
//Bit 26        reg_chroma_end_at_last_line        //unsigned, RW, default = 0
//Bit 25        reg_luma_end_at_last_line          //unsigned, RW, default = 0
//Bit 24:19     reg_hold_lines[5:0]                //unsigned, RW, default = 6'h4
//Bit 18        reg_last_line_mode                 //unsigned, RW, default = 1'b1
//Bit 17        ro_busy                            //unsigned, RO, default = 0 //used as busy readback, ro ?
//Bit 16        reg_demux_mode                     //unsigned, RW, default = 0
//Bit 15:14     reg_bytes_per_pixel                //unsigned, RW, default = 0
//Bit 13:12     reg_ddr_burst_size_cr              //unsigned, RW, default = 0
//Bit 11:10     reg_ddr_burst_size_cb              //unsigned, RW, default = 0
//Bit 9:8       reg_ddr_burst_size_y               //unsigned, RW, default = 0
//Bit 7         reserved                           //unsigned, pulse reg_start_frame_man
//Bit 6         reg_chro_rpt_lastl                 //unsigned, RW, default = 0
//Bit 5         reserved                           //unsigned,
//Bit 4         reg_little_endian                  //unsigned, RW, default = 0
//Bit 3         reg_chroma_hz_avg                  //unsigned, RW, default = 0
//Bit 2         reg_luma_hz_avg                    //unsigned, RW, default = 0
//Bit 1         reg_st_separate_en                 //unsigned, RW, default = 0
//Bit 0         reg_enable                         //unsigned, RW, default = 0
#define ISP_RDMIF1_CANVAS0                         ((0x1bc1  << 2) + 0xfe3b4000)
//Bit 31        reg_canvas0_addr_syncen            //unsigned, RW, default = 0
//Bit 30:24     reserved
//Bit 23:16     reg_canvas0_addr2                  //unsigned, RW, default = 0
//Bit 15:8      reg_canvas0_addr1                  //unsigned, RW, default = 0
//Bit 7:0       reg_canvas0_addr0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA_X0                         ((0x1bc3  << 2) + 0xfe3b4000)
//Bit 31        reserved
//Bit 30:16     reg_luma_x_end0                    //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      reg_luma_x_start0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA_Y0                         ((0x1bc4  << 2) + 0xfe3b4000)
//Bit 31:29     reserved
//Bit 28:16     reg_luma_y_end0                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_luma_y_start0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA_X0                       ((0x1bc5  << 2) + 0xfe3b4000)
//Bit 31        reserved
//Bit 30:16     reg_chroma_x_end0                  //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      reg_chroma_x_start0                //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA_Y0                       ((0x1bc6  << 2) + 0xfe3b4000)
//Bit 31:29     reserved
//Bit 28:16     reg_chroma_y_end0                  //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_chroma_y_start0                //unsigned, RW, default = 0
#define ISP_RDMIF1_RPT_LOOP                        ((0x1bcb  << 2) + 0xfe3b4000)
//Bit 31:16     reserved
//Bit 15:8      reg_chroma_rpt_loop0               //unsigned, RW, default = 0
//Bit 7:0       reg_luma_rpt_loop0                 //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA0_RPT_PAT                   ((0x1bcc  << 2) + 0xfe3b4000)
//Bit 31:0      reg_luma_rpt_pat0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA0_RPT_PAT                 ((0x1bcd  << 2) + 0xfe3b4000)
//Bit 31:0      reg_chroma_rpt_pat0                //unsigned, RW, default = 0
#define ISP_RDMIF1_DUMMY_PIXEL                     ((0x1bd2  << 2) + 0xfe3b4000)
//Bit 31:0      reg_dummy_pixel_val                //unsigned, RW, default = 32'h00808000
#define ISP_RDMIF1_LUMA_FIFO_SIZE                  ((0x1bd3  << 2) + 0xfe3b4000)
//Bit 31:13     reserved
//Bit 12:0      reg_luma_fifo_size                 //unsigned, RW, default = 13'h80
#define ISP_RDMIF1_AXI_CMD_CNT                     ((0x1bd4  << 2) + 0xfe3b4000)
//Bit 31:0      ro_axi_cmd_cnt_sel                  //unsigned, RO, default = 0
#define ISP_RDMIF1_AXI_RDAT_CNT                    ((0x1bd5  << 2) + 0xfe3b4000)
//Bit 31:0      ro_axi_rdat_cnt_sel                 //unsigned, RO, default = 0
#define ISP_RDMIF1_RANGE_MAP_Y                     ((0x1bd6  << 2) + 0xfe3b4000)
//Bit 31:23     reg_din_offset_y                   //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_y               //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_y                 //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_y                  //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_y                 //unsigned, RW, default = 0
#define ISP_RDMIF1_RANGE_MAP_CB                    ((0x1bd7  << 2) + 0xfe3b4000)
//Bit 31:23     reg_din_offset_cb                  //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_cb              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_cb                //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_cb                 //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_cb                //unsigned, RW, default = 0
#define ISP_RDMIF1_RANGE_MAP_CR                    ((0x1bd8  << 2) + 0xfe3b4000)
//Bit 31:23     reg_din_offset_cr                  //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_cr              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_cr                //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_cr                 //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_cr                //unsigned, RW, default = 0
#define ISP_RDMIF1_GEN_REG2                        ((0x1bd9  << 2) + 0xfe3b4000)
//Bit 31:30     reserved
//Bit 29        reg_chroma_line_read_sel           //unsigned, RW, default = 0
//Bit 28        reg_luma_line_read_sel             //unsigned, RW, default = 0
//Bit 27:26     reserved
//Bit 25:24     reg_shift_pat_cr                   //unsigned, RW, default = 0
//Bit 23:18     reserved
//Bit 17:16     reg_shift_pat_cb                   //unsigned, RW, default = 0
//Bit 15:10     reserved
//Bit 9:8       reg_shift_pat_y                    //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6         reg_hold_lines[6]                  //unsigned, RW, default = 0
//Bit 5         reserved
//Bit 4         reserved
//Bit 3         reg_y_rev0                         //unsigned, RW, default = 0
//Bit 2         reg_x_rev0                         //unsigned, RW, default = 0
//Bit 1:0       reg_color_map                      //unsigned, RW, default = 0
#define ISP_RDMIF1_URGENT_CTRL                     ((0x1bdb  << 2) + 0xfe3b4000)
//Bit 31:16     reg_urgent_ctrl_luma               //unsigned, RW, default = 0
//Bit 15:0      reg_urgent_ctrl_chroma             //unsigned, RW, default = 0
#define ISP_RDMIF1_GEN_REG3                        ((0x1bdc  << 2) + 0xfe3b4000)
//Bit 31:27     reserved
//Bit 26        reg_f0_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        reg_f0_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        reg_f0_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     reg_f0_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     reg_f0_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     reg_f0_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17:16     reg_abort_mode                     //unsigned, RW, default = 0
//Bit 15:14     reg_burst_len2                     //unsigned, RW, default = 2'd2
//Bit 13:12     reg_burst_len1                     //unsigned, RW, default = 2'd2
//Bit 11:10     reg_dbg_mode                       //unsigned, RW, default = 0
//Bit 9:8       reg_bits_mode                      //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6:4       reg_blk_len                        //unsigned, RW, default = 3'd3
//Bit 3         reserved
//Bit 2:1       reg_burst_len0                     //unsigned, RW, default = 2'd2
//Bit 0         reg_64bit_rev                      //unsigned, RW, default = 1'b1
#define ISP_RDMIF1_CFMT_CTRL                       ((0x1bdd  << 2) + 0xfe3b4000)
//Bit 31        reg_cfmt_gclk_bit_dis              //unsigned, RW, default = 0;
//Bit 30        reg_cfmt_soft_rst_bit              //unsigned, RW, default = 0;
//Bit 29        reserved
//Bit 28        reg_chfmt_rpt_pix                  //unsigned, RW, default = 0;
//Bit 27:24     reg_chfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 23        reg_chfmt_rpt_p0_en                //unsigned, RW, default = 0;
//Bit 22:21     reg_chfmt_yc_ratio                 //unsigned, RW, default = 0;
//Bit 20        reg_chfmt_en                       //unsigned, RW, default = 0;
//Bit 19        reg_cvfmt_phase0_always_en         //unsigned, RW, default = 0;
//Bit 18        reg_cvfmt_rpt_last_dis             //unsigned, RW, default = 0;
//Bit 17        reg_cvfmt_phase0_nrpt_en           //unsigned, RW, default = 0;
//Bit 16        reg_cvfmt_rpt_line0_en             //unsigned, RW, default = 0;
//Bit 15:12     reg_cvfmt_skip_line_num            //unsigned, RW, default = 0;
//Bit 11:8      reg_cvfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 7:1       reg_cvfmt_phase_step               //unsigned, RW, default = 0;
//Bit 0         reg_cvfmt_en                       //unsigned, RW, default = 0;
#define ISP_RDMIF1_CFMT_W                          ((0x1bde  << 2) + 0xfe3b4000)
//Bit 31        reg_dbg_mode_ctrl1                 //unsigned, RW, default = 0;
//Bit 30        reg_dbg_mode_ctrl0                 //unsigned, RW, default = 0;
//Bit 29        reserved
//Bit 28:16     reg_chfmt_w                        //unsigned, RW, default = 0;
//Bit 15:13     reserved
//Bit 12:0      reg_cvfmt_w                        //unsigned, RW, default = 0;
#define ISP_RDMIF1_BADDR_Y                         ((0x1be0  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f0_baddr_y                        //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CB                        ((0x1be1  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f0_baddr_cb                       //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CR                        ((0x1be2  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f0_baddr_cr                       //unsigned, RW, default = 0
#define ISP_RDMIF1_STRIDE_0                        ((0x1be3  << 2) + 0xfe3b4000)
//Bit 31:29     reserved
//Bit 28:16     reg_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      reg_f0_stride_y                       //unsigned, RW, default = 256
#define ISP_RDMIF1_STRIDE_1                        ((0x1be4  << 2) + 0xfe3b4000)
//Bit 31:17     reserved
//Bit 16        reg_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_f0_stride_cr                      //unsigned, RW, default = 256
#define ISP_RDMIF1_BADDR_Y_F1                      ((0x1be5  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f1_baddr_y                     //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CB_F1                     ((0x1be6  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f1_baddr_cb                    //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CR_F1                     ((0x1be7  << 2) + 0xfe3b4000)
//Bit 31:0      reg_f1_baddr_cr                    //unsigned, RW, default = 0
#define ISP_RDMIF1_STRIDE_0_F1                     ((0x1be8  << 2) + 0xfe3b4000)
//Bit 31:29     reserved
//Bit 28:16     reg_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      reg_f1_stride_y                    //unsigned, RW, default = 256;
#define ISP_RDMIF1_STRIDE_1_F1                     ((0x1be9  << 2) + 0xfe3b4000)
//Bit 31:26     reserved
//Bit 25        reg_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 24        reg_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 23        reg_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 22:21     reg_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 20:19     reg_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 18:17     reg_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 16        reg_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_f1_stride_cr                   //unsigned, RW, default = 256
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_rdmifx3_reg_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB1_APB_BASE = 0x1c
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_0_CH0_CTRL0                    ((0x1c00  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH0_CTRL1                    ((0x1c01  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_CH1_CTRL0                    ((0x1c02  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH1_CTRL1                    ((0x1c03  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_CH2_CTRL0                    ((0x1c04  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH2_CTRL1                    ((0x1c05  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_BIT_FORCE                    ((0x1c06  << 2) + 0xfe3b4000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_0_WIN_LUMA_H                   ((0x1c08  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_0_WIN_LUMA_V                   ((0x1c09  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_0_WIN_CHROM_H                  ((0x1c0a  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_0_WIN_CHROM_V                  ((0x1c0b  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_0_CH0_BADDR                    ((0x1c10  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH1_BADDR                    ((0x1c11  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH2_BADDR                    ((0x1c12  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH0_BADDR_OFST               ((0x1c13  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_CH1_BADDR_OFST               ((0x1c14  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_CH2_BADDR_OFST               ((0x1c15  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_BADDR_OFSTEN                 ((0x1c16  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_0_TIMCTRL                      ((0x1c17  << 2) + 0xfe3b4000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_0_FMT_SIZE                     ((0x1c19  << 2) + 0xfe3b4000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_0_FMT_CTRL                     ((0x1c1a  << 2) + 0xfe3b4000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7     reserved
//Bit 6     reg_mtx_rgb_swap            //unsigned, RW, default = 0, 0:{r,g,b} 1:{b,g,r}
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reg_mtx_yc_swap             //unsigned, RW, default = 0, 0:{y,c} 1:{c,y}
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_0_GCLK                         ((0x1c1d  << 2) + 0xfe3b4000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_RO_STAT                      ((0x1c1e  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_RO_CH01                      ((0x1c20  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_RO_CH2                       ((0x1c21  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_CRP_CTR                      ((0x1c22  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CRP_HSIZE                    ((0x1c23  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CRP_VSIZE                    ((0x1c24  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_1_CH0_CTRL0                    ((0x1c40  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH0_CTRL1                    ((0x1c41  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_CH1_CTRL0                    ((0x1c42  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH1_CTRL1                    ((0x1c43  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_CH2_CTRL0                    ((0x1c44  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH2_CTRL1                    ((0x1c45  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_BIT_FORCE                    ((0x1c46  << 2) + 0xfe3b4000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_1_WIN_LUMA_H                   ((0x1c48  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_1_WIN_LUMA_V                   ((0x1c49  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_1_WIN_CHROM_H                  ((0x1c4a  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_1_WIN_CHROM_V                  ((0x1c4b  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_1_CH0_BADDR                    ((0x1c50  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH1_BADDR                    ((0x1c51  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH2_BADDR                    ((0x1c52  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH0_BADDR_OFST               ((0x1c53  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_CH1_BADDR_OFST               ((0x1c54  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_CH2_BADDR_OFST               ((0x1c55  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_BADDR_OFSTEN                 ((0x1c56  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_1_TIMCTRL                      ((0x1c57  << 2) + 0xfe3b4000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_1_FMT_SIZE                     ((0x1c59  << 2) + 0xfe3b4000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_1_FMT_CTRL                     ((0x1c5a  << 2) + 0xfe3b4000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7     reserved
//Bit 6     reg_mtx_rgb_swap            //unsigned, RW, default = 0, 0:{r,g,b} 1:{b,g,r}
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reg_mtx_yc_swap             //unsigned, RW, default = 0, 0:{y,c} 1:{c,y}
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_1_GCLK                         ((0x1c5d  << 2) + 0xfe3b4000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_RO_STAT                      ((0x1c5e  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_RO_CH01                      ((0x1c60  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_RO_CH2                       ((0x1c61  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_CRP_CTR                      ((0x1c62  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CRP_HSIZE                    ((0x1c63  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CRP_VSIZE                    ((0x1c64  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_2_CH0_CTRL0                    ((0x1c80  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH0_CTRL1                    ((0x1c81  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_CH1_CTRL0                    ((0x1c82  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH1_CTRL1                    ((0x1c83  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_CH2_CTRL0                    ((0x1c84  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH2_CTRL1                    ((0x1c85  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_BIT_FORCE                    ((0x1c86  << 2) + 0xfe3b4000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_2_WIN_LUMA_H                   ((0x1c88  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_2_WIN_LUMA_V                   ((0x1c89  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_2_WIN_CHROM_H                  ((0x1c8a  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_2_WIN_CHROM_V                  ((0x1c8b  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_2_CH0_BADDR                    ((0x1c90  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH1_BADDR                    ((0x1c91  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH2_BADDR                    ((0x1c92  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH0_BADDR_OFST               ((0x1c93  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_CH1_BADDR_OFST               ((0x1c94  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_CH2_BADDR_OFST               ((0x1c95  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_BADDR_OFSTEN                 ((0x1c96  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_2_TIMCTRL                      ((0x1c97  << 2) + 0xfe3b4000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_2_FMT_SIZE                     ((0x1c99  << 2) + 0xfe3b4000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_2_FMT_CTRL                     ((0x1c9a  << 2) + 0xfe3b4000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7     reserved
//Bit 6     reg_mtx_rgb_swap            //unsigned, RW, default = 0, 0:{r,g,b} 1:{b,g,r}
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reg_mtx_yc_swap             //unsigned, RW, default = 0, 0:{y,c} 1:{c,y}
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_2_GCLK                         ((0x1c9d  << 2) + 0xfe3b4000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_RO_STAT                      ((0x1c9e  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_RO_CH01                      ((0x1ca0  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_RO_CH2                       ((0x1ca1  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_CRP_CTR                      ((0x1ca2  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CRP_HSIZE                    ((0x1ca3  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CRP_VSIZE                    ((0x1ca4  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_3.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_3_CH0_CTRL0                    ((0x1cc0  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_3_CH0_CTRL1                    ((0x1cc1  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_3_CH1_CTRL0                    ((0x1cc2  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_3_CH1_CTRL1                    ((0x1cc3  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_3_CH2_CTRL0                    ((0x1cc4  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_3_CH2_CTRL1                    ((0x1cc5  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_3_BIT_FORCE                    ((0x1cc6  << 2) + 0xfe3b4000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_3_WIN_LUMA_H                   ((0x1cc8  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_3_WIN_LUMA_V                   ((0x1cc9  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_3_WIN_CHROM_H                  ((0x1cca  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_3_WIN_CHROM_V                  ((0x1ccb  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_3_CH0_BADDR                    ((0x1cd0  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_CH1_BADDR                    ((0x1cd1  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_CH2_BADDR                    ((0x1cd2  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_CH0_BADDR_OFST               ((0x1cd3  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_3_CH1_BADDR_OFST               ((0x1cd4  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_3_CH2_BADDR_OFST               ((0x1cd5  << 2) + 0xfe3b4000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_3_BADDR_OFSTEN                 ((0x1cd6  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_3_TIMCTRL                      ((0x1cd7  << 2) + 0xfe3b4000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_3_FMT_SIZE                     ((0x1cd9  << 2) + 0xfe3b4000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_3_FMT_CTRL                     ((0x1cda  << 2) + 0xfe3b4000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7     reserved
//Bit 6     reg_mtx_rgb_swap            //unsigned, RW, default = 0, 0:{r,g,b} 1:{b,g,r}
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reg_mtx_yc_swap             //unsigned, RW, default = 0, 0:{y,c} 1:{c,y}
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_3_GCLK                         ((0x1cdd  << 2) + 0xfe3b4000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_RO_STAT                      ((0x1cde  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_3_RO_CH01                      ((0x1ce0  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_3_RO_CH2                       ((0x1ce1  << 2) + 0xfe3b4000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_3_CRP_CTR                      ((0x1ce2  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_CRP_HSIZE                    ((0x1ce3  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_3_CRP_VSIZE                    ((0x1ce4  << 2) + 0xfe3b4000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_3.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB2_APB_BASE = 0x1d
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/viu_dmawr_reg.h
//
#define VIU_DMAWR_CTRL1                            ((0x1d00  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel            // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id           // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len           // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian       // unsigned , RW, default = 0, big endian enable
//Bit 5     reg_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode           // unsigned , RW, default = 5, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define VIU_DMAWR_CTRL2                            ((0x1d01  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst              // unsigned , RW, default = 0,
//Bit 29:22 reserved
//Bit 21:20 reg_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl           // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define VIU_DMAWR_CTRL3                            ((0x1d02  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en             // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num            // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num            // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode            // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride              // unsigned , RW, default = 4096,
#define VIU_DMAWR_SCOPE_X                          ((0x1d04  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end               // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start             // unsigned , RW, default = 0, the canvas hor start pixel position
#define VIU_DMAWR_SCOPE_Y                          ((0x1d05  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end               // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start             // unsigned , RW, default = 0, the canvas ver start pixel position
#define VIU_DMAWR_BADDR0                           ((0x1d10  << 2) + 0xfe3b4000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_0       // unsigned , RW, default = 28'ha0000,
#define VIU_DMAWR_BADDR1                           ((0x1d11  << 2) + 0xfe3b4000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_1       // unsigned , RW, default = 28'hb0000,
#define VIU_DMAWR_BADDR2                           ((0x1d12  << 2) + 0xfe3b4000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_2       // unsigned , RW, default = 28'hc0000,
#define VIU_DMAWR_BADDR3                           ((0x1d13  << 2) + 0xfe3b4000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_3       // unsigned , RW, default = 28'hd0000,
#define VIU_DMAWR_BADDR4                           ((0x1d14  << 2) + 0xfe3b4000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_4       // unsigned , RW, default = 28'he0000,
#define VIU_DMAWR_SIZE0                            ((0x1d15  << 2) + 0xfe3b4000)
//Bit 31:16  reg_chx_size_1         // unsigned , RW, default = 16'h800,
//Bit 15:0   reg_chx_size_0         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_SIZE1                            ((0x1d16  << 2) + 0xfe3b4000)
//Bit 31:16  reg_chx_size_3         // unsigned , RW, default = 16'h800,
//Bit 15:0   reg_chx_size_2         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_SIZE2                            ((0x1d17  << 2) + 0xfe3b4000)
//Bit 31:16  reserved
//Bit 15:0   reg_chx_size_4         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_BLKLEN0                          ((0x1d18  << 2) + 0xfe3b4000)
//Bit 31:24  reg_blk_len_3          // unsigned , RW, default =  8,
//Bit 23:16  reg_blk_len_2          // unsigned , RW, default = 16,
//Bit 15:8   reg_blk_len_1          // unsigned , RW, default = 16,
//Bit 7:0    reg_blk_len_0          // unsigned , RW, default = 16,
#define VIU_DMAWR_BLKLEN1                          ((0x1d19  << 2) + 0xfe3b4000)
//Bit 31:8   reserved
//Bit 7:0    reg_blk_len_4          // unsigned , RW, default = 16,
#define VIU_DMAWR_BUFDEPTH0                        ((0x1d1a  << 2) + 0xfe3b4000)
//Bit 31:24  reg_chxbuf_depth_3     // unsigned , RW, default = 16,
//Bit 23:16  reg_chxbuf_depth_2     // unsigned , RW, default = 16,
//Bit 15:8   reg_chxbuf_depth_1     // unsigned , RW, default = 64,
//Bit 7:0    reg_chxbuf_depth_0     // unsigned , RW, default = 16,
#define VIU_DMAWR_BUFDEPTH1                        ((0x1d1b  << 2) + 0xfe3b4000)
//Bit 31:8   reserved
//Bit 7:0    reg_chxbuf_depth_4     // unsigned , RW, default = 48,
#define VIU_DMAWR_RO_STAT                          ((0x1d1f  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_wrmif_status         // unsigned , RO ,default = 0,
//
// Closing file:  ./isp_inc/inc_sw/viu_dmawr_reg.h
//
//reserved  "viu_wrarb_reg_0.h"             //0x80-0x8f  [ISP_WRARB,ISP_WRARB0]
//reserved  "viu_wrarb_reg_1.h"             //0x90-0x9f  [ISP_WRARB,ISP_WRARB1]
//reserved  "viu_rdarb_reg.h"               //0xc0-0xcf
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB3_APB_BASE = 0x1e
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_NR2_CTRL1                         ((0x1e00  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_NR2_CTRL2                         ((0x1e01  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_NR2_CTRL3                         ((0x1e02  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_NR2_CTRL4                         ((0x1e03  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_NR2_SCOPE_X                       ((0x1e04  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_NR2_SCOPE_Y                       ((0x1e05  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_NR2_RO_STAT                       ((0x1e06  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_NR2_CTRL5                         ((0x1e07  << 2) + 0xfe3b4000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_NR2_CTRL6                         ((0x1e08  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_NR2_CTRL7                         ((0x1e09  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_NR3_CTRL1                         ((0x1e20  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_NR3_CTRL2                         ((0x1e21  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_NR3_CTRL3                         ((0x1e22  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_NR3_CTRL4                         ((0x1e23  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_NR3_SCOPE_X                       ((0x1e24  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_NR3_SCOPE_Y                       ((0x1e25  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_NR3_RO_STAT                       ((0x1e26  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_NR3_CTRL5                         ((0x1e27  << 2) + 0xfe3b4000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_NR3_CTRL6                         ((0x1e28  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_NR3_CTRL7                         ((0x1e29  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_NR2_CTRL1                         ((0x1e40  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_NR2_CTRL2                         ((0x1e41  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_NR2_CTRL3                         ((0x1e42  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_NR2_CTRL4                         ((0x1e43  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_NR2_SCOPE_X                       ((0x1e44  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_NR2_SCOPE_Y                       ((0x1e45  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_NR2_RO_STAT                       ((0x1e46  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_NR2_CTRL5                         ((0x1e47  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_NR3_CTRL1                         ((0x1e60  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_NR3_CTRL2                         ((0x1e61  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_NR3_CTRL3                         ((0x1e62  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_NR3_CTRL4                         ((0x1e63  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_NR3_SCOPE_X                       ((0x1e64  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_NR3_SCOPE_Y                       ((0x1e65  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_NR3_RO_STAT                       ((0x1e66  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_NR3_CTRL5                         ((0x1e67  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_3.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_PNR0_CTRL1                        ((0x1e80  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_PNR0_CTRL2                        ((0x1e81  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_PNR0_CTRL3                        ((0x1e82  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_PNR0_CTRL4                        ((0x1e83  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_PNR0_SCOPE_X                      ((0x1e84  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_PNR0_SCOPE_Y                      ((0x1e85  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_PNR0_RO_STAT                      ((0x1e86  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_PNR0_CTRL5                        ((0x1e87  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_3.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_PNR0_CTRL1                        ((0x1ec0  << 2) + 0xfe3b4000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_PNR0_CTRL2                        ((0x1ec1  << 2) + 0xfe3b4000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_PNR0_CTRL3                        ((0x1ec2  << 2) + 0xfe3b4000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_PNR0_CTRL4                        ((0x1ec3  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_PNR0_SCOPE_X                      ((0x1ec4  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_PNR0_SCOPE_Y                      ((0x1ec5  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_PNR0_RO_STAT                      ((0x1ec6  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_PNR0_CTRL5                        ((0x1ec7  << 2) + 0xfe3b4000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_PNR0_CTRL6                        ((0x1ec8  << 2) + 0xfe3b4000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_PNR0_CTRL7                        ((0x1ec9  << 2) + 0xfe3b4000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_2.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB4_APB_BASE = 0x1f
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSEM_PIX_TOP_CTRL                    ((0x1f00  << 2) + 0xfe3b4000)
//Bit 31    reg_crc_on          // unsigned, RW, default = 0
//Bit 30:13 reserved
//Bit 12    reg_losse_byp_en    // unsigned, RW, default = 1
//Bit 11:0  reg_gclk_ctrl       // unsigned, RW, default = 0
//
#define ISP_LOSSEM_PIX_CRC_SUM1                    ((0x1f01  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_CRC_SUM2                    ((0x1f02  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_CRC_SUM3                    ((0x1f03  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum3         // unsigned, RO, default = 0
//MMU RDMIF REG
#define ISP_LOSSEM_PIX_MMU_MIF_CTRL0               ((0x1f04  << 2) + 0xfe3b4000)
//Bit 31:29 reserved           // unsigned, RW, default=0
//Bit 28:16	reg_stride         // unsigned, RW, default=4096
//Bit 15:14 reserved
//Bit 13:12	reg_auto_ctrl      // unsigned, RW, default=0
//Bit 11:10	reg_gclk_ctrl      // unsigned, RW, default=0
//Bit 9 : 8	reg_cmd_req_size   // unsigned, RW, default=1
//Bit 7     reserved
//Bit 6 : 4	reg_cmd_intr_len   // unsigned, RW, default=1
//Bit 3    	reg_swap_64bit     // unsigned, RW, default=0
//Bit 2    	reg_little_endian  // unsigned, RW, default=1
//Bit 1:0  	reg_burst_len      // unsigned, RW, default=1
#define ISP_LOSSEM_PIX_MMU_MIF_CTRL1               ((0x1f05  << 2) + 0xfe3b4000)
//Bit 31:24 reserved
//Bit 23:22 reg_int_clr         // unsigned, RW, default=0
//Bit 21:20 reserved
//Bit 19:18 reg_sw_rst          // unsigned, RW, default=0
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl     //unsigned, RW, default=0
#define ISP_LOSSEM_PIX_MMU_MIF_RO_STAT             ((0x1f06  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status           // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_MIF_CTRL                    ((0x1f07  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 17:16 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_burst_len     // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 9:8   reg_losse_clr     // unsigned , RW, default = 0,
//Bit 7     reserved
//Bit 6:4   reg_sw_rst        // unsigned , RW, default = 0
//Bit 3     reg_rst_mode      // unsigned , RW, default = 0
//Bit 2     reg_en_mode       // unsigned , RW, default = 0
//Bit 1     reg_enable        // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSEM_PIX_UGT_CTRL                    ((0x1f08  << 2) + 0xfe3b4000)
//Bit 31:17 reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSEM_PIX_GCLK_CTRL                   ((0x1f09  << 2) + 0xfe3b4000)
//Bit 31:12 reserved
//Bit 11:0  reg_pass_num      // unsigned , RW, default = 1
#define ISP_LOSSEM_PIX_LUT_SIZE                    ((0x1f0a  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_lut_vsize        // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_lut_hsize        // unsigned , RW, default = 4096,
#define ISP_LOSSEM_PIX_RO_STAT                     ((0x1f0b  << 2) + 0xfe3b4000)
//Bit 31:0  ro_losse_stat       // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_RO_MMU_NUM                  ((0x1f0c  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_frm_mmu_num      // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/cmpr_raw_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSE_PIX_CTRL                         ((0x1f80  << 2) + 0xfe3b4000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSE_PIX_FRAME_HOLD                   ((0x1f81  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define ISP_LOSSE_PIX_GCLK_CTRL                    ((0x1f82  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSE_PIX_RO_CODEC_STATUS              ((0x1f83  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define ISP_LOSSE_PIX_MISC                         ((0x1f84  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSE_PIX_BASIS                        ((0x1f88  << 2) + 0xfe3b4000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define ISP_LOSSE_PIX_OFST_BIT_DEPTH               ((0x1f89  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define ISP_LOSSE_PIX_PIC_SIZE                     ((0x1f8a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSE_PIX_SLICE_SIZE                   ((0x1f8b  << 2) + 0xfe3b4000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_1                 ((0x1f8c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_2                 ((0x1f8d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_3                 ((0x1f8e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_PRESL_LAST_BITS              ((0x1f8f  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define ISP_LOSSE_PIX_PRESL_FIFO_LEVEL             ((0x1f90  << 2) + 0xfe3b4000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define ISP_LOSSE_PIX_DEBUG                        ((0x1f91  << 2) + 0xfe3b4000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_REF_DATA                     ((0x1f92  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_REF_DATA_1                   ((0x1f93  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_REF_DATA_2                   ((0x1f94  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_PRED_PROCE                   ((0x1f95  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define ISP_LOSSE_PIX_GLOBAL_PHASE_LUT             ((0x1f96  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSE_PIX_GLOBAL_PHASE_LUT_1           ((0x1f97  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSE_PIX_PHASE_LUT                    ((0x1f98  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define ISP_LOSSE_PIX_FLATNESS_0                   ((0x1f99  << 2) + 0xfe3b4000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSE_PIX_FLATNESS_QP                  ((0x1f9a  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define ISP_LOSSE_PIX_FLATNESS_TH0                 ((0x1f9b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_FLATNESS_TH1                 ((0x1f9c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_FLATNESS_TH2                 ((0x1f9d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_QP_MAP_CHN0                  ((0x1f9e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_1                ((0x1f9f  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_2                ((0x1fa0  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_3                ((0x1fa1  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_4                ((0x1fa2  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_5                ((0x1fa3  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_6                ((0x1fa4  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_7                ((0x1fa5  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_8                ((0x1fa6  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_9                ((0x1fa7  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1                  ((0x1fa8  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_1                ((0x1fa9  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_2                ((0x1faa  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_3                ((0x1fab  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_4                ((0x1fac  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_5                ((0x1fad  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_6                ((0x1fae  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_7                ((0x1faf  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_8                ((0x1fb0  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_9                ((0x1fb1  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2                  ((0x1fb2  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_1                ((0x1fb3  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_2                ((0x1fb4  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_3                ((0x1fb5  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_4                ((0x1fb6  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_5                ((0x1fb7  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_6                ((0x1fb8  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_7                ((0x1fb9  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_8                ((0x1fba  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_9                ((0x1fbb  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_RC_GROUP_2                   ((0x1fbc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSE_PIX_RC_BUDGET_0                  ((0x1fbd  << 2) + 0xfe3b4000)
#define ISP_LOSSE_PIX_RC_BUDGET_1                  ((0x1fbe  << 2) + 0xfe3b4000)
#define ISP_LOSSE_PIX_RC_BUDGET_2                  ((0x1fbf  << 2) + 0xfe3b4000)
#define ISP_LOSSE_PIX_RC_BUDGET_3                  ((0x1fc0  << 2) + 0xfe3b4000)
#define ISP_LOSSE_PIX_RC_BUDGET_4                  ((0x1fc1  << 2) + 0xfe3b4000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSE_PIX_RC_BUDGET_5                  ((0x1fc2  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSE_PIX_RC_BUDGET_6                  ((0x1fc3  << 2) + 0xfe3b4000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSE_PIX_RC_QP_MARGIN                 ((0x1fc4  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_1               ((0x1fc5  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_2               ((0x1fc6  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_3               ((0x1fc7  << 2) + 0xfe3b4000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_PIX_RC_QP_MARGIN_4               ((0x1fc8  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_PIX_RC_QP_MARGIN_5               ((0x1fc9  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_PIX_FLATNESS_ADJ0                ((0x1fca  << 2) + 0xfe3b4000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSE_PIX_FLATNESS_ADJ1                ((0x1fcb  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSE_PIX_FIFO_THD_0                   ((0x1fcc  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_THD_1                   ((0x1fcd  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_THD_2                   ((0x1fce  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_AVG                     ((0x1fcf  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSE_PIX_FIFO_DLT                     ((0x1fd0  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_BITSGAP_THD_0                ((0x1fd1  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSE_PIX_BITSGAP_THD_1                ((0x1fd2  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSE_PIX_REF_ADJ                      ((0x1fd3  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_0                ((0x1fd4  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_1                ((0x1fd5  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_2                ((0x1fd6  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_3                ((0x1fd7  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_4                ((0x1fd8  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_REF_ADJ_DLT_5            ((0x1fd9  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN0              ((0x1fda  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN0_1            ((0x1fdb  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN1              ((0x1fdc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN1_1            ((0x1fdd  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN2              ((0x1fde  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN2_1            ((0x1fdf  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define ISP_LOSSE_PIX_ACCUM_OFSET_0                ((0x1fe0  << 2) + 0xfe3b4000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_1                ((0x1fe1  << 2) + 0xfe3b4000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_2                ((0x1fe2  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_3                ((0x1fe3  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_WDR_LINE_DELAY               ((0x1fe4  << 2) + 0xfe3b4000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define ISP_LOSSE_PIX_CORING_TH_OFST               ((0x1fe5  << 2) + 0xfe3b4000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define ISP_LOSSE_PIX_CORING_RST                   ((0x1fe6  << 2) + 0xfe3b4000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define ISP_LOSSE_PIX_STATS_RAM_MODE               ((0x1fe7  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define ISP_LOSSE_PIX_STATS_RAM_ADDR               ((0x1fe8  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define ISP_LOSSE_PIX_RO_STATS_RAM_DATA            ((0x1fe9  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/cmpr_raw_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB5_APB_BASE = 0x20
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSEM_MIX_TOP_CTRL                    ((0x2000  << 2) + 0xfe3b4000)
//Bit 31    reg_crc_on          // unsigned, RW, default = 0
//Bit 30:13 reserved
//Bit 12    reg_losse_byp_en    // unsigned, RW, default = 1
//Bit 11:0  reg_gclk_ctrl       // unsigned, RW, default = 0
//
#define ISP_LOSSEM_MIX_CRC_SUM1                    ((0x2001  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_CRC_SUM2                    ((0x2002  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_CRC_SUM3                    ((0x2003  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum3         // unsigned, RO, default = 0
//MMU RDMIF REG
#define ISP_LOSSEM_MIX_MMU_MIF_CTRL0               ((0x2004  << 2) + 0xfe3b4000)
//Bit 31:29 reserved           // unsigned, RW, default=0
//Bit 28:16	reg_stride         // unsigned, RW, default=4096
//Bit 15:14 reserved
//Bit 13:12	reg_auto_ctrl      // unsigned, RW, default=0
//Bit 11:10	reg_gclk_ctrl      // unsigned, RW, default=0
//Bit 9 : 8	reg_cmd_req_size   // unsigned, RW, default=1
//Bit 7     reserved
//Bit 6 : 4	reg_cmd_intr_len   // unsigned, RW, default=1
//Bit 3    	reg_swap_64bit     // unsigned, RW, default=0
//Bit 2    	reg_little_endian  // unsigned, RW, default=1
//Bit 1:0  	reg_burst_len      // unsigned, RW, default=1
#define ISP_LOSSEM_MIX_MMU_MIF_CTRL1               ((0x2005  << 2) + 0xfe3b4000)
//Bit 31:24 reserved
//Bit 23:22 reg_int_clr         // unsigned, RW, default=0
//Bit 21:20 reserved
//Bit 19:18 reg_sw_rst          // unsigned, RW, default=0
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl     //unsigned, RW, default=0
#define ISP_LOSSEM_MIX_MMU_MIF_RO_STAT             ((0x2006  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_status           // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_MIF_CTRL                    ((0x2007  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 17:16 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_burst_len     // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 9:8   reg_losse_clr     // unsigned , RW, default = 0,
//Bit 7     reserved
//Bit 6:4   reg_sw_rst        // unsigned , RW, default = 0
//Bit 3     reg_rst_mode      // unsigned , RW, default = 0
//Bit 2     reg_en_mode       // unsigned , RW, default = 0
//Bit 1     reg_enable        // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSEM_MIX_UGT_CTRL                    ((0x2008  << 2) + 0xfe3b4000)
//Bit 31:17 reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSEM_MIX_GCLK_CTRL                   ((0x2009  << 2) + 0xfe3b4000)
//Bit 31:12 reserved
//Bit 11:0  reg_pass_num      // unsigned , RW, default = 1
#define ISP_LOSSEM_MIX_LUT_SIZE                    ((0x200a  << 2) + 0xfe3b4000)
//Bit 31:29 reserved
//Bit 28:16 reg_lut_vsize        // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_lut_hsize        // unsigned , RW, default = 4096,
#define ISP_LOSSEM_MIX_RO_STAT                     ((0x200b  << 2) + 0xfe3b4000)
//Bit 31:0  ro_losse_stat       // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_RO_MMU_NUM                  ((0x200c  << 2) + 0xfe3b4000)
//Bit 31:16 reserved
//Bit 15:0  ro_frm_mmu_num      // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/losslite_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSE_MIX_CTRL                         ((0x2080  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reserved
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSE_MIX_FRAME_HOLD                   ((0x2081  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0
#define ISP_LOSSE_MIX_GCLK_CTRL                    ((0x2082  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSE_MIX_RO_CODEC_STATUS              ((0x2083  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RO, default = 0  codec status, write 1 to clear
#define ISP_LOSSE_MIX_MISC                         ((0x2084  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSE_MIX_BASIS                        ((0x2088  << 2) + 0xfe3b4000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:28        reserved
//Bit 27: 8        reserved
//Bit  7: 0        reg_ratio_bppx16          // unsigned ,    RW, default = 96  bits per pixel x16, fracbits_bpp = x/16;
#define ISP_LOSSE_MIX_PIC_SIZE                     ((0x2089  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSE_MIX_SLICE_Y                      ((0x208a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSE_MIX_SLICE_Y_1                    ((0x208b  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_MIX_QP_MAP_CHN0                  ((0x208c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_3       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_2       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_1       // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_0       // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_1                ((0x208d  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_7       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_6       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_5       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_4       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_2                ((0x208e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_11      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_10      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_9       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_8       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_3                ((0x208f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_15      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_14      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_13      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_12      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_4                ((0x2090  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_19      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_18      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_17      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_16      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_5                ((0x2091  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_23      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_22      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_21      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_20      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_FLATNESS_0                   ((0x2092  << 2) + 0xfe3b4000)
//Bit 31           reg_flat_en               // unsigned ,    RW, default = 0  enable signal for the flatness mode.
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29           reg_flatness_qerr_flag    // unsigned ,    RW, default = 0
//Bit 28            reserved
//Bit 27:24        reserved
//Bit 23:20        reg_flatness_qp_thresh    // unsigned ,    RW, default = 2  thresh qp for flatness to be used
//Bit 19:16        reserved
//Bit 15:12        reg_flatness_qp_reduce    // unsigned ,    RW, default = 2  if the cell is flatness qlevel = master_qp- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSE_MIX_FLATNESS_TH                  ((0x2093  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_MIX_RC_GROUP_2                   ((0x2094  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1920  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSE_MIX_RC_BUDGET_0                  ((0x2095  << 2) + 0xfe3b4000)
#define ISP_LOSSE_MIX_RC_BUDGET_1                  ((0x2096  << 2) + 0xfe3b4000)
#define ISP_LOSSE_MIX_RC_BUDGET_2                  ((0x2097  << 2) + 0xfe3b4000)
#define ISP_LOSSE_MIX_RC_BUDGET_3                  ((0x2098  << 2) + 0xfe3b4000)
#define ISP_LOSSE_MIX_RC_BUDGET_4                  ((0x2099  << 2) + 0xfe3b4000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSE_MIX_RC_BUDGET_5                  ((0x209a  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_master_qp_max      // unsigned ,    RW, default = 9  maxmum qpx2 during the rc_loop
//Bit 23:20        reserved
//Bit 19:16        reg_rc_master_qp_min      // unsigned ,    RW, default = 0  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSE_MIX_RC_BUDGET_6                  ((0x209b  << 2) + 0xfe3b4000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qp_margin3_blkth   // unsigned ,    RW, default = 0  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSE_MIX_RC_QP_MARGIN                 ((0x209c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_1    // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_0    // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSE_MIX_RC_QP_MARGIN_1               ((0x209d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_3    // signed ,    RW, default = 16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_2    // signed ,    RW, default = -32  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSE_MIX_RC_QP_MARGIN_2               ((0x209e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_qp_margin_dlt_3    // unsigned ,    RW, default = 4  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_qp_margin_dlt_2    // unsigned ,    RW, default = 3
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_qp_margin_dlt_1    // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_qp_margin_dlt_0    // unsigned ,    RW, default = 1  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
#define ISP_LOSSE_MIX_FLATNESS_ADJ0                ((0x209f  << 2) + 0xfe3b4000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt, default=[1, 2]
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 0  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSE_MIX_FLATNESS_ADJ1                ((0x20a0  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 0  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSE_MIX_FIFO_THD_0                   ((0x20a1  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_THD_1                   ((0x20a2  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_THD_2                   ((0x20a3  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_AVG                     ((0x20a4  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:16        reserved
//Bit 15:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 6  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSE_MIX_FIFO_DLT_1STCH               ((0x20a5  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 3  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 1  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_BITSGAP_THD_0                ((0x20a6  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSE_MIX_BITSGAP_THD_1                ((0x20a7  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSE_MIX_RC_QP_MARGIN_3               ((0x20a8  << 2) + 0xfe3b4000)
//Bit 31:30        reg_rc_qp_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_MIX_RC_QP_MARGIN_4               ((0x20a9  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_MIX_RC_QP_MARGIN_5               ((0x20aa  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_qp_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_qp_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_qp_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_qp_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_MIX_LUMA                         ((0x20ab  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16           reg_luma_adjust_en        // unsigned ,    RW, default = 0  enable of luma(G) adjust
//Bit 15:13        reserved
//Bit 12: 8        reg_pixel_luma_adj_dlt_1  // unsigned ,    RW, default = 1  of level according to luma
//Bit  7: 5        reserved
//Bit  4: 0        reg_pixel_luma_adj_dlt_0  // unsigned ,    RW, default = 2
#define ISP_LOSSE_MIX_LUMA_TH                      ((0x20ac  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_luma_adj_th_1   // unsigned ,    RW, default = 128  of luma level
//Bit 15: 0        reg_pixel_luma_adj_th_0   // unsigned ,    RW, default = 256
#define ISP_LOSSE_MIX_DEBUG                        ((0x20ad  << 2) + 0xfe3b4000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30: 8        reserved
//Bit  7: 0        reg_dbg_qlevel            // unsigned ,    RW, default = 0
#define ISP_LOSSE_MIX_RO_MAX_ERROR                 ((0x20ae  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        ro_max_error              // unsigned ,    RO, default = 0  current channel max pixel diff
#define ISP_LOSSE_MIX_RO_SQUARE_L                  ((0x20af  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_error_acc_l            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSE_MIX_RO_SQUARE_H                  ((0x20b0  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_error_acc_h            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_0               ((0x20b1  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_0               ((0x20b2  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_1               ((0x20b3  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_1               ((0x20b4  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_2               ((0x20b5  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_2               ((0x20b6  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_3               ((0x20b7  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_3               ((0x20b8  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/losslite_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB6_APB_BASE = 0x21
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSDM_PIX_MIF_CTRL                    ((0x2100  << 2) + 0xfe3b4000)
//Bit 31    reg_crc_on        // unsigned , RW, default = 1
//Bit 30    reserved
//Bit 29:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 19:18 reg_lossd_clr     // unsigned , RW, default = 0,
//Bit 17:16 reserved
//Bit 15    reg_lossd_byp_en  // unsigned , RW, default = 1
//Bit 14:12 reg_sw_rst        // unsigned , RW, default = 0
//Bit 11    reserved
//Bit 10:8  reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 7:6   reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 5:4   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 3     reg_swap_64bit    // unsigned , RW, default = 0
//Bit 2     reg_little_endian // unsigned , RW, default = 1
//Bit 1     reg_mif_enable    // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSDM_PIX_UGT_CTRL                    ((0x2101  << 2) + 0xfe3b4000)
//Bit 31:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSDM_PIX_GCLK_CTRL                   ((0x2102  << 2) + 0xfe3b4000)
//Bit 31:29 reg_body_intr_len   //unsigned, RW, default = 1
//Bit 28:27 reg_body_req_size   //unsigned, RW, default = 1
//Bit 26:16 reserved
//Bit 15:0  reg_gclk_ctrl       //unsigned, RW, default = 0
#define ISP_LOSSDM_PIX_RO_STAT                     ((0x2103  << 2) + 0xfe3b4000)
//Bit 31:0  ro_mif_status       //unsigned, RO, default=0
#define ISP_LOSSDM_PIX_CRC_SUM1                    ((0x2104  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSDM_PIX_CRC_SUM2                    ((0x2105  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/cmpr_raw_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSD_PIX_CTRL                         ((0x2180  << 2) + 0xfe3b4000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSD_PIX_FRAME_HOLD                   ((0x2181  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define ISP_LOSSD_PIX_GCLK_CTRL                    ((0x2182  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSD_PIX_RO_CODEC_STATUS              ((0x2183  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define ISP_LOSSD_PIX_MISC                         ((0x2184  << 2) + 0xfe3b4000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSD_PIX_BASIS                        ((0x2188  << 2) + 0xfe3b4000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define ISP_LOSSD_PIX_OFST_BIT_DEPTH               ((0x2189  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define ISP_LOSSD_PIX_PIC_SIZE                     ((0x218a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSD_PIX_SLICE_SIZE                   ((0x218b  << 2) + 0xfe3b4000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_1                 ((0x218c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_2                 ((0x218d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_3                 ((0x218e  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_PRESL_LAST_BITS              ((0x218f  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define ISP_LOSSD_PIX_PRESL_FIFO_LEVEL             ((0x2190  << 2) + 0xfe3b4000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define ISP_LOSSD_PIX_DEBUG                        ((0x2191  << 2) + 0xfe3b4000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_REF_DATA                     ((0x2192  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_REF_DATA_1                   ((0x2193  << 2) + 0xfe3b4000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_REF_DATA_2                   ((0x2194  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_PRED_PROCE                   ((0x2195  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define ISP_LOSSD_PIX_GLOBAL_PHASE_LUT             ((0x2196  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSD_PIX_GLOBAL_PHASE_LUT_1           ((0x2197  << 2) + 0xfe3b4000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSD_PIX_PHASE_LUT                    ((0x2198  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define ISP_LOSSD_PIX_FLATNESS_0                   ((0x2199  << 2) + 0xfe3b4000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSD_PIX_FLATNESS_QP                  ((0x219a  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define ISP_LOSSD_PIX_FLATNESS_TH0                 ((0x219b  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_FLATNESS_TH1                 ((0x219c  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_FLATNESS_TH2                 ((0x219d  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_QP_MAP_CHN0                  ((0x219e  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_1                ((0x219f  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_2                ((0x21a0  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_3                ((0x21a1  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_4                ((0x21a2  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_5                ((0x21a3  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_6                ((0x21a4  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_7                ((0x21a5  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_8                ((0x21a6  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_9                ((0x21a7  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1                  ((0x21a8  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_1                ((0x21a9  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_2                ((0x21aa  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_3                ((0x21ab  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_4                ((0x21ac  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_5                ((0x21ad  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_6                ((0x21ae  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_7                ((0x21af  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_8                ((0x21b0  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_9                ((0x21b1  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2                  ((0x21b2  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_1                ((0x21b3  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_2                ((0x21b4  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_3                ((0x21b5  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_4                ((0x21b6  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_5                ((0x21b7  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_6                ((0x21b8  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_7                ((0x21b9  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_8                ((0x21ba  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_9                ((0x21bb  << 2) + 0xfe3b4000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_RC_GROUP_2                   ((0x21bc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSD_PIX_RC_BUDGET_0                  ((0x21bd  << 2) + 0xfe3b4000)
#define ISP_LOSSD_PIX_RC_BUDGET_1                  ((0x21be  << 2) + 0xfe3b4000)
#define ISP_LOSSD_PIX_RC_BUDGET_2                  ((0x21bf  << 2) + 0xfe3b4000)
#define ISP_LOSSD_PIX_RC_BUDGET_3                  ((0x21c0  << 2) + 0xfe3b4000)
#define ISP_LOSSD_PIX_RC_BUDGET_4                  ((0x21c1  << 2) + 0xfe3b4000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSD_PIX_RC_BUDGET_5                  ((0x21c2  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSD_PIX_RC_BUDGET_6                  ((0x21c3  << 2) + 0xfe3b4000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSD_PIX_RC_QP_MARGIN                 ((0x21c4  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_1               ((0x21c5  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_2               ((0x21c6  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_3               ((0x21c7  << 2) + 0xfe3b4000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_PIX_RC_QP_MARGIN_4               ((0x21c8  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_PIX_RC_QP_MARGIN_5               ((0x21c9  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_PIX_FLATNESS_ADJ0                ((0x21ca  << 2) + 0xfe3b4000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSD_PIX_FLATNESS_ADJ1                ((0x21cb  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSD_PIX_FIFO_THD_0                   ((0x21cc  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_THD_1                   ((0x21cd  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_THD_2                   ((0x21ce  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_AVG                     ((0x21cf  << 2) + 0xfe3b4000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSD_PIX_FIFO_DLT                     ((0x21d0  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_BITSGAP_THD_0                ((0x21d1  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSD_PIX_BITSGAP_THD_1                ((0x21d2  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSD_PIX_REF_ADJ                      ((0x21d3  << 2) + 0xfe3b4000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_0                ((0x21d4  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_1                ((0x21d5  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_2                ((0x21d6  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_3                ((0x21d7  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_4                ((0x21d8  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_REF_ADJ_DLT_5            ((0x21d9  << 2) + 0xfe3b4000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of level according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN0              ((0x21da  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN0_1            ((0x21db  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN1              ((0x21dc  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN1_1            ((0x21dd  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN2              ((0x21de  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN2_1            ((0x21df  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define ISP_LOSSD_PIX_ACCUM_OFSET_0                ((0x21e0  << 2) + 0xfe3b4000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_1                ((0x21e1  << 2) + 0xfe3b4000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_2                ((0x21e2  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_3                ((0x21e3  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_WDR_LINE_DELAY               ((0x21e4  << 2) + 0xfe3b4000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define ISP_LOSSD_PIX_CORING_TH_OFST               ((0x21e5  << 2) + 0xfe3b4000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define ISP_LOSSD_PIX_CORING_RST                   ((0x21e6  << 2) + 0xfe3b4000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define ISP_LOSSD_PIX_STATS_RAM_MODE               ((0x21e7  << 2) + 0xfe3b4000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define ISP_LOSSD_PIX_STATS_RAM_ADDR               ((0x21e8  << 2) + 0xfe3b4000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define ISP_LOSSD_PIX_RO_STATS_RAM_DATA            ((0x21e9  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/cmpr_raw_regs_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB7_APB_BASE = 0x22
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSDM_MIX_MIF_CTRL                    ((0x2200  << 2) + 0xfe3b4000)
//Bit 31    reg_crc_on        // unsigned , RW, default = 1
//Bit 30    reserved
//Bit 29:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 19:18 reg_lossd_clr     // unsigned , RW, default = 0,
//Bit 17:16 reserved
//Bit 15    reg_lossd_byp_en  // unsigned , RW, default = 1
//Bit 14:12 reg_sw_rst        // unsigned , RW, default = 0
//Bit 11    reserved
//Bit 10:8  reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 7:6   reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 5:4   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 3     reg_swap_64bit    // unsigned , RW, default = 0
//Bit 2     reg_little_endian // unsigned , RW, default = 1
//Bit 1     reg_mif_enable    // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSDM_MIX_UGT_CTRL                    ((0x2201  << 2) + 0xfe3b4000)
//Bit 31:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSDM_MIX_GCLK_CTRL                   ((0x2202  << 2) + 0xfe3b4000)
//Bit 31:29 reg_body_intr_len   //unsigned, RW, default = 1
//Bit 28:27 reg_body_req_size   //unsigned, RW, default = 1
//Bit 26:16 reserved
//Bit 15:0  reg_gclk_ctrl       //unsigned, RW, default = 0
#define ISP_LOSSDM_MIX_RO_STAT                     ((0x2203  << 2) + 0xfe3b4000)
//Bit 31:0  ro_mif_status       //unsigned, RO, default=0
#define ISP_LOSSDM_MIX_CRC_SUM1                    ((0x2204  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSDM_MIX_CRC_SUM2                    ((0x2205  << 2) + 0xfe3b4000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/losslite_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSD_MIX_CTRL                         ((0x2280  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reserved
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSD_MIX_FRAME_HOLD                   ((0x2281  << 2) + 0xfe3b4000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0
#define ISP_LOSSD_MIX_GCLK_CTRL                    ((0x2282  << 2) + 0xfe3b4000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSD_MIX_RO_CODEC_STATUS              ((0x2283  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RO, default = 0  codec status, write 1 to clear
#define ISP_LOSSD_MIX_MISC                         ((0x2284  << 2) + 0xfe3b4000)
//Bit 31: 4        reserved
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSD_MIX_BASIS                        ((0x2288  << 2) + 0xfe3b4000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:28        reserved
//Bit 27: 8        reserved
//Bit  7: 0        reg_ratio_bppx16          // unsigned ,    RW, default = 96  bits per pixel x16, fracbits_bpp = x/16;
#define ISP_LOSSD_MIX_PIC_SIZE                     ((0x2289  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture vertical size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSD_MIX_SLICE_Y                      ((0x228a  << 2) + 0xfe3b4000)
//Bit 31:16        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSD_MIX_SLICE_Y_1                    ((0x228b  << 2) + 0xfe3b4000)
//Bit 31:16        reserved
//Bit 15: 0        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_MIX_QP_MAP_CHN0                  ((0x228c  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_3       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_2       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_1       // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_0       // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_1                ((0x228d  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_7       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_6       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_5       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_4       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_2                ((0x228e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_11      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_10      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_9       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_8       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_3                ((0x228f  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_15      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_14      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_13      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_12      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_4                ((0x2290  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_19      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_18      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_17      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_16      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_5                ((0x2291  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_23      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_22      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_21      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_20      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_FLATNESS_0                   ((0x2292  << 2) + 0xfe3b4000)
//Bit 31           reg_flat_en               // unsigned ,    RW, default = 0  enable signal for the flatness mode.
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29           reg_flatness_qerr_flag    // unsigned ,    RW, default = 0
//Bit 28            reserved
//Bit 27:24        reserved
//Bit 23:20        reg_flatness_qp_thresh    // unsigned ,    RW, default = 2  thresh qp for flatness to be used
//Bit 19:16        reserved
//Bit 15:12        reg_flatness_qp_reduce    // unsigned ,    RW, default = 2  if the cell is flatness qlevel = master_qp- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSD_MIX_FLATNESS_TH                  ((0x2293  << 2) + 0xfe3b4000)
//Bit 31:16        reg_flatness_det_thresh_min // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_MIX_RC_GROUP_2                   ((0x2294  << 2) + 0xfe3b4000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1920  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSD_MIX_RC_BUDGET_0                  ((0x2295  << 2) + 0xfe3b4000)
#define ISP_LOSSD_MIX_RC_BUDGET_1                  ((0x2296  << 2) + 0xfe3b4000)
#define ISP_LOSSD_MIX_RC_BUDGET_2                  ((0x2297  << 2) + 0xfe3b4000)
#define ISP_LOSSD_MIX_RC_BUDGET_3                  ((0x2298  << 2) + 0xfe3b4000)
#define ISP_LOSSD_MIX_RC_BUDGET_4                  ((0x2299  << 2) + 0xfe3b4000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSD_MIX_RC_BUDGET_5                  ((0x229a  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_master_qp_max      // unsigned ,    RW, default = 9  maxmum qpx2 during the rc_loop
//Bit 23:20        reserved
//Bit 19:16        reg_rc_master_qp_min      // unsigned ,    RW, default = 0  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSD_MIX_RC_BUDGET_6                  ((0x229b  << 2) + 0xfe3b4000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qp_margin3_blkth   // unsigned ,    RW, default = 0  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSD_MIX_RC_QP_MARGIN                 ((0x229c  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_1    // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_0    // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSD_MIX_RC_QP_MARGIN_1               ((0x229d  << 2) + 0xfe3b4000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_3    // signed ,    RW, default = 16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_2    // signed ,    RW, default = -32  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSD_MIX_RC_QP_MARGIN_2               ((0x229e  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_qp_margin_dlt_3    // unsigned ,    RW, default = 4  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_qp_margin_dlt_2    // unsigned ,    RW, default = 3
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_qp_margin_dlt_1    // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_qp_margin_dlt_0    // unsigned ,    RW, default = 1  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
#define ISP_LOSSD_MIX_FLATNESS_ADJ0                ((0x229f  << 2) + 0xfe3b4000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt, default=[1, 2]
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 0  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSD_MIX_FLATNESS_ADJ1                ((0x22a0  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 0  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSD_MIX_FIFO_THD_0                   ((0x22a1  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_THD_1                   ((0x22a2  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_THD_2                   ((0x22a3  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_AVG                     ((0x22a4  << 2) + 0xfe3b4000)
//Bit 31:24        reserved
//Bit 23:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:16        reserved
//Bit 15:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 6  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSD_MIX_FIFO_DLT_1STCH               ((0x22a5  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 3  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 1  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_BITSGAP_THD_0                ((0x22a6  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSD_MIX_BITSGAP_THD_1                ((0x22a7  << 2) + 0xfe3b4000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSD_MIX_RC_QP_MARGIN_3               ((0x22a8  << 2) + 0xfe3b4000)
//Bit 31:30        reg_rc_qp_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_MIX_RC_QP_MARGIN_4               ((0x22a9  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_MIX_RC_QP_MARGIN_5               ((0x22aa  << 2) + 0xfe3b4000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_qp_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_qp_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_qp_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_qp_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_MIX_LUMA                         ((0x22ab  << 2) + 0xfe3b4000)
//Bit 31:17        reserved
//Bit 16           reg_luma_adjust_en        // unsigned ,    RW, default = 0  enable of luma(G) adjust
//Bit 15:13        reserved
//Bit 12: 8        reg_pixel_luma_adj_dlt_1  // unsigned ,    RW, default = 1  of level according to luma
//Bit  7: 5        reserved
//Bit  4: 0        reg_pixel_luma_adj_dlt_0  // unsigned ,    RW, default = 2
#define ISP_LOSSD_MIX_LUMA_TH                      ((0x22ac  << 2) + 0xfe3b4000)
//Bit 31:16        reg_pixel_luma_adj_th_1   // unsigned ,    RW, default = 128  of luma level
//Bit 15: 0        reg_pixel_luma_adj_th_0   // unsigned ,    RW, default = 256
#define ISP_LOSSD_MIX_DEBUG                        ((0x22ad  << 2) + 0xfe3b4000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30: 8        reserved
//Bit  7: 0        reg_dbg_qlevel            // unsigned ,    RW, default = 0
#define ISP_LOSSD_MIX_RO_MAX_ERROR                 ((0x22ae  << 2) + 0xfe3b4000)
//Bit 31:20        reserved
//Bit 19: 0        ro_max_error              // unsigned ,    RO, default = 0  current channel max pixel diff
#define ISP_LOSSD_MIX_RO_SQUARE_L                  ((0x22af  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_error_acc_l            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSD_MIX_RO_SQUARE_H                  ((0x22b0  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_error_acc_h            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_0               ((0x22b1  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_0               ((0x22b2  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_1               ((0x22b3  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_1               ((0x22b4  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_2               ((0x22b5  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_2               ((0x22b6  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_3               ((0x22b7  << 2) + 0xfe3b4000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_3               ((0x22b8  << 2) + 0xfe3b4000)
//Bit 31: 0        ro_slice_len_l_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
// synopsys translate_off
// synopsys translate_on
//
#endif
// Closing file:  ./isp_inc/inc_sw/losslite_regs_1.h
//
//
// Closing file:  ./isp_inc/inc_sw/isp_regs_base.h
//
//
// Reading file:  ./ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
////// GE2D Registers    0x8a0 - 0x8ff
//address is 0xd016_0000 - 0xd0160000 - 0xd01603ff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  GE2D_GCBUS_BASE = 0x00
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst1 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 22:17,  reserved
//Bit 16:15, src2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 9:7    reserved
//Bit 6:5,   src1  8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define GE2D_GEN_CTRL0                             ((0x00a0  << 2) + 0xff040000)
//Bit 31, soft rst
//Bit 30, dst write response counter reset
//Bit 29, disable adding dst write response count to busy bit
//Bit 28:26, reserved
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords
//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 11, dst2 request urgent enable
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst1 request urgent enable
//Bit 7:0 src1 global alpha
#define GE2D_GEN_CTRL1                             ((0x00a1  << 2) + 0xff040000)
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0;
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst1 color_map
//        dst1_format=0                  : output 8-bit;
//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit
#define GE2D_GEN_CTRL2                             ((0x00a2  << 2) + 0xff040000)
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define GE2D_CMD_CTRL                              ((0x00a3  << 2) + 0xff040000)
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define GE2D_STATUS0                               ((0x00a4  << 2) + 0xff040000)
//
//Read only
// Bit 29:16 ge2d_dst1_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define GE2D_STATUS1                               ((0x00a5  << 2) + 0xff040000)
//SRC1 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC1_DEF_COLOR                        ((0x00a6  << 2) + 0xff040000)
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define GE2D_SRC1_CLIPX_START_END                  ((0x00a7  << 2) + 0xff040000)
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define GE2D_SRC1_CLIPY_START_END                  ((0x00a8  << 2) + 0xff040000)
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define GE2D_SRC1_CANVAS                           ((0x00a9  << 2) + 0xff040000)
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define GE2D_SRC1_X_START_END                      ((0x00aa  << 2) + 0xff040000)
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define GE2D_SRC1_Y_START_END                      ((0x00ab  << 2) + 0xff040000)
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define GE2D_SRC1_LUT_ADDR                         ((0x00ac  << 2) + 0xff040000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define GE2D_SRC1_LUT_DAT                          ((0x00ad  << 2) + 0xff040000)
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase,
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2
#define GE2D_SRC1_FMT_CTRL                         ((0x00ae  << 2) + 0xff040000)
//SRC2 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC2_DEF_COLOR                        ((0x00af  << 2) + 0xff040000)
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define GE2D_SRC2_CLIPX_START_END                  ((0x00b0  << 2) + 0xff040000)
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define GE2D_SRC2_CLIPY_START_END                  ((0x00b1  << 2) + 0xff040000)
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define GE2D_SRC2_X_START_END                      ((0x00b2  << 2) + 0xff040000)
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define GE2D_SRC2_Y_START_END                      ((0x00b3  << 2) + 0xff040000)
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define GE2D_DST_CLIPX_START_END                   ((0x00b4  << 2) + 0xff040000)
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define GE2D_DST_CLIPY_START_END                   ((0x00b5  << 2) + 0xff040000)
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_X_START_END                       ((0x00b6  << 2) + 0xff040000)
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_Y_START_END                       ((0x00b7  << 2) + 0xff040000)
//Bit 23:16 DST2 canvas address
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST1 canvas address
#define GE2D_SRC2_DST_CANVAS                       ((0x00b8  << 2) + 0xff040000)
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_VSC_START_PHASE_STEP                  ((0x00b9  << 2) + 0xff040000)
//phase slope
//Bit 24:0, bit 24 signed bit
#define GE2D_VSC_PHASE_SLOPE                       ((0x00ba  << 2) + 0xff040000)
//Bit 30:29, vertical repeat line0 number
//Bit 23:0, vertical scaler initial phase
#define GE2D_VSC_INI_CTRL                          ((0x00bb  << 2) + 0xff040000)
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_HSC_START_PHASE_STEP                  ((0x00bc  << 2) + 0xff040000)
//phase slope
//Bit 24:0, bit 24 signed bit
#define GE2D_HSC_PHASE_SLOPE                       ((0x00bd  << 2) + 0xff040000)
//Bit 30:29, horizontal repeat line0 number
//Bit 23:0, horizontal scaler initial phase
#define GE2D_HSC_INI_CTRL                          ((0x00be  << 2) + 0xff040000)
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode
#define GE2D_HSC_ADV_CTRL                          ((0x00bf  << 2) + 0xff040000)
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 28 is enable
//Bit 14, pre horizontal scaler enable
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat horizontal repeat line number as minus line number.
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat vertical repeat line number as minus line number.
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define GE2D_SC_MISC_CTRL                          ((0x00c0  << 2) + 0xff040000)
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_VSC_NRND_POINT                        ((0x00c1  << 2) + 0xff040000)
//Read only
//vertical scaler next round phase
//bit 23:0
#define GE2D_VSC_NRND_PHASE                        ((0x00c2  << 2) + 0xff040000)
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_HSC_NRND_POINT                        ((0x00c3  << 2) + 0xff040000)
//Read only
//horizontal scaler next round phase
//bit 23:0
#define GE2D_HSC_NRND_PHASE                        ((0x00c4  << 2) + 0xff040000)
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX_PRE_OFFSET                     ((0x00c5  << 2) + 0xff040000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX_COEF00_01                      ((0x00c6  << 2) + 0xff040000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX_COEF02_10                      ((0x00c7  << 2) + 0xff040000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX_COEF11_12                      ((0x00c8  << 2) + 0xff040000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX_COEF20_21                      ((0x00c9  << 2) + 0xff040000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX_COEF22_CTRL                    ((0x00ca  << 2) + 0xff040000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX_OFFSET                         ((0x00cb  << 2) + 0xff040000)
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultiply)
//Bit 24    SRC2 color multiplier alpha selection
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define GE2D_ALU_OP_CTRL                           ((0x00cc  << 2) + 0xff040000)
//bit 31:0 (RGBA,YCBCRA)
#define GE2D_ALU_CONST_COLOR                       ((0x00cd  << 2) + 0xff040000)
//SRC1 Key
//31:0
#define GE2D_SRC1_KEY                              ((0x00ce  << 2) + 0xff040000)
//SRC1 Key Mask
//31:0
#define GE2D_SRC1_KEY_MASK                         ((0x00cf  << 2) + 0xff040000)
//SRC2 Key
//31:0
#define GE2D_SRC2_KEY                              ((0x00d0  << 2) + 0xff040000)
//SRC2 Key Mask
//31:0
#define GE2D_SRC2_KEY_MASK                         ((0x00d1  << 2) + 0xff040000)
//Destination Bit Mask
//31:0
#define GE2D_DST_BITMASK                           ((0x00d2  << 2) + 0xff040000)
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define GE2D_DP_ONOFF_CTRL                         ((0x00d3  << 2) + 0xff040000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define GE2D_SCALE_COEF_IDX                        ((0x00d4  << 2) + 0xff040000)
//coefficients for vertical filter and horizontal filter
#define GE2D_SCALE_COEF                            ((0x00d5  << 2) + 0xff040000)
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above.
//Bit 7:0   src1 outside alpha
#define GE2D_SRC_OUTSIDE_ALPHA                     ((0x00d6  << 2) + 0xff040000)
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha
//Bit 23:16     register value for the first line alpha when bit 24 is 1
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha
//Bit 7:0      register value for the last line alpha when bit 8 is 1
#define GE2D_ANTIFLICK_CTRL0                       ((0x00d8  << 2) + 0xff040000)
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define GE2D_ANTIFLICK_CTRL1                       ((0x00d9  << 2) + 0xff040000)
//Bit 31:24, Y threshold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_COLOR_FILT0                 ((0x00da  << 2) + 0xff040000)
//Bit 31:24, Y threshold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define GE2D_ANTIFLICK_COLOR_FILT1                 ((0x00db  << 2) + 0xff040000)
//Bit 31:24, Y threshold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define GE2D_ANTIFLICK_COLOR_FILT2                 ((0x00dc  << 2) + 0xff040000)
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define GE2D_ANTIFLICK_COLOR_FILT3                 ((0x00dd  << 2) + 0xff040000)
//Bit 31:24, Alpha threshold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_ALPHA_FILT0                 ((0x00de  << 2) + 0xff040000)
//Bit 31:24, Alpha threshold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define GE2D_ANTIFLICK_ALPHA_FILT1                 ((0x00df  << 2) + 0xff040000)
//Bit 31:24, Alpha threshold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define GE2D_ANTIFLICK_ALPHA_FILT2                 ((0x00e0  << 2) + 0xff040000)
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define GE2D_ANTIFLICK_ALPHA_FILT3                 ((0x00e1  << 2) + 0xff040000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_Y_CTRL                 ((0x00e3  << 2) + 0xff040000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CB_CTRL                ((0x00e4  << 2) + 0xff040000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CR_CTRL                ((0x00e5  << 2) + 0xff040000)
//Bit 21:16     src1 pre-arbiter burst number
//Bit 13:8      src2 pre-arbiter burst number
//Bit 5:0       dst pre-arbiter burst number
#define GE2D_ARB_BURST_NUM                         ((0x00e6  << 2) + 0xff040000)
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define GE2D_TID_TOKEN                             ((0x00e7  << 2) + 0xff040000)
//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
//Bit 25:24, dst2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 22:19 dst2 color_map
//        dst2_format=0                  : output 8-bit;
//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15     reserved
//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     9 reserved
//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
//Bit  7: 6 reserved
//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     1 reserved
//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
#define GE2D_GEN_CTRL3                             ((0x00e8  << 2) + 0xff040000)
//Read only
// Bit 13:0 ge2d_dst2_status, for debug only
#define GE2D_STATUS2                               ((0x00e9  << 2) + 0xff040000)
//Bit 27:26  src1 Y fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 25:24  src2 fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 23:22  dst1 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 21:20  dst2 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 19:18, dst1 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 17:16, dst2 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 15:1, top_wrap_ctrl
//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
#define GE2D_GEN_CTRL4                             ((0x00ea  << 2) + 0xff040000)
#define GE2D_GCLK_CTRL0                            ((0x00ef  << 2) + 0xff040000)
#define GE2D_GCLK_CTRL1                            ((0x00f0  << 2) + 0xff040000)
#define GE2D_GEN_CTRL5                             ((0x00f1  << 2) + 0xff040000)
#define GE2D_DST1_BADDR_CTRL                       ((0x00f2  << 2) + 0xff040000)
//Bit 31:0, dst1 base address in 64bits
#define GE2D_DST1_STRIDE_CTRL                      ((0x00f3  << 2) + 0xff040000)
//Bit 19:0, dst1 stride size in 64bits
#define GE2D_DST2_BADDR_CTRL                       ((0x00f4  << 2) + 0xff040000)
//Bit 31:0, dst1 base address in 64bits
#define GE2D_DST2_STRIDE_CTRL                      ((0x00f5  << 2) + 0xff040000)
//Bit 19:0, dst1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_Y                     ((0x00f6  << 2) + 0xff040000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_Y                    ((0x00f7  << 2) + 0xff040000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_CB                    ((0x00f8  << 2) + 0xff040000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_CB                   ((0x00f9  << 2) + 0xff040000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_CR                    ((0x00fa  << 2) + 0xff040000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_CR                   ((0x00fb  << 2) + 0xff040000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC2_BADDR_CTRL                       ((0x00fc  << 2) + 0xff040000)
//Bit 31:0, src2 base address in 64bits
#define GE2D_SRC2_STRIDE_CTRL                      ((0x00fd  << 2) + 0xff040000)
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX2_PRE_OFFSET                    ((0x0090  << 2) + 0xff040000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX2_COEF00_01                     ((0x0091  << 2) + 0xff040000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX2_COEF02_10                     ((0x0092  << 2) + 0xff040000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX2_COEF11_12                     ((0x0093  << 2) + 0xff040000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX2_COEF20_21                     ((0x0094  << 2) + 0xff040000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX2_COEF22_CTRL                   ((0x0095  << 2) + 0xff040000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX2_OFFSET                        ((0x0096  << 2) + 0xff040000)
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX3_PRE_OFFSET                    ((0x0097  << 2) + 0xff040000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX3_COEF00_01                     ((0x0098  << 2) + 0xff040000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX3_COEF02_10                     ((0x0099  << 2) + 0xff040000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX3_COEF11_12                     ((0x009a  << 2) + 0xff040000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX3_COEF20_21                     ((0x009b  << 2) + 0xff040000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX3_COEF22_CTRL                   ((0x009c  << 2) + 0xff040000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX3_OFFSET                        ((0x009d  << 2) + 0xff040000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./ge2d_regs.h
//
//
// Reading file:  ./parser_regs.h
//
//
//***************************************************************************
// Title:      parser.h
//
// Author:     chong.gu
//
// Created:    17:15:11 06/08/2019
//
// Description:
//
// Note:
//
// History:
//
//***************************************************************************
//-----------------------------------------------------------
// PARSER
//-----------------------------------------------------------
// -----------------------------------------------
// REG_BASE:  PARSER_PCBUS_BASE = 0x38
// -----------------------------------------------
// bit 31:8 -- es_pack_size
// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
// bit 5 -- es_write
// bit 4 -- es_passthrough
// bit 3 -- insert_before_es_write
// bit 2 -- discard_cmd
// bit 1 -- search_cmd
// bit 0 -- Parser Busy
#define PARSER_CONTROL                             ((0x3860  << 2) + 0xfdf00000)
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define PARSER_FETCH_ADDR                          ((0x3861  << 2) + 0xfdf00000)
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr
//   4:3 cmd_wr_ptr
//   2:0 cmd_number
#define PARSER_FETCH_CMD                           ((0x3862  << 2) + 0xfdf00000)
// 31:0 stop_fetch_addr
#define PARSER_FETCH_STOP_ADDR                     ((0x3863  << 2) + 0xfdf00000)
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define PARSER_FETCH_LEVEL                         ((0x3864  << 2) + 0xfdf00000)
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits)
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define PARSER_CONFIG                              ((0x3865  << 2) + 0xfdf00000)
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define PFIFO_WR_PTR                               ((0x3866  << 2) + 0xfdf00000)
// bit 9:0 -- point to byte address
#define PFIFO_RD_PTR                               ((0x3867  << 2) + 0xfdf00000)
// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
#define PFIFO_DATA                                 ((0x3868  << 2) + 0xfdf00000)
// bit 31:0 -- parser search pattern
#define PARSER_SEARCH_PATTERN                      ((0x3869  << 2) + 0xfdf00000)
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define PARSER_SEARCH_MASK                         ((0x386a  << 2) + 0xfdf00000)
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu
// bit 7:0 -- Parser interrupt enable for Amrisc
#define PARSER_INT_ENABLE                          ((0x386b  << 2) + 0xfdf00000)
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based)
#define PARSER_INT_STATUS                          ((0x386c  << 2) + 0xfdf00000)
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define PARSER_SCR_CTL                             ((0x386d  << 2) + 0xfdf00000)
// bit 31:0 SCR value
#define PARSER_SCR                                 ((0x386e  << 2) + 0xfdf00000)
// bit 31:24 -- insert_loop_number
// bit 23:21 --
// bit 20:16 -- insert_byte_number
// bit 15:0 -- discard number
#define PARSER_PARAMETER                           ((0x386f  << 2) + 0xfdf00000)
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continous write to this address can write upto 16 bytes
#define PARSER_INSERT_DATA                         ((0x3870  << 2) + 0xfdf00000)
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define VAS_STREAM_ID                              ((0x3871  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_DTS
#define VIDEO_DTS                                  ((0x3872  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_PTS
#define VIDEO_PTS                                  ((0x3873  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define VIDEO_PTS_DTS_WR_PTR                       ((0x3874  << 2) + 0xfdf00000)
// Bit 31:0 -- AUDIO_PTS
#define AUDIO_PTS                                  ((0x3875  << 2) + 0xfdf00000)
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define AUDIO_PTS_WR_PTR                           ((0x3876  << 2) + 0xfdf00000)
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian
// bit 0 -- VIDEO using manual read point
#define PARSER_ES_CONTROL                          ((0x3877  << 2) + 0xfdf00000)
// Bit 31:0 PFIFO_MONITOR
#define PFIFO_MONITOR                              ((0x3878  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_VIDEO_START_PTR                     ((0x3880  << 2) + 0xfdf00000)
#define PARSER_VIDEO_END_PTR                       ((0x3881  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define PARSER_VIDEO_WP                            ((0x3882  << 2) + 0xfdf00000)
#define PARSER_VIDEO_RP                            ((0x3883  << 2) + 0xfdf00000)
#define PARSER_VIDEO_HOLE                          ((0x3884  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_AUDIO_START_PTR                     ((0x3885  << 2) + 0xfdf00000)
#define PARSER_AUDIO_END_PTR                       ((0x3886  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define PARSER_AUDIO_WP                            ((0x3887  << 2) + 0xfdf00000)
#define PARSER_AUDIO_RP                            ((0x3888  << 2) + 0xfdf00000)
#define PARSER_AUDIO_HOLE                          ((0x3889  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_SUB_START_PTR                       ((0x388a  << 2) + 0xfdf00000)
#define PARSER_SUB_END_PTR                         ((0x388b  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define PARSER_SUB_WP                              ((0x388c  << 2) + 0xfdf00000)
#define PARSER_SUB_RP                              ((0x388d  << 2) + 0xfdf00000)
#define PARSER_SUB_HOLE                            ((0x388e  << 2) + 0xfdf00000)
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define PARSER_FETCH_INFO                          ((0x388f  << 2) + 0xfdf00000)
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define PARSER_STATUS                              ((0x3890  << 2) + 0xfdf00000)
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define PARSER_AV_WRAP_COUNT                       ((0x3891  << 2) + 0xfdf00000)
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define WRRSP_PARSER                               ((0x3892  << 2) + 0xfdf00000)
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_VIDEO2_START_PTR                    ((0x3893  << 2) + 0xfdf00000)
#define PARSER_VIDEO2_END_PTR                      ((0x3894  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define PARSER_VIDEO2_WP                           ((0x3895  << 2) + 0xfdf00000)
#define PARSER_VIDEO2_RP                           ((0x3896  << 2) + 0xfdf00000)
#define PARSER_VIDEO2_HOLE                         ((0x3897  << 2) + 0xfdf00000)
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define PARSER_AV2_WRAP_COUNT                      ((0x3898  << 2) + 0xfdf00000)
//-----------------------------------------------------------
// PARSER_B
//-----------------------------------------------------------
// -----------------------------------------------
// REG_BASE:  PARSER_B_PCBUS_BASE = 0x11
// -----------------------------------------------
#define PARSER_B_PARSER_CONTROL                    ((0x1160  << 2) + 0xfdf00000)
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define PARSER_B_PARSER_FETCH_ADDR                 ((0x1161  << 2) + 0xfdf00000)
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr
//   4:3 cmd_wr_ptr
//   2:0 cmd_number
#define PARSER_B_PARSER_FETCH_CMD                  ((0x1162  << 2) + 0xfdf00000)
// 31:0 stop_fetch_addr
#define PARSER_B_PARSER_FETCH_STOP_ADDR            ((0x1163  << 2) + 0xfdf00000)
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define PARSER_B_PARSER_FETCH_LEVEL                ((0x1164  << 2) + 0xfdf00000)
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits)
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define PARSER_B_PARSER_CONFIG                     ((0x1165  << 2) + 0xfdf00000)
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define PARSER_B_PFIFO_WR_PTR                      ((0x1166  << 2) + 0xfdf00000)
// bit 9:0 -- point to byte address
#define PARSER_B_PFIFO_RD_PTR                      ((0x1167  << 2) + 0xfdf00000)
// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
#define PARSER_B_PFIFO_DATA                        ((0x1168  << 2) + 0xfdf00000)
// bit 31:0 -- parser search pattern
#define PARSER_B_PARSER_SEARCH_PATTERN             ((0x1169  << 2) + 0xfdf00000)
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define PARSER_B_PARSER_SEARCH_MASK                ((0x116a  << 2) + 0xfdf00000)
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu
// bit 7:0 -- Parser interrupt enable for Amrisc
#define PARSER_B_PARSER_INT_ENABLE                 ((0x116b  << 2) + 0xfdf00000)
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based)
#define PARSER_B_PARSER_INT_STATUS                 ((0x116c  << 2) + 0xfdf00000)
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define PARSER_B_PARSER_SCR_CTL                    ((0x116d  << 2) + 0xfdf00000)
// bit 31:0 SCR value
#define PARSER_B_PARSER_SCR                        ((0x116e  << 2) + 0xfdf00000)
// bit 31:24 -- insert_loop_number
// bit 23:21 --
// bit 20:16 -- insert_byte_number
// bit 15:0 -- discard number
#define PARSER_B_PARSER_PARAMETER                  ((0x116f  << 2) + 0xfdf00000)
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continous write to this address can write upto 16 bytes
#define PARSER_B_PARSER_INSERT_DATA                ((0x1170  << 2) + 0xfdf00000)
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define PARSER_B_VAS_STREAM_ID                     ((0x1171  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_DTS
#define PARSER_B_VIDEO_DTS                         ((0x1172  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_PTS
#define PARSER_B_VIDEO_PTS                         ((0x1173  << 2) + 0xfdf00000)
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define PARSER_B_VIDEO_PTS_DTS_WR_PTR              ((0x1174  << 2) + 0xfdf00000)
// Bit 31:0 -- AUDIO_PTS
#define PARSER_B_AUDIO_PTS                         ((0x1175  << 2) + 0xfdf00000)
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define PARSER_B_AUDIO_PTS_WR_PTR                  ((0x1176  << 2) + 0xfdf00000)
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:13 -- VIDEO2 Ees_write Endian
// bit 12 -- VIDEO2 using manual read point
// bit 11:9 -- SUB Ees_write Endian
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian
// bit 0 -- VIDEO using manual read point
#define PARSER_B_PARSER_ES_CONTROL                 ((0x1177  << 2) + 0xfdf00000)
// Bit 31:0 PFIFO_MONITOR
#define PARSER_B_PFIFO_MONITOR                     ((0x1178  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_B_PARSER_VIDEO_START_PTR            ((0x1180  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO_END_PTR              ((0x1181  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define PARSER_B_PARSER_VIDEO_WP                   ((0x1182  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO_RP                   ((0x1183  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO_HOLE                 ((0x1184  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_B_PARSER_AUDIO_START_PTR            ((0x1185  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_AUDIO_END_PTR              ((0x1186  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define PARSER_B_PARSER_AUDIO_WP                   ((0x1187  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_AUDIO_RP                   ((0x1188  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_AUDIO_HOLE                 ((0x1189  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_B_PARSER_SUB_START_PTR              ((0x118a  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_SUB_END_PTR                ((0x118b  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define PARSER_B_PARSER_SUB_WP                     ((0x118c  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_SUB_RP                     ((0x118d  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_SUB_HOLE                   ((0x118e  << 2) + 0xfdf00000)
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define PARSER_B_PARSER_FETCH_INFO                 ((0x118f  << 2) + 0xfdf00000)
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define PARSER_B_PARSER_STATUS                     ((0x1190  << 2) + 0xfdf00000)
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define PARSER_B_PARSER_AV_WRAP_COUNT              ((0x1191  << 2) + 0xfdf00000)
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define PARSER_B_WRRSP_PARSER                      ((0x1192  << 2) + 0xfdf00000)
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug
// --------------------------------------------
// PARSER_VIDEO2 DDR Interface
// --------------------------------------------
// The PARSER_VIDEO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define PARSER_B_PARSER_VIDEO2_START_PTR           ((0x1193  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO2_END_PTR             ((0x1194  << 2) + 0xfdf00000)
// --------------------------------------------
// PARSER_VIDEO2 Buffer Level Manager
// --------------------------------------------
#define PARSER_B_PARSER_VIDEO2_WP                  ((0x1195  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO2_RP                  ((0x1196  << 2) + 0xfdf00000)
#define PARSER_B_PARSER_VIDEO2_HOLE                ((0x1197  << 2) + 0xfdf00000)
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO2_wrap_count
#define PARSER_B_PARSER_AV2_WRAP_COUNT             ((0x1198  << 2) + 0xfdf00000)
//
// Closing file:  ./parser_regs.h
//

#endif // REGISTER_H

